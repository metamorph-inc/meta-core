<#@ template language="C#" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ output extension=".py" #>


# ---------------------------------------------------
# Auto generated by CyPhy2CAD
# ---------------------------------------------------
import zipfile
import os
import os.path
import shutil
import subprocess

components_folder = [ \
<# foreach (var folder in CadFolders)
	{ #>
    r'<#= CyPhy2CAD_CSharp.TestBenchModel.TestBenchBase.SanitizePythonRawString(folder) #>',
<#  } #>
    ]


def find_python_path():
    import _winreg
    meta_python_path = ""
    try:
        uninstall_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, r"Software\META", 0,
                                        _winreg.KEY_READ | _winreg.KEY_WOW64_32KEY)
        val, typ = _winreg.QueryValueEx(uninstall_key, 'META_PATH')
        meta_python_path = os.path.join(val, r"bin\Python311\Python.exe")
    except WindowsError as e:
        meta_python_path = None
        
    return meta_python_path


def call_script(meta_python, scriptname, error_msg):
    return_out = 0
    try:
        script_cmd = '"{0}" "{1}"'\
                    .format(meta_python, scriptname)
            
        status = subprocess.check_output(script_cmd, stderr=subprocess.STDOUT, shell=True)
    except subprocess.CalledProcessError as err:
        msg = "Subprocess call failed!"
        msg += "\n  command       : {0}".format(err.cmd)
        msg += "\n  return-code   : {0}".format(err.returncode)
        if err.output:
            msg += "\n  console output: \n\n{0}".format(err.output)
        if err.message:
            msg +=  "\n  error message : {0}".format(err.message)
        error_msg.append(msg)
        return_out = 1

    return return_out


def main():
    error_msg = list()
    # call Copy_Parts.bat
    copy_bat = 'Copy_Parts.py'
    if os.path.exists(copy_bat):
        try:
            meta_python = find_python_path()
            if meta_python is not None:
                call_script(meta_python, copy_bat, error_msg) 
            else:
                error_msg.append('Can not find META Python Package!')
        except Exception as msg:
            error_msg.append(str(msg))
            error_msg.append('\nNot able to copy cad files.')

    if len(error_msg) > 0:
        with open('_FAILED.txt', 'w') as f_out:
            for item in error_msg:
                f_out.write(item)
        if os.name == 'nt':
            os._exit(3)
        elif os.name == 'posix':
            os._exit(os.EX_OSFILE)

    search_path = 'search_META.pro'
    if os.path.exists(search_path):
        shutil.copyfile(search_path, search_path + '.local')

    with open (search_path, 'w') as search_path_file:
        if os.path.exists('Cad_Auxiliary_Directory'):
            search_path_file.write('".\Cad_Auxiliary_Directory"\n')

        for folder in components_folder:
            search_path_file.write('".\\' + folder + '"\n')

    # zip
    output_filename = 'source_data.zip'

    if os.path.exists(output_filename):
        os.remove(output_filename)

    cur_work_dir = os.getcwd()

    with zipfile.ZipFile(output_filename, 'w', allowZip64=True) as z:
        parent_dir_name = os.path.basename(os.getcwd())
        os.chdir('..\\')
        for dirpath,dirs,files in os.walk(parent_dir_name):
          for f in files:
            if output_filename == f:
                continue
            fn = os.path.join(dirpath, f)
            z.write(fn, compress_type=zipfile.ZIP_DEFLATED)
            

    # removes the copied over components directory after zipping because it won't be needed after the workspace.zip comes back since
    # paths in search_meta.pro would be switched to reference local components directory in /project_dir/components etc 
    for folder in (os.path.normpath(f) for f in components_folder):
        path_list = folder.split(os.sep)
        if len(path_list) > 0:
            components_root_dir = os.path.join(cur_work_dir, path_list[0])
            if os.path.exists(components_root_dir):
                shutil.rmtree(os.path.join(cur_work_dir, components_root_dir))

if __name__ == '__main__':
    main()

<#+
public List<string> CadFolders{get;set;}
#>