import sys
import os
import os.path

import importlib.machinery
import importlib.util

# undo fractions.gcd removal https://docs.python.org/3/whatsnew/3.9.html
import fractions
import math
fractions.gcd = math.gcd

# Undo "Remove deprecated aliases to Collections Abstract Base Classes from the collections module." https://docs.python.org/3/whatsnew/3.10.html
# https://github.com/python/cpython/issues/81505
# https://github.com/python/cpython/commit/c47c78b878ff617164b2b94ff711a6103e781753
import collections
def __getattr__(name):
    import _collections_abc
    # For backwards compatibility, continue to make the collections ABCs
    # through Python 3.6 available through the collections module.
    # Note, no new collections ABCs were added in Python 3.7
    if name in _collections_abc.__all__:
        obj = getattr(_collections_abc, name)
        import warnings
        warnings.warn("Using or importing the ABCs from 'collections' instead "
                      "of from 'collections.abc' is deprecated since Python 3.3, "
                      "and in 3.10 it will stop working",
                      DeprecationWarning, stacklevel=2)
        globals()[name] = obj
        return obj
    raise AttributeError(f'module collections has no attribute {name!r}')

setattr(collections, '__getattr__', __getattr__)
del __getattr__

if os.path.normcase(os.environ.get('ProgramFiles', 'C:\\Program Files')) not in os.path.normcase(os.path.abspath(__file__)):
    import glob
    for entry in glob.glob(os.path.join(os.path.dirname(os.path.abspath(__file__)), r"../../../../src/Python27Packages") + "/*"):
        if os.path.isdir(entry):
            sys.path.append(os.path.normpath(entry))
    sys.path.append(os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), r"../../../../src/Python27Packages")))
    sys.path.append(os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), r"../../../../src")))
    sys.path.append(os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), r"../../../../meta/DesignDataPackage/lib/python")))

_this_dir = os.path.dirname(os.path.abspath(__file__))

# import glob, os.path
# ', '.join(["'{}'".format(os.path.basename(f)[:-4]) for f in glob.glob('bin/python27/lib/site-packages/win32/*pyd')])
_win32api_modules = set(('mmapfile', 'odbc', 'perfmon', 'servicemanager', 'timer', 'win2kras', 'win32api', 'win32clipboard', 'win32console', 'win32cred', 'win32crypt', 'win32event', 'win32evtlog', 'win32file', 'win32gui', 'win32help', 'win32inet', 'win32job', 'win32lz', 'win32net', 'win32pdh', 'win32pipe', 'win32print', 'win32process', 'win32profile', 'win32ras', 'win32security', 'win32service', 'win32trace', 'win32transaction', 'win32ts', 'win32wnet', 'winxpgui', '_win32sysloader', '_winxptheme'))

class PythonComLoader(object):
    """
    pythoncom.py calls LoadLibrary("pythoncom27.dll"), which will load via %PATH%
    Anaconda's pythoncom27.dll (for one) doesn't include the correct SxS activation info, so trying to load it results in "An application has made an attempt to load the C runtime library incorrectly."
    load our pythoncom27.dll(which we know works) with an explicit path

    For win32api.pyd et al, we need to load our pywintypes27.dll first, so we don't load from SysWOW64 or Anaconda.

    pywintypes.py from pywin32 has some magic to load the correct pywintypes27, but it doesn't appear to work.
    """

    def find_module(self, fullname, path=None):
        if fullname == 'pythoncom':
            return self
        if fullname != '_win32sysloader' and fullname in _win32api_modules:
            # n.b. use _win32sysloader instead of ctypes, since we will definitely load the former, but maybe not the latter
            import _win32sysloader
            # just a LoadLibrary; if needed as a Python module, it will be loaded later
            _win32sysloader.LoadModule(os.path.join(_this_dir, 'pywin32_system32', 'pywintypes' + ''.join(map(str, sys.version_info[0:2])) + '.dll'))
        return None

    def load_module(self, name):
        if name in sys.modules:
            return sys.modules[name]
        import traceback
        if name == 'pythoncom':
            try:
                # pywin32 version 223
                return self.load_dynamic('pythoncom', os.path.join(_this_dir, 'pywin32_system32', 'pythoncom' + ''.join(map(str, sys.version_info[0:2])) + '.dll'))
            except Exception as e:
                # maybe the user downgraded pywin32. Print the error to show something is wrong
                traceback.print_exc()
            # pywin32 version 220
            import afxres
            return self.load_dynamic('pythoncom', os.path.join(os.path.dirname(afxres.__file__), 'pythoncom' + ''.join(map(str, sys.version_info[0:2])) + '.dll'))

    @staticmethod
    def load_dynamic(name, path):
        loader = importlib.machinery.ExtensionFileLoader(name, path)
        spec = importlib.machinery.ModuleSpec(name=name, loader=loader, origin=path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        return mod


sys.meta_path.insert(0, PythonComLoader())
