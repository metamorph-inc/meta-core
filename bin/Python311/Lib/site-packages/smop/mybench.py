# Autogenerated with SMOP version 0.26.3-15-gcf44923
# /home/lei/.local/bin/smop -r core -r octave -o mybench.py mybench.m
from __future__ import division
from __future__ import absolute_import
from .core import *
from octave import *
def mybench(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    global IS_OCTAVE,IS_IMAGE_PROCESSING
    conf=struct_(char('noOfRepeats'),3,char('normalize'),true,char('imagep'),true,char('onlyTests'),[])
    conf=getargs(conf,varargin)
    IS_OCTAVE=exist(char('OCTAVE_VERSION'),char('builtin')) > 0
    IS_IMAGE_PROCESSING=copy(false)
    NO_REPETITIONS=conf.noOfRepeats
    NORMALIZE_TIMES=conf.normalize
    if exist(char('imrotate'),char('file')) > 0 and exist(char('imresize'),char('file')) > 0 and exist(char('imerode'),char('file')) > 0 and conf.imagep == true:
        disp(char('Image processing toolbox found'))
        IS_IMAGE_PROCESSING=copy(true)
    if conf.noOfRepeats < 1:
        conf.noOfRepeats = copy(1)
    clc
    mytests=getBenchmarkTests()
    noOftests=length(mytests)
    moVersio=strrep(version(),char(' '),char('_'))
    outFileName=char('foo.txt')
    fid=fopen(outFileName,char('w'))
    if NORMALIZE_TIMES:
        fprintf(fid,char('%s\t%s\t%s\n'),[char('Name_'),moVersio],char('Time'),char('Norm_time'))
    else:
        fprintf(fid,char('%s\t%s\n'),[char('Name_'),moVersio],char('Time_[s]'))
    avarage_time=0
    times_vector=matlabarray([])
    times_vector1=matlabarray([])
    if isempty(conf.onlyTests):
        doTheseTests=arange(1,noOftests)
    else:
        doTheseTests=conf.onlyTests
        noOftests=length(conf.onlyTests)
    for i in doTheseTests.reshape(-1):
        fprintf(1,char('Execute test %d/%d -  %s\n'),i,noOftests,mytests[i].name)
        if IS_OCTAVE:
            fflush(stdout)
        try:
            x=mytests[i].input()
            cumulative_time=0
            cumulative_time1=0
            goldResult=1
            for ii in arange(1,NO_REPETITIONS).reshape(-1):
                fprintf(1,char('%d '),ii)
                if IS_OCTAVE:
                    fflush(stdout)
                t0=tic()
                mytests[i].test(x)
                t1=toc(t0)
                if isfield(mytests[i],char('goldResult')) and NORMALIZE_TIMES == true:
                    goldResult=mytests[i].goldResult
                cumulative_time=cumulative_time + t1 / goldResult
                cumulative_time1=cumulative_time1 + t1
            avarage_time=cumulative_time / NO_REPETITIONS
            avarage_time1=cumulative_time1 / NO_REPETITIONS
            times_vector[end() + 1]=avarage_time
            times_vector1[end() + 1]=avarage_time1
        finally:
            pass
        if isfield(mytests[i],char('post')):
            mytests[i].post()
        fprintf(1,char('\n\tTime %.2f [s]\n'),avarage_time1)
        if NORMALIZE_TIMES == true:
            fprintf(1,char('\tNormalized time %.2f \n'),avarage_time)
        fprintf(1,char('\n'))
        if IS_OCTAVE:
            fflush(stdout)
        if NORMALIZE_TIMES:
            fprintf(fid,char('%s\t%f\t%f\n'),mytests[i].name,avarage_time1,avarage_time)
        else:
            fprintf(fid,char('%s\t%f\n'),mytests[i].name,avarage_time1)
    times_product=prod(times_vector)
    times_mean=mean(times_vector)
    times_geometric_mean=times_product ** (1 / length(times_vector))
    times_product1=prod(times_vector1)
    times_mean1=mean(times_vector1)
    times_geometric_mean1=times_product1 ** (1 / length(times_vector1))
    res.norm_geometric_mean = copy(times_geometric_mean)
    res.norm_arithmetic_mean = copy(times_mean)
    res.norm_min = copy(min(times_vector))
    res.norm_max = copy(max(times_vector))
    fprintf(1,char('\n\t --- SUMMARY ---\n'))
    fprintf(1,char('\n\tMean: geometric %.3f [s], arithmetic %.3f [s]'),times_geometric_mean1,times_mean1)
    fprintf(1,char('\n\tMin %.3f [s], Max %.3f [s]\n\n'),min(times_vector1),max(times_vector1))
    if NORMALIZE_TIMES == true:
        fprintf(1,char('\tNormalized Mean: geometric %.3f, arithmetic %.3f'),times_geometric_mean,times_mean)
        fprintf(1,char('\n\tNormalized Min %.3f [s], Max %.3f [s]\n\n'),min(times_vector),max(times_vector))
    if IS_OCTAVE:
        fflush(stdout)
    if NORMALIZE_TIMES:
        fprintf(fid,char('%s\t%f\t%f\n'),char('Geom_mean'),times_geometric_mean1,times_geometric_mean)
    else:
        fprintf(fid,char('%s\t%f\t%f\n'),char('Geom_mean'),times_geometric_mean1)
    fclose(fid)
    disp(char(''))
    disp([char('End of test. File '),outFileName,char(' was created.')])
    if exist(char('out_gray.png')):
        delete(char('out_gray.png'))
    if exist(char('out_1.png')):
        delete(char('out_1.png'))
    if exist(char('out_mtx')):
        delete(char('out_mtx'))
    if exist(char('out_mtx.mat')):
        delete(char('out_mtx.mat'))
    if exist(char('dlm.txt')):
        delete(char('dlm.txt'))
    clear(char('IS_OCTAVE'),char('IS_IMAGE_PROCESSING'))
    return res
def getBenchmarkTests(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    global IS_OCTAVE,IS_IMAGE_PROCESSING
    s=cellarray([])
    s[end() + 1]=struct_(char('name'),char('rand'),char('test'),lambda x: rand(x),char('input'),lambda : 4000,char('goldResult'),1.12)
    s[end() + 1]=struct_(char('name'),char('randn'),char('test'),lambda x: randn(x),char('input'),lambda : 4000,char('goldResult'),0.58)
    s[end() + 1]=struct_(char('name'),char('primes'),char('test'),lambda x: primes(x),char('input'),lambda : 10000000.0,char('goldResult'),0.74)
    s[end() + 1]=struct_(char('name'),char('fft2'),char('test'),lambda x: fft2(x),char('input'),lambda : rand(3000),char('goldResult'),2.28)
    s[end() + 1]=struct_(char('name'),char('square'),char('test'),lambda x: x ** 2,char('input'),lambda : rand(1000),char('goldResult'),1.35)
    s[end() + 1]=struct_(char('name'),char('inv'),char('test'),lambda x: inv(x),char('input'),lambda : rand(1000),char('goldResult'),0.87)
    s[end() + 1]=struct_(char('name'),char('eig'),char('test'),lambda x: eig(x),char('input'),lambda : rand(1000),char('goldResult'),9.45)
    s[end() + 1]=struct_(char('name'),char('qr'),char('test'),lambda x: qr(x),char('input'),lambda : rand(1000),char('goldResult'),0.79)
    s[end() + 1]=struct_(char('name'),char('schur'),char('test'),lambda x: schur(x),char('input'),lambda : rand(600),char('goldResult'),2.67)
    s[end() + 1]=struct_(char('name'),char('roots'),char('test'),lambda x: roots(x),char('input'),lambda : rand(600,1),char('goldResult'),2.08)
    s[end() + 1]=struct_(char('name'),char('interp2'),char('test'),lambda x: interp2(x,2,char('spline')),char('input'),lambda : rand(600),char('goldResult'),4.2)
    s[end() + 1]=struct_(char('name'),char('binary'),char('test'),lambda x: eye(x) < 1,char('input'),lambda : 5000,char('goldResult'),0.51)
    s[end() + 1]=struct_(char('name'),char('forLoop'),char('test'),lambda x: forLoop(x),char('input'),lambda : 200,char('goldResult'),0.06)
    s[end() + 1]=struct_(char('name'),char('makeSparse'),char('test'),lambda x: sparse(x),char('input'),lambda : eye(5000),char('goldResult'),0.49)
    s[end() + 1]=struct_(char('name'),char('multiplySparse'),char('test'),lambda x: sparse(x) * sparse(x),char('input'),lambda : eye(5000) * rand(1),char('goldResult'),0.98)
    s[end() + 1]=struct_(char('name'),char('sLinearEq'),char('test'),lambda x: magic(x) / rand(1,x),char('input'),lambda : 2000,char('goldResult'),1.94)
    s[end() + 1]=struct_(char('name'),char('saveLoadMtx'),char('test'),lambda x: saveLoadMtx(x),char('input'),lambda : rand(1000),char('goldResult'),0.93)
    s[end() + 1]=struct_(char('name'),char('dlmwriteRead'),char('test'),lambda x: dlmwriteRead(x),char('input'),lambda : rand(500),char('goldResult'),5.03)
    s[end() + 1]=struct_(char('name'),char('median'),char('test'),lambda x: median(x[:]),char('input'),lambda : rand(4000),char('goldResult'),3.32)
    s[end() + 1]=struct_(char('name'),char('std'),char('test'),lambda x: std(x[:]),char('input'),lambda : rand(4000),char('goldResult'),0.84)
    if IS_IMAGE_PROCESSING:
        s[end() + 1]=struct_(char('name'),char('doImgAndSaveAsPNG'),char('test'),lambda x: doImgAndSaveAsPNG(x),char('input'),lambda : rand(1500,1500,3),char('post'),lambda : pause(2),char('goldResult'),2.0)
        s[end() + 1]=struct_(char('name'),char('imageToGray'),char('test'),lambda I: imageToGray(I),char('input'),lambda : imread(char('out_1.png')),char('goldResult'),0.56)
        s[end() + 1]=struct_(char('name'),char('imageRotate'),char('test'),lambda I: imageRotate(I),char('input'),lambda : imread(char('out_gray.png')),char('goldResult'),2.94)
        s[end() + 1]=struct_(char('name'),char('imresize'),char('test'),lambda I: imresize(I,1.2),char('input'),lambda : imread(char('out_gray.png')),char('goldResult'),1.24)
        s[end() + 1]=struct_(char('name'),char('imageFilter'),char('test'),lambda I: imageFilter(I),char('input'),lambda : imread(char('out_gray.png')),char('goldResult'),0.2)
        s[end() + 1]=struct_(char('name'),char('imageErode'),char('test'),lambda I: imageErode(I),char('input'),lambda : imread(char('out_gray.png')),char('goldResult'),0.46)
        s[end() + 1]=struct_(char('name'),char('medfilt2'),char('test'),lambda I: medfilt2(I),char('input'),lambda : magic(2000),char('goldResult'),1.03)
    return s
def saveLoadMtx(out_mtx=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[out_mtx].count(None)+len(args)

    save(char('out_mtx'))
    clear(char('out_mtx'))
    load(char('out_mtx'))
    return
def dlmwriteRead(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    dlmwrite(char('dlm.txt'),x)
    dlmread(char('dlm.txt'))
    return
def forLoop(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    for i in arange(1,x).reshape(-1):
        for j in arange(1,x).reshape(-1):
            for k in arange(1,x).reshape(-1):
                i + j + k
    return
def doImgAndSaveAsPNG(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    imwrite(x,char('out_1.png'))
    return
def solveNonLinearEq(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    x,fval,info=fsolve(equationsToSolve,[[1],[1],[1],[1]],nargout=3)
    return
def equationsToSolve(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    y[1]=- 2 * x[1] ** 2 + 3 * x[1] * x[2] + 4 * sin(x[2]) + log(x[3]) - 6
    y[2]=3 * x[1] ** 2 - 2 * x[2] * x[2] ** 2 + 3 * cos(x[1]) + 4
    y[3]=1 * x[1] ** 2 - 2 * x[1] * x[2] * x[4] ** 2 + 3 * cos(x[1]) + 4
    y[4]=1 * x[1] ** 2 - 2 * x[1] * x[2] * x[3] ** 2 + 3 * cos(x[4]) + 4
    return y
def imageToGray(I=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[I].count(None)+len(args)

    Igray=rgb2gray(I)
    imwrite(Igray,char('out_gray.png'))
    return
def imageRotate(I=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[I].count(None)+len(args)

    I2=imrotate(I,2)
    return
def imageFilter(I=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[I].count(None)+len(args)

    h=fspecial(char('sobel'))
    filteredI=imfilter(I,h)
    return
def imageErode(I=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[I].count(None)+len(args)

    SE=eye(5)
    erodedI=imerode(I,SE)
    return
def getargs(defs=None,varglist=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[defs,varglist].count(None)+len(args)

    l=length(varglist)
    if l == 0:
        return defs
    if mod(l,2) != 0:
        disp(char(' !!! Odd number of parameters !!!'))
        defs=cellarray([])
        return defs
    varnames=cellarray([varglist[1:2:l]])
    varvalues=cellarray([varglist[2:2:l]])
    given_vars=zeros(1,l / 2)
    for i in arange(1,l / 2,1).reshape(-1):
        existss=isfield(defs,varnames[i])
        given_vars[i]=existss
    if min(given_vars) == 0:
        disp(char('!!! No such parameter(s):'))
        disp(varnames[not given_vars])
        defs=cellarray([])
        return defs
    for i in arange(1,l / 2,1).reshape(-1):
        setattr(defs,varnames[i],varvalues[i])
    return defs

mybench()
