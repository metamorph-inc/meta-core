
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Setting up a Basic Model With Paraboloid &mdash; OpenMDAO Documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMDAO Documentation" href="../index.html" />
    <link rel="up" title="The Basics" href="index.html" />
    <link rel="next" title="OpenMDAO Tutorials" href="../tutorials/index.html" />
    <link rel="prev" title="Working with Variables" href="variables.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tutorials/index.html" title="OpenMDAO Tutorials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="variables.html" title="Working with Variables"
             accesskey="P">previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../index.html">OpenMDAO Documentation v0.8.1</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Basics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="setting-up-a-basic-model-with-paraboloid">
<h1>Setting up a Basic Model With Paraboloid<a class="headerlink" href="#setting-up-a-basic-model-with-paraboloid" title="Permalink to this headline">¶</a></h1>
<p>Working with the Paraboloid component that we built in the previous section, you now have an
analysis tool that you can run. So how do we set up some kind of analysis with this model?
Before you get there, we&#8217;re going to discuss a few more basic concepts in the OpenMDAO framework:
<em>Driver</em>, <em>Workflow</em>, and <em>Assembly</em>. Then we&#8217;ll move on to building a simple assembly that lets you run a basic
analysis.</p>
<div class="section" id="driver">
<h2>Driver<a class="headerlink" href="#driver" title="Permalink to this headline">¶</a></h2>
<p>Once you have a bunch of components, you&#8217;re going to want to do something with them,
like run an optimization or a Design of Experiments. Any kind of iterative execution
of components is controlled by a <a class="reference internal" href="../glossary.html#term-driver"><em class="xref std std-term">Driver</em></a>. There are a number of different kinds
of drivers in the standard library, but you could also write your own if need be.</p>
</div>
<div class="section" id="workflow">
<span id="workflow-overview"></span><h2>Workflow<a class="headerlink" href="#workflow" title="Permalink to this headline">¶</a></h2>
<p>When a Driver is running, it needs to know which components to execute and in what order
to execute them. This behavior is controlled by the <a class="reference internal" href="../glossary.html#term-workflow"><em class="xref std std-term">Workflow</em></a> class. Each driver
has a workflow associated with it. You can think of the workflow as being responsible for
controlling the process used to run a given analysis.</p>
<p>Although in many cases a workflow contains just basic components, it can also contain
other drivers. This allows nested iterative processes to be created.
Nested iterations provide the flexibility needed to build
complex optimization processes defined by MDAO architectures.
Also, Components are allowed to show up multiple times in a single workflow
or in multiple parts of a nested workflow.  This can be used, for
example, if you need to train a meta model in one part of a workflow
and then optimize it in another. We often refer to collection of drivers/workflows
in a given model as an <a class="reference internal" href="../glossary.html#term-iteration-hierarchy"><em class="xref std std-term">iteration hierarchy</em></a>.</p>
<p>The following figure shows an example of an iteration hierarchy involving four
different Drivers.  Note that in this example the same component, <em>component2</em>,
appears in two different parts of the iteration hierarchy.</p>
<div class="figure align-center" id="iteration-hierarchy-concept">
<img alt="Figure shows workflows for each of 4 drivers; the workflows contain a total of 5 components" src="../_images/IterationHierarchy.png" />
<p class="caption">View of an Iteration Hierarchy</p>
</div>
<p>Each component can report its location in the iteration hierarchy by its
<a class="reference internal" href="../glossary.html#term-iteration-coordinates"><em class="xref std std-term">iteration coordinates</em></a>.  The coordinates are of the form
<tt class="docutils literal"><span class="pre">&lt;workflow</span> <span class="pre">execution</span> <span class="pre">count&gt;-&lt;component</span> <span class="pre">index</span> <span class="pre">in</span> <span class="pre">workflow&gt;</span></tt> for each level in
the hierarchy. For example, when <cite>component2</cite> above is executing in the
workflow for <cite>driver3</cite> for the first time, its iteration coordinates would be
<tt class="docutils literal"><span class="pre">1-3.1-1</span></tt>. These coordinates denote the first execution of the top workflow, third
component (<cite>driver3</cite>), first execution of that driver&#8217;s workflow, first
component in that workflow (<cite>component2</cite>). To have all components report their
iteration coordinates to stderr (the default):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.util.log</span> <span class="kn">import</span> <span class="n">enable_trace</span><span class="p">,</span> <span class="n">disable_trace</span>
<span class="n">enable_trace</span><span class="p">()</span>
</pre></div>
</div>
<p>Later, the tracing can be turned off:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">disable_trace</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="assembly">
<h2>Assembly<a class="headerlink" href="#assembly" title="Permalink to this headline">¶</a></h2>
<p>An <a class="reference internal" href="../glossary.html#term-assembly"><em class="xref std std-term">Assembly</em></a> is a container for all of your components, drivers, and workflows. When an
Assembly executes, it will always look for a Driver named <cite>driver</cite> and  start there; then it will
work its way down the iteration hierarchy.</p>
<p>Besides being a container for all the other objects, an Assembly has two other main functions.
It is responsible for managing all of the data connections between components in the framework.
Whenever data needs to move from one component to another, this action is specified via the <cite>connect</cite>
method of the assembly.</p>
<div class="figure align-center" id="driver-intro2">
<img alt="Refer to adjacent text" src="../_images/Intro-Driver2.png" />
<p class="caption">View of an Assembly Showing Data Flow</p>
</div>
<p>An Assembly is also a special type of Component. Assemblies, like regular
components, can have their own inputs and outputs. You can take advantage of this behavior
to construct nested models that can help simplify a complex analysis a bit. You could
produce a model of a jet engine from a number of analysis tools, then wrap that
up into an assembly that is used as part of an aircraft simulation.</p>
<p>For example, we could replace <em>component3</em> from the figure above with an assembly
containing two other components, resulting in the following:</p>
<div class="figure align-center" id="driver-intro1">
<img alt="Refer to caption" src="../_images/Intro-Driver1.png" />
<p class="caption">View of an Assembly within an Assembly</p>
</div>
<p>So assemblies allow us to organize our model into a hierarchy of submodels, and within each
submodel, drivers and workflows give us a flexible way to define an iteration scheme.</p>
</div>
<div class="section" id="building-a-basic-model">
<h2>Building a Basic Model<a class="headerlink" href="#building-a-basic-model" title="Permalink to this headline">¶</a></h2>
<p>So a model is built from an assembly which contains components, drivers, and workflows.
Each assembly has its own iteration hierarchy, with <cite>driver</cite> at the root, that determines
which components are run and in what order.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span>
<span class="kn">from</span> <span class="nn">openmdao.examples.simple.paraboloid</span> <span class="kn">import</span> <span class="n">Paraboloid</span>

<span class="k">class</span> <span class="nc">BasicModel</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A basic OpenMDAO Model&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly containing a Paraboloid component&quot;&quot;&quot;</span>

        <span class="c"># Create Paraboloid component instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;paraboloid&#39;</span><span class="p">,</span> <span class="n">Paraboloid</span><span class="p">())</span>

        <span class="c"># Add to driver&#39;s workflow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;paraboloid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can see here that you use the <tt class="docutils literal"><span class="pre">configure</span></tt> method to add
things into an assembly. Within the <tt class="docutils literal"><span class="pre">configure</span></tt> method, you use the <tt class="docutils literal"><span class="pre">add</span></tt> method
which takes a valid OpenMDAO name and a corresponding component
instance as its arguments. This adds the instance to the
OpenMDAO model using the given name. In this case then,
the Paraboloid is accessed via <tt class="docutils literal"><span class="pre">self.paraboloid</span></tt>.</p>
<p>Notice that we never added any kind of driver, but we still
referenced it to add <cite>paraboloid</cite> to the workflow. Assemblies
always have a default driver, which simply runs once through its
workflow. In later tutorials, we&#8217;ll show you how to replace the
default driver with something else like an optimizer. For now though,
our models just run once through their workflows.</p>
</div>
<div class="section" id="connecting-components">
<span id="id1"></span><h2>Connecting Components<a class="headerlink" href="#connecting-components" title="Permalink to this headline">¶</a></h2>
<p>Of course, most of your models will have more than one component in them,
and you&#8217;re going to want to pass some information between them. In OpenMDAO
we use <cite>connections</cite> for that. Lets take a look at how connections work.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span>
<span class="kn">from</span> <span class="nn">openmdao.examples.simple.paraboloid</span> <span class="kn">import</span> <span class="n">Paraboloid</span>

<span class="k">class</span> <span class="nc">ConnectingComponents</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Top level assembly &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly containing a chain of Paraboloid components&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par1&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par2&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par3&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;par1&#39;</span><span class="p">,</span><span class="s">&#39;par2&#39;</span><span class="p">,</span><span class="s">&#39;par3&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;par1.f_xy&quot;</span><span class="p">,</span><span class="s">&quot;par2.x&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;par2.f_xy&quot;</span><span class="p">,</span><span class="s">&quot;par3.y&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>connect</cite> method takes two arguments, the first of which must be a component
output, and the second of which must be a component input or a sequence of
component inputs. One thing to note is that only one output can
be connected to any given input.  On the other hand, it is fine to connect an output to multiple
inputs. When you connect one output to multiple inputs, we call that <tt class="docutils literal"><span class="pre">broadcasting</span></tt> the output.</p>
<p>In the above code, we created a chain of three paraboloid components. However, we could have
configured them slightly differently so that the output of the first paraboloid gets broadcast
to the inputs for the next to.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span>
<span class="kn">from</span> <span class="nn">openmdao.examples.simple.paraboloid</span> <span class="kn">import</span> <span class="n">Paraboloid</span>

<span class="k">class</span> <span class="nc">ConnectingComponents</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Top level assembly &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly containing a chain of Paraboloid components&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par1&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par2&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par3&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;par1&#39;</span><span class="p">,</span><span class="s">&#39;par2&#39;</span><span class="p">,</span><span class="s">&#39;par3&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;par1.f_xy&quot;</span><span class="p">,</span><span class="s">&quot;par2.x&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;par1.f_xy&quot;</span><span class="p">,</span><span class="s">&quot;par3.y&quot;</span><span class="p">)</span>

        <span class="c">#shortcut syntax</span>
        <span class="c">#self.connect(&quot;par1.f_xy&quot;,[&quot;par2.x&quot;,&quot;par3.y&quot;])</span>
</pre></div>
</div>
<p>You can broadcast the output two ways. The above code shows them both. The first way
is just to issue two separate connections. Notice that both connection calls have <tt class="docutils literal"><span class="pre">par1.f_xt</span></tt>
as their source. The second way provides a shortcut, where you make one connect call, but specify
a list of inputs to connect two. The two methods result in the exact same result, so use whichever
one you prefer.</p>
<p>One last note: A variable is not required to be connected to anything. Typically
components will have numerous inputs, and many of these will contain values
that are set by the user or are perfectly fine at their defaults. That&#8217;s fine; you
only need to issue connections when you want to link up multiple codes.</p>
</div>
<div class="section" id="variables-and-assemblies">
<h2>Variables and Assemblies<a class="headerlink" href="#variables-and-assemblies" title="Permalink to this headline">¶</a></h2>
<p>Variables can be added directly to an assembly and used to <em>promote</em> internal variables,
making them visible to components outside of the assembly. A convenience
function called <tt class="docutils literal"><span class="pre">create_passthrough</span></tt> creates a variable in the assembly and
connects it to an internal component variable in one step.</p>
<p>Consider a similar assembly as shown above, except that we want to promote the
remaining unconnected variables to the assembly boundary so that they can be
linked at that level.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span><span class="p">,</span> <span class="n">set_as_top</span>
<span class="kn">from</span> <span class="nn">openmdao.examples.simple.paraboloid</span> <span class="kn">import</span> <span class="n">Paraboloid</span>

<span class="k">class</span> <span class="nc">ConnectingComponents</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Top level assembly &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly containing a Paraboloid and an optimizer&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par1&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;par2&quot;</span><span class="p">,</span><span class="n">Paraboloid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;par1.f_xy&quot;</span><span class="p">,</span><span class="s">&quot;par2.x&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;par1&#39;</span><span class="p">,</span><span class="s">&#39;par2&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_passthrough</span><span class="p">(</span><span class="s">&#39;par1.x&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_passthrough</span><span class="p">(</span><span class="s">&#39;par1.y&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_passthrough</span><span class="p">(</span><span class="s">&#39;par2.y&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_passthrough</span><span class="p">(</span><span class="s">&#39;par2.f_xy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">create_passthrough</span></tt> function creates a variable in the assembly. This new variable has
the same name, iotype, default value, units, description, and range characteristics as the
original variable on the component that you&#8217;re passing through. If you would like to present a different interface
external to the assembly (perhaps you would like different units), then a passthrough
cannot be used. Instead, the desired variables must be manually created and
connected. You can find a more detailed example of this in the <a class="reference internal" href="../tutorials/complex/index.html#a-more-complex-tutorial-problem"><em>complex tutorial</em></a>. Most of the time passthroughs are sufficient.</p>
<p>Next we&#8217;ll move on to our tutorial for setting up a basic optimization, still using the same Paraboloid component
that we built for this one.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://openmdao.org">
 <img src="../_static/OpenMDAO_Logo_200w_padded.png"
border="0" alt="OpenMDAO Home"/>
</a>

  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Setting up a Basic Model With Paraboloid</a><ul>
<li><a class="reference internal" href="#driver">Driver</a></li>
<li><a class="reference internal" href="#workflow">Workflow</a></li>
<li><a class="reference internal" href="#assembly">Assembly</a></li>
<li><a class="reference internal" href="#building-a-basic-model">Building a Basic Model</a></li>
<li><a class="reference internal" href="#connecting-components">Connecting Components</a></li>
<li><a class="reference internal" href="#variables-and-assemblies">Variables and Assemblies</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="variables.html"
                        title="previous chapter">Working with Variables</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../tutorials/index.html"
                        title="next chapter">OpenMDAO Tutorials</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/basics/assembly.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tutorials/index.html" title="OpenMDAO Tutorials"
             >next</a> |</li>
        <li class="right" >
          <a href="variables.html" title="Working with Variables"
             >previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../index.html">OpenMDAO Documentation v0.8.1</a> &raquo;</li>

          <li><a href="index.html" >The Basics</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright none.
      Last updated on Aug 26, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>