within ;
package C2M2L_OM "C2M2L Open Modelica"
  extends Modelica.Icons.Package;

  import SI = Modelica.SIunits;
  import Modelica.Constants.pi;

  package MSL_Extend
      extends Modelica.Icons.Package;

    package Blocks "Holds extensions to the MSL package of the same name"
        extends Modelica.Icons.Package;

      package Math "Holds extensions to the MSL package of the same name"
          extends Modelica.Icons.Package;

        package Min_Max "Contains blocks that output min or max values"
        extends Modelica.Icons.Package;

          block Max_Against_Parameter
            "Passes the largest of input signal u or parameter p"
            extends Modelica.Blocks.Interfaces.SISO;
            parameter Real p=0 "The value that u is compared against";
          equation
            y = max(p, u);
            annotation (Icon(graphics={Text(
                    extent={{-106,30},{106,-24}},
                    lineColor={135,135,135},
                    textString="max(u,p)"), Text(
                    extent={{-106,-32},{106,-74}},
                    lineColor={135,135,135},
                    textString="p=%p%")}));
          end Max_Against_Parameter;

          block Min_Against_Parameter
            "Passes the smallest of input signal u or parameter p"
            extends Modelica.Blocks.Interfaces.SISO;
            parameter Real p=0 "The value that u is compared against";
          equation
            y = min(p, u);
            annotation (Icon(graphics={Text(
                    extent={{-104,32},{108,-22}},
                    lineColor={135,135,135},
                    textString="min(u,p)"), Text(
                    extent={{-104,-34},{108,-76}},
                    lineColor={135,135,135},
                    textString="p=%p%")}));
          end Min_Against_Parameter;

          block Max_From_Vector "y = max(u)"
            extends Modelica.Blocks.Interfaces.PartialRealMISO;
          equation
            y = max(u);
            annotation (Icon(graphics={Text(
                    extent={{-104,56},{112,-38}},
                    lineColor={0,0,0},
                    textString="max")}));
          end Max_From_Vector;

          block Max_Abs_From_Vector "y = max(abs(u))"
            extends Modelica.Blocks.Interfaces.PartialRealMISO;
          equation
            y = noEvent(max(abs(u)));
            annotation (Icon(graphics={Text(
                    extent={{-102,44},{114,-34}},
                    lineColor={0,0,0},
                    textString="|max|")}));
          end Max_Abs_From_Vector;

          block Max_Integer "Pass through the largest signal"

            Modelica.Blocks.Interfaces.IntegerInput u1 "Integer input"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Modelica.Blocks.Interfaces.IntegerInput u2 "Integer input"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Modelica.Blocks.Interfaces.IntegerOutput y "Minimum integer out"
              annotation (Placement(transformation(extent={{100,-14},{130,16}})));
          equation
            y = max(u1, u2);
            annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics={
                                          Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()")}),
                                    Documentation(info="<html>
<p>
This block computes the output <b>y</b> as <i>maximum</i>
of the two Integer inputs <b>u1</b> and <b>u2</b>:
</p>
<pre>    y = <b>max</b> ( u1 , u2 );
</pre>
</html>
"),           Diagram(graphics));
          end Max_Integer;

          block Min_Integer "Pass through the smallest signal"

            Modelica.Blocks.Interfaces.IntegerInput u1 "Integer input"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Modelica.Blocks.Interfaces.IntegerInput u2 "Integer input"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Modelica.Blocks.Interfaces.IntegerOutput y "Minimum integer out"
              annotation (Placement(transformation(extent={{100,-14},{130,16}})));
          equation
             y = min(u1, u2);
            annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics={
                                          Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()")}),
                                    Documentation(info="<html>
<p>
This block computes the output <b>y</b> as <i>minimum</i> of
the two Integer inputs <b>u1</b> and <b>u2</b>:
</p>
<pre>    y = <b>min</b> ( u1 , u2 );
</pre>
</html>
"),           Diagram(graphics));
          end Min_Integer;

          model Min_Signed_Abs_Comparison
            "Find the smallest abs signal but output the signed signal"
            extends Modelica.Blocks.Interfaces.SI2SO;
          equation
            if noEvent(abs(u1) >= abs(u2)) then
              y = u2;
            else
              y = u1;
            end if;
          end Min_Signed_Abs_Comparison;
        end Min_Max;

        block Division_P
          "Output first input divided by second input (protected)"
          extends Modelica.Blocks.Interfaces.SI2SO;
          parameter Real max_y=Modelica.Constants.inf
            "Magnitude of the largest output value that should be generated";
          parameter Real min_u=Modelica.Constants.eps
            "Magnitude of the smallest value to divide by";

        /*
  (c) 2012, Modelon AB
  
  The code shall avoid a division by zero of the two input signals u1/u2.
  It is structured in such a way that also overflows are avoided as long
  as the parameters, max_y and min_u, are set correct.
  
*/

        algorithm
          // check de-nominator is larger than minimum value
          if noEvent(abs(u2) > min_u) then
            // check that the abs(u1)/abs(u2) does not lead to overflow
            if noEvent(abs(u1)/max_y > abs(u2)) then
              // check which sign the absolute max value shall have
              if noEvent(sign(u1)*sign(u2) < 0) then
                y := -max_y;
              else
                y := max_y;
              end if;
            else
              y := u1/u2;
            end if;
          else
            //check no overflow will occur
            if noEvent(abs(u1)/max_y > min_u) then
              // check which sign shall be used
              if noEvent(sign(u1)*sign(u2) < 0) then
                y := -max_y;
              else
                y := max_y;
              end if;
            else
              // check which sign of the absolute minimum value shall be used
              if noEvent(sign(u2) < 0) then
                y := -u1/min_u;
              else
                y := u1/min_u;
              end if;
            end if;
          end if;
          annotation (Diagram(graphics), Icon(graphics={
                Line(points={{-98,60},{-64,60},{-38,30}}, color={0,0,255}),
                Ellipse(extent={{-48,50},{52,-50}}, lineColor={0,0,255}),
                Ellipse(
                  extent={{-3,20},{7,30}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-28,0},{32,0}}, color={0,0,0}),
                Ellipse(
                  extent={{-3,-20},{7,-30}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-98,-60},{2,-60},{2,-50}}, color={0,0,255}),
                Line(points={{52,0},{102,0}}, color={0,0,255}),
                Text(
                  extent={{-134,-14},{22,-106}},
                  lineColor={128,128,128},
                  lineThickness=0.5,
                  textString="0"),
                Line(
                  points={{-20,-20},{-100,-100}},
                  color={255,0,0},
                  thickness=0.5,
                  smooth=Smooth.None),
                Line(
                  points={{40,40},{-40,-40}},
                  color={255,0,0},
                  thickness=0.5,
                  smooth=Smooth.None,
                  origin={-60,-60},
                  rotation=90)}));
        end Division_P;

        block One_Minus_U "y = 1 - u"
          extends Modelica.Blocks.Interfaces.SISO;
          parameter Boolean use_abs_u = false "if true, use |u| instead of u";
        equation
          if use_abs_u then
            y = 1 - abs(u);
          else
            y = 1 - u;
          end if;
          annotation (Icon(graphics={Text(
                  extent={{-100,40},{100,-40}},
                  lineColor={135,135,135},
                  textString="1-u",visible=not use_abs_u), Text(
                  extent={{-100,40},{100,-40}},
                  lineColor={135,135,135},
                  textString="1-|u|",visible=use_abs_u)}),   Documentation(info="<html>
<p>Simple convenience block that helps tidy up some diagrams by replacing a common operation that requires a separate add and constant block with a single block.</p>
</html>"));
        end One_Minus_U;

        block Proportional_Combining
          "Combine u1 and u2 together using p.  When p=1, y=u1 and when p=0, y=u2 and linearly interpolates between 0 and 1"
          extends Modelica.Blocks.Interfaces.SI2SO;
          Modelica.Blocks.Interfaces.RealInput p "Proportioning signal (0-1)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));
        protected
          Real lim_p;
        equation
          lim_p = max(min(p, 1.0), 0.0);
          y = (1 - lim_p) * u2 + lim_p * u1;
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                    {{-100,-100},{100,100}}),
                              graphics), Icon(graphics={
                Text(
                  extent={{26,-76},{92,-94}},
                  lineColor={0,0,255},
                  textString="1"),
                Text(
                  extent={{-114,-76},{-44,-94}},
                  lineColor={0,0,255},
                  textString="0"),
                Text(
                  extent={{-160,116},{-100,76}},
                  lineColor={128,128,128},
                  textString="u1"),
                Text(
                  extent={{-160,-76},{-100,-116}},
                  lineColor={128,128,128},
                  textString="u2"),
            Line(points={{-90,-80},{68,-80}},
                                          color={192,192,192}),
            Polygon(
              points={{90,-80},{68,-72},{68,-88},{90,-80}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-88},{-80,68}},
                                          color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
                Line(
                  points={{-90,60},{74,60}},
                  color={170,85,255},
                  smooth=Smooth.None),
                Line(
                  points={{-90,-60},{74,-60}},
                  color={255,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-80,-60},{64,60}},
                  color={244,232,255},
                  smooth=Smooth.None),
                Line(
                  points={{0,-100},{0,6},{98,6}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash)}));
        end Proportional_Combining;

        block Positive_Negative_Split
          "Split a signal u to send only +ve values to y_pos (otherwise zero) and only negative to y_neg (otherwise zero)"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          Modelica.Blocks.Interfaces.RealInput u
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput y_pos "u if u>0 else 0"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput y_neg "u if u < 0 else 0"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
          parameter Boolean flip_neg=false
            "if true output the negative signals as positive values";
          parameter Boolean check_zero_crossing = false
            "true if an event should be generated when sign of u changes";
        equation
          if (if check_zero_crossing then u >= 0.0 else noEvent(u >= 0.0)) then
            y_pos = u;
            y_neg = 0;
          else
            y_pos = 0;
            y_neg = if flip_neg then -u else u;
          end if;
          annotation (Diagram(graphics), Icon(graphics={Text(
                  extent={{38,84},{106,28}},
                  lineColor={255,0,0},
                  textString="+"), Text(
                  extent={{36,-28},{104,-84}},
                  lineColor={0,0,255},
                  textString="-"), Text(
                  extent={{36,-28},{104,-84}},
                  lineColor={0,0,0},
                  textString="| |",
                  visible=flip_neg),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Line(points={{-90,0},{68,0}}, color={192,192,192}),
            Polygon(
              points={{90,0},{68,8},{68,-8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
                Line(
                  points={{-88,30},{-76,52},{-54,58},{-44,34},{-28,0},{8,0},{14,20},{26,
                      20},{36,0},{60,0}},
                  color={255,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-88,0},{-28,0},{-24,-20},{-14,-56},{-6,-52},{8,0},{36,0},{46,
                      -32},{48,-34},{60,-34}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{8,20},{8,-20}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  visible=check_zero_crossing),
                Line(
                  points={{36,20},{36,-20}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  visible=check_zero_crossing),
                Line(
                  points={{-28,20},{-28,-20}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  visible=check_zero_crossing)}));
        end Positive_Negative_Split;

        block Real_To_Signed_Integer
          "Converts a +ve input > threshold to +1 and -ve input < -threshold to -1 otherwise 0"
          extends Modelica.Blocks.Interfaces.IntegerSO;

          parameter Real threshold = 0.0 "If abs(u) < threshold y = 0";

          Modelica.Blocks.Interfaces.RealInput u
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        equation
          if abs(u) < threshold then
            y = 0;
          else
            if u >= 0 then
              y = 1;
            else
              y = -1;
            end if;
          end if;
          annotation (Icon(graphics={
                Rectangle(
                  extent={{-78,20},{80,-20}},
                  fillColor={220,255,220},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-78,-20},{80,-90}},
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-78,90},{80,20}},
                  fillColor={255,220,220},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-40,98},{38,36}},
                  lineColor={0,0,255},
                  textString="+"),
                Text(
                  extent={{-38,-38},{40,-100}},
                  lineColor={0,0,255},
                  textString="-"),
            Polygon(
              points={{-78,90},{-86,68},{-70,68},{-78,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-78,-88},{-78,68}},
                                          color={192,192,192}),
            Line(points={{-88,0},{70,0}}, color={192,192,192}),
            Polygon(
              points={{92,0},{70,8},{70,-8},{92,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
                Line(
                  points={{-78,0},{-74,6},{-60,32},{-38,38},{-34,38},{-10,26},{0,-10},{
                      22,-36},{56,-38},{70,-44}},
                  color={0,0,255},
                  smooth=Smooth.None)}));
        end Real_To_Signed_Integer;

        block Triggered_Add_Limited
          "Add input to previous value of output, if rising edge of trigger port"
          extends Modelica.Blocks.Interfaces.PartialIntegerSISO;

          parameter Boolean use_reset = false "=true, if reset port enabled"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Boolean use_set = false
            "=true, if set port enabled and used as default value when reset"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Integer y_start = 0
            "Initial and reset value of y if set port is not used";

          Modelica.Blocks.Interfaces.BooleanInput trigger annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120})));
          Modelica.Blocks.Interfaces.BooleanInput reset if use_reset annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={60,-120})));
          Modelica.Blocks.Interfaces.IntegerInput set if use_set annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,120}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={32,96})));
        protected
          Modelica.Blocks.Interfaces.BooleanOutput local_reset annotation(HideResult=true);
          Modelica.Blocks.Interfaces.IntegerOutput local_set;
        public
          Modelica.Blocks.Interfaces.IntegerInput u_max annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,120}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=0,
                origin={-120,80})));
          Modelica.Blocks.Interfaces.IntegerInput u_min annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={0,120}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=0,
                origin={-120,-80})));
        initial equation
          pre(y) =  min(max((y_start), u_min), u_max);
        equation
          if use_reset then
             connect(reset, local_reset);
               if use_set then
                 connect(set, local_set);
               else
                 local_set = y_start;
               end if;
          else
             local_reset = false;
             local_set = 0;
          end if;

          when {trigger, local_reset} then
            y = if local_reset then local_set else min(max((pre(y) + u), u_min), u_max);
          end when;
          annotation (
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1), graphics),
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1), graphics={
                Rectangle(
                  extent={{-78,86},{88,60}},
                  pattern=LinePattern.None,
                  fillColor={255,220,220},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-78,-60},{88,-86}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-100,0},{32,76}},
                  color={255,128,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-100,0},{32,-20}},
                  color={255,128,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(
                  points={{-54,-56},{-26,-56},{-26,-20},{32,-20},{32,76}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-100},{32,-20}},
                  color={255,0,255},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Text(
                  visible=use_reset,
                  extent={{-28,-62},{94,-86}},
                  lineColor={0,0,0},
                  textString="reset"),
                Line(
                  points={{-98,80},{-78,80},{-78,60},{94,60}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{-92,-80},{-78,-80},{-78,-60},{94,-60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{-54,-56},{-54,-80}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-198,138},{-78,98}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  textString="max",
                  lineColor={128,128,128}),
                Text(
                  extent={{-198,-94},{-78,-134}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={128,128,128},
                  textString="min"),
                Text(
                  extent={{26,122},{146,82}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={128,128,128},
                  textString="set",
                  visible=use_set),
                Line(
                  points={{-54,-60},{-54,-80}},
                  smooth=Smooth.None,
                  color={255,255,255}),
                Line(
                  points={{32,80},{32,60}},
                  smooth=Smooth.None,
                  color={255,255,255})}),
            Documentation(info="<html>
<p>Add input to previous value of output, if rising edge of trigger port </p>
<p>This block has one Integer input &QUOT;u&QUOT;, one Boolean input &QUOT;trigger&QUOT;, an optional Boolean input &QUOT;reset&QUOT;, an optional Integer input &QUOT;set&QUOT;, a minimum Integer value &QUOT;u_min&QUOT;, a maximum Integer value &QUOT;u_max&QUOT;, and an Integer output &QUOT;y&QUOT;. The optional inputs can be activated with the &QUOT;use_reset&QUOT; and &QUOT;use_set&QUOT; flags, respectively. </p>
<p>The input &QUOT;u&QUOT; is added to the previous value of the output &QUOT;y&QUOT; if the &QUOT;trigger&QUOT; port has a rising edge. At the start of the simulation &QUOT;y = y_start&QUOT;.  The output is limited to a minimum of &QUOT;u_min&QUOT; and a maximum of &QUOT;u_max&QUOT;.  </p>
<p>If the &QUOT;reset&QUOT; port is enabled, then the output &QUOT;y&QUOT; is reset to &QUOT;set&QUOT; or to &QUOT;y_start&QUOT; (if the &QUOT;set&QUOT; port is not enabled), whenever the &QUOT;reset&QUOT; port has a rising edge.  </p>
<p>The usage is demonstrated, e.g., in example <a href=\"modelica://Modelica.Blocks.Examples.IntegerNetwork1\">Modelica.Blocks.Examples.IntegerNetwork1</a>. </p>
</html>"));
        end Triggered_Add_Limited;

        block Sigmoid_Between_Limits
          "y = sigmoid(u) with y very close to 0 at u = u_low and very close to 1 at u = u_high"
          extends Modelica.Blocks.Interfaces.SISO;
          import C2M2L_OM.MSL_Extend.Math.Logistic;
          //import C2M2L_Ext.Math.der_Logistic;
          parameter Real u_low = 0
            "Value of u at which y should be very close to 0";
          parameter Real u_high = 1
            "Value of u at which y should be very close to 1";
          parameter Real sharpness = 10
            "Higher values give a sharper transition and less deviation at u=u_low and u=u_high.  Default 10 gives 0.7% deviation.";
        protected
          parameter Real mid_point = (u_high + u_low) * 0.5;
          parameter Real scale = u_high - u_low;
        equation
          assert(u_high > u_low, "Sigmoid_Between_Limits: u_high must be greater than u_low");
          y = Logistic(sharpness * (u - mid_point) / scale);
          annotation (Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1),
                           graphics={
            Line(points={{-76,-84},{-43.8,-82.7},{-31.8,-79.7},{-23.7,-74.6},{-18.1,
                      -68.2},{-13.3,-59.9},{-8.5,-48.3},{-3.64,-33.2},{2.79,-8.82},{
                      10.83,22.3},{15.7,38},{20.5,50.2},{25.3,59.1},{30.9,65.9},{38.2,
                      71},{49.4,74.4},{76,75.9},{84,76}},
                                                      color={0,0,0}),
            Line(points={{-94,0},{90,0}},  color={192,192,192}),
            Line(points={{6,-90},{6,84}}, color={192,192,192}),
            Polygon(
              points={{6,90},{-2,68},{14,68},{6,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{96,0},{74,8},{74,-8},{96,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
                Text(
                  extent={{-198,-110},{200,-130}},
                  lineColor={0,0,0},
                  textString="u_low=%u_low"),
                Text(
                  extent={{-200,-140},{200,-160}},
                  lineColor={0,0,0},
                  textString=" u_high=%u_high")}), Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1), graphics));
        end Sigmoid_Between_Limits;

        block Reg_Step "Wraps Modelica.Fluid.Utilities.regStep in a block"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          import Modelica.Fluid.Utilities.regStep;
          Modelica.Blocks.Interfaces.RealInput u "Controls blending of a and b"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));
          Modelica.Blocks.Interfaces.RealOutput y "Blend of a and b based on u"
            annotation (Placement(transformation(extent={{100,50},{120,70}},
                rotation=0), iconTransformation(extent={{100,50},{120,70}})));

          parameter Real u_small=1e-5
            "Size of region around u_offset to perform interpolation";
          parameter Real u_offset=0 "Value of u at which y = (a + b)/2";
          Modelica.Blocks.Interfaces.RealInput b
            "value to use when u less than u_offset - u_small"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Modelica.Blocks.Interfaces.RealInput a
            "value to use when u > u_offset + u_small"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Modelica.Blocks.Interfaces.RealOutput y_rev
            "Uses pos and neg on opposite sides to y"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}),
                iconTransformation(extent={{100,-70},{120,-50}})));

        equation
          y = regStep(u - u_offset, a, b, u_small);

          y_rev = a + b - y;

          annotation (
            Diagram(graphics),
            Icon(graphics={
                Line(points={{-94,0},{90,0}}, color={192,192,192}),
                Line(points={{-14,-86},{-14,88}}, color={192,192,192}),
                Polygon(
                  points={{-14,100},{-20,84},{-8,84},{-14,100}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{8,-96},{48,-136}},
                  lineColor={160,160,164},
                  textString="u"),
                Text(
                  extent={{101,108},{140,68}},
                  lineColor={160,160,164},
                  textString="y"),
                Line(points={{6,80},{-2,80}}, color={192,192,192}),
                Line(points={{6,-80},{-2,-80}}, color={192,192,192}),
                Line(
                  points={{-96,80},{92,80}},
                  color={215,215,215},
                  smooth=Smooth.None),
                Line(
                  points={{-94,-80},{94,-80}},
                  color={215,215,215},
                  smooth=Smooth.None),
                Line(
                  points={{-114,-80},{-14,-80},{-14,80},{72,80}},
                  color={95,95,95},
                  smooth=Smooth.None),
                Line(
                  points={{-114,-80},{-74,-80},{-54,-80},{-14,-60},{-14,60},{26,80},{46,
                      80},{76,80}},
                  color={255,85,85},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{78,-12},{218,-52}},
                  lineColor={160,160,164},
                  textString="y_rev"),
                Text(
                  extent={{-140,132},{-100,92}},
                  lineColor={160,160,164},
                  textString="a"),
                Text(
                  extent={{-140,-26},{-100,-66}},
                  lineColor={160,160,164},
                  textString="b"),
                Line(
                  points={{0,-100},{0,66},{80,66}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{60,76},{80,66},{60,56}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Polygon(
                  points={{0,8},{-6,-8},{6,-8},{0,8}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  origin={86,0},
                  rotation=270)}),
            Documentation(info="<html>
<p>Mixes together the signals at a (above) and &apos;b&apos; (below) based on the value of the input u. Parameter u_offset determines the center point and u_small determines the range over which mix the signals.</p>
<p>When u = u_offset, y=(a + b)/2. </p>
<p>if u &LT; u_offset-u_small, y = b</p>
<p>if u &GT; u_offset+u_small, y= a</p>
<p>if |u| &LT; u_small, smoothly blend a,b ensuring a continuous derivative.</p>
<p><br/>The reversed output is also optionally available at port y_rev. This would be the value if a and b were transposed.</p>
</html>"));
        end Reg_Step;

        block Reg_Double_Step
          "Wraps 2 x Modelica.Fluid.Utilities.regStep in a block to allow switching between a or b at two values of u"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          import C2M2L_OM.MSL_Extend.Math.Reg_Double_Step;
          Modelica.Blocks.Interfaces.RealInput u "Controls blending of a and b"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));
          Modelica.Blocks.Interfaces.RealOutput y "Blend of a and b based on u"
            annotation (Placement(transformation(extent={{100,50},{120,70}},
                rotation=0), iconTransformation(extent={{100,50},{120,70}})));

          parameter Real u_small_low=1e-5
            "Size of region around u_low to perform interpolation";
          parameter Real u_small_high=1e-5
            "Size of region around u_high to perform interpolation";
          parameter Real u_low=0
            "Value of u at which y = (a + b)/2 at start of step";
          parameter Real u_high=0
            "Value of u at which y = (a + b)/2 at end of step";
          Modelica.Blocks.Interfaces.RealInput b
            "Value to use when u less than u_offset - u_small"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Modelica.Blocks.Interfaces.RealInput a
            "Value to use when u > u_offset + u_small"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Modelica.Blocks.Interfaces.RealOutput y_rev
            "Output on y if a and b were transposed"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}),
                iconTransformation(extent={{100,-70},{120,-50}})));
        equation
          y = Reg_Double_Step(u, a, b, u_low, u_high, u_small_low, u_small_high);
          y_rev = a + b - y;

          annotation (
            Diagram(graphics),
            Icon(graphics={
                Line(points={{-94,0},{90,0}}, color={192,192,192}),
                Line(points={{-14,-86},{-14,88}}, color={192,192,192}),
                Polygon(
                  points={{-14,100},{-20,84},{-8,84},{-14,100}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{8,-96},{48,-136}},
                  lineColor={160,160,164},
                  textString="u"),
                Text(
                  extent={{101,108},{140,68}},
                  lineColor={160,160,164},
                  textString="y"),
                Line(points={{6,80},{-2,80}}, color={192,192,192}),
                Line(points={{6,-80},{-2,-80}}, color={192,192,192}),
                Line(
                  points={{-96,80},{92,80}},
                  color={215,215,215},
                  smooth=Smooth.None),
                Line(
                  points={{-94,-80},{94,-80}},
                  color={215,215,215},
                  smooth=Smooth.None),
                Line(
                  points={{-114,-80},{-14,-80},{-14,80},{72,80}},
                  color={95,95,95},
                  smooth=Smooth.None),
                Line(
                  points={{-100,-80},{-42,-80},{-24,-80},{-8,-60},{-8,60},{14,80},{30,80},
                      {38,80}},
                  color={255,85,85},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{78,-12},{218,-52}},
                  lineColor={160,160,164},
                  textString="y_rev"),
                Text(
                  extent={{-140,132},{-100,92}},
                  lineColor={160,160,164},
                  textString="a"),
                Text(
                  extent={{-140,-26},{-100,-66}},
                  lineColor={160,160,164},
                  textString="b"),
                Line(
                  points={{0,-100},{0,66},{100,66}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{80,76},{100,66},{80,56}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Polygon(
                  points={{0,8},{-6,-8},{6,-8},{0,8}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  origin={86,0},
                  rotation=270),
                Line(
                  points={{110,-80},{108,-80},{100,-80},{84,-60},{84,60},{62,80},{46,80},
                      {38,80}},
                  color={255,85,85},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>Mixes together the signals at a (above) and &apos;b&apos; (below) based on the value of the input u. Parameter u_offset determines the center point and u_small determines the range over which mix the signals.</p>
<p>When u = u_offset, y=(a + b)/2. </p>
<p>if u &LT; u_offset-u_small, y = b</p>
<p>if u &GT; u_offset+u_small, y= a</p>
<p>if |u| &LT; u_small, smoothly blend a,b ensuring a continuous derivative.</p>
<p><br/>The reversed output is also optionally available at port y_rev. This would be the value if a and b were transposed.</p>
</html>"));
        end Reg_Double_Step;

        package Tests "Simple tests for components"
        extends Icons.Package_For_Simple_Test_Cases;

          model Test_Reg_Step "Show operation of Reg_Step component"
            extends Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Constant const(k=2.2)
              annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
            Modelica.Blocks.Sources.Constant const1(k=0.7)
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              height=2,
              duration=1,
              offset=-1,
              startTime=1)
              annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
            Reg_Step reg_Step1(
              u_small=0.1,
              u_offset=-1)
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            Sigmoid_Between_Limits sigmoid_Between_Limits(
              u_low=-0.5,
              u_high=0.5,
              sharpness=10)
              annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
            Modelica.Blocks.Continuous.Der der_reg_step
              annotation (Placement(transformation(extent={{20,0},{40,20}})));
            Modelica.Blocks.Continuous.Der der_sigmoid
              annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
          equation
            connect(reg_Step1.u, ramp.y) annotation (Line(
                points={{-10,-2},{-10,-12},{-32,-12},{-32,10},{-59,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(reg_Step1.y, der_reg_step.u) annotation (Line(
                points={{1,16},{9.5,16},{9.5,10},{18,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(der_sigmoid.u, sigmoid_Between_Limits.y) annotation (Line(
                points={{18,-50},{1,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, sigmoid_Between_Limits.u) annotation (Line(
                points={{-59,10},{-42,10},{-42,-50},{-22,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const1.y, reg_Step1.b) annotation (Line(
                points={{-59,-30},{-40,-30},{-40,2},{-22,2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const.y, reg_Step1.a) annotation (Line(
                points={{-59,50},{-40.5,50},{-40.5,18},{-22,18}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics));
          end Test_Reg_Step;

          model Test_Positive_Negative_Split
            extends Icons.Simple_Test_Case;
            Positive_Negative_Split pn_cont(check_zero_crossing=true, flip_neg=true)
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            Modelica.Blocks.Sources.Sine sine(freqHz=1)
              annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
            Positive_Negative_Split pn_discrete(check_zero_crossing=true)
              annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
            Sources.Normal_Random_Steps normal_Random_Steps(length=0.314)
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
          equation
            connect(sine.y, pn_cont.u) annotation (Line(
                points={{-59,10},{-22,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(normal_Random_Steps.y, pn_discrete.u) annotation (Line(
                points={{-59,-30},{-22,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(graphics),
              experiment(StopTime=10, NumberOfIntervals=50),
              __Dymola_experimentSetupOutput);
          end Test_Positive_Negative_Split;

          model Test_Division_P
            extends Icons.Simple_Test_Case;
            Division_P division_P(max_y=10)
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            Modelica.Blocks.Sources.Constant const(k=1)
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            Modelica.Blocks.Sources.Sine sine(freqHz=1)
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
          equation
            connect(const.y, division_P.u1) annotation (Line(
                points={{-59,30},{-42,30},{-42,16},{-22,16}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sine.y, division_P.u2) annotation (Line(
                points={{-59,-10},{-40,-10},{-40,4},{-22,4}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(graphics),
              experiment(StopTime=5),
              __Dymola_experimentSetupOutput);
          end Test_Division_P;

          model Test_Real_To_Signed_Integer
            extends Icons.Simple_Test_Case;
            Real_To_Signed_Integer real_To_Signed_Integer(threshold=0.5)
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
            Modelica.Blocks.Sources.Sine sine(freqHz=1)
              annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          equation
            connect(sine.y, real_To_Signed_Integer.u) annotation (Line(
                points={{-59,10},{-42,10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics));
          end Test_Real_To_Signed_Integer;

          model Test_Proportional_Combining
            extends Icons.Simple_Test_Case;
            Proportional_Combining proportional_Combining
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            Modelica.Blocks.Sources.Constant const(k=1)
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Modelica.Blocks.Sources.Constant const1(k=2)
              annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              height=2,
              duration=1,
              offset=-0.5,
              startTime=0)
              annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
          equation
            connect(const.y, proportional_Combining.u1) annotation (Line(
                points={{-39,30},{-26,30},{-26,6},{-12,6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const1.y, proportional_Combining.u2) annotation (Line(
                points={{-39,-30},{-26,-30},{-26,-6},{-12,-6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, proportional_Combining.p) annotation (Line(
                points={{-19,-70},{0,-70},{0,-12}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics));
          end Test_Proportional_Combining;

          model Test_Triggered_Add_Limited
            extends Icons.Simple_Test_Case;
            Triggered_Add_Limited triggered_Add_Limited1(
              use_reset=false,
              use_set=false,
              y_start=25) annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Modelica.Blocks.Sources.IntegerConstant integerConstant(k=15)
              annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
            Modelica.Blocks.Sources.IntegerConstant integerConstant1(k=-4)
              annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
            Modelica.Blocks.Sources.IntegerConstant integerConstant2(k=2)
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
            Modelica.Blocks.Sources.SampleTrigger sampleTrigger(period=0.05, startTime=
                  0.05)
              annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
          equation
            connect(integerConstant1.y, triggered_Add_Limited1.u) annotation (Line(
                points={{-59,10},{-4,10}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(integerConstant.y, triggered_Add_Limited1.u_max) annotation (Line(
                points={{-59,50},{-30,50},{-30,18},{-2,18}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(integerConstant2.y, triggered_Add_Limited1.u_min) annotation (Line(
                points={{-59,-30},{-30,-30},{-30,2},{-2,2}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(sampleTrigger.y, triggered_Add_Limited1.trigger) annotation (Line(
                points={{-19,-50},{4,-50},{4,-2}},
                color={255,0,255},
                smooth=Smooth.None));
            annotation (Diagram(graphics));
          end Test_Triggered_Add_Limited;

          model Test_Reg_Double_Step
            "Show operation of Reg_Double_Step component"
            extends Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Ramp     const(height=4, duration=3)
              annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
            Modelica.Blocks.Sources.Constant const1(k=1.2)
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              height=2,
              duration=1,
              offset=-1,
              startTime=1)
              annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
            Reg_Double_Step double_step(
              u_small_low=0.1,
              u_small_high=0.1,
              u_low=0.2,
              u_high=0.6)
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            Modelica.Blocks.Continuous.Der der_reg_step
              annotation (Placement(transformation(extent={{20,0},{40,20}})));
          equation
            connect(double_step.u, ramp.y)
                                         annotation (Line(
                points={{-10,-2},{-10,-50},{-19,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(double_step.y, der_reg_step.u)
                                                 annotation (Line(
                points={{1,16},{9.5,16},{9.5,10},{18,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const1.y, double_step.b)
                                           annotation (Line(
                points={{-59,-30},{-40,-30},{-40,2},{-22,2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const.y, double_step.a)
                                          annotation (Line(
                points={{-59,50},{-40.5,50},{-40.5,18},{-22,18}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=3),
              __Dymola_experimentSetupOutput);
          end Test_Reg_Double_Step;
        end Tests;

        block Squash
          "Manipulates a signal from zero to one to implement deadbands"
          extends Modelica.Blocks.Interfaces.SISO;
          parameter Real u_low = 0 "u value that gives y = 0";
          parameter Real u_high = 1 "u value that gives y = 1";
        equation
          y = max(0, min(1, (u - u_low) / (u_high - u_low)));
          annotation (Icon(graphics={
            Line(points={{-80,-88},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
            Polygon(
              points={{90,-80},{68,-72},{68,-88},{90,-80}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{70,-52},{94,-72}},
              lineColor={160,160,164},
              textString="u"),
            Text(
              extent={{-77,98},{-50,78}},
              lineColor={160,160,164},
              textString="y"),
                Line(
                  points={{-80,-80},{-52,-80},{20,60},{60,60}},
                  color={255,0,0},
                  smooth=Smooth.None),
            Text(
              extent={{-102,-80},{-78,-100}},
              lineColor={160,160,164},
                  textString="0"),
            Text(
              extent={{-102,68},{-78,48}},
              lineColor={160,160,164},
                  textString="1"),
            Text(
              extent={{48,-80},{72,-100}},
              lineColor={160,160,164},
                  textString="1"),
            Text(
              extent={{-92,-76},{14,-100}},
              lineColor={160,160,164},
                  textString="u_low"),
            Text(
              extent={{-22,92},{84,68}},
              lineColor={160,160,164},
                  textString="u_high"),
                Line(
                  points={{20,60},{20,-80}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{-52,60},{-52,-80}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{-80,60},{20,60}},
                  color={215,215,215},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(
                  points={{60,-80},{60,60}},
                  color={215,215,215},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None)}));
        end Squash;
      end Math;

      package Logical "Extensions to the MSL package of the same name"
          extends Modelica.Icons.Package;

        block Integer_Equality "Compare two integers for equality"

          Modelica.Blocks.Interfaces.IntegerInput u1 "Integer input signal"
            annotation (Placement(transformation(extent={{-180,30},{-100,110}}),
                iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.BooleanOutput y "Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}}),
                iconTransformation(extent={{99,-11},{120,10}})));
          Modelica.Blocks.Interfaces.IntegerInput u2 "Integer input signal"
            annotation (Placement(transformation(extent={{-180,-110},{-100,-30}}),
                iconTransformation(extent={{-140,-80},{-100,-40}})));
        equation
          y = u1 == u2;
          annotation (Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1),  graphics),
                                     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1),  graphics={
                Text(
                  extent={{110,-50},{250,-70}},
                  lineColor={0,0,0},
                  textString=DynamicSelect(" ", realString(
                          y,
                          1,
                          0))),
                Text(
                  extent={{-250,170},{250,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-148,120},{-108,80}},
                  lineColor={128,128,128},
                  textString="u1"),
                Text(
                  extent={{-154,-76},{-94,-116}},
                  lineColor={128,128,128},
                  textString="u2"),
                Text(
                  extent={{-118,40},{102,-40}},
                  lineColor={128,128,128},
                  textString="=="),              Ellipse(
                  extent={{75,7},{89,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                            {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                            {235,235,235}),
                  fillPattern=FillPattern.Solid)}));
        end Integer_Equality;

        block Switch_Integer "Switch between two Integer signals"
          extends Modelica.Blocks.Interfaces.partialBooleanBlockIcon;
          Modelica.Blocks.Interfaces.IntegerInput u1
            "Connector of first Integer input signal"
                                         annotation (Placement(transformation(extent=
                    {{-140,60},{-100,100}}, rotation=0)));
          Modelica.Blocks.Interfaces.BooleanInput u2
            "Connector of Boolean input signal"
                                            annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}, rotation=0)));
          Modelica.Blocks.Interfaces.IntegerInput u3
            "Connector of second Integer input signal"
                                         annotation (Placement(transformation(extent=
                    {{-140,-100},{-100,-60}}, rotation=0)));
          Modelica.Blocks.Interfaces.IntegerOutput y
            "Connector of Integer output signal"
                                         annotation (Placement(transformation(extent=
                    {{100,-10},{120,10}}, rotation=0)));

        equation
          y = if u2 then u1 else u3;
          annotation (defaultComponentName="switch1",
            Documentation(info="<html>
<p>The Logical.Switch switches, depending on the
logical connector u2 (the middle connector)
between the two possible input signals
u1 (upper connector) and u3 (lower connector).</p>
<p>If u2 is <b>true</b>, the output signal y is set equal to
u1, else it is set equal to u3.</p>
</html>
"),         Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(
                  points={{12,0},{100,0}},
                  pattern=LinePattern.Solid,
                  thickness=0.25,
                  arrow={Arrow.None,Arrow.None},
                  color={255,127,0}),
                Line(
                  points={{-100,0},{-40,0}},
                  color={255,0,127},
                  pattern=LinePattern.Solid,
                  thickness=0.25,
                  arrow={Arrow.None,Arrow.None}),
                Line(
                  points={{-100,-80},{-40,-80},{-40,-80}},
                  pattern=LinePattern.Solid,
                  thickness=0.25,
                  arrow={Arrow.None,Arrow.None},
                  color={255,127,0}),
                Line(points={{-40,12},{-40,-12}}, color={255,0,127}),
                Line(points={{-100,80},{-38,80}}, color={255,127,0}),
                Line(
                  points={{-38,80},{6,2}},
                  thickness=1,
                  color={255,127,0}),
                Ellipse(
                  extent={{2,8},{18,-6}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255})}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics));
        end Switch_Integer;

        block Integer_Equality_Parameter "y = true if u == p"
          parameter Integer p "The value to compare u against";

          Modelica.Blocks.Interfaces.IntegerInput u "Integer input signal"
            annotation (Placement(transformation(extent={{-180,-40},{-100,40}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.BooleanOutput y "Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}}),
                iconTransformation(extent={{101,-11},{122,10}})));

        equation
          y = u == p;
          annotation (Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1),  graphics),
                                     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Text(
                  extent={{110,-50},{250,-70}},
                  lineColor={0,0,0},
                  textString=DynamicSelect(" ", realString(
                          y,
                          1,
                          0))),
                Text(
                  extent={{-250,170},{250,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-94,108},{92,-52}},
                  lineColor={128,128,128},
                  textString="p"),
                Text(
                  extent={{-100,40},{100,-40}},
                  lineColor={0,0,0},
                  textString="=="),              Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                            {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                            {235,235,235}),
                  fillPattern=FillPattern.Solid)}));
        end Integer_Equality_Parameter;

        block Hysteresis_Movable_Limits
          "Same as MSL Hysteresis but the limits are inputs rather than parameters"
          extends Modelica.Blocks.Interfaces.partialBooleanSO;
          parameter Boolean pre_y_start = false
            "Value of pre(y) at initial time";

          Modelica.Blocks.Interfaces.RealInput lo annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120})));
          Modelica.Blocks.Interfaces.RealInput hi annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={60,-120})));
          Modelica.Blocks.Interfaces.RealInput u annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},
                    {-100,20}})));
        initial equation
          pre(y) = pre_y_start;
        equation
           assert(hi > lo, "hi must be greater than lo in Hysteresis_Movable_Limits");
           y = u > hi or pre(y) and u >= lo;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}),     graphics={
                Polygon(
                  points={{-65,89},{-73,67},{-57,67},{-65,89}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-65,67},{-65,-81}}, color={192,192,192}),
                Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{70,-80},{94,-100}},
                  lineColor={160,160,164},
                  textString="u"),
                Text(
                  extent={{-65,93},{-12,75}},
                  lineColor={160,160,164},
                  textString="y"),
                Line(
                  points={{-80,-40},{30,-40}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-50,40},{80,40}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-50,40},{-50,-40}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{30,40},{30,-40}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-10,-35},{0,-40},{-10,-45}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-10,45},{-20,40},{-10,35}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-55,10},{-50,0},{-44,10}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{25,0},{30,11},{35,0}},
                  color={0,0,0},
                  thickness=0.5),
                Text(
                  extent={{-99,32},{-70,48}},
                  lineColor={160,160,164},
                  textString="true"),
                Text(
                  extent={{-98,-57},{-66,-43}},
                  lineColor={160,160,164},
                  textString="false"),
                Line(points={{-69,40},{-60,40}}, color={160,160,164}),
                Line(
                  points={{-60,-100},{-60,-60},{-50,-60},{-50,-40}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{60,-100},{60,-60},{30,-60},{30,-40}},
                  color={0,0,255},
                  smooth=Smooth.None)}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                            graphics={
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
                Polygon(
                  points={{92,-29},{70,-21},{70,-37},{92,-29}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
                Line(points={{-79,-29},{41,-29}}, color={0,0,0}),
                Line(points={{-15,-21},{1,-29},{-15,-36}}, color={0,0,0}),
                Line(points={{41,51},{41,-29}}, color={0,0,0}),
                Line(points={{33,3},{41,22},{50,3}}, color={0,0,0}),
                Line(points={{-49,51},{81,51}}, color={0,0,0}),
                Line(points={{-4,59},{-19,51},{-4,43}}, color={0,0,0}),
                Line(points={{-59,29},{-49,11},{-39,29}}, color={0,0,0}),
                Line(points={{-49,51},{-49,-29}}, color={0,0,0}),
                Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
                Line(points={{41,-29},{41,-49}}, color={192,192,192}),
                Line(
                  points={{-60,-100},{-60,-60},{-50,-60},{-50,-30}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{60,-100},{60,-60},{42,-60},{42,-28}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash)}),
            Documentation(info="<HTML>
<p>
This block transforms a <b>Real</b> input signal into a <b>Boolean</b>
output signal:
</p>
<ul>
<li> When the output was <b>false</b> and the input becomes
     <b>greater</b> than parameter <b>uHigh</b>, the output
     switches to <b>true</b>.</li>
<li> When the output was <b>true</b> and the input becomes
     <b>less</b> than parameter <b>uLow</b>, the output
     switches to <b>false</b>.</li>
</ul>
<p>
The start value of the output is defined via parameter
<b>pre_y_start</b> (= value of pre(y) at initial time).
The default value of this parameter is <b>false</b>.
</p>
</HTML>
"));
        end Hysteresis_Movable_Limits;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;
          model Test_Latch_Control
            extends Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Sine sine(freqHz=1)
              annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
            Modelica.Blocks.Sources.Ramp const(
              duration=3,
              offset=1,
              height=-2)
              annotation (Placement(transformation(extent={{-80,-80},{-60,-60}})));
            Modelica.Blocks.Sources.Constant const1(k=-2.5)
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
            Hysteresis_Movable_Limits hysteresis_Movable_Limits
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
          equation
            connect(hysteresis_Movable_Limits.u, sine.y) annotation (Line(
                points={{-22,10},{-59,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const1.y, hysteresis_Movable_Limits.lo) annotation (Line(
                points={{-59,-30},{-16,-30},{-16,-2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const.y, hysteresis_Movable_Limits.hi) annotation (Line(
                points={{-59,-70},{-4,-70},{-4,-2}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(graphics),
              experiment(StopTime=3),
              __Dymola_experimentSetupOutput);
          end Test_Latch_Control;
        end Tests;
      end Logical;

      package Sources
          extends Modelica.Icons.SourcesPackage;

        block Steps_Multiple "Generate multiple step signals of type Real"
          extends
            C2M2L_OM.MSL_Extend.Blocks.Sources.Base_Classes.Partial_Step_Source;
          parameter Real height=1 "Height of step";

        equation
          y = offset + height*(steps - 1);
          annotation (Icon(graphics={
                Line(
                  points={{-80,-86},{-40,-86},{-40,-46},{0,-46},{0,-6},{40,-6},{40,34},
                      {80,34}},
                  color={0,0,255},
                  smooth=Smooth.None)}),            Documentation(info="<html>
<p>Provides an incrementing step function (like a staircase).</p>
<p>Whever time &GT; (steps * length + starttime) the steps Integer variable is incremented by 1. (Steps is always initialized to 1.)</p>
<p>The ouput value y is then = offset + height * (steps - 1)</p>
<p>So the first step after starttime is reached will still be at y = offset.</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
</html>"));
        end Steps_Multiple;

        block Normal_Faults "Generate normally distributed faults"
          extends
            C2M2L_OM.MSL_Extend.Blocks.Sources.Base_Classes.Partial_Step_Source;
          import Dir = C2M2L_OM.MSL_Extend.Types.Direction;
          parameter Real sigma=0.1 "Standard deviation of faults";
          parameter Real max_fault_size=1.0
            "Max magnitude of fault, <0 means no limit";
          parameter Boolean fault_pos = false
            "if true, fault is added to offset else subtracted";
          parameter Real seed=362436 "Seed for random number generation";
          parameter Dir fault_dir(start=Dir.Negative)
            "Which direction(s) to apply faults";
        protected
          Real fault;
          C2M2L_OM.MSL_Extend.Math.Random.Seed s(start={seed,seed,seed});
          Real fault_lim;
        equation
          when {change(flip_flop), initial()} then
            (fault,s) = C2M2L_OM.MSL_Extend.Math.Random.normalvariate(0.0, sigma, pre(s));
            if max_fault_size < 0 then
              fault_lim = fault;
            else
              fault_lim = min(max(fault, -max_fault_size), max_fault_size);
            end if;
            if fault_dir == Dir.Both then
              y = offset + fault_lim;
            elseif fault_dir == Dir.Positive then
              y = offset + abs(fault_lim);
            else
              y = offset - abs(fault_lim);
            end if;
          end when;
          annotation (Icon(graphics={
                Polygon(
                  points={{-76,40},{-76,6},{-40,6},{-40,-16},{0,-16},{0,-62},{40,-62},{
                      40,-34},{78,-34},{78,-8},{96,-8},{96,40},{-76,40}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={255,220,220},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-76,6},{-40,6},{-40,-16},{0,-16},{0,-62},{40,-62},{40,-34},{
                      78,-34},{78,-8},{96,-8}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Polygon(
                  points={{-70,100},{-78,78},{-62,78},{-70,100}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-70,88},{-70,-80}}, color={192,192,192}),
                Line(points={{-80,-70},{92,-70}}, color={192,192,192}),
                Polygon(
                  points={{100,-70},{78,-62},{78,-78},{100,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-76,40},{96,40}},
                  color={0,0,0},
                  smooth=Smooth.None)}), Documentation(info="<html>
<p>Provides a signal with a normally distributed fault level subtracted from it.</p>
<p>Whever time &GT; (steps * length + starttime) another fault value is chosen from a uniform distribution with standard deviation = sigma.</p>
<p>If abs(fault_value) &GT; max_fault_size then fault_value = max_fault_size</p>
<p><br/>The ouput value y is then = offset- abs(fault_value)</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
<p>The random seed is set as a parameter so using the same seed and sigma will always give the same sequence. So if using multiple instances of this block it is recommended to change this seed value to prevent correlation between the blocks.</p>
</html>"));
        end Normal_Faults;

        block Normal_Random_Steps
          "Generate random steps according to a normal distribution"
          extends
            C2M2L_OM.MSL_Extend.Blocks.Sources.Base_Classes.Partial_Step_Source;
          parameter Real sigma=0.1 "Standard deviation of output";
          parameter Real min_out=-1.0 "Maximum signal size out";
          parameter Real max_out=1.0 "Maximum signal size out";
          parameter Real seed = 290675;
        protected
          Real out;
          C2M2L_OM.MSL_Extend.Math.Random.Seed   s( start = {seed,seed,seed});
        equation
          when {change(flip_flop), initial()} then
            (out, s) = C2M2L_OM.MSL_Extend.Math.Random.normalvariate(  0.0, sigma, pre(s));
            y = min(max(out + offset, min_out), max_out);
          end when;
          annotation (Icon(graphics={
                Line(
                  points={{-74,-46},{-40,-46},{-40,40},{0,40},{0,-22},{40,-22},{40,-52},
                      {78,-52},{78,16},{94,16}},
                  color={0,0,255},
                  smooth=Smooth.None)}), Documentation(info="<html>
<p>Provides a signal with a normally distributed fault level subtracted from it.</p>
<p>Whever time &GT; (steps * length + starttime) another fault value is chosen from  a uniform distribution with standard deviation = sigma.</p>
<p>If abs(fault_value) &GT; max_fault_size then fault_value = max_fault_size</p>
<p><br/>The ouput value y is then = offset- abs(fault_value)</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
<p>The random seed is set as a parameter so using the same seed and sigma will always give the same sequence.  So if using multiple numbers of this block it is recommended to change this seed value.</p>
</html>"));
        end Normal_Random_Steps;

        model Normal_Random_Lookahead
          "Provides a random sample signal y(t) and also y(t + la) where la is the time in seconds to look ahead"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          Blocks.Sources.Normal_Random_Steps lookahead_data(
            offset=offset,
            sigma=sigma,
            min_out=min_out,
            max_out=max_out,
            length=length,
            seed=seed)
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          Blocks.Sources.Normal_Random_Steps current_data(
            startTime=look_ahead_time,
            offset=offset,
            sigma=sigma,
            min_out=min_out,
            max_out=max_out,
            length=length,
            seed=seed)
            annotation (Placement(transformation(extent={{-80,-18},{-60,2}})));
          parameter SI.Time look_ahead_time=5 "Amount of time la to look ahead";
          parameter Real offset=0 "Offset of output signal y";
          parameter Real sigma=0.1 "Standard deviation of output";
          parameter Real min_out=-1.0 "Maximum signal size out";
          parameter Real max_out=1.0 "Maximum signal size out";
          parameter SI.Time length=1.0;
          parameter Real seed=290675 "Random seed";
          Modelica.Blocks.Interfaces.RealOutput y_look_ahead
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
        equation
          connect(lookahead_data.y, y_look_ahead) annotation (Line(
              points={{-59,30},{22,30},{22,60},{110,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(current_data.y, y) annotation (Line(
              points={{-59,-8},{22,-8},{22,-60},{110,-60}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            experiment(StopTime=100),
            __Dymola_experimentSetupOutput,
            Diagram(graphics),
            Icon(graphics={
                Text(
                  extent={{100,100},{300,60}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="y(t + la)"),
                Text(
                  extent={{120,-20},{220,-60}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="y(t)"),
                Line(points={{-70,88},{-70,-80}}, color={192,192,192}),
                Polygon(
                  points={{-70,100},{-78,78},{-62,78},{-70,100}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-64,-46},{-40,-46},{-40,40},{-8,40},{-8,-22},{26,-22},{26,
                      -46},{56,-46},{56,16},{88,16}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Polygon(
                  points={{100,-70},{78,-62},{78,-78},{100,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-70},{92,-70}}, color={192,192,192}),
                Line(
                  points={{-102,-46},{-78,-46},{-78,40},{-46,40},{-46,-22},{-12,-22},{
                      -12,-46},{18,-46},{18,16},{50,16}},
                  color={255,170,170},
                  smooth=Smooth.None),
                Line(
                  points={{18,28},{18,80}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{56,28},{56,80}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Text(
                  extent={{-84,100},{156,60}},
                  lineColor={128,128,128},
                  textString="la"),
                Line(
                  points={{56,56},{18,56},{28,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{18,56},{28,46}},
                  color={0,0,0},
                  smooth=Smooth.None)}));
        end Normal_Random_Lookahead;

        block Time_Table_Lookahead
          "Same as CombiTimeTable from MSL but provides a y(t + la) output in addition to y(t)"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          Modelica.Blocks.Sources.CombiTimeTable lookahead_data(
            tableOnFile=tableOnFile,
            table=table,
            tableName=tableName,
            fileName=fileName,
            smoothness=smoothness,
            extrapolation=extrapolation,
            offset=offset)
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          Modelica.Blocks.Sources.CombiTimeTable current_data(
            tableOnFile=tableOnFile,
            table=table,
            tableName=tableName,
            fileName=fileName,
            smoothness=smoothness,
            extrapolation=extrapolation,
            offset=offset,
            startTime=lookahead_time)
            annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
          parameter Boolean tableOnFile=false
            "= true, if table is defined on file or in function usertab"
            annotation (Dialog(group="table data definitioin"));
          parameter Real table[:,:]=fill(
              0.0,
              0,
              2) "Table matrix (time = first column; e.g., table=[0,2])"
            annotation (Dialog(group="table data definitioin", enable=not tableOnFile));
          parameter String tableName="NoName"
            "Table name on file or in function usertab (see docu)"
            annotation (Dialog(group="table data definitioin", enable=tableOnFile));
          parameter String fileName="NoName" "File where matrix is stored"
            annotation (Dialog(group="table data definitioin", enable=tableOnFile));
          parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
            "Smoothness of table interpolation"
            annotation (Dialog(group="table data interpretation"));
          parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
            "Extrapolation of data outside the definition range"
                                                                annotation (Dialog(group="table data interpretation"));
          parameter Real offset[:]={0} "Offsets of output signals" annotation (Dialog(group="table data interpretation"));
          parameter SI.Time lookahead_time=0 "Amount of time to lookahead" annotation (Dialog(group="look ahead"));
          Modelica.Blocks.Interfaces.RealOutput y_look_ahead
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
        equation
          connect(current_data.y[1], y) annotation (Line(
              points={{-19,-50},{42,-50},{42,-60},{110,-60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookahead_data.y[1], y_look_ahead) annotation (Line(
              points={{-19,50},{42,50},{42,60},{110,60}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(graphics), Icon(graphics={
                Text(
                  extent={{80,100},{280,60}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="y(t + la)"),
                Text(
                  extent={{100,0},{200,-40}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="y(t)"),
                Polygon(
                  points={{-78,86},{-86,64},{-70,64},{-78,86}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-78,64},{-78,-84}}, color={192,192,192}),
                Line(points={{-88,-74},{84,-74}}, color={192,192,192}),
                Polygon(
                  points={{92,-74},{70,-66},{70,-82},{92,-74}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-72,-60},{-54,-18},{-26,6},{-14,-18},{12,-40},{22,8},{34,58},
                      {36,58},{60,58},{72,24},{82,-14},{92,-36},{100,-40}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-100,-36},{-92,-18},{-64,6},{-52,-18},{-26,-40},{-16,8},{-4,
                      58},{-2,58},{22,58},{34,24},{44,-14},{54,-36},{76,-46},{100,-50}},
                  color={255,170,170},
                  smooth=Smooth.None),
                Line(
                  points={{-4,60},{-4,98}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,60},{34,98}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{20,-46},{80,-106}},
                  lineColor={0,0,0},
                  textString="t")}));
        end Time_Table_Lookahead;

        block Normal_Random_Triggered
          "Generate random values according to a normal distribution when triggered"
          extends
            C2M2L_OM.MSL_Extend.Blocks.Sources.Base_Classes.Partial_Triggered_Source;
          parameter Real sigma=0.1 "Standard deviation of output";
          parameter Real min_out=-1.0 "Maximum signal size out";
          parameter Real max_out=1.0 "Maximum signal size out";
          parameter Real seed = 290675;
        protected
          Real out;
          C2M2L_OM.MSL_Extend.Math.Random.Seed   s( start = {seed,seed,seed});
        equation
          when {change(u), initial()} then
            (out, s) = C2M2L_OM.MSL_Extend.Math.Random.normalvariate(  0.0, sigma, pre(s));
            y = min(max(out + offset, min_out), max_out);
          end when;
          annotation (Icon(graphics={
                Line(
                  points={{-74,-46},{-40,-46},{-40,40},{0,40},{0,-22},{40,-22},{40,-52},
                      {78,-52},{78,16},{94,16}},
                  color={0,0,255},
                  smooth=Smooth.None)}), Documentation(info="<html>
<p>Provides a signal with a normally distributed fault level subtracted from it.</p>
<p>Whever time &GT; (steps * length + starttime) another fault value is chosen from  a uniform distribution with standard deviation = sigma.</p>
<p>If abs(fault_value) &GT; max_fault_size then fault_value = max_fault_size</p>
<p><br/>The ouput value y is then = offset- abs(fault_value)</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
<p>The random seed is set as a parameter so using the same seed and sigma will always give the same sequence.  So if using multiple numbers of this block it is recommended to change this seed value.</p>
</html>"));
        end Normal_Random_Triggered;

        package Constants "Commonly used constants with small icons"
        extends Modelica.Icons.Package;

          block Fix_0 "Small icon for a fixed value of 0"

            Modelica.Blocks.Interfaces.RealOutput y=0
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                    extent={{-38,40},{42,-40}},
                    lineColor={128,128,128},
                    textString="0",
                    fontName="Comic Sans MS"),    Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255})}));
          end Fix_0;

          block Fix_Minus_1 "Small icon for a fixed value of -1"

            Modelica.Blocks.Interfaces.RealOutput y=-1
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                    extent={{-38,40},{42,-40}},
                    lineColor={128,128,128},
                    textString="-1",
                    fontName="Comic Sans MS"),    Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255})}));
          end Fix_Minus_1;

          block Fix_Plus_1 "Small icon for a fixed value of +1"

            Modelica.Blocks.Interfaces.RealOutput y=1
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                    extent={{-38,40},{42,-40}},
                    lineColor={128,128,128},
                    fontName="Comic Sans MS",
                    textString="+1"),             Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255})}));
          end Fix_Plus_1;

          block Fix_PI "Small icon for a fixed value of pi"

            Modelica.Blocks.Interfaces.RealOutput y=pi
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                                  Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255}),
                  Rectangle(
                    extent={{-20,16},{20,10}},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{6,10},{12,-10}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-12,10},{-6,-10}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid)}));
          end Fix_PI;

          block Fix_PI_Neg "Small icon for a fixed value of -pi"

            Modelica.Blocks.Interfaces.RealOutput y=-pi
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                    extent={{-62,46},{18,-34}},
                    lineColor={128,128,128},
                    textString="-"),              Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255}),
                  Rectangle(
                    extent={{-10,18},{30,12}},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-2,12},{4,-8}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{16,12},{22,-8}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid)}));
          end Fix_PI_Neg;

          block Fix_PI_Over_2 "Small icon for a fixed value of pi/2"

            Modelica.Blocks.Interfaces.RealOutput y=pi/2
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                                  Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255}),
                    Text(
                    extent={{-38,8},{44,-50}},
                    lineColor={128,128,128},
                    fontName="Comic Sans MS",
                    textString="2"),
                    Text(
                    extent={{-38,54},{44,-4}},
                    lineColor={128,128,128},
                    textStyle={TextStyle.UnderLine},
                    textString="   "),
                  Rectangle(
                    extent={{-18,38},{22,32}},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{8,32},{14,12}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-10,32},{-4,12}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid)}));
          end Fix_PI_Over_2;

          block Fix_PI_Over_2_Neg "Small icon for a fixed value of -pi/2"

            Modelica.Blocks.Interfaces.RealOutput y=-pi/2
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            annotation (Diagram(coordinateSystem(extent={{-40,-40},{40,40}})), Icon(
                  coordinateSystem(extent={{-40,-40},{40,40}}, preserveAspectRatio=true),
                  graphics={Rectangle(extent={{-40,40},{40,-40}}, lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                    extent={{-42,50},{40,-8}},
                    lineColor={128,128,128},
                    textString="-  ",
                    textStyle={TextStyle.UnderLine}),
                                                  Text(
                  extent={{-150,80},{150,40}},
                  textString="%name",
                  lineColor={0,0,255}),
                    Text(
                    extent={{-38,8},{44,-50}},
                    lineColor={128,128,128},
                    fontName="Comic Sans MS",
                    textString="2"),
                  Rectangle(
                    extent={{20,28},{26,8}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{2,28},{8,8}},
                    pattern=LinePattern.None,
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-6,34},{34,28}},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}));
          end Fix_PI_Over_2_Neg;
        annotation (Icon(graphics={
              Rectangle(
                extent={{-66,14},{54,2}},
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{14,4},{24,-46}},
                pattern=LinePattern.None,
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-36,2},{-26,-46}},
                pattern=LinePattern.None,
                fillColor={128,128,128},
                fillPattern=FillPattern.Solid)}));
        end Constants;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;

          model Test_Normal
            extends Icons.Simple_Test_Case;
            Normal_Faults normal_Faults(offset=2,
              fault_dir=C2M2L_OM.MSL_Extend.Types.Direction.Both,
              sigma=2,
              max_fault_size=1)
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            Normal_Random_Steps normal_Random_Steps
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            Normal_Random_Lookahead normal_Random_Lookahead(look_ahead_time=2.2)
              annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
            annotation (experiment(StopTime=200),__Dymola_experimentSetupOutput);
          end Test_Normal;

          model Test_Steps_Multiple
            extends Icons.Simple_Test_Case;
            Steps_Multiple steps_Multiple
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            Modelica.Blocks.Discrete.TriggeredSampler speed_sampler(y_start=0)
              annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
            Modelica.Blocks.Sources.Ramp ramp(duration=10)
              annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
          equation
            connect(steps_Multiple.sample_trigger, speed_sampler.trigger) annotation (
                Line(
                points={{-59,36},{-30,36},{-30,58.2}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(ramp.y, speed_sampler.u) annotation (Line(
                points={{-59,70},{-42,70}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=10),
              __Dymola_experimentSetupOutput);
          end Test_Steps_Multiple;

          model Test_Normal_Random_Triggered
            extends Icons.Simple_Test_Case;
            Normal_Random_Triggered normal_Random_Triggered(
              offset=1,
              sigma=0.5,
              min_out=0.01,
              max_out=4)
              annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
            Modelica.Blocks.Logical.Timer timer
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
            Modelica.Blocks.Logical.Greater greater
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Modelica.Blocks.Logical.Pre pre1
              annotation (Placement(transformation(extent={{40,-20},{60,0}})));
            Normal_Random_Triggered normal_Random_Triggered1(
              min_out=0.1,
              offset=10,
              sigma=5,
              max_out=40,
              seed=5774) annotation (Placement(transformation(extent={{40,20},{60,40}})));
          equation
            connect(timer.y, greater.u2) annotation (Line(
                points={{-19,10},{-12,10},{-12,22},{-2,22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(normal_Random_Triggered.y, greater.u1) annotation (Line(
                points={{-19,50},{-10,50},{-10,30},{-2,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(greater.y, pre1.u) annotation (Line(
                points={{21,30},{30,30},{30,-10},{38,-10}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(pre1.y, normal_Random_Triggered.u) annotation (Line(
                points={{61,-10},{80,-10},{80,-40},{-60,-40},{-60,50},{-42,50}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(pre1.y, timer.u) annotation (Line(
                points={{61,-10},{80,-10},{80,-40},{-60,-40},{-60,10},{-42,10}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(normal_Random_Triggered1.u, greater.y) annotation (Line(
                points={{38,30},{21,30}},
                color={255,0,255},
                smooth=Smooth.None));
            annotation (Diagram(graphics));
          end Test_Normal_Random_Triggered;
        end Tests;

        package Base_Classes
        extends Modelica.Icons.BasesPackage;

          partial block Partial_Step_Source
            "Base class for sources that generate stepped outputs"
            extends Modelica.Blocks.Interfaces.SignalSource;
            parameter Modelica.SIunits.Time length=1.0 "Length of step";

            Modelica.Blocks.Interfaces.BooleanOutput sample_trigger(start=false, fixed=true)
              "true during the event step change event"
              annotation (Placement(transformation(extent={{100,50},{120,70}}),
                  iconTransformation(extent={{100,50},{120,70}})));
          protected
            Integer steps(start=1, fixed=true);
            Boolean flip_flop(start=false, fixed=true);
            Boolean not_flip_flop=not flip_flop;
          equation
            when time > (pre(steps)*length + startTime) then
              steps = pre(steps) + 1;
              flip_flop = not pre(flip_flop);
            end when;

            // output true on sample_trigger whenever the output on y changes
            sample_trigger = change(flip_flop);

            annotation (Icon(graphics={
                  Line(
                    points={{0,60},{0,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{40,60},{40,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{78,60},{78,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,60},{-40,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Polygon(
                    points={{-70,100},{-78,78},{-62,78},{-70,100}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-70,88},{-70,-80}}, color={192,192,192}),
                  Line(points={{-80,-70},{92,-70}}, color={192,192,192}),
                  Polygon(
                    points={{100,-70},{78,-62},{78,-78},{100,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{0,88},{0,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,88},{-40,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{100,60},{-66,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{78,88},{78,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{40,88},{40,60}},
                    color={255,0,255},
                    smooth=Smooth.None)}),            Documentation(info="<html>
<p>Provides an incrementing step function (like a staircase).</p>
<p>Whever time &GT; (steps * length + starttime) the steps Integer variable is incremented by 1. (Steps is always initialized to 1.)</p>
<p>The ouput value y is then = offset + height * (steps - 1)</p>
<p>So the first step after starttime is reached will still be at y = offset.</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
</html>"));
          end Partial_Step_Source;

          partial block Partial_Triggered_Source
            "Base class for sources that generate a new output when boolean input changes"
            extends Modelica.Blocks.Interfaces.SignalSource;

          public
            Modelica.Blocks.Interfaces.BooleanInput u annotation (Placement(
                  transformation(extent={{-140,-20},{-100,20}}), iconTransformation(
                    extent={{-140,-20},{-100,20}})));
          equation

            annotation (Icon(graphics={
                  Line(
                    points={{0,60},{0,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{40,60},{40,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{78,60},{78,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,60},{-40,-70}},
                    color={255,220,255},
                    smooth=Smooth.None),
                  Polygon(
                    points={{-70,100},{-78,78},{-62,78},{-70,100}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-70,88},{-70,-80}}, color={192,192,192}),
                  Line(points={{-80,-70},{92,-70}}, color={192,192,192}),
                  Polygon(
                    points={{100,-70},{78,-62},{78,-78},{100,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{0,88},{0,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,88},{-40,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{100,60},{-66,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{78,88},{78,60}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{40,88},{40,60}},
                    color={255,0,255},
                    smooth=Smooth.None)}),            Documentation(info="<html>
<p>Provides an incrementing step function (like a staircase).</p>
<p>Whever time &GT; (steps * length + starttime) the steps Integer variable is incremented by 1. (Steps is always initialized to 1.)</p>
<p>The ouput value y is then = offset + height * (steps - 1)</p>
<p>So the first step after starttime is reached will still be at y = offset.</p>
<p>The parameters starttime and offset are inherited from SignalSource.</p>
</html>"));
          end Partial_Triggered_Source;
        end Base_Classes;
      end Sources;

      package Continuous
        "Provides extensions to the MSL package of the same name"
        extends Modelica.Icons.Package;

        block Integrator_Resettable
          "Output the integral of the input signal.  Plus a reset port."
          import Modelica.Blocks.Types.Init;
          parameter Boolean use_reset_port = false "=true, show reset port" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real k(unit="1")=1 "Integrator gain";

          /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
          parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
            "Type of initialization (1: no init, 2: steady state, 3,4: initial output)"
                                                                                            annotation(Evaluate=true,
              Dialog(group="Initialization"));
          parameter Real y_start=0 "Initial or guess value of output (= state)"
            annotation (Dialog(group="Initialization"));
          extends Modelica.Blocks.Interfaces.SISO(y(start=y_start));

          Modelica.Blocks.Interfaces.BooleanInput reset if use_reset_port
            "When true reset the output to zero and stop integrating" annotation (
              Placement(transformation(
                extent={{-21,-20},{21,20}},
                rotation=90,
                origin={-1,-120})));
        protected
          Modelica.Blocks.Sources.BooleanConstant reset_always_false(k=false) if not use_reset_port
            "only used if reset port disabled"
            annotation (Placement(transformation(extent={{-90,-98},{-70,-78}})));
          Modelica.Blocks.MathBoolean.Or internal_reset(nu=1)
            annotation (Placement(transformation(extent={{52,-84},{64,-72}})));
        initial equation
          if initType == Init.SteadyState then
             der(y) = 0;
          elseif initType == Init.InitialState or
                 initType == Init.InitialOutput then
            y = y_start;
          end if;
        equation
          if not internal_reset.y then
            der(y) = k*u;
          else
            der(y) = 0.0;
          end if;
          when internal_reset.y then
            reinit(y, 0.0);
          end when;
          connect(reset_always_false.y, internal_reset.u[1]) annotation (Line(
              points={{-69,-88},{-28,-88},{-28,-78},{52,-78}},
              color={255,0,255},
              smooth=Smooth.None));
          connect(reset, internal_reset.u[1]) annotation (Line(
              points={{-1,-120},{-1,-78},{52,-78}},
              color={255,0,255},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
This blocks computes output <b>y</b> (element-wise) as
<i>integral</i> of the input <b>u</b> multiplied with
the gain <i>k</i>:
</p>
<pre>
         k
     y = - u
         s
</pre>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

</html>
"),         Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
                Polygon(
                  points={{90,-80},{68,-72},{68,-88},{90,-80}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{0,-10},{60,-70}},
                  lineColor={192,192,192},
                  textString="I"),
                Text(
                  extent={{-150,40},{150,80}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Line(points={{-80,-80},{80,80}}, color={0,0,127})}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
                Line(points={{-100,0},{-60,0}}, color={0,0,255}),
                Line(points={{60,0},{100,0}}, color={0,0,255}),
                Text(
                  extent={{-36,60},{32,2}},
                  lineColor={0,0,0},
                  textString="k"),
                Text(
                  extent={{-32,0},{36,-58}},
                  lineColor={0,0,0},
                  textString="s"),
                Line(points={{-46,0},{46,0}}, color={0,0,0})}));
        end Integrator_Resettable;

        block LimPID_Resettable
          "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting.  Plus an optional reset port"
          import Modelica.Blocks.Types.InitPID;
          import Modelica.Blocks.Types.SimpleController;
          extends Modelica.Blocks.Interfaces.SVcontrol;
          output Real controlError = u_s - u_m
            "Control error (set point - measurement)";
          parameter Boolean use_reset_port=false "=true, show reset port"   annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
            Dialog(group="Connection options"));
          parameter Boolean use_feed_forward=false
            "=true, use feed forward signal"                                          annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
            Dialog(group="Connection options"));
          parameter Modelica.Blocks.Types.SimpleController controllerType=
                 Modelica.Blocks.Types.SimpleController.PID
            "Type of controller";
          parameter Real k(min=0, unit="1") = 1 "Gain of controller";
          parameter SI.Time Ti(min=Modelica.Constants.small, start=0.5)
            "Time constant of Integrator block"
             annotation(Dialog(enable=controllerType==SimpleController.PI or
                                      controllerType==SimpleController.PID));
          parameter SI.Time Td(min=0, start=0.1)
            "Time constant of Derivative block"
               annotation(Dialog(enable=controllerType==SimpleController.PD or
                                        controllerType==SimpleController.PID));
          parameter Real yMax(start=1) "Upper limit of output";
          parameter Real yMin=-yMax "Lower limit of output";
          parameter Real wp(min=0) = 1
            "Set-point weight for Proportional block (0..1)";
          parameter Real wd(min=0) = 0
            "Set-point weight for Derivative block (0..1)"
               annotation(Dialog(enable=controllerType==SimpleController.PD or
                                        controllerType==SimpleController.PID));
          parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
            "Ni*Ti is time constant of anti-windup compensation"
             annotation(Dialog(enable=controllerType==SimpleController.PI or
                                      controllerType==SimpleController.PID));
          parameter Real Nd(min=100*Modelica.Constants.eps) = 10
            "The higher Nd, the more ideal the derivative block"
               annotation(Dialog(enable=controllerType==SimpleController.PD or
                                        controllerType==SimpleController.PID));
          parameter Modelica.Blocks.Types.InitPID initType= Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
            "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                             annotation(Evaluate=true,
              Dialog(group="Initialization"));
          parameter Boolean limitsAtInit = true
            "= false, if limits are ignored during initializiation"
            annotation(Evaluate=true, Dialog(group="Initialization",
                               enable=controllerType==SimpleController.PI or
                                      controllerType==SimpleController.PID));
          parameter Real xi_start=0
            "Initial or guess value value for integrator output (= integrator state)"
            annotation (Dialog(group="Initialization",
                        enable=controllerType==SimpleController.PI or
                               controllerType==SimpleController.PID));
          parameter Real xd_start=0
            "Initial or guess value for state of derivative block"
            annotation (Dialog(group="Initialization",
                                 enable=controllerType==SimpleController.PD or
                                        controllerType==SimpleController.PID));
          parameter Real y_start=0 "Initial value of output"
            annotation(Dialog(enable=initType == InitPID.InitialOutput, group=
                  "Initialization"));

          Modelica.Blocks.Math.Add addP(k1=wp, k2=-1)
            annotation (Placement(transformation(extent={{-80,40},{-60,60}}, rotation=
                   0)));
          Modelica.Blocks.Math.Add addD(k1=wd, k2=-1) if with_D
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}},
                  rotation=0)));
          Modelica.Blocks.Math.Gain P(k=1)
                             annotation (Placement(transformation(extent={{-40,40},{
                    -20,60}}, rotation=0)));
          C2M2L_OM.MSL_Extend.Blocks.Continuous.Integrator_Resettable
                                I(
            use_reset_port=use_reset_port,
            k=1/Ti,
            y_start=xi_start,
            initType=if initType == InitPID.SteadyState then InitPID.SteadyState else
                if initType == InitPID.InitialState or initType == InitPID.DoNotUse_InitialIntegratorState
                 then InitPID.InitialState else InitPID.NoInit) if with_I
            annotation (Placement(transformation(extent={{-30,-60},{-10,-40}},
                  rotation=0)));
          Modelica.Blocks.Continuous.Derivative D(
            k=Td,
            T=max([Td/Nd,1.e-14]),
            x_start=xd_start,
            initType=if initType == InitPID.SteadyState or initType == InitPID.InitialOutput
                 then InitPID.SteadyState else if initType == InitPID.InitialState
                 then InitPID.InitialState else InitPID.NoInit) if with_D
            annotation (Placement(transformation(extent={{-52,-10},{-32,10}},
                  rotation=0)));
          Modelica.Blocks.Math.Gain gainPID(k=k)
                                        annotation (Placement(transformation(extent={{32,-5},
                    {42,5}},           rotation=0)));
          Modelica.Blocks.Math.Add3 addPID
                                  annotation (Placement(transformation(
                  extent={{3,-10},{23,10}}, rotation=0)));
          Modelica.Blocks.Math.Add3 addI(k2=-1) if with_I
                                                 annotation (Placement(
                transformation(extent={{-80,-60},{-60,-40}}, rotation=0)));
          Modelica.Blocks.Math.Add addSat(k1=+1, k2=-1) if with_I
            annotation (Placement(transformation(
                origin={80,-50},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Modelica.Blocks.Math.Gain gainTrack(k=1/(k*Ni)) if with_I
            annotation (Placement(transformation(extent={{40,-80},{20,-60}}, rotation=
                   0)));
          Modelica.Blocks.Nonlinear.Limiter limiter(
            uMax=yMax,
            uMin=yMin,
            limitsAtInit=limitsAtInit)
            annotation (Placement(transformation(extent={{66,-10},{86,10}}, rotation=
                    0)));
        protected
          parameter Boolean with_I = controllerType==SimpleController.PI or
                                     controllerType==SimpleController.PID annotation(Evaluate=true, HideResult=true);
          parameter Boolean with_D = controllerType==SimpleController.PD or
                                     controllerType==SimpleController.PID annotation(Evaluate=true, HideResult=true);
        public
          Modelica.Blocks.Sources.Constant Dzero(k=0) if not with_D
            annotation (Placement(transformation(extent={{-73,22},{-63,32}}, rotation=
                   0)));
          Modelica.Blocks.Sources.Constant Izero(k=0) if not with_I
            annotation (Placement(transformation(extent={{18,-55},{8,-45}}, rotation=
                    0)));
          Modelica.Blocks.Interfaces.BooleanInput reset if use_reset_port
            "Reset integrator and set output to zero" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={1,119})));
          Modelica.Blocks.Interfaces.RealInput u_ff if use_feed_forward
            "feed forward input (optional)"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Sources.Constant no_ff(k=0) if not use_feed_forward
            "used if there is no feed forward"
            annotation (Placement(transformation(extent={{20,60},{30,70}})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{47,-2},{57,8}})));
        initial equation
          if initType==InitPID.InitialOutput then
             y = y_start;
          end if;
        equation
          assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) +
                               ") < yMin (=" + String(yMin) + ")");
          if initType == InitPID.InitialOutput and (y_start < yMin or y_start > yMax) then
              Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) +
                 ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");
          end if;
          assert(limitsAtInit or not limitsAtInit and y >= yMin and y <= yMax,
                 "LimPID: During initialization the limits have been switched off.\n" +
                 "After initialization, the output y (=" + String(y) +
                 ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");

          connect(u_s, addP.u1) annotation (Line(points={{-120,0},{-96,0},{-96,56},{
                  -82,56}}, color={0,0,127}));
          connect(u_s, addD.u1) annotation (Line(points={{-120,0},{-96,0},{-96,6},{
                  -82,6}}, color={0,0,127}));
          connect(u_s, addI.u1) annotation (Line(points={{-120,0},{-96,0},{-96,-42},{
                  -82,-42}}, color={0,0,127}));
          connect(addP.y, P.u) annotation (Line(points={{-59,50},{-42,50}}, color={0,
                  0,127}));
          connect(addD.y, D.u)
            annotation (Line(points={{-59,0},{-52,0},{-54,0}},
                                                       color={0,0,127}));
          connect(addI.y, I.u) annotation (Line(points={{-59,-50},{-32,-50}}, color={
                  0,0,127}));
          connect(addPID.y, gainPID.u)
            annotation (Line(points={{24,0},{24,0},{31,0}},
                                                     color={0,0,127}));
          connect(addSat.y, gainTrack.u) annotation (Line(points={{80,-61},{80,-70},{
                  42,-70}}, color={0,0,127}));
          connect(gainTrack.y, addI.u3) annotation (Line(points={{19,-70},{-88,-70},{
                  -88,-58},{-82,-58}}, color={0,0,127}));
          connect(reset, I.reset) annotation (Line(
              points={{1,119},{1,93},{94,93},{94,-93},{-20,-93},{-20,-62},{-20.1,-62}},
              color={255,0,255},
              smooth=Smooth.None));

          connect(I.y, addPID.u3) annotation (Line(
              points={{-9,-50},{-4,-50},{-4,-8},{1,-8}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(D.y, addPID.u2) annotation (Line(
              points={{-31,0},{1,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(Dzero.y, addPID.u2) annotation (Line(
              points={{-62.5,27},{-25,27},{-25,0},{1,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(P.y, addPID.u1) annotation (Line(
              points={{-19,50},{-4,50},{-4,8},{1,8}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(Izero.y, addPID.u3) annotation (Line(
              points={{7.5,-50},{-4,-50},{-4,-8},{1,-8}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u_m, addP.u2) annotation (Line(
              points={{0,-120},{0,-94},{-94,-94},{-94,44},{-82,44}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u_m, addD.u2) annotation (Line(
              points={{0,-120},{0,-94},{-94,-94},{-94,-6},{-82,-6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u_m, addI.u2) annotation (Line(
              points={{0,-120},{0,-120},{0,-118},{0,-118},{0,-94},{-94,-94},{-94,-50},
                  {-82,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(limiter.y, y) annotation (Line(
              points={{87,0},{95,0},{95,0},{110,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(limiter.y, addSat.u1) annotation (Line(
              points={{87,0},{89,0},{89,-38},{86,-38}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(gainPID.y, add.u2) annotation (Line(
              points={{42.5,0},{46,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.u1, no_ff.y) annotation (Line(
              points={{46,6},{39,6},{39,65},{30.5,65}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, limiter.u) annotation (Line(
              points={{57.5,3},{60,3},{60,0},{64,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, addSat.u2) annotation (Line(
              points={{57.5,3},{60,3},{60,-30},{74,-30},{74,-38}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u_ff, add.u1) annotation (Line(
              points={{-120,80},{-54,80},{-54,79},{15,79},{15,18},{46,18},{46,6}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (defaultComponentName="PID",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
                Polygon(
                  points={{90,-80},{68,-72},{68,-88},{90,-80}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-80,50},{-80,-20},{30,60},{80,60}}, color={0,
                      0,127}),
                Text(
                  extent={{-20,-20},{80,-60}},
                  lineColor={192,192,192},
                  textString="PID"),
                Text(
                  extent={{-38,-104},{-14,-127}},
                  lineColor={0,0,255},
                  textString="m"),
                Text(
                  extent={{-131,41},{-107,18}},
                  lineColor={0,0,255},
                  textString="s"),
                Text(
                  visible=  use_feed_forward,
                  extent={{-129,118},{-105,95}},
                  lineColor={0,0,255},
                  textString="ff"),
                Text(
                  visible=  use_reset_port,
                  extent={{-57,100},{59,71}},
                  lineColor={0,0,255},
                  textString="reset")}),
            Documentation(info="<HTML>
<p>
Via parameter <b>controllerType</b> either <b>P</b>, <b>PI</b>, <b>PD</b>,
or <b>PID</b> can be selected. If, e.g., PI is selected, all components belonging to the
D-part are removed from the block (via conditional declarations).
The example model
<a href=\"modelica://Modelica.Blocks.Examples.PID_Controller\">Modelica.Blocks.Examples.PID_Controller</a>
demonstrates the usage of this controller.
Several practical aspects of PID controller design are incorporated
according to chapter 3 of the book:
</p>

<dl>
<dt>&Aring;str&ouml;m K.J., and H&auml;gglund T.:</dt>
<dd> <b>PID Controllers: Theory, Design, and Tuning</b>.
     Instrument Society of America, 2nd edition, 1995.
</dd>
</dl>

<p>
Besides the additive <b>proportional, integral</b> and <b>derivative</b>
part of this controller, the following features are present:
</p>
<ul>
<li> The output of this controller is limited. If the controller is
     in its limits, anti-windup compensation is activated to drive
     the integrator state to zero. </li>
<li> The high-frequency gain of the derivative part is limited
     to avoid excessive amplification of measurement noise.</li>
<li> Setpoint weighting is present, which allows to weight
     the setpoint in the proportional and the derivative part
     independantly from the measurement. The controller will respond
     to load disturbances and measurement noise independantly of this setting
     (parameters wp, wd). However, setpoint changes will depend on this
     setting. For example, it is useful to set the setpoint weight wd
     for the derivative part to zero, if steps may occur in the
     setpoint signal.</li>
</ul>

<p>
The parameters of the controller can be manually adjusted by performing
simulations of the closed loop system (= controller + plant connected
together) and using the following strategy:
</p>

<ol>
<li> Set very large limits, e.g., yMax = Modelica.Constants.inf</li>
<li> Select a <b>P</b>-controller and manually enlarge parameter <b>k</b>
     (the total gain of the controller) until the closed-loop response
     cannot be improved any more.</li>
<li> Select a <b>PI</b>-controller and manually adjust parameters
     <b>k</b> and <b>Ti</b> (the time constant of the integrator).
     The first value of Ti can be selected, such that it is in the
     order of the time constant of the oscillations occuring with
     the P-controller. If, e.g., vibrations in the order of T=10 ms
     occur in the previous step, start with Ti=0.01 s.</li>
<li> If you want to make the reaction of the control loop faster
     (but probably less robust against disturbances and measurement noise)
     select a <b>PID</b>-Controller and manually adjust parameters
     <b>k</b>, <b>Ti</b>, <b>Td</b> (time constant of derivative block).</li>
<li> Set the limits yMax and yMin according to your specification.</li>
<li> Perform simulations such that the output of the PID controller
     goes in its limits. Tune <b>Ni</b> (Ni*Ti is the time constant of
     the anti-windup compensation) such that the input to the limiter
     block (= limiter.u) goes quickly enough back to its limits.
     If Ni is decreased, this happens faster. If Ni=infinity, the
     anti-windup compensation is switched off and the controller works bad.</li>
</ol>

<p>
<b>Initialization</b>
</p>

<p>
This block can be initialized in different
ways controlled by parameter <b>initType</b>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
This type is identical to
<a href=\"modelica://Modelica.Blocks.Types.Init\">Types.Init</a>,
with the only exception that the additional option
<b>DoNotUse_InitialIntegratorState</b> is added for
backward compatibility reasons (= integrator is initialized with
InitialState whereas differential part is initialized with
NoInit which was the initialization in version 2.2 of the Modelica
standard library).
</p>

<p>
Based on the setting of initType, the integrator (I) and derivative (D)
blocks inside the PID controller are initialized according to the following table:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>initType</b></td>
      <td valign=\"top\"><b>I.initType</b></td>
      <td valign=\"top\"><b>D.initType</b></td></tr>

  <tr><td valign=\"top\"><b>NoInit</b></td>
      <td valign=\"top\">NoInit</td>
      <td valign=\"top\">NoInit</td></tr>

  <tr><td valign=\"top\"><b>SteadyState</b></td>
      <td valign=\"top\">SteadyState</td>
      <td valign=\"top\">SteadyState</td></tr>

  <tr><td valign=\"top\"><b>InitialState</b></td>
      <td valign=\"top\">InitialState</td>
      <td valign=\"top\">InitialState</td></tr>

  <tr><td valign=\"top\"><b>InitialOutput</b><br>
          and initial equation: y = y_start</td>
      <td valign=\"top\">NoInit</td>
      <td valign=\"top\">SteadyState</td></tr>

  <tr><td valign=\"top\"><b>DoNotUse_InitialIntegratorState</b></td>
      <td valign=\"top\">InitialState</td>
      <td valign=\"top\">NoInit</td></tr>
</table>

<p>
In many cases, the most useful initial condition is
<b>SteadyState</b> because initial transients are then no longer
present. If initType = InitPID.SteadyState, then in some
cases difficulties might occur. The reason is the
equation of the integrator:
</p>

<pre>
   <b>der</b>(y) = k*u;
</pre>

<p>
The steady state equation \"der(x)=0\" leads to the condition that the input u to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <b>singular</b>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is natural to
initialize it with zero. As sketched this is, however, not possible.
The solution is to not initialize u_m or the variable that is used
to compute u_m by an algebraic equation.
</p>

<p>
If parameter <b>limitAtInit</b> = <b>false</b>, the limits at the
output of this controller block are removed from the initialization problem which
leads to a much simpler equation system. After initialization has been
performed, it is checked via an assert whether the output is in the
defined limits. For backward compatibility reasons
<b>limitAtInit</b> = <b>true</b>. In most cases it is best
to use <b>limitAtInit</b> = <b>false</b>.
</p>
</HTML>
"),         Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics));
        end LimPID_Resettable;

        model Future_Estimate "Predict  u(t+la) from u(t) and du/dt"
          extends Modelica.Blocks.Interfaces.SISO;
          Modelica.Blocks.Continuous.Derivative du(T=Td)
            annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
          Modelica.Blocks.Math.Gain delta_u(k=lookahead)   annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={10,30})));
          Modelica.Blocks.Math.Add w_pred annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={50,6})));
          parameter SI.Time lookahead=0.5
            "Time period ahead of current point to estimate future u";
          parameter SI.Time Td=0.1
            "Derivative time constant.  Smaller is closer to ideal but likely to be unstable.";
        equation
          connect(du.y,delta_u.u) annotation (Line(
              points={{-39,30},{-2,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(w_pred.y, y) annotation (Line(
              points={{61,6},{83.5,6},{83.5,0},{110,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(delta_u.y, w_pred.u2) annotation (Line(
              points={{21,30},{28,30},{28,12},{38,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u, w_pred.u1) annotation (Line(
              points={{-120,0},{-42,0},{-42,1.77636e-015},{38,1.77636e-015}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(du.u, u) annotation (Line(
              points={{-62,30},{-86,30},{-86,0},{-120,0}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                  preserveAspectRatio=true), graphics), Icon(coordinateSystem(extent={{-100,
                    -100},{100,100}}, preserveAspectRatio=true), graphics={
                Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
                Polygon(
                  points={{90,-80},{68,-72},{68,-88},{90,-80}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,-58},{-60,-64},{-36,-68},{-22,-44},{-2,-16},{26,12}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{26,12},{72,50}},
                  color={255,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-24,-56},{104,-96}},
                  lineColor={128,128,128},
                  pattern=LinePattern.Dash,
                  textString="u(t)"),
                Text(
                  extent={{-94,70},{2,30}},
                  lineColor={128,128,128},
                  pattern=LinePattern.Dash,
                  textString="u(t+la)"),
                Text(
                  extent={{-140,-100},{140,-140}},
                  lineColor={128,128,128},
                  textString="la=%lookahead"),
                Text(
                  extent={{-70,102},{170,62}},
                  lineColor={128,128,128},
                  textString="la"),
                Line(
                  points={{26,28},{26,80}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{72,56},{62,46}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{26,56},{72,56},{62,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{72,28},{72,80}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash)}));
        end Future_Estimate;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;
          model Test_LimPID_Resettable
            extends Icons.Simple_Test_Case;
            LimPID_Resettable PID(
              yMax=10,
              k=1,
              controllerType=Modelica.Blocks.Types.SimpleController.PI,
              Ti=1,
              use_reset_port=true,
              use_feed_forward=false)
              annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
            Sources.Normal_Random_Steps random_steps(
              length=5,
              sigma=3,
              min_out=-10,
              max_out=10) annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=0,
                  origin={88,48})));
            Modelica.Mechanics.Rotational.Sources.Torque controlled_torque
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Modelica.Mechanics.Rotational.Sources.Torque disturbance_torque
              "represents external unseen disturbances"
              annotation (Placement(transformation(extent={{60,40},{40,60}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia(w(fixed=true), J=5)
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={10,12})));
            Modelica.Blocks.Sources.Constant const(k=10)
              annotation (Placement(transformation(extent={{-108,40},{-88,60}})));
            Modelica.Blocks.Sources.SampleTrigger sampleTrigger(period=20, startTime=20)
              annotation (Placement(transformation(extent={{-92,82},{-72,102}})));
          equation
            connect(random_steps.y, disturbance_torque.tau) annotation (Line(
                points={{77,48},{70,48},{70,50},{62,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(PID.y, controlled_torque.tau) annotation (Line(
                points={{-39,50},{-22,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(controlled_torque.flange, inertia.flange_a) annotation (Line(
                points={{0,50},{10,50}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia.flange_b, disturbance_torque.flange) annotation (Line(
                points={{30,50},{40,50}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(speedSensor.flange, inertia.flange_a) annotation (Line(
                points={{10,22},{10,36},{10,36},{10,50}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(speedSensor.w, PID.u_m) annotation (Line(
                points={{10,1},{10,-6},{-50,-6},{-50,38}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const.y, PID.u_s) annotation (Line(
                points={{-87,50},{-62,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sampleTrigger.y, PID.reset) annotation (Line(
                points={{-71,92},{-62,92},{-62,90},{-49.9,90},{-49.9,61.9}},
                color={255,0,255},
                smooth=Smooth.None));
            annotation (
              Diagram(graphics),
              experiment(StopTime=100),
              __Dymola_experimentSetupOutput);
          end Test_LimPID_Resettable;
        end Tests;
      end Continuous;

      package Metrics
        "Contains blocks that measure metrics of a model (e.g. min, max, time to threshold)"
      extends Modelica.Icons.SensorsPackage;

        package Base_Classes
          "Partial models used in construction of components"
        extends Modelica.Icons.BasesPackage;

          partial block Partial_Metric "base class for various metric blocks"
            extends Modelica.Blocks.Interfaces.SISO(y(start=0));
            parameter Boolean use_reset_port = false
              "=true, if optional reset port is enabled"
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Blocks.Interfaces.BooleanInput reset if use_reset_port annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=90,
                  origin={0,-120})));
            Modelica.Blocks.MathBoolean.Or reset_enable(nu=if use_reset_port then 2 else 1)
              annotation (Placement(transformation(extent={{10,-90},{22,-78}})));
            Modelica.Blocks.Sources.BooleanConstant booleanConstant(k=false)
              annotation (Placement(transformation(extent={{-42,-96},{-22,-76}})));
          equation
            connect(reset, reset_enable.u[2]) annotation (Line(
                points={{0,-120},{0,-84},{10,-84}},
                color={255,0,255},
                thickness=0.5,
                smooth=Smooth.None));
            connect(booleanConstant.y, reset_enable.u[1]) annotation (Line(
                points={{-21,-86},{-14,-86},{-14,-84},{10,-84}},
                color={255,0,255},
                thickness=0.5,
                smooth=Smooth.None));
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={
                  Line(
                    points={{-80,-80},{-80,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-60,-80},{-60,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,-80},{-40,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-20,-80},{-20,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-80},{0,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{20,-80},{20,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{40,-80},{40,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{60,-80},{60,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{80,-80},{80,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-80,-32},{-60,-20},{-40,-38},{-20,-30},{0,22},{20,-68},{40,44},{80,-36}},
                    color={255,0,0},
                    smooth=Smooth.None)}),
              Diagram(graphics));
          end Partial_Metric;

          block Partial_Metric_Empty
            "base class for various metric blocks with EMPTY implementations.  They serve only as easily identifiable markers for automated extraction."
            extends Modelica.Blocks.Interfaces.BlockIcon;
            parameter Boolean use_reset_port = false
              "=true, if optional reset port is enabled";
                parameter Integer nu(min=0)=0 "Number of input connections"
                                                                      annotation(Dialog(connectorSizing=true), HideResult=true);
            Modelica.Blocks.Interfaces.RealVectorInput u[nu]
              annotation (Placement(transformation(extent={{-120,70},{-80,-70}}),
                  iconTransformation(extent={{-110,70},{-90,-70}})));
            Modelica.Blocks.Interfaces.RealOutput y[nu]
              annotation (Placement(transformation(extent={{100,-17},{134,17}})));
            Modelica.Blocks.Interfaces.BooleanInput reset if use_reset_port annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=90,
                  origin={0,-120})));
            Modelica.Blocks.MathBoolean.Or reset_enable(nu=if use_reset_port then 2 else 1)
              annotation (Placement(transformation(extent={{10,-90},{22,-78}})));
            Modelica.Blocks.Sources.BooleanConstant booleanConstant(k=false)
              annotation (Placement(transformation(extent={{-42,-96},{-22,-76}})));
          equation
            // Dummy block does nothing
            y = u;
            connect(reset, reset_enable.u[2]) annotation (Line(
                points={{0,-120},{0,-84},{10,-84}},
                color={255,0,255},
                thickness=0.5,
                smooth=Smooth.None));
            connect(booleanConstant.y, reset_enable.u[1]) annotation (Line(
                points={{-21,-86},{-14,-86},{-14,-84},{10,-84}},
                color={255,0,255},
                thickness=0.5,
                smooth=Smooth.None));
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
                                                        experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={
                  Line(
                    points={{-80,-80},{-80,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-60,-80},{-60,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,-80},{-40,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-20,-80},{-20,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-80},{0,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{20,-80},{20,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{40,-80},{40,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{60,-80},{60,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{80,-80},{80,80}},
                    color={215,215,215},
                    smooth=Smooth.None),
                  Line(
                    points={{-80,-32},{-60,-20},{-40,-38},{-20,-30},{0,22},{20,-68},{40,44},{80,-36}},
                    color={255,0,0},
                    smooth=Smooth.None),
                  Text(
                    extent={{46,-58},{124,-108}},
                    lineColor={0,0,255},
                    textString="E"),
                  Rectangle(
                    extent={{-110,110},{110,-112}},
                    lineColor={255,170,85},
                    lineThickness=0.5)}),
              Diagram(graphics));
          end Partial_Metric_Empty;
        end Base_Classes;

        package Functional_Metrics
          "Contains metrics that will actually perform their stated function during a simulation (as oppose to the EMPTY implementations)"
        extends Modelica.Icons.Package;

          block Latch_Max_Abs "y = max value of |u| seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric;
          equation
            if initial() or reset_enable.y then
              y=noEvent(max(abs(u)));
            else
              y=max(noEvent(max(abs(u))), y);
            end if;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={Line(
                    points={{-80,-30},{-60,-18},{-40,-18},{-20,-18},{0,22},{40,44},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-80,-34},{-60,-34},{-40,-42},{-20,-42},{0,-42},{20,-70},{80,
                        -70}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dash)}));
          end Latch_Max_Abs;

          block Time_To_Threshold
            "y = -1 until a threshold is crossed by u from the specified direction at time=t, then y=t"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric;
            parameter Real threshold = 0.0 "Threshold to check u against";
            parameter Boolean use_below_threshold = false
              "=true, check when u falls below threshold else when u climbs above"
                                                                                   annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            output Boolean triggered(start=false);
          initial equation
            // have to account for already reaching threshold at time=0
            if ((not use_below_threshold and u > threshold) or (use_below_threshold and u < threshold)) then
              y = 0;
              triggered = true;
            else
              y = -1;
              triggered = false;
            end if;
          equation
            der(y) = 0;
          algorithm
            // Need to have the pre(triggered) at the front to avoid evaluating u > or u < threshold and causing multiple events
            when not pre(triggered) and ((not use_below_threshold and u > threshold) or (use_below_threshold and u < threshold)) then
              reinit(y, time);
              triggered := true;
            elsewhen edge(reset_enable.y) then
              if ((not use_below_threshold and u > threshold) or (use_below_threshold and u < threshold)) then
                // threshold may already be reached when reset is enabled
                reinit(y, time);
                triggered := true;
              else
                reinit(y, -1);
                triggered := false;
              end if;
            end when;
            annotation (Icon(graphics={
                  Line(
                    points={{-80,-18},{92,-18}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-16,82},{-16,-92}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-92,96},{94,48}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-96,94},{92,48}},
                    lineColor={0,0,255},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    horizontalAlignment=TextAlignment.Right,
                    textString="%threshold"),
                  Line(
                    points={{-30,48},{-44.0273,23.6367},{-68,-18},{-66,4}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-68,-18},{-48,-6}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-82,-68},{-16,-68}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-82,-58},{-82,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-32,-60},{-16,-68},{-32,-76}},
                    color={0,0,0},
                    smooth=Smooth.None)}), Diagram(graphics));
          end Time_To_Threshold;

          block Latch_Max "y = max value of u seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric;
          equation
            if initial() or reset_enable.y then
              y=u;
            else
              y=max(u, y);
            end if;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={Line(
                    points={{-80,-30},{-60,-18},{-40,-18},{-20,-18},{0,22},{40,44},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}));
          end Latch_Max;

          block Latch_Min "y = min value of u seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric;
          equation
            if initial() or reset_enable.y then
              y=u;
            else
              y=min(u, y);
            end if;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={
                  Line(
                    points={{-80,-32},{-60,-32},{-40,-40},{-20,-40},{0,-40},{20,-68},{80,-68}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}));
          end Latch_Min;

          block Time_Exceed_Band
            "y = total time u is exceeding or within band (specified by user) of a band defined by an upper and lower threshold"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric(      y(start=0, fixed=true));
            parameter Real threshold_up = 1.0 "Upper threshold of band";
            parameter Real threshold_dn = -1.0 "Lower threshold of band";
            parameter Boolean use_in_band = false
              "=true, accrue time when u is in band else when u is out of bound"
                                                                                 annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          //protected
            //Boolean in_band;

          equation
            //in_band = u < threshold_up and u > threshold_dn;
            if use_in_band == ( u < threshold_up and u > threshold_dn) then
              der(y) = 1;
            else
              der(y) = 0;
            end if;

            when edge(reset_enable.y) then
              reinit(y, 0);
            end when;
            annotation (Icon(graphics={
                  Polygon(
                    points={{-12,-8},{0,22},{6,-8},{-12,-8}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    fillColor={255,214,255},
                    lineColor={0,0,0}),
                  Polygon(
                    points={{30,-8},{40,44},{64,-6},{30,-8}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-12,-60},{-12,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{16,-60},{16,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{24,-60},{24,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{68,-60},{68,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{30,-70},{68,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-70},{6,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Polygon(
                    points={{20,-68},{14,-38},{26,-38},{20,-68}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-20,-30},{0,22},{20,-66},{40,42},{80,-36}},
                    smooth=Smooth.None,
                    color={255,0,0}),
                  Line(
                    points={{-80,-38},{92,-38}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-80,-8},{92,-8}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{30,-60},{30,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{6,-60},{6,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{16,-70},{24,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None)}), Diagram(graphics));
          end Time_Exceed_Band;

          block Time_Exceed_Threshold
            "y = total time a threshold is exceeded by u from the specified direction"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric(      y(start=0, fixed=true));
            parameter Real threshold = 0.0 "Threshold to check u against";
            parameter Boolean use_below_threshold = false
              "=true, accrue time when u falls below threshold else when u climbs above"
                                                                                         annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          equation
            if ((not use_below_threshold and u > threshold) or (use_below_threshold and u < threshold)) then
              der(y) = 1;
            else
              der(y) = 0;
            end if;

            when edge(reset_enable.y) then
              reinit(y, 0);
            end when;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-92,96},{94,48}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-96,94},{92,48}},
                    lineColor={0,0,255},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    horizontalAlignment=TextAlignment.Right,
                    textString="%threshold"),
                  Line(
                    points={{-30,48},{-44.0273,23.6367},{-68,-18},{-66,4}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-68,-18},{-48,-6}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Polygon(
                    points={{-16,-18},{0,22},{10,-18},{-16,-18}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    fillColor={255,214,255},
                    lineColor={0,0,0}),
                  Polygon(
                    points={{30,-18},{40,44},{72,-18},{30,-18}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-16,-60},{-16,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{10,-60},{10,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{28,-60},{28,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{74,-60},{74,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{28,-70},{74,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-16,-70},{10,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-20,-30},{0,22},{20,-66},{40,42},{80,-36}},
                    smooth=Smooth.None,
                    color={255,0,0}),
                  Line(
                    points={{-80,-18},{92,-18}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}),      Diagram(graphics));
          end Time_Exceed_Threshold;
        end Functional_Metrics;

        package Empty_Metrics
          "Contains metrics with EMPTY implementations that serve as markers only.  These are usually the right ones to use."
        extends Modelica.Icons.Package;

          block Latch_Max_Abs_Empty
            "y = max value of |u| seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={Line(
                    points={{-80,-30},{-60,-18},{-40,-18},{-20,-18},{0,22},{40,44},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-80,-34},{-60,-34},{-40,-42},{-20,-42},{0,-42},{20,-70},{80,
                        -70}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5,
                    pattern=LinePattern.Dash)}));
          end Latch_Max_Abs_Empty;

          block Time_Exceed_Band_Empty
            "y = total time u is exceeding or within band (specified by user) of a band defined by an upper and lower threshold"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            parameter Real threshold_up = 1.0 "Upper threshold of band";
            parameter Real threshold_dn = -1.0 "Lower threshold of band";
            parameter Boolean use_in_band = false
              "=true, accrue time when u is in band else when u is out of bound"
                                                                                 annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

            annotation (Icon(graphics={
                  Polygon(
                    points={{-12,-8},{0,22},{6,-8},{-12,-8}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    fillColor={255,214,255},
                    lineColor={0,0,0}),
                  Polygon(
                    points={{30,-8},{40,44},{64,-6},{30,-8}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-12,-60},{-12,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{16,-60},{16,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{24,-60},{24,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{68,-60},{68,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{30,-70},{68,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-70},{6,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Polygon(
                    points={{20,-68},{14,-38},{26,-38},{20,-68}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-20,-30},{0,22},{20,-66},{40,42},{80,-36}},
                    smooth=Smooth.None,
                    color={255,0,0}),
                  Line(
                    points={{-80,-38},{92,-38}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-80,-8},{92,-8}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{30,-60},{30,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{6,-60},{6,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{16,-70},{24,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None)}), Diagram(graphics));
          end Time_Exceed_Band_Empty;

          block Time_Exceed_Threshold_Empty
            "y = total time a threshold is exceeded by u from the specified direction"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            parameter Real threshold = 0.0 "Threshold to check u against";
            parameter Boolean use_below_threshold = false
              "=true, accrue time when u falls below threshold else when u climbs above"
                                                                                         annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-92,96},{94,48}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-96,94},{92,48}},
                    lineColor={0,0,255},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    horizontalAlignment=TextAlignment.Right,
                    textString="%threshold"),
                  Line(
                    points={{-30,48},{-44.0273,23.6367},{-68,-18},{-66,4}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-68,-18},{-48,-6}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Polygon(
                    points={{-16,-18},{0,22},{10,-18},{-16,-18}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    fillColor={255,214,255},
                    lineColor={0,0,0}),
                  Polygon(
                    points={{30,-18},{40,44},{72,-18},{30,-18}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    fillColor={255,214,255}),
                  Line(
                    points={{-16,-60},{-16,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{10,-60},{10,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{28,-60},{28,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{74,-60},{74,-82}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{28,-70},{74,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-16,-70},{10,-70}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-20,-30},{0,22},{20,-66},{40,42},{80,-36}},
                    smooth=Smooth.None,
                    color={255,0,0}),
                  Line(
                    points={{-80,-18},{92,-18}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}),      Diagram(graphics));
          end Time_Exceed_Threshold_Empty;

          block Time_To_Threshold_Empty
            "y = -1 until a threshold is crossed by u from the specified direction at time=t, then y=t"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            parameter Real threshold = 0.0 "Threshold to check u against";
            parameter Boolean use_below_threshold = false
              "=true, check when u falls below threshold else when u climbs above"
                                                                                   annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

            annotation (Icon(graphics={
                  Line(
                    points={{-80,-18},{92,-18}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-16,82},{-16,-92}},
                    color={255,0,255},
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-92,96},{94,48}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-96,94},{92,48}},
                    lineColor={0,0,255},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    horizontalAlignment=TextAlignment.Right,
                    textString="%threshold"),
                  Line(
                    points={{-30,48},{-44.0273,23.6367},{-68,-18},{-66,4}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-68,-18},{-48,-6}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-82,-68},{-16,-68}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-82,-58},{-82,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{-32,-60},{-16,-68},{-32,-76}},
                    color={0,0,0},
                    smooth=Smooth.None)}), Diagram(graphics));
          end Time_To_Threshold_Empty;

          block Latch_Max_Empty "y = max value of u seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={Line(
                    points={{-80,-30},{-60,-18},{-40,-18},{-20,-18},{0,22},{40,44},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}));
          end Latch_Max_Empty;

          block Latch_Min_Empty "y = min value of u seen so far, at t=0, y=u"
            extends
              C2M2L_OM.MSL_Extend.Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={
                  Line(
                    points={{-80,-32},{-60,-32},{-40,-40},{-20,-40},{0,-40},{20,-68},{80,-68}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}));
          end Latch_Min_Empty;

          block Record "record value for later use"
            extends Blocks.Metrics.Base_Classes.Partial_Metric_Empty;
            annotation (                                experiment(StopTime = 150), __Dymola_experimentSetupOutput,
              Icon(graphics={
                  Line(
                    points={{-80,-32},{-60,-32},{-40,-40},{-20,-40},{0,-40},{20,-68},{80,-68}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5)}));
          end Record;
        end Empty_Metrics;
      end Metrics;

      package Tables
        "Contains extensions to the similarly named package in the MSL"
      extends Modelica.Icons.Package;

        model Limited_Map
          "y = table(u) unless 'table' is extrapolating in which case alt_table(u) is used instead."
          extends Modelica.Blocks.Interfaces.SISO;
          Modelica.Blocks.Tables.CombiTable1D lim_table(smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              table=table)
            annotation (Placement(transformation(extent={{-10,-8},{6,8}})));
          Modelica.Blocks.Tables.CombiTable1D unlim_table(smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              table=flip_table) "table to use outside the range of lim_table"
            annotation (Placement(transformation(extent={{-10,-70},{6,-54}})));
          parameter Real table[:,:]=[0,1; 0,1] "Primary table to use";
          parameter Real alt_table[:,:]=[0,1; 0,1]
            "Alternative table to use when outside range of primary";
          parameter Real above_blend(min=0.0) = 1.0
            "Range in u over which to blend from last valid primary to alternate";
          parameter Real below_blend(min=0.0) = 1.0
            "Range in u over which to blend from alternate to first valid primary";
          parameter Boolean flip_alt_table=true
            "=true, flip the sign of the second column in alt_table";
        protected
          Real blend "amount of each table to use, 1=primary and 0=alternate";
          parameter Real flip=if flip_alt_table then -1.0 else 1.0;
          parameter Real last_u=lim_table.table[size(lim_table.table, 1), 1];
          parameter Real first_u=lim_table.table[1, 1];
          parameter Real flip_table[:,2]=[(alt_table[:, 1]),flip*(alt_table[:, 2])];

        equation
          if noEvent(u >= first_u and u <= last_u) then
            blend = 1.0;
          elseif noEvent(u > last_u and above_blend > 0) then
            blend = max(1 - ((u - last_u)/above_blend), 0);
          elseif noEvent(u < first_u and below_blend > 0) then
            blend = max(1 - ((first_u - u)/below_blend), 0);
          else
            blend = 0.0;
          end if;
          y = lim_table.y[1]*blend + unlim_table.y[1]*(1 - blend);
          connect(u, lim_table.u[1])        annotation (Line(
              points={{-120,0},{-11.6,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(u, unlim_table.u[1]) annotation (Line(
              points={{-120,0},{-66,0},{-66,-62},{-11.6,-62}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(graphics), Icon(graphics={
                Rectangle(
                  extent={{50,82},{86,-74}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-76,82},{-40,-74}},
                  pattern=LinePattern.None,
                  fillColor={220,220,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,82},{50,-74}},
                  pattern=LinePattern.None,
                  fillColor={220,255,220},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Line(
                  points={{-74,-14},{-40,-20},{-40,10},{-24,28},{0,40},{24,36},{50,6},{
                      50,-50},{80,-60}},
                  color={175,175,175},
                  smooth=Smooth.None),
                Line(points={{-76,64},{-76,-84}}, color={192,192,192}),
                Polygon(
                  points={{-76,86},{-84,64},{-68,64},{-76,86}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-86,-74},{86,-74}}, color={192,192,192}),
                Polygon(
                  points={{94,-74},{72,-66},{72,-82},{94,-74}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-40,10},{-24,28},{0,40},{24,36},{50,6}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-40,-20},{-16,-26},{24,-42},{50,-50}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{-40,-20},{-74,-14}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{50,-50},{80,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{38,-64},{78,-104}},
                  lineColor={128,128,128},
                  textString="u"),
                Text(
                  extent={{-108,66},{-68,26}},
                  lineColor={128,128,128},
                  textString="y")}));
        end Limited_Map;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;
          model Test_Limited_Map
            extends Icons.Simple_Test_Case;
            Limited_Map limited_Map(
              table=[3,1; 4,1.1; 5,1.15; 6,1.1; 7,1],
              alt_table=[0,-1; 2,-1.2; 4,-1.5; 6,-2.0],
              flip_alt_table=false,
              above_blend=0,
              below_blend=0)
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              height=10,
              duration=10,
              offset=0) annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          equation
            connect(ramp.y, limited_Map.u) annotation (Line(
                points={{-59,10},{-22,10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(graphics),
              experiment(StopTime=10),
              __Dymola_experimentSetupOutput);
          end Test_Limited_Map;
        end Tests;
      end Tables;
    end Blocks;

    package Electrical
      "Contains extensions to the MSL package of the same name"
      extends Modelica.Icons.Package;

      package Batteries "Contains electrical energy storage devices"
        extends Modelica.Icons.Package;

        package Voltage_Versus_Charge_Submodels
          "Contains models that describe Voc (open circuit voltage) versus state of charge"
        extends Modelica.Icons.BasesPackage;

          partial model Partial_Voltage_Versus_Charge
            "Base class for voltage versus charge relationships"
            extends Modelica.Electrical.Analog.Interfaces.OnePort;
            parameter SI.Voltage e_max = 1 "Maximum battery voltage";
            parameter SI.Charge q_max = 1 "Maximum capacity";
            parameter Real soc_init(min=0.0, max=1.0) = 1
              "Initial state of charge (0 - 1)";
            SI.Charge q_batt(start=soc_init*q_max, fixed=true);

          public
            Modelica.Blocks.Interfaces.RealOutput soc "state of charge(0-1)"
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={0,106})));
          equation
            der(q_batt) = i;
            soc = (q_batt)/q_max;

          end Partial_Voltage_Versus_Charge;

          model Shepard_Equation
            "Describes V=f(Q) using Shepherd equation e = e_o - K * (1/1 -f), f= Integral(I.dT/Q0)"
            extends
              C2M2L_OM.MSL_Extend.Electrical.Batteries.Voltage_Versus_Charge_Submodels.Partial_Voltage_Versus_Charge;
            parameter SI.Resistance K = 0.1 "Polarization Resistance";
          //protected
            Real f;
          equation
            f = (q_max - q_batt) / q_max;
            if f > 0.999 then
              // Drive voltage to zero to prevent SOC < 0.0
              v = (e_max - K * (1 / (1 - f))) * (1 - (f - 0.999) / 0.001);
            else
              v = e_max - K * (1 / (1 - f));
            end if;
          end Shepard_Equation;

          model Linear_3_Segment
            "Describes V=f(Q) using 3 linear segments joined by 3 pts(max, nom and exp) plus 0,0"
            extends
              C2M2L_OM.MSL_Extend.Electrical.Batteries.Voltage_Versus_Charge_Submodels.Partial_Voltage_Versus_Charge;
            parameter SI.Voltage e_nom = 3.9 "Nominal voltage (V)";
            parameter SI.Voltage e_exp = 0.92*e_nom "Exp point voltage (V)";

            parameter SI.Charge q_nom =  0.4*e_nom "Nominal capacity (Ah)";
            parameter SI.Charge q_exp = q_nom*0.7 "Exp point capacity (Ah)";

          protected
            type VoltageOverCharge = Real (final quantity="VoltageOverCharge", final unit="V/C");

            final parameter VoltageOverCharge k1 = (e_max-e_nom)/(q_max-q_nom);
            final parameter VoltageOverCharge k2 = (e_nom-e_exp)/(q_nom-q_exp);
            final parameter VoltageOverCharge k3 = e_exp/q_exp;
          equation
            if q_batt > q_nom then
              v = e_nom + k1 * (q_batt - q_nom);
            elseif q_batt > q_exp then
              v = e_exp + k2 * (q_batt - q_exp);
            else
              v = k3 * q_batt;
            end if;

          end Linear_3_Segment;

          model Shepard_Equation_Extended
            "Describes V=f(Q) using Shepherd equation e = e_o - K * (1/1 -f) + A.e(-B.f), f= Integral(I.dT/Q0)"
            extends
              C2M2L_OM.MSL_Extend.Electrical.Batteries.Voltage_Versus_Charge_Submodels.Partial_Voltage_Versus_Charge;

            parameter SI.Voltage e_nom = 200.0 "Nominal voltage (V)";
            parameter SI.Voltage e_exp = 0.92*e_nom "Exp point voltage (V)";

            parameter SI.Charge q_nom =  q_max * 0.4 "Nominal capacity (Ah)";
            parameter SI.Charge q_exp = q_max * 0.7 "Exp point capacity (Ah)";

            //parameter SI.Resistance K = 0.1 "Polarization Resistance";
            parameter Real A = e_max - e_exp;
            parameter Real B = 3 / (q_exp / q_max);

           // parameter SI.Resistance e_nom = e_max - K * (1 / (1 - f_nom)) + A * exp(-B * f_nom);
            parameter SI.Resistance K = (e_max - e_nom + A * exp(-B * f_nom)) * (1 - f_nom);

          //protected
            Real f;
            parameter Real f_nom = (q_max - q_nom) / q_max;
            SI.Voltage v_mod;
            SI.Charge capacity;
          equation
            capacity = q_max - q_batt;
            f = (q_max - q_batt) / q_max;
            if f > 0.999 then
              // Drive voltage to zero to prevent SOC < 0.0
              v = (e_max - K * (1 / (1 - f)) + A * exp(-B * f)) * (1 - (f - 0.999) / 0.001);
              v_mod = 0;
            else
              v = e_max - K * (1 / (1 - f)) + A * exp(-B * f);
              v_mod = A * exp(-B * f);
            end if;
          end Shepard_Equation_Extended;
        end Voltage_Versus_Charge_Submodels;

        model Battery_Simplified_Partial_Voltage_Versus_Charge
          "Battery model with replaceable voltage/charge sub-model and simplified thermal model"
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort;

          Modelica.Electrical.Analog.Basic.Resistor r_batt(R=R_batt, useHeatPort=true,
            v(start=0)) "Interal resistance for battery"
                                                       annotation (Placement(
                transformation(
                extent={{-8,-8},{8,8}},
                rotation=90,
                origin={-40,50})));
          Modelica.Electrical.Analog.Interfaces.Pin v_batt
            annotation (Placement(transformation(extent={{-90,90},{-70,110}}),
                iconTransformation(extent={{-90,90},{-70,110}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin
                                                    rtn
            annotation (Placement(transformation(extent={{70,90},{90,110}}),
                iconTransformation(extent={{70,90},{90,110}})));

          Voltage_Versus_Charge_Submodels.Partial_Voltage_Versus_Charge
                                                                  v_battery
            "defines voltage/current relationship and other parameters for the battery"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={10,-30})),choicesAllMatching=true, Dialog(group="Electrical"));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heatCapacitor(
                                              C=cp_batt*mass_batt, T(start=T_start,
                fixed=true))
            annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={-20,68})));

          parameter SI.Current max_charge_current = 0
            "Maximum current possible during charge";
          parameter SI.Current max_discharge_current = 0
            "Maximum current possible during discharge";

          parameter SI.Resistance R_batt=0.05
            "Battery interal resistance (Ohm)"
                annotation (Dialog(group="Electrical"));
        //   parameter SI.Voltage e_max = 1 "Maximum battery voltage"        annotation (Dialog(group="Electrical"));
        //   parameter SI.Charge q_max = 1 "Maximum capacity"        annotation (Dialog(group="Electrical"));
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature"
                annotation (Dialog(group="Thermal"));
          parameter SI.Mass mass_batt = 5 "Mass of battery"
                annotation (Dialog(group="Thermal"));
          parameter SI.ThermalResistance R_thermal = 0.01
            "Battery thermal resistance"
                annotation (Dialog(group="Thermal"));
          parameter SI.SpecificHeatCapacity cp_batt = 1000
            "Specific heat of battery"
                annotation (Dialog(group="Thermal"));

          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={30,100})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-62,70})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temperatureSensor
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          parameter SI.Temperature T_start= 293.15
            "Initial temperature of battery"
            annotation (Dialog(group="Initialization"));
          parameter Real soc_init=1 "Initial state of charge (0 - 1)"
                annotation (Dialog(group="Initialization"));

          Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=1
                /R_thermal)
            annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
          Modelica.Blocks.Interfaces.RealOutput soc
            annotation (Placement(transformation(extent={{96,-24},{116,-4}})));
          Modelica.Blocks.Interfaces.RealOutput Temp
            annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{96,4},{116,24}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{96,18},{116,38}})));
        equation
          connect(v_battery.p, r_batt.p)
                                     annotation (Line(
              points={{0,-30},{-40,-30},{-40,42}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.n, rtn) annotation (Line(
              points={{20,-30},{110,-30},{110,36},{80,36},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(r_batt.heatPort, heatCapacitor.port) annotation (Line(
              points={{-32,50},{-20,50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(voltageSensor.n, rtn) annotation (Line(
              points={{40,100},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(temperatureSensor.port, heatCapacitor.port) annotation (Line(
              points={{-20,20},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(r_batt.n, currentSensor.p) annotation (Line(
              points={{-40,58},{-40,70},{-52,70}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, v_batt) annotation (Line(
              points={{20,100},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(thermalConductor.port_b, heatCapacitor.port) annotation (Line(
              points={{-60,-50},{-20,-50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(thermalConductor.port_a, internalHeatPort) annotation (Line(
              points={{-80,-50},{-100,-50},{-100,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(currentSensor.n, v_batt) annotation (Line(
              points={{-72,70},{-80,70},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.soc, soc) annotation (Line(
              points={{10,-19.4},{10,-14},{106,-14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(temperatureSensor.T, Temp) annotation (Line(
              points={{0,20},{50,20},{50,0},{106,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,90},{30,26},{56,26},{56,14},{106,14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{-62,80},{-62,84},{72,84},{72,28},{106,28}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                    {{-100,-100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={255,208,221},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={0,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-4.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-122,102},{-38,24}},
                  lineColor={255,0,0},
                  textString="+"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={80,67},
                  rotation=180)}),
            Documentation(info="<html>
<p>This Battery component models a voltage source with an internal resistance. The battery voltage is defined as a function of the charge of the battery. The battery voltage and current is given at the positive (+) &apos;v_batt&apos; pin. The state of charge (SOC) is given at the output connector &apos;soc&apos;. Thermal properties must be defined to determine thermal effects.</p>
</html>"));
        end Battery_Simplified_Partial_Voltage_Versus_Charge;

        model Battery_Simplified_Shepard_Equation
          "Battery model with replaceable voltage/charge sub-model and simplified thermal model"
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort;

          Modelica.Electrical.Analog.Basic.Resistor r_batt(R=R_batt, useHeatPort=true,
            v(start=0)) "Interal resistance for battery"
                                                       annotation (Placement(
                transformation(
                extent={{-8,-8},{8,8}},
                rotation=90,
                origin={-40,50})));
          Modelica.Electrical.Analog.Interfaces.Pin v_batt
            annotation (Placement(transformation(extent={{-90,90},{-70,110}}),
                iconTransformation(extent={{-90,90},{-70,110}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin
                                                    rtn
            annotation (Placement(transformation(extent={{70,90},{90,110}}),
                iconTransformation(extent={{70,90},{90,110}})));

          Voltage_Versus_Charge_Submodels.Shepard_Equation        v_battery
            "defines voltage/current relationship and other parameters for the battery"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={10,-30})),choicesAllMatching=true, Dialog(group="Electrical"));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heatCapacitor(
                                              C=cp_batt*mass_batt, T(start=T_start,
                fixed=true))
            annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={-20,68})));

          parameter SI.Current max_charge_current = 0
            "Maximum current possible during charge";
          parameter SI.Current max_discharge_current = 0
            "Maximum current possible during discharge";

          parameter SI.Resistance R_batt=0.05
            "Battery interal resistance (Ohm)"
                annotation (Dialog(group="Electrical"));
        //   parameter SI.Voltage e_max = 1 "Maximum battery voltage"        annotation (Dialog(group="Electrical"));
        //   parameter SI.Charge q_max = 1 "Maximum capacity"        annotation (Dialog(group="Electrical"));
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature"
                annotation (Dialog(group="Thermal"));
          parameter SI.Mass mass_batt = 5 "Mass of battery"
                annotation (Dialog(group="Thermal"));
          parameter SI.ThermalResistance R_thermal = 0.01
            "Battery thermal resistance"
                annotation (Dialog(group="Thermal"));
          parameter SI.SpecificHeatCapacity cp_batt = 1000
            "Specific heat of battery"
                annotation (Dialog(group="Thermal"));

          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={30,100})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-62,70})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temperatureSensor
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          parameter SI.Temperature T_start= 293.15
            "Initial temperature of battery"
            annotation (Dialog(group="Initialization"));
          parameter Real soc_init=1 "Initial state of charge (0 - 1)"
                annotation (Dialog(group="Initialization"));

          Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=1
                /R_thermal)
            annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
          Modelica.Blocks.Interfaces.RealOutput soc
            annotation (Placement(transformation(extent={{96,-24},{116,-4}})));
          Modelica.Blocks.Interfaces.RealOutput Temp
            annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{96,4},{116,24}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{96,18},{116,38}})));
        equation
          connect(v_battery.p, r_batt.p)
                                     annotation (Line(
              points={{0,-30},{-40,-30},{-40,42}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.n, rtn) annotation (Line(
              points={{20,-30},{110,-30},{110,36},{80,36},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(r_batt.heatPort, heatCapacitor.port) annotation (Line(
              points={{-32,50},{-20,50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(voltageSensor.n, rtn) annotation (Line(
              points={{40,100},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(temperatureSensor.port, heatCapacitor.port) annotation (Line(
              points={{-20,20},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(r_batt.n, currentSensor.p) annotation (Line(
              points={{-40,58},{-40,70},{-52,70}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, v_batt) annotation (Line(
              points={{20,100},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(thermalConductor.port_b, heatCapacitor.port) annotation (Line(
              points={{-60,-50},{-20,-50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(thermalConductor.port_a, internalHeatPort) annotation (Line(
              points={{-80,-50},{-100,-50},{-100,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(currentSensor.n, v_batt) annotation (Line(
              points={{-72,70},{-80,70},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.soc, soc) annotation (Line(
              points={{10,-19.4},{10,-14},{106,-14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(temperatureSensor.T, Temp) annotation (Line(
              points={{0,20},{50,20},{50,0},{106,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,90},{30,26},{56,26},{56,14},{106,14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{-62,80},{-62,84},{72,84},{72,28},{106,28}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={255,208,221},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={0,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-4.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-122,102},{-38,24}},
                  lineColor={255,0,0},
                  textString="+"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={80,67},
                  rotation=180)}),
            Documentation(info="<html>
<p>This Battery component models a voltage source with an internal resistance. The battery voltage is defined as a function of the charge of the battery. The battery voltage and current is given at the positive (+) &apos;v_batt&apos; pin. The state of charge (SOC) is given at the output connector &apos;soc&apos;. Thermal properties must be defined to determine thermal effects.</p>
</html>"));
        end Battery_Simplified_Shepard_Equation;

        model Battery_Simplified_Linear_3_Segment
          "Battery model with replaceable voltage/charge sub-model and simplified thermal model"
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort;

          Modelica.Electrical.Analog.Basic.Resistor r_batt(R=R_batt, useHeatPort=true,
            v(start=0)) "Interal resistance for battery"
                                                       annotation (Placement(
                transformation(
                extent={{-8,-8},{8,8}},
                rotation=90,
                origin={-40,50})));
          Modelica.Electrical.Analog.Interfaces.Pin v_batt
            annotation (Placement(transformation(extent={{-90,90},{-70,110}}),
                iconTransformation(extent={{-90,90},{-70,110}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin
                                                    rtn
            annotation (Placement(transformation(extent={{70,90},{90,110}}),
                iconTransformation(extent={{70,90},{90,110}})));

          Voltage_Versus_Charge_Submodels.Linear_3_Segment        v_battery
            "defines voltage/current relationship and other parameters for the battery"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={10,-30})),choicesAllMatching=true, Dialog(group="Electrical"));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heatCapacitor(
                                              C=cp_batt*mass_batt, T(start=T_start,
                fixed=true))
            annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={-20,68})));

          parameter SI.Current max_charge_current = 0
            "Maximum current possible during charge";
          parameter SI.Current max_discharge_current = 0
            "Maximum current possible during discharge";

          parameter SI.Resistance R_batt=0.05
            "Battery interal resistance (Ohm)"
                annotation (Dialog(group="Electrical"));
        //   parameter SI.Voltage e_max = 1 "Maximum battery voltage"        annotation (Dialog(group="Electrical"));
        //   parameter SI.Charge q_max = 1 "Maximum capacity"        annotation (Dialog(group="Electrical"));
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature"
                annotation (Dialog(group="Thermal"));
          parameter SI.Mass mass_batt = 5 "Mass of battery"
                annotation (Dialog(group="Thermal"));
          parameter SI.ThermalResistance R_thermal = 0.01
            "Battery thermal resistance"
                annotation (Dialog(group="Thermal"));
          parameter SI.SpecificHeatCapacity cp_batt = 1000
            "Specific heat of battery"
                annotation (Dialog(group="Thermal"));

          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={30,100})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-62,70})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temperatureSensor
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          parameter SI.Temperature T_start= 293.15
            "Initial temperature of battery"
            annotation (Dialog(group="Initialization"));
          parameter Real soc_init=1 "Initial state of charge (0 - 1)"
                annotation (Dialog(group="Initialization"));

          Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=1
                /R_thermal)
            annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
          Modelica.Blocks.Interfaces.RealOutput soc
            annotation (Placement(transformation(extent={{96,-24},{116,-4}})));
          Modelica.Blocks.Interfaces.RealOutput Temp
            annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{96,4},{116,24}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{96,18},{116,38}})));
        equation
          connect(v_battery.p, r_batt.p)
                                     annotation (Line(
              points={{0,-30},{-40,-30},{-40,42}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.n, rtn) annotation (Line(
              points={{20,-30},{110,-30},{110,36},{80,36},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(r_batt.heatPort, heatCapacitor.port) annotation (Line(
              points={{-32,50},{-20,50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(voltageSensor.n, rtn) annotation (Line(
              points={{40,100},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(temperatureSensor.port, heatCapacitor.port) annotation (Line(
              points={{-20,20},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(r_batt.n, currentSensor.p) annotation (Line(
              points={{-40,58},{-40,70},{-52,70}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, v_batt) annotation (Line(
              points={{20,100},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(thermalConductor.port_b, heatCapacitor.port) annotation (Line(
              points={{-60,-50},{-20,-50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(thermalConductor.port_a, internalHeatPort) annotation (Line(
              points={{-80,-50},{-100,-50},{-100,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(currentSensor.n, v_batt) annotation (Line(
              points={{-72,70},{-80,70},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.soc, soc) annotation (Line(
              points={{10,-19.4},{10,-14},{106,-14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(temperatureSensor.T, Temp) annotation (Line(
              points={{0,20},{50,20},{50,0},{106,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,90},{30,26},{56,26},{56,14},{106,14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{-62,80},{-62,84},{72,84},{72,28},{106,28}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                    {{-100,-100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={255,208,221},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={0,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-4.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-122,102},{-38,24}},
                  lineColor={255,0,0},
                  textString="+"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={80,67},
                  rotation=180)}),
            Documentation(info="<html>
<p>This Battery component models a voltage source with an internal resistance. The battery voltage is defined as a function of the charge of the battery. The battery voltage and current is given at the positive (+) &apos;v_batt&apos; pin. The state of charge (SOC) is given at the output connector &apos;soc&apos;. Thermal properties must be defined to determine thermal effects.</p>
</html>"));
        end Battery_Simplified_Linear_3_Segment;

        model Battery_Simplified_Shepard_Equation_Extended
          "Battery model with replaceable voltage/charge sub-model and simplified thermal model"
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort;

          Modelica.Electrical.Analog.Basic.Resistor r_batt(R=R_batt, useHeatPort=true,
            v(start=0)) "Interal resistance for battery"
                                                       annotation (Placement(
                transformation(
                extent={{-8,-8},{8,8}},
                rotation=90,
                origin={-40,50})));
          Modelica.Electrical.Analog.Interfaces.Pin v_batt
            annotation (Placement(transformation(extent={{-90,90},{-70,110}}),
                iconTransformation(extent={{-90,90},{-70,110}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin
                                                    rtn
            annotation (Placement(transformation(extent={{70,90},{90,110}}),
                iconTransformation(extent={{70,90},{90,110}})));

          Voltage_Versus_Charge_Submodels.Shepard_Equation_Extended
                                                                  v_battery
            "defines voltage/current relationship and other parameters for the battery"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={10,-30})),choicesAllMatching=true, Dialog(group="Electrical"));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heatCapacitor(
                                              C=cp_batt*mass_batt, T(start=T_start,
                fixed=true))
            annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={-20,68})));

          parameter SI.Current max_charge_current = 0
            "Maximum current possible during charge";
          parameter SI.Current max_discharge_current = 0
            "Maximum current possible during discharge";

          parameter SI.Resistance R_batt=0.05
            "Battery interal resistance (Ohm)"
                annotation (Dialog(group="Electrical"));
        //   parameter SI.Voltage e_max = 1 "Maximum battery voltage"        annotation (Dialog(group="Electrical"));
        //   parameter SI.Charge q_max = 1 "Maximum capacity"        annotation (Dialog(group="Electrical"));
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature"
                annotation (Dialog(group="Thermal"));
          parameter SI.Mass mass_batt = 5 "Mass of battery"
                annotation (Dialog(group="Thermal"));
          parameter SI.ThermalResistance R_thermal = 0.01
            "Battery thermal resistance"
                annotation (Dialog(group="Thermal"));
          parameter SI.SpecificHeatCapacity cp_batt = 1000
            "Specific heat of battery"
                annotation (Dialog(group="Thermal"));

          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={30,100})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-62,70})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temperatureSensor
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          parameter SI.Temperature T_start= 293.15
            "Initial temperature of battery"
            annotation (Dialog(group="Initialization"));
          parameter Real soc_init=1 "Initial state of charge (0 - 1)"
                annotation (Dialog(group="Initialization"));

          Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=1
                /R_thermal)
            annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
          Modelica.Blocks.Interfaces.RealOutput soc
            annotation (Placement(transformation(extent={{96,-24},{116,-4}})));
          Modelica.Blocks.Interfaces.RealOutput Temp
            annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{96,4},{116,24}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{96,18},{116,38}})));
        equation
          connect(v_battery.p, r_batt.p)
                                     annotation (Line(
              points={{0,-30},{-40,-30},{-40,42}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.n, rtn) annotation (Line(
              points={{20,-30},{110,-30},{110,36},{80,36},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(r_batt.heatPort, heatCapacitor.port) annotation (Line(
              points={{-32,50},{-20,50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(voltageSensor.n, rtn) annotation (Line(
              points={{40,100},{80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(temperatureSensor.port, heatCapacitor.port) annotation (Line(
              points={{-20,20},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(r_batt.n, currentSensor.p) annotation (Line(
              points={{-40,58},{-40,70},{-52,70}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, v_batt) annotation (Line(
              points={{20,100},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(thermalConductor.port_b, heatCapacitor.port) annotation (Line(
              points={{-60,-50},{-20,-50},{-20,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(thermalConductor.port_a, internalHeatPort) annotation (Line(
              points={{-80,-50},{-100,-50},{-100,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(currentSensor.n, v_batt) annotation (Line(
              points={{-72,70},{-80,70},{-80,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_battery.soc, soc) annotation (Line(
              points={{10,-19.4},{10,-14},{106,-14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(temperatureSensor.T, Temp) annotation (Line(
              points={{0,20},{50,20},{50,0},{106,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,90},{30,26},{56,26},{56,14},{106,14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{-62,80},{-62,84},{72,84},{72,28},{106,28}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                    {{-100,-100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={255,208,221},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={0,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-4.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-122,102},{-38,24}},
                  lineColor={255,0,0},
                  textString="+"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={80,67},
                  rotation=180)}),
            Documentation(info="<html>
<p>This Battery component models a voltage source with an internal resistance. The battery voltage is defined as a function of the charge of the battery. The battery voltage and current is given at the positive (+) &apos;v_batt&apos; pin. The state of charge (SOC) is given at the output connector &apos;soc&apos;. Thermal properties must be defined to determine thermal effects.</p>
</html>"));
        end Battery_Simplified_Shepard_Equation_Extended;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;
          model Test_Simple_Battery
            extends MSL_Extend.Icons.Simple_Test_Case;
            Battery_Simplified_Shepard_Equation_Extended      battery2_1(
              R_thermal=0.01,
              R_batt=0.065,
              mass_batt=100,
              cp_batt=66,
              soc_init=1,
              v_battery(
                e_max=428,
                q_max=3600*59.1,
                e_nom=381,
                soc_init=0.6,
                e_exp=342))                  annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-34,-46})));
            Modelica.Electrical.Analog.Basic.Resistor discharge_load(useHeatPort=false, R=0.5)
                                                                     annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={7,1})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-22,-82},{-10,-70}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage charging_source(V=260)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={38,-16})));
            Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch    switch_mode
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-14,22})));
            Modelica.Blocks.Logical.Hysteresis hysteresis(
              pre_y_start=false,
              uHigh=0.99,
              uLow=-0.01)
              annotation (Placement(transformation(extent={{76,30},{56,50}})));
            Modelica.Electrical.Analog.Basic.Resistor charging_current_limiter(
                useHeatPort=false, R=0.005)                          annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={7,-15})));
          equation

            connect(battery2_1.rtn, ground.p) annotation (Line(
                points={{-26,-36},{-16,-36},{-16,-70}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.v_batt, switch_mode.p) annotation (Line(
                points={{-42,-36},{-42,22},{-24,22}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.n1, charging_source.p) annotation (Line(
                points={{-4,27},{52,27},{52,-16},{48,-16}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.n2, discharge_load.p) annotation (Line(
                points={{-4,22},{24,22},{24,1},{14,1}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(discharge_load.n, battery2_1.rtn) annotation (Line(
                points={{-8.88178e-016,1},{-26,1},{-26,-36}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(hysteresis.y, switch_mode.control) annotation (Line(
                points={{55,40},{-14,40},{-14,30}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(charging_current_limiter.p, charging_source.n) annotation (Line(
                points={{14,-15},{22,-15},{22,-16},{28,-16}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(charging_current_limiter.n, battery2_1.rtn) annotation (Line(
                points={{-8.88178e-016,-15},{-12,-15},{-12,-16},{-26,-16},{-26,-36}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.soc, hysteresis.u) annotation (Line(
                points={{-23.4,-47.4},{96,-47.4},{96,40},{78,40}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=250),
              __Dymola_experimentSetupOutput);
          end Test_Simple_Battery;
        end Tests;
      end Batteries;

      package Electric_Machines
        "Contains devices that convert between electrical and mechanical energy"
      extends Modelica.Icons.Package;

        package Base_Classes
          "Parts used to construct other components by composition or extension"
        extends Modelica.Icons.BasesPackage;

          model EMF_External_Control
            "Electromotoric force (electric/mechanic transformer) with an external input for setting k"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            //parameter SI.ElectricalTorqueConstant k(start=1) "Transformation coefficient";
            SI.Voltage v "Voltage drop between the two pins";
            SI.Current i "Current flowing from positive to negative pin";
            SI.Angle phi
              "Angle of shaft flange with respect to support (= flange.phi - support.phi)";
            SI.AngularVelocity w
              "Angular velocity of flange relative to support";
            Modelica.Electrical.Analog.Interfaces.PositivePin p
                                     annotation (Placement(transformation(
                  origin={0,100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Electrical.Analog.Interfaces.NegativePin n
                                     annotation (Placement(transformation(
                  origin={0,-100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
              annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
            Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
              "Support/housing of emf shaft"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          protected
            Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
              annotation (Placement(transformation(extent={{-90,-20},{-70,0}})));
            Modelica.Mechanics.Rotational.Interfaces.InternalSupport internalSupport(tau=-
                  flange.tau)
              annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
          public
            Modelica.Blocks.Interfaces.RealInput k(final quantity="ElectricalTorqueConstant",final unit= "N.m/A")
              "Transformation coefficient"
              annotation (Placement(transformation(extent={{-140,50},{-100,90}})));
          equation
            v = p.v - n.v;
            0 = p.i + n.i;
            i = p.i;

            phi = flange.phi - internalSupport.phi;
            w = der(phi);
            k*w = v;
            flange.tau = -k*i;
            connect(internalSupport.flange, support) annotation (Line(
                points={{-80,0},{-100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport.flange,fixed. flange) annotation (Line(
                points={{-80,0},{-80,-10}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              defaultComponentName="emf",
              Icon(
                  coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-85,10},{-36,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={192,192,192}),
                  Line(points={{0,90},{0,40}}, color={0,0,255}),
                  Rectangle(
                    extent={{35,10},{100,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{-40,40},{40,-40}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Line(points={{0,-90},{0,-40}}, color={0,0,255}),
                  Text(
                    extent={{0,-50},{199,-90}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{0,80},{189,46}},
                    lineColor={160,160,164},
                    textString="k=%k"),
                  Line(
                    visible=not useSupport,
                    points={{-100,-30},{-40,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-100,-50},{-80,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-80,-50},{-60,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-60,-50},{-40,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-70,-30},{-70,-10}},
                    color={0,0,0})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Polygon(
                    points={{-17,95},{-20,85},{-23,95},{-17,95}},
                    lineColor={160,160,164},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-20,110},{-20,85}}, color={160,160,164}),
                  Text(
                    extent={{-40,110},{-30,90}},
                    lineColor={160,160,164},
                    textString="i"),
                  Line(points={{9,75},{19,75}}, color={192,192,192}),
                  Line(points={{-20,-110},{-20,-85}}, color={160,160,164}),
                  Polygon(
                    points={{-17,-100},{-20,-110},{-23,-100},{-17,-100}},
                    lineColor={160,160,164},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-40,-110},{-30,-90}},
                    lineColor={160,160,164},
                    textString="i"),
                  Line(points={{8,-79},{18,-79}}, color={192,192,192}),
                  Line(points={{14,80},{14,70}}, color={192,192,192})}),
              Documentation(info="<html>
<p>EMF transforms electrical energy into rotational mechanical energy. It is used as basic building block of an electrical motor. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection.</p>
</html>",  revisions="<html>
<ul>
<li><i> 1998   </i>
       by Martin Otter<br> initially implemented<br>
       </li>
</ul>
</html>"));
          end EMF_External_Control;

          model EMF_Internal_Regulator
            "Electromotoric force (electric/mechanic transformer) combined with a regulator that controls voltage output"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            parameter Boolean useHeatPort=true "= true, if heat port enabled"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            parameter SI.Voltage v_nom = 28 "Nominal operating voltage";
            parameter SI.AngularVelocity w_cut "Voltage cutoff speed";
            parameter Real i_table[:,:]=fill(
                0.0,
                0,
                2)
              "table of max current[A] @ nominal voltage versus speed[rad/s]";
            parameter Real tau_table[:,:]=fill(
                0.0,
                0,
                2) "table of torque[Nm] @ max current versus speed[rad/s]";

            Modelica.Electrical.Analog.Interfaces.PositivePin p annotation (Placement(transformation(
                  origin={0,100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Electrical.Analog.Interfaces.NegativePin n annotation (Placement(transformation(
                  origin={0,-100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
              annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
            Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
              "Support/housing of emf shaft"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          protected
            Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
              annotation (Placement(transformation(extent={{-90,-42},{-70,-22}})));
            Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
              annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
            Modelica.Blocks.Tables.CombiTable1D v_vs_speed(table=[0.0,0; w_cut*0.9,0;
                  w_cut,v_nom; w_cut*10,v_nom])
              annotation (Placement(transformation(extent={{-90,20},{-80,30}})));

          public
            C2M2L_OM.MSL_Extend.Electrical.Electric_Machines.Base_Classes.EMF_External_Control
                                 emf(useSupport=true)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={66,32})));
            Mechanics.Rotational.Components.Efficiency_Loss_Controlled
              efficiency_Loss_Fixed(useSupport=true,
              use_environment_heat_port=not useHeatPort,
              useHeatPort=useHeatPort)
              annotation (Placement(transformation(extent={{38,-8},{54,8}})));
            Modelica.Blocks.Math.Division division2
              "voltage from table divided by instantaneous speed"
              annotation (Placement(transformation(extent={{-63,10},{-53,20}})));
            Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
                Placement(transformation(
                  extent={{-8,8},{8,-8}},
                  rotation=90,
                  origin={0,-62})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                              max_Against_Parametersdgsdg(p=1)
              annotation (Placement(transformation(extent={{-144,6},{-132,18}})));
            Modelica.Blocks.Math.Add add(k1=1, k2=-1)
              annotation (Placement(transformation(extent={{-71,59},{-60,70}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Positive_Negative_Split positive_Negative_Split
              annotation (Placement(transformation(extent={{-54,59},{-43,70}})));
            Modelica.Blocks.Math.Division division
              annotation (Placement(transformation(extent={{-35,4},{-25,14}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                              max_Against_Parameter1(p=1)
              annotation (Placement(transformation(extent={{-22,56},{-12,66}})));
            Modelica.Blocks.Math.Gain gain(k=-10)
              annotation (Placement(transformation(extent={{-37,57},{-29,65}})));
            Modelica.Blocks.Tables.CombiTable1D tau_vs_speed(table=tau_table)
              annotation (Placement(transformation(extent={{-94,98},{-84,108}})));
            Modelica.Blocks.Tables.CombiTable1D i_vs_speed(table=i_table)
              annotation (Placement(transformation(extent={{-97,70},{-87,80}})));
            Modelica.Blocks.Math.Product product3
              "torque from table mutiplied by instantaneous speed"
              annotation (Placement(transformation(extent={{-68,102},{-61,109}})));
            Modelica.Blocks.Math.Product product4
              "current from table mutiplied by instantaneous voltage"
              annotation (Placement(transformation(extent={{-67,87},{-60,94}})));
            Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
                Placement(transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=270,
                  origin={29,78})));
            Modelica.Blocks.Math.Division eff
              annotation (Placement(transformation(extent={{-34,82},{-27,89}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                              min_Against_Parameter(p=1e-6)
              annotation (Placement(transformation(extent={{-50,98},{-42,106}})));
            Modelica.Blocks.Continuous.FirstOrder firstOrder(T=0.1, y_start=1)
              annotation (Placement(transformation(extent={{-40,31},{-31,40}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                              limiter(p=1e-6)
              annotation (Placement(transformation(extent={{13,30},{23,40}})));

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort if useHeatPort
              "Optional port to which dissipated losses are transported in form of heat"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={55,-100}),
               iconTransformation(extent={{-110,-110},{-90,-90}})));
            Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
              annotation (Placement(transformation(extent={{70,-7},{84,7}})));
            Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={107,-14})));
            Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={107,-40})));
            Modelica.Blocks.Interfaces.RealOutput w
              annotation (Placement(transformation(extent={{97,-63},{117,-43}})));
            Modelica.Blocks.Interfaces.RealOutput tau
              annotation (Placement(transformation(extent={{97,-38},{117,-18}})));
          equation
            connect(emf.p, p) annotation (Line(
                points={{0,10},{0,100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(support, internalSupport) annotation (Line(
                points={{-100,0},{-80,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fixed.flange, internalSupport) annotation (Line(
                points={{-80,-32},{-80,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, emf.support) annotation (Line(
                points={{-80,0},{-10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(efficiency_Loss_Fixed.support, internalSupport) annotation (Line(
                points={{46,-8},{46,-24},{-80,-24},{-80,0}},
                color={0,0,0},
                smooth=Smooth.None));

            connect(speedSensor.w, v_vs_speed.u[1])
                                               annotation (Line(
                points={{66,39.7},{66,118},{-131,118},{-131,25},{-91,25}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(currentSensor.p, n) annotation (Line(
                points={{-4.89859e-016,-70},{0,-70},{0,-100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(currentSensor.n, emf.n) annotation (Line(
                points={{4.89859e-016,-54},{4.89859e-016,-34},{0,-34},{0,-10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(speedSensor.w, max_Against_Parametersdgsdg.u) annotation (Line(
                points={{66,39.7},{66,70},{117,70},{117,-112},{-152,-112},{-152,12},{
                    -145.2,12}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(max_Against_Parametersdgsdg.y, division2.u2) annotation (Line(
                points={{-131.4,12},{-64,12}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(emf.flange, efficiency_Loss_Fixed.flange_a) annotation (Line(
                points={{10,0},{38,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(currentSensor.i, add.u2) annotation (Line(
                points={{-8,-62},{-121,-62},{-121,61.2},{-72.1,61.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(division2.y, division.u1) annotation (Line(
                points={{-52.5,15},{-44,15},{-44,12},{-36,12}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(division.y, emf.k) annotation (Line(
                points={{-24.5,9},{-20,9},{-20,7},{-12,7}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, positive_Negative_Split.u) annotation (Line(
                points={{-59.45,64.5},{-55.1,64.5}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(v_vs_speed.y[1], division2.u1) annotation (Line(
                points={{-79.5,25},{-76,25},{-76,18},{-64,18}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(positive_Negative_Split.y_neg, gain.u) annotation (Line(
                points={{-42.45,61.2},{-35.725,61.2},{-35.725,61},{-37.8,61}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(gain.y, max_Against_Parameter1.u) annotation (Line(
                points={{-28.6,61},{-23,61}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(i_vs_speed.y[1], add.u1) annotation (Line(
                points={{-86.5,75},{-82,75},{-82,68},{-72,68},{-72.1,67.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(speedSensor.w, tau_vs_speed.u[1]) annotation (Line(
                points={{66,39.7},{66,118},{-109,118},{-109,103},{-95,103}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(speedSensor.w, i_vs_speed.u[1]) annotation (Line(
                points={{66,39.7},{66,118},{-109,118},{-109,75},{-98,75}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(tau_vs_speed.y[1], product3.u2) annotation (Line(
                points={{-83.5,103},{-76,103},{-76,103.4},{-68.7,103.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(i_vs_speed.y[1], product4.u1) annotation (Line(
                points={{-86.5,75},{-78,75},{-78,92.6},{-67.7,92.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(voltageSensor.p, p) annotation (Line(
                points={{29,86},{15,86},{15,100},{0,100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.n, n) annotation (Line(
                points={{29,70},{29,-87},{12,-87},{12,-100},{0,-100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.v, product4.u2) annotation (Line(
                points={{21,78},{-73,78},{-73,88.4},{-67.7,88.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(speedSensor.w, product3.u1) annotation (Line(
                points={{66,39.7},{66,118},{-75,118},{-75,107.6},{-68.7,107.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(product4.y, eff.u1) annotation (Line(
                points={{-59.65,90.5},{-51,90.5},{-51,87.6},{-34.7,87.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(min_Against_Parameter.y, eff.u2) annotation (Line(
                points={{-41.6,102},{-39,102},{-39,83.4},{-34.7,83.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(min_Against_Parameter.u, product3.y) annotation (Line(
                points={{-50.8,102},{-53,102},{-53,105.5},{-60.65,105.5}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(max_Against_Parameter1.y, firstOrder.u) annotation (Line(
                points={{-11.5,61},{-9,61},{-9,62},{-5,62},{-5,45},{-50,45},{-50,35.5},{-40.9,
                    35.5}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(firstOrder.y, division.u2) annotation (Line(
                points={{-30.55,35.5},{-24,35.5},{-24,21},{-40,21},{-40,6},{-36,6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(limiter.u, eff.y) annotation (Line(
                points={{12,35},{5,35},{5,85.5},{-26.65,85.5}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(limiter.y, efficiency_Loss_Fixed.efficiency) annotation (Line(
                points={{23.5,35},{49.28,35},{49.28,9.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(efficiency_Loss_Fixed.heatPort, heatPort) annotation (Line(
                points={{38,-8},{38,-66},{55,-66},{55,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(torqueSensor.flange_b, flange) annotation (Line(
                points={{84,8.88178e-016},{89,8.88178e-016},{89,0},{100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torqueSensor.flange_a, efficiency_Loss_Fixed.flange_b) annotation (
                Line(
                points={{70,8.88178e-016},{59.5,8.88178e-016},{59.5,0},{54,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(speedSensor.flange, torqueSensor.flange_a) annotation (Line(
                points={{66,25},{66,8.88178e-016},{70,8.88178e-016}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(voltageSensor.v, v) annotation (Line(
                points={{21,78},{17,78},{17,47},{58,47},{58,-14},{107,-14}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(torqueSensor.tau, tau) annotation (Line(
                points={{71.4,-7.7},{71.4,-28},{107,-28}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(currentSensor.i, i) annotation (Line(
                points={{-8,-62},{-20,-62},{-20,-40},{107,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(speedSensor.w, w) annotation (Line(
                points={{66,39.7},{66,47},{89,47},{89,-53},{107,-53}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              defaultComponentName="emf",
              Icon(
                  coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-85,10},{-36,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={192,192,192}),
                  Line(points={{0,90},{0,40}}, color={0,0,255}),
                  Rectangle(
                    extent={{35,10},{100,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{-40,40},{40,-40}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Line(points={{0,-90},{0,-40}}, color={0,0,255}),
                  Text(
                    extent={{0,-50},{199,-90}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    visible=not useSupport,
                    points={{-100,-30},{-40,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-100,-50},{-80,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-80,-50},{-60,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-60,-50},{-40,-30}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-70,-30},{-70,-10}},
                    color={0,0,0}),
                  Text(
                    extent={{-100,80},{130,50}},
                    lineColor={0,0,0},
                    horizontalAlignment=TextAlignment.Left,
                    textString="V_nom=%v_nom")}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Polygon(
                    points={{-17,95},{-20,85},{-23,95},{-17,95}},
                    lineColor={160,160,164},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-20,110},{-20,85}}, color={160,160,164}),
                  Text(
                    extent={{-40,110},{-30,90}},
                    lineColor={160,160,164},
                    textString="i"),
                  Line(points={{9,75},{19,75}}, color={192,192,192}),
                  Line(points={{-20,-110},{-20,-85}}, color={160,160,164}),
                  Polygon(
                    points={{-17,-100},{-20,-110},{-23,-100},{-17,-100}},
                    lineColor={160,160,164},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-40,-110},{-30,-90}},
                    lineColor={160,160,164},
                    textString="i"),
                  Line(points={{8,-79},{18,-79}}, color={192,192,192}),
                  Line(points={{14,80},{14,70}}, color={192,192,192})}),
              Documentation(info="<html>
<p>EMF transforms electrical energy into rotational mechanical energy. It is used as basic building block of an electrical motor. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection.</p>
</html>",  revisions="<html>
<ul>
<li><i> 1998   </i>
       by Martin Otter<br> initially implemented<br>
       </li>
</ul>
</html>"));
          end EMF_Internal_Regulator;

          model Motor_With_Inverter
            "Elemental model of an electric motor plus inverter fed with a DC supply"
            extends Modelica.Electrical.Analog.Interfaces.OnePort;
            extends
              Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
            parameter SI.Voltage v_nom=100
              "Nominal voltage at which data was generated"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Voltage v_max=250
              "Maximum voltage at which data was generated"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Voltage v_cutoff=v_nom*0.1
              "Supply voltage below which power limit cannot be reached"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
                                                                            annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Torque trq_max=100 "Maximum output torque"
                                                                   annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Torque trq_nom=50 "Nominal output torque"
                                                                  annotation (Dialog(group="Electrical/Mechanical"));
            parameter Real efficiency(
              min=0,
              max=1) = 0.95 "Efficiency of electrical to mechanical conversion"
                                                                               annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Power pow_stall=pow_max*0.01
              "Electrical power consumed near stall at max demand"   annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Temperature temp_max = 373.15 "Maximum device temp" annotation (Dialog(group="Electrical/Mechanical"));
            SI.Time time_temp_max = 10
              "Maximum time device can operate at max power";

            SI.AngularVelocity w;
            SI.Power pow_lim_at_v_nom;
            SI.Power pow_elec;
            SI.Power pow_mech;

            Real k;

            Modelica.Blocks.Interfaces.RealInput demand
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Real limit;

            parameter Boolean use_heat_port = false
              "=true, if external heat port is enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true), Dialog(group="Thermal Behaviour"));

            SI.Temperature T_device(start=293.15, fixed=true, displayUnit="degC")
              "Bulk averaged temperature of device" annotation(Dialog(group="Thermal Behaviour", showStartAttribute=true));
            SI.Power loss_power
              "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)";
            SI.Power heat_generated "heat_generated by component";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              final T=T_device,
              final Q_flow=-loss_power) if use_heat_port
              "Optional port to which dissipated losses are transported in form of heat"
              annotation (Placement(transformation(extent={{-110,-110},{-90,-90}}),
               iconTransformation(extent={{-110,-110},{-90,-90}})));
            parameter SI.HeatCapacity C_device = 1 "Heat capacity of device"   annotation (Dialog(group="Thermal Behaviour"));

          //protected
            parameter SI.Torque trq_gross_max=trq_max/efficiency;
            parameter SI.Current i_max=pow_max/v_nom
              "The current that limits operation to below power_max at v_nom";
            discrete Modelica.SIunits.Time entryTime(start = 0) "Time instant";
            Boolean T_exceeded(start = false, fixed = true);
          equation
            C_device * der(T_device) = heat_generated - loss_power;
            w = der(flange.phi);

            pow_elec = v*i;
            pow_mech = w*flange.tau;
              // Calculate time when device temp goes able critical value
          algorithm
              when T_device > temp_max and not pre(T_exceeded) then
                entryTime := time;
                T_exceeded := true;

            elsewhen T_device <= temp_max and pre(T_exceeded) then
                entryTime := time;
                T_exceeded := false;
            end when;

          equation
            if T_exceeded then
               if time > entryTime + 2*time_temp_max then
                 //when  the critical device temp is exceeds the 2 times the maximum time it can operate at max, the output torque is reduced to zero
                 k=0;
               else
                 k=trq_nom/trq_max;
               end if;
            else
              k=1;
            end if;
            // Calculate a limit to reduce current below v_cutoff
            limit = min(1.0, max(0, 1 - 2 *(v_cutoff - v)/v_cutoff));

            i = (min(max(pow_stall, pow_lim_at_v_nom)/v, i_max)*abs(demand)) * limit;

            flange.tau = -(min(trq_gross_max, pow_elec/max(1e-12, abs(w))))*efficiency * sign(demand);
            pow_lim_at_v_nom = min(trq_gross_max*abs(w), pow_max);

            // Thermal model
            //loss_power = pow_elec + pow_mech;
            heat_generated = pow_elec + pow_mech;
            if not use_heat_port then
              // assume all heat generated is lost immediately (effectively isothermal)
              loss_power = heat_generated;
            end if;

            annotation (Icon(graphics={Rectangle(extent={{-100,100},{100,-100}}, lineColor=
                       {0,0,255}), Text(
                    extent={{-136,20},{136,-20}},
                    lineColor={0,0,255},
                    textString="%name",
                    origin={-6,132},
                    rotation=180),
                  Rectangle(
                    extent={{-12,10},{12,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    origin={0,86},
                    rotation=90),
                  Rectangle(
                    extent={{-33,31},{33,-31}},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    origin={1,43},
                    rotation=90),
                  Rectangle(
                    extent={{-40,-20},{40,-60}},
                    lineColor={0,0,255},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-94,0},{-60,0},{-60,-40},{-40,-40},{-40,-38}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{96,0},{60,0},{60,-40},{40,-40}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Text(
                    extent={{-54,-24},{54,-58}},
                    lineColor={0,0,255},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    textString="INV"),
                  Line(
                    points={{-20,-20},{-20,-8},{-40,-8},{-40,20},{-30,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{20,-20},{20,-8},{40,-8},{40,20},{30,20}},
                    color={0,0,255},
                    smooth=Smooth.None)}),
                                    Diagram(coordinateSystem(preserveAspectRatio=
                      false, extent={{-100,-100},{100,100}}),
                                            graphics));
          end Motor_With_Inverter;

          model Current_Gain

            Modelica.Electrical.Analog.Sources.SignalCurrent signalCurrent
              annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                  rotation=270,
                  origin={0,0})));
            Modelica.Electrical.Analog.Interfaces.PositivePin p annotation (Placement(transformation(
                  origin={0,100},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Electrical.Analog.Interfaces.NegativePin n annotation (Placement(transformation(
                  origin={0,-100},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealInput current
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-106,52})));
            Modelica.Blocks.Interfaces.RealInput demand
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-106,-50})));
            Modelica.Blocks.Math.Product product1
              annotation (Placement(transformation(extent={{-30,-4},{-22,4}})));
          equation
            connect(signalCurrent.n, n) annotation (Line(
                points={{-1.83697e-015,-10},{0,-10},{0,-100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(demand, product1.u2)
                                     annotation (Line(
                points={{-106,-50},{-60,-50},{-60,-2.4},{-30.8,-2.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(product1.y, signalCurrent.i) annotation (Line(
                points={{-21.6,0},{-7,0},{-7,1.28588e-015}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(signalCurrent.p, p) annotation (Line(
                points={{1.83697e-015,10},{0,10},{0,100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(product1.u1, current)
                                    annotation (Line(
                points={{-30.8,2.4},{-60,2.4},{-60,52},{-106,52}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}), Text(
                    extent={{-100,30},{100,-12}},
                    lineColor={0,0,0},
                    fillColor={127,0,0},
                    fillPattern=FillPattern.Solid,
                    textString="i * gain")}));
          end Current_Gain;

          model Voltage_Modulator "Used to modulate voltage for electric motor"

            Modelica.Electrical.Analog.Sources.SignalVoltage signalVoltage2 annotation (
                Placement(transformation(
                  extent={{8,-8},{-8,8}},
                  rotation=90,
                  origin={60,0})));
            Modelica.Electrical.Analog.Interfaces.NegativePin n_out
                                                                annotation (Placement(
                  transformation(rotation=0, extent={{-10,-110},{10,-90}})));
            Modelica.Electrical.Analog.Interfaces.PositivePin p_out
                                                                annotation (Placement(
                  transformation(rotation=0, extent={{-10,90},{10,110}})));
            Modelica.Blocks.Math.Product product1 annotation (Placement(transformation(
                  extent={{6,-6},{-6,6}},
                  rotation=180,
                  origin={0,0})));
            Modelica.Blocks.Interfaces.RealInput u1 annotation (Placement(transformation(
                    rotation=0, extent={{-114,32},{-94,52}})));
            Modelica.Blocks.Interfaces.RealInput u2 annotation (Placement(transformation(
                    rotation=0, extent={{-114,-52},{-94,-32}})));
            Modelica.Blocks.Math.Add add(k2=-1)
              annotation (Placement(transformation(extent={{-42,-44},{-32,-34}})));
            Modelica.Blocks.Sources.Constant const2(k=1)
              annotation (Placement(transformation(extent={{-74,-36},{-62,-24}})));
          equation
            connect(u1, product1.u2) annotation (Line(
                points={{-104,42},{-20,42},{-20,3.6},{-7.2,3.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(product1.y, signalVoltage2.v) annotation (Line(
                points={{6.6,-8.08267e-016},{30.3,-8.08267e-016},{30.3,3.42901e-016},{
                    54.4,3.42901e-016}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(signalVoltage2.p, p_out) annotation (Line(
                points={{60,8},{60,100},{0,100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(signalVoltage2.n, n_out) annotation (Line(
                points={{60,-8},{60,-100},{0,-100}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(add.y, product1.u1) annotation (Line(
                points={{-31.5,-39},{-16,-39},{-16,-3.6},{-7.2,-3.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const2.y, add.u1) annotation (Line(
                points={{-61.4,-30},{-52,-30},{-52,-36},{-43,-36}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(u2, add.u2) annotation (Line(
                points={{-104,-42},{-43,-42}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}), Text(
                    extent={{-60,20},{74,-16}},
                    lineColor={0,0,0},
                    fillColor={127,0,0},
                    fillPattern=FillPattern.Solid,
                    textString="V * gain")}));
          end Voltage_Modulator;

          model Generator "Elemental model of an electric generator"
            extends Modelica.Electrical.Analog.Interfaces.OnePort;
            extends
              Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
            extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort_Device_With_Thermal_Mass;
            parameter SI.Voltage v_nom=200
              "Nominal voltage at which data was generated"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Voltage v_max=250
              "Maximum voltage at which data was generated"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Voltage v_cutoff=v_nom*0.1
              "Supply voltage below which power limit cannot be reached"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
                                                                            annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Torque trq_max=200 "Maximum output torque"
                                                                   annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Torque trq_nom=110 "Nominal output torque"
                                                                   annotation (Dialog(group="Electrical/Mechanical"));
            parameter Real efficiency(
              min=0,
              max=1) = 0.95 "Efficiency of electrical to mechanical conversion"
                                                                               annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Power pow_stall=pow_max*0.01
              "Electrical power consumed near stall at max demand"   annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Temperature temp_max = 373.15 "Maximum device temp" annotation (Dialog(group="Electrical/Mechanical"));
            SI.Time time_temp_max = 50
              "Maximum time device can operate at max power";

            SI.AngularVelocity w;
            SI.Power pow_lim_at_v_nom;
            SI.Power pow_elec;
            SI.Power pow_mech;

            SI.Torque trq;
            SI.Voltage voltage;

            Real limit;
            Modelica.Blocks.Interfaces.RealInput demand
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          //protected
            parameter SI.Torque trq_gross_max=trq_max/efficiency;
            parameter SI.Current i_max=pow_max/v_nom
              "The current that limits operation to below power_max at v_nom";
            parameter SI.ElectricalTorqueConstant k=1
              "Transformation coefficient";
            discrete Modelica.SIunits.Time entryTime(start = 0) "Time instant";
            Boolean T_exceeded(start = false, fixed = true);
          equation
            w = der(flange.phi);

            pow_elec = v*i;
            pow_mech = w*flange.tau;

            // Calculate time when device temp goes able critical value
          algorithm
              when T_device > temp_max and not pre(T_exceeded) then
                entryTime := time;
                T_exceeded := true;

            elsewhen T_device <= temp_max and pre(T_exceeded) then
                entryTime := time;
                T_exceeded := false;
            end when;

          equation
            if T_exceeded and time > entryTime + time_temp_max then
              trq = trq_nom;
              voltage = v_nom;
            else
              trq = trq_max;
              voltage = v_max;
            end if;

              limit = min(1.0, max(0, 1 - 2 *(v_cutoff - v)/v_cutoff));

              pow_lim_at_v_nom = min((trq/efficiency)*abs(w), pow_max);
              flange.tau = -min(trq,min((k*(pow_lim_at_v_nom/max(1e-12,v))),pow_max/max(1e-12,abs(w))))*efficiency*demand;
              //flange.tau = -min(trq,k*(pow_lim_at_v_nom/max(1e-12,v)))*efficiency*demand;
              //v = max(0,min(voltage,min(v_max,pow_lim_at_v_nom/max(1e-12,abs(i)))))*efficiency*demand;

              //v = max(0,(min(voltage,min(pow_max/min(i_max,max(1e-12,abs(i))),pow_lim_at_v_nom/min(i_max,max(1e-12,abs(i)))))))*efficiency*demand;

              i = -(min(pow_lim_at_v_nom/max(1e-12,max(voltage,v)), pow_max/voltage)*abs(demand));

              // Thermal model
            //loss_power = pow_elec + pow_mech;
            heat_generated = abs(pow_elec + pow_mech);
            if not use_heat_port then
              // assume all heat generated is lost immediately (effectively isothermal)
              loss_power = heat_generated;
            end if;

            annotation (Icon(graphics={Rectangle(extent={{-100,100},{100,-100}}, lineColor=
                       {0,0,255}), Text(
                    extent={{-136,20},{136,-20}},
                    lineColor={0,0,255},
                    textString="%name",
                    origin={-6,132},
                    rotation=180),
                  Rectangle(
                    extent={{-12,10},{12,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    origin={0,86},
                    rotation=90),
                  Rectangle(
                    extent={{-33,31},{33,-31}},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    origin={1,43},
                    rotation=90),
                  Line(
                    points={{-90,0},{-40,0},{-40,20},{-30,20},{-28,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{90,0},{40,0},{40,20},{30,20},{28,20}},
                    color={0,0,255},
                    smooth=Smooth.None)}),
                                    Diagram(graphics));
          end Generator;

          model Motor_With_Inverter_As_Generator
            "Elemental model of an electric motor plus inverter fed with a DC supply"
            extends Modelica.Electrical.Analog.Interfaces.OnePort;
            extends
              Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
          //  extends C2M2L_Ext.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;
            extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort_Device_With_Thermal_Mass;
            parameter SI.Voltage v_nom=100
              "Nominal voltage at which data was generated"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Voltage v_cutoff=v_nom*0.1
              "Supply voltage below which power limit cannot be reached"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.AngularVelocity w_cutoff=100
              "Rotational speed below which power limit cannot be reached"
              annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
                                                                            annotation (Dialog(group="Electrical/Mechanical"));
            parameter SI.Torque trq_max=100 "Maximum output torque"
                                                                   annotation (Dialog(group="Electrical/Mechanical"));
            parameter Real efficiency(
              min=0,
              max=1) = 0.95 "Efficiency of mechanical to electrical conversion"
                                                                               annotation (Dialog(group="Electrical/Mechanical"));

            SI.AngularVelocity w;
            SI.Power pow_lim_at_v_nom;
            SI.Power pow_elec;
            SI.Power pow_mech;
            Modelica.Blocks.Interfaces.RealInput demand
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Real limit;
          //protected
            parameter SI.Torque trq_gross_max=trq_max*efficiency;
            parameter SI.Current i_max=pow_max/v_nom
              "The current that limits operation to below power_max at v_nom";
          equation
            w = der(flange.phi);

            pow_elec = v*i;
            pow_mech = w*flange.tau;

            // Calculate a limit to reduce current below w_cutoff
            limit = min(1.0, max(0, 1 - 2*(w_cutoff - w)/w_cutoff));

           // i = (min(max(pow_stall, pow_lim_at_v_nom)/v, i_max)*abs(demand)) * limit;
            i = -(min(if noEvent(abs(v) > 0) then pow_lim_at_v_nom/abs(v) else i_max, i_max)*abs(
              demand))*limit;

            // flange.tau = -(min(-trq_gross_max, pow_elec/max(1e-12, abs(w))))/efficiency*
            //   sign(demand);

            flange.tau = -(max(-trq_gross_max, pow_elec/max(1e-12, abs(w))))/efficiency;

           // pow_lim_at_v_nom = min(trq_gross_max*max(1e-12, abs(w)), pow_max);

            pow_lim_at_v_nom = min(i_max*max(1e-12, abs(v)), pow_max);

            // Thermal model
            //loss_power = pow_elec + pow_mech;
            heat_generated = pow_elec + pow_mech;
            if not use_heat_port then
              // assume all heat generated is lost immediately (effectively isothermal)
              loss_power = heat_generated;
            end if;

            annotation (Icon(graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                  Text(
                    extent={{-136,20},{136,-20}},
                    lineColor={0,0,255},
                    textString="%name",
                    origin={-6,132},
                    rotation=180),
                  Rectangle(
                    extent={{-12,10},{12,-10}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    origin={0,86},
                    rotation=90),
                  Rectangle(
                    extent={{-33,31},{33,-31}},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={95,95,95},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    origin={1,43},
                    rotation=90),
                  Rectangle(
                    extent={{-40,-20},{40,-60}},
                    lineColor={0,0,255},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-94,0},{-60,0},{-60,-40},{-40,-40},{-40,-38}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{96,0},{60,0},{60,-40},{40,-40}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Text(
                    extent={{-54,-24},{54,-58}},
                    lineColor={0,0,255},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    textString="INV"),
                  Line(
                    points={{-20,-20},{-20,-8},{-40,-8},{-40,20},{-30,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{20,-20},{20,-8},{40,-8},{40,20},{30,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Text(
                    extent={{-180,78},{184,-6}},
                    lineColor={255,0,0},
                    textString="GEN")}), Diagram(graphics));
          end Motor_With_Inverter_As_Generator;

          package Tests
          extends Icons.Package_For_Simple_Test_Cases;

            model Test_Motor_With_Inverter
              extends Icons.Simple_Test_Case;
              Motor_With_Inverter motor_With_Inverter(
                efficiency=0.8,
                use_heat_port=true,
                C_device=1000)
                annotation (Placement(transformation(extent={{-10,0},{10,20}})));
              Modelica.Electrical.Analog.Basic.Ground ground
                annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
              Modelica.Blocks.Sources.Pulse const(
                                                 startTime=10,
                period=10,
                amplitude=2,
                width=90,
                offset=-1)
                annotation (Placement(transformation(extent={{-90,40},{-70,60}})));
              Modelica.Blocks.Sources.Step const1(
                height=200,
                offset=200,
                startTime=30)
                annotation (Placement(transformation(extent={{-90,0},{-70,20}})));
              Modelica.Mechanics.Rotational.Components.Inertia inertia(     w(fixed=true,
                    start=-104.71975511966), J=0.5)
                                             annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={0,42})));
              Modelica.Mechanics.Rotational.Components.Damper damper(d=0.02)
                annotation (Placement(transformation(extent={{0,60},{20,80}})));
              Modelica.Mechanics.Rotational.Components.Fixed fixed
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={40,70})));
              Batteries.Battery_Simplified_Shepard_Equation
                                           battery_Simplified(
                cp_batt=10,
                R_batt=0.0005,
                R_thermal=0.01,
                useHeatPort=true)
                               annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={0,-50})));
              Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=
                    323.15)
                annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
              Modelica.Thermal.HeatTransfer.Components.Convection convection
                annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            equation
              connect(const.y, motor_With_Inverter.demand) annotation (Line(
                  points={{-69,50},{-30,50},{-30,18},{-12,18}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(inertia.flange_a, motor_With_Inverter.flange) annotation (Line(
                  points={{-6.12323e-016,32},{-6.12323e-016,20},{0,20}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(damper.flange_b, fixed.flange) annotation (Line(
                  points={{20,70},{40,70}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(damper.flange_a, inertia.flange_b) annotation (Line(
                  points={{0,70},{6.12323e-016,70},{6.12323e-016,52}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(battery_Simplified.rtn, motor_With_Inverter.n) annotation (Line(
                  points={{8,-40},{8,-34},{20,-34},{20,10},{10,10}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(battery_Simplified.v_batt, motor_With_Inverter.p) annotation (Line(
                  points={{-8,-40},{-8,-34},{-20,-34},{-20,10},{-10,10}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(ground.p, battery_Simplified.rtn) annotation (Line(
                  points={{20,-74},{20,-34},{8,-34},{8,-40}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(fixedTemperature.port, convection.solid) annotation (Line(
                  points={{-70,-20},{-60,-20}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(convection.fluid, motor_With_Inverter.heatPort) annotation (Line(
                  points={{-40,-20},{-11,-20},{-11,0},{-10,0}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(const1.y, convection.Gc) annotation (Line(
                  points={{-69,10},{-50,10},{-50,-10}},
                  color={0,0,127},
                  smooth=Smooth.None));
              annotation (
                Diagram(graphics),
                experiment(StopTime=60, Tolerance=1e-005),
                __Dymola_experimentSetupOutput);
            end Test_Motor_With_Inverter;

            model Test_Generator
              extends Icons.Simple_Test_Case;
              Modelica.Electrical.Analog.Basic.Ground ground
                annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
              Modelica.Blocks.Sources.Pulse const(
                                                 startTime=10,
                width=90,
                period=100,
                amplitude=300,
                offset=0)
                annotation (Placement(transformation(extent={{-90,40},{-70,60}})));
              Modelica.Blocks.Sources.Step const1(
                height=200,
                offset=200,
                startTime=0)
                annotation (Placement(transformation(extent={{-90,0},{-70,20}})));
              Modelica.Mechanics.Rotational.Components.Inertia inertia(J=0.1)
                                             annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={0,42})));
              Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
                annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
              Modelica.Thermal.HeatTransfer.Components.Convection convection
                annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
              Mechanics.Rotational.Components.Dyno dyno(
                Ti=0.1,
                controllerType=Modelica.Blocks.Types.SimpleController.PI,
                Td=1,
                k=10,
                J=0.1,
                max_res_trq=1000)
                      annotation (Placement(transformation(extent={{10,10},{-10,-10}},
                    rotation=270,
                    origin={0,74})));
              Modelica.Blocks.Sources.Ramp ramp1(
                                                duration=100, height=300)
                annotation (Placement(transformation(extent={{-60,64},{-40,84}})));
              Modelica.Blocks.Sources.Constant const2(k=0.001)
                annotation (Placement(transformation(extent={{-48,-70},{-28,-50}})));
              Modelica.Electrical.Analog.Basic.VariableResistor
                                                        resistor annotation (Placement(
                    transformation(
                    extent={{10,-10},{-10,10}},
                    rotation=180,
                    origin={2,-30})));
              Generator generator(use_heat_port=true,
                C_device=10000,
                v_max=500,
                efficiency=0.95)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
              Modelica.Blocks.Sources.Constant const3(k=1)
                annotation (Placement(transformation(extent={{-54,24},{-34,44}})));
              Modelica.Blocks.Sources.Step const4(
                height=-999.999,
                offset=1000,
                startTime=250)
                annotation (Placement(transformation(extent={{-80,-82},{-60,-62}})));
            equation
              connect(fixedTemperature.port, convection.solid) annotation (Line(
                  points={{-70,-20},{-60,-20}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(const1.y, convection.Gc) annotation (Line(
                  points={{-69,10},{-50,10},{-50,-10}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(dyno.flange, inertia.flange_b) annotation (Line(
                  points={{-1.83697e-015,64},{6.12323e-016,64},{6.12323e-016,52}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(inertia.flange_a, generator.flange) annotation (Line(
                  points={{-6.12323e-016,32},{0,32},{0,10}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(resistor.p, generator.p) annotation (Line(
                  points={{-8,-30},{-20,-30},{-20,0},{-10,0}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(const3.y, generator.demand) annotation (Line(
                  points={{-33,34},{-22,34},{-22,8},{-12,8}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(ramp1.y, dyno.request_speed) annotation (Line(
                  points={{-39,74},{-12,74}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(generator.heatPort, convection.fluid) annotation (Line(
                  points={{-10,-10},{-10,-20},{-40,-20}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(const2.y, resistor.R) annotation (Line(
                  points={{-27,-60},{2,-60},{2,-41}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(resistor.n, ground.p) annotation (Line(
                  points={{12,-30},{20,-30},{20,-74}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(generator.n, ground.p) annotation (Line(
                  points={{10,0},{20,0},{20,-74}},
                  color={0,0,255},
                  smooth=Smooth.None));
              annotation (
                Diagram(graphics),
                experiment(StopTime=500, Tolerance=1e-005),
                __Dymola_experimentSetupOutput);
            end Test_Generator;

            model Test_Generator_with_Battery
              extends Icons.Simple_Test_Case;
              Modelica.Electrical.Analog.Basic.Ground ground
                annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
              Modelica.Blocks.Sources.Pulse const(
                                                 startTime=10,
                width=90,
                period=100,
                amplitude=300,
                offset=0)
                annotation (Placement(transformation(extent={{-90,40},{-70,60}})));
              Modelica.Blocks.Sources.Step const1(
                height=200,
                offset=200,
                startTime=0)
                annotation (Placement(transformation(extent={{-90,0},{-70,20}})));
              Modelica.Mechanics.Rotational.Components.Inertia inertia(J=0.1)
                                             annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={0,42})));
              Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
                annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
              Modelica.Thermal.HeatTransfer.Components.Convection convection
                annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
              Mechanics.Rotational.Components.Dyno dyno(
                Ti=0.1,
                controllerType=Modelica.Blocks.Types.SimpleController.PI,
                Td=1,
                k=10,
                J=0.1,
                max_res_trq=1000)
                      annotation (Placement(transformation(extent={{10,10},{-10,-10}},
                    rotation=270,
                    origin={0,74})));
              Modelica.Blocks.Sources.Ramp ramp1(
                                                duration=100, height=300)
                annotation (Placement(transformation(extent={{-60,64},{-40,84}})));
              Modelica.Blocks.Sources.Constant const2(k=100)
                annotation (Placement(transformation(extent={{-48,-70},{-28,-50}})));
              Modelica.Electrical.Analog.Basic.VariableResistor
                                                        resistor annotation (Placement(
                    transformation(
                    extent={{10,-10},{-10,10}},
                    rotation=180,
                    origin={2,-30})));
              Generator generator(use_heat_port=true,
                C_device=10000,
                v_max=500)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
              Modelica.Blocks.Sources.Constant const3(k=1)
                annotation (Placement(transformation(extent={{-54,24},{-34,44}})));
              Modelica.Blocks.Sources.Step const4(
                height=-999.999,
                offset=1000,
                startTime=250)
                annotation (Placement(transformation(extent={{-80,-82},{-60,-62}})));
              Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                                battery2_1(
                R_thermal=0.01,
                R_batt=0.065,
                mass_batt=100,
                cp_batt=66,
                soc_init=1,
                useHeatPort=true,
                T_ref(displayUnit="K"),
                v_battery(
                  soc_init=0.6,
                  e_max=150,
                  e_nom=140,
                  e_exp=120,
                  q_max=3600*200))             annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={62,-12})));
            equation
              connect(fixedTemperature.port, convection.solid) annotation (Line(
                  points={{-70,-20},{-60,-20}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(const1.y, convection.Gc) annotation (Line(
                  points={{-69,10},{-50,10},{-50,-10}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(dyno.flange, inertia.flange_b) annotation (Line(
                  points={{-1.83697e-015,64},{6.12323e-016,64},{6.12323e-016,52}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(inertia.flange_a, generator.flange) annotation (Line(
                  points={{-6.12323e-016,32},{0,32},{0,10}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(resistor.p, generator.p) annotation (Line(
                  points={{-8,-30},{-20,-30},{-20,0},{-10,0}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(const3.y, generator.demand) annotation (Line(
                  points={{-33,34},{-22,34},{-22,8},{-12,8}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(ramp1.y, dyno.request_speed) annotation (Line(
                  points={{-39,74},{-12,74}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(generator.heatPort, convection.fluid) annotation (Line(
                  points={{-10,-10},{-10,-20},{-40,-20}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(const2.y, resistor.R) annotation (Line(
                  points={{-27,-60},{2,-60},{2,-41}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(resistor.n, battery2_1.v_batt) annotation (Line(
                  points={{12,-30},{40,-30},{40,0},{54,0},{54,-2}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(ground.p, battery2_1.rtn) annotation (Line(
                  points={{20,-74},{32,-74},{32,-40},{86,-40},{86,-2},{70,-2}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(generator.n, battery2_1.rtn) annotation (Line(
                  points={{10,0},{22,0},{22,8},{70,8},{70,-2}},
                  color={0,0,255},
                  smooth=Smooth.None));
              annotation (
                Diagram(graphics),
                experiment(StopTime=5000, Tolerance=1e-005),
                __Dymola_experimentSetupOutput);
            end Test_Generator_with_Battery;
          end Tests;
        end Base_Classes;

        model Electric_Generator
          "Electromotoric force (electric/mechanic transformer) combined with a regulator that controls voltage output"
          parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Boolean useHeatPort=true "= true, if heat port enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter SI.Voltage v_nom = 28 "Nominal operating voltage";
          parameter SI.AngularVelocity w_cut = 50 "Voltage cutoff speed";
          parameter SI.Torque max_torque = 1800 "Maximum torque";
          parameter Real efficiency(
            min=0,
            max=1) = 0.95 "Efficiency of electrical to mechanical conversion";

          Modelica.Electrical.Analog.Interfaces.PositivePin p annotation (Placement(transformation(
                origin={0,100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,80})));
          Modelica.Electrical.Analog.Interfaces.NegativePin n annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-80})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
            annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
          Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
            "Support/housing of emf shaft"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        protected
          Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
            annotation (Placement(transformation(extent={{-90,-42},{-70,-22}})));
          Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
          Modelica.Blocks.Tables.CombiTable1D v_vs_speed(table=[0.0,0; w_cut*0.9,0;
                w_cut,v_nom; w_cut*10,v_nom])
            annotation (Placement(transformation(extent={{-90,20},{-80,30}})));

        public
          C2M2L_OM.MSL_Extend.Electrical.Electric_Machines.Base_Classes.EMF_External_Control
                               emf(useSupport=true)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
              Placement(transformation(
                extent={{-7,-7},{7,7}},
                rotation=90,
                origin={66,32})));
          Mechanics.Rotational.Components.Efficiency_Loss_Controlled
            efficiency_Loss_Fixed(useSupport=true,
            use_environment_heat_port=not useHeatPort,
            useHeatPort=useHeatPort)
            annotation (Placement(transformation(extent={{38,-8},{54,8}})));
          Modelica.Blocks.Math.Division division2
            "voltage from table divided by instantaneous speed"
            annotation (Placement(transformation(extent={{-63,10},{-53,20}})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (
              Placement(transformation(
                extent={{8,8},{-8,-8}},
                rotation=90,
                origin={0,-62})));
          C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                            max_Against_Parametersdgsdg(p=1)
            annotation (Placement(transformation(extent={{-126,6},{-114,18}})));
          Modelica.Blocks.Math.Add add(k1=1, k2=1)
            annotation (Placement(transformation(extent={{-71,59},{-60,70}})));
          Blocks.Math.Positive_Negative_Split positive_Negative_Split
            annotation (Placement(transformation(extent={{-54,59},{-43,70}})));
          Modelica.Blocks.Math.Division division
            annotation (Placement(transformation(extent={{-44,4},{-34,14}})));
          C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                            max_Against_Parameter1(p=1)
            annotation (Placement(transformation(extent={{-22,56},{-12,66}})));
          Modelica.Blocks.Math.Gain gain(k=-1)
            annotation (Placement(transformation(extent={{-37,57},{-29,65}})));
          Modelica.Blocks.Tables.CombiTable1D tau_vs_speed(table=[0.0,0; w_cut,
                max_torque*0.420; w_cut*5,max_torque*0.33])
            annotation (Placement(transformation(extent={{-92,63},{-82,73}})));
          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
              Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=270,
                origin={29,78})));
          Modelica.Blocks.Continuous.FirstOrder firstOrder(T=0.1, y_start=1)
            annotation (Placement(transformation(extent={{-63,31},{-54,40}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort if useHeatPort
            "Optional port to which dissipated losses are transported in form of heat"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={55,-100}),
             iconTransformation(extent={{-90,-90},{-70,-70}})));
          Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
            annotation (Placement(transformation(extent={{70,7},{84,-7}})));
          Modelica.Blocks.Math.Product product1
            "current from table mutiplied by instantaneous voltage"
            annotation (Placement(transformation(extent={{-27,3},{-20,10}})));
          Modelica.Blocks.Math.Gain gain1(k=-1)
            annotation (Placement(transformation(extent={{-43,-14},{-35,-6}})));
          Modelica.Blocks.Sources.Constant const1(k=efficiency)
            annotation (Placement(transformation(extent={{10,13},{20,23}})));
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={106,-15})));
          Modelica.Blocks.Interfaces.RealOutput tau
            annotation (Placement(transformation(extent={{96,-39},{116,-19}})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={106,-41})));
          Modelica.Blocks.Interfaces.RealOutput w
            annotation (Placement(transformation(extent={{96,-64},{116,-44}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=180,
                origin={106,-73})));
        equation
          connect(emf.p, p) annotation (Line(
              points={{0,10},{0,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(support, internalSupport) annotation (Line(
              points={{-100,0},{-80,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(fixed.flange, internalSupport) annotation (Line(
              points={{-80,-32},{-80,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(internalSupport, emf.support) annotation (Line(
              points={{-80,0},{-10,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(efficiency_Loss_Fixed.support, internalSupport) annotation (Line(
              points={{46,-8},{46,-24},{-80,-24},{-80,0}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(speedSensor.w, v_vs_speed.u[1])
                                             annotation (Line(
              points={{66,39.7},{66,107},{-131,107},{-131,25},{-91,25}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(max_Against_Parametersdgsdg.y, division2.u2) annotation (Line(
              points={{-113.4,12},{-64,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.flange, efficiency_Loss_Fixed.flange_a) annotation (Line(
              points={{10,0},{38,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(division2.y, division.u1) annotation (Line(
              points={{-52.5,15},{-47,15},{-47,12},{-45,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, positive_Negative_Split.u) annotation (Line(
              points={{-59.45,64.5},{-55.1,64.5}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(v_vs_speed.y[1], division2.u1) annotation (Line(
              points={{-79.5,25},{-76,25},{-76,18},{-64,18}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(positive_Negative_Split.y_neg, gain.u) annotation (Line(
              points={{-42.45,61.2},{-35.725,61.2},{-35.725,61},{-37.8,61}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor.w, tau_vs_speed.u[1]) annotation (Line(
              points={{66,39.7},{66,107},{-97,107},{-97,68},{-93,68}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.p, p) annotation (Line(
              points={{29,86},{15,86},{15,100},{0,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.n, n) annotation (Line(
              points={{29,70},{29,-87},{12,-87},{12,-100},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(max_Against_Parameter1.y, firstOrder.u) annotation (Line(
              points={{-11.5,61},{-6,61},{-6,44},{-67,44},{-67,35.5},{-63.9,35.5}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(efficiency_Loss_Fixed.heatPort, heatPort) annotation (Line(
              points={{38,-8},{38,-66},{55,-66},{55,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_b, flange) annotation (Line(
              points={{84,-8.88178e-016},{89,-8.88178e-016},{89,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_a, efficiency_Loss_Fixed.flange_b) annotation (
              Line(
              points={{70,-8.88178e-016},{59.5,-8.88178e-016},{59.5,0},{54,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor.flange, torqueSensor.flange_a) annotation (Line(
              points={{66,25},{66,-8.88178e-016},{70,-8.88178e-016}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(division.y, product1.u1) annotation (Line(
              points={{-33.5,9},{-31,9},{-31,8.6},{-27.7,8.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(max_Against_Parametersdgsdg.u, v_vs_speed.u[1]) annotation (Line(
              points={{-127.2,12},{-131,12},{-131,25},{-91,25}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(product1.y, emf.k) annotation (Line(
              points={{-19.65,6.5},{-15.825,6.5},{-15.825,7},{-12,7}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.p, emf.n) annotation (Line(
              points={{4.89859e-016,-54},{4.89859e-016,-32.5},{0,-32.5},{0,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, n) annotation (Line(
              points={{-4.89859e-016,-70},{-4.89859e-016,-83.5},{0,-83.5},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(gain1.y, product1.u2) annotation (Line(
              points={{-34.6,-10},{-32,-10},{-32,4.4},{-27.7,4.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.u2, torqueSensor.tau) annotation (Line(
              points={{-72.1,61.2},{-77,61.2},{-77,53},{71.4,53},{71.4,7.7}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.u1, tau_vs_speed.y[1]) annotation (Line(
              points={{-72.1,67.8},{-77,67.8},{-77,68},{-81.5,68}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(const1.y, efficiency_Loss_Fixed.efficiency) annotation (Line(
              points={{20.5,18},{49.28,18},{49.28,9.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(gain.y, max_Against_Parameter1.u) annotation (Line(
              points={{-28.6,61},{-23,61}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(firstOrder.y, division.u2) annotation (Line(
              points={{-53.55,35.5},{-50,35.5},{-50,6},{-45,6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(torqueSensor.tau, tau) annotation (Line(
              points={{71.4,7.7},{71.4,18},{87,18},{87,-29},{106,-29}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{21,78},{16,78},{16,32},{90,32},{90,-15},{106,-15}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor.w, w) annotation (Line(
              points={{66,39.7},{66,44},{79,44},{79,-54},{106,-54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(gain1.u, demand) annotation (Line(
              points={{-43.8,-10},{-50,-10},{-50,-73},{106,-73}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{-8,-62},{-18,-62},{-18,-41},{106,-41}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            defaultComponentName="emf",
            Icon(
                coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Rectangle(
                  extent={{35,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,80},{64,-80}},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95},
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{64,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95})}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Polygon(
                  points={{-17,95},{-20,85},{-23,95},{-17,95}},
                  lineColor={160,160,164},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(points={{-20,110},{-20,85}}, color={160,160,164}),
                Text(
                  extent={{-40,110},{-30,90}},
                  lineColor={160,160,164},
                  textString="i"),
                Line(points={{9,75},{19,75}}, color={192,192,192}),
                Line(points={{-20,-110},{-20,-85}}, color={160,160,164}),
                Polygon(
                  points={{-17,-100},{-20,-110},{-23,-100},{-17,-100}},
                  lineColor={160,160,164},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-40,-110},{-30,-90}},
                  lineColor={160,160,164},
                  textString="i"),
                Line(points={{8,-79},{18,-79}}, color={192,192,192}),
                Line(points={{14,80},{14,70}}, color={192,192,192})}),
            Documentation(info="<html>
<p>Electric Generator transforms rotational mechanical energy into electrical energy. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection.</p>
</html>",revisions="<html>
<ul>
<li><i> 1998   </i>
       by Martin Otter<br> initially implemented<br>
       </li>
</ul>
</html>"));
        end Electric_Generator;

        model Electric_Motor

          Electric_Machines.Base_Classes.Motor_With_Inverter
                              motor_With_Inverter(
            v_nom=v_nom,
            pow_max=pow_max,
            trq_max=trq_max,
            efficiency=efficiency,
            use_heat_port=use_heat_port,
            useSupport=true)             annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,0})));
          Modelica.Electrical.Analog.Interfaces.PositivePin p annotation (Placement(transformation(
                origin={0,100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,80})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
            annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
          Modelica.Electrical.Analog.Interfaces.NegativePin n annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-80})));
          Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
            "Support/housing of emf shaft"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor
            "measures voltage across electric motor" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,68})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor
            "measures current through electric motor" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-48})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor
            "measures rotational speed of electric motor shaft" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,18})));
          Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
            "measures torque at the shaft of electric motor"
            annotation (Placement(transformation(extent={{70,10},{90,-10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort if use_heat_port
            "Optional port to which dissipated losses are transported in form of heat"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-59,-100}),
             iconTransformation(extent={{-90,-90},{-70,-70}})));
          parameter SI.Voltage v_nom=100
            "Nominal voltage at which data was generated";
          parameter SI.Voltage v_cutoff=v_nom*0.1
            "Supply voltage below which power limit cannot be reached";
          parameter SI.Power pow_max=100000 "Maximum input power at v_nom";
          parameter SI.Torque trq_max=100 "Maximum output torque";
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion";
          parameter Boolean use_heat_port=true "=true, if HeatPort is enabled";
          parameter Boolean useSupport=true
            "= true, if support flange enabled, otherwise implicitly grounded";
          parameter SI.Voltage v_max=250
            "Maximum voltage at which data was generated";
          parameter SI.Torque trq_nom=110 "Nominal output torque";
          parameter SI.Temperature temp_max=373.15 "Maximum device temp";
          parameter SI.HeatCapacity C_device=1000 "Heat capacity of device";
          parameter SI.Temperature T_device=293.15
            "Start temperature of device";
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={32,106})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={68,106})));
          Modelica.Blocks.Interfaces.RealOutput w
            annotation (Placement(transformation(extent={{96,68},{116,88}})));
          Modelica.Blocks.Interfaces.RealOutput tau
            annotation (Placement(transformation(extent={{96,46},{116,66}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=180,
                origin={106,30})));
        equation
          connect(p, motor_With_Inverter.p) annotation (Line(
              points={{0,100},{0,10},{1.83697e-015,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.n, p) annotation (Line(
              points={{20,78},{20,84},{0,84},{0,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, n) annotation (Line(
              points={{20,58},{20,-88},{0,-88},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, motor_With_Inverter.n) annotation (Line(
              points={{6.12323e-016,-38},{6.12323e-016,-24},{-1.83697e-015,-24},{
                  -1.83697e-015,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.p, n) annotation (Line(
              points={{-6.12323e-016,-58},{0,-58},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(speedSensor.flange, motor_With_Inverter.flange) annotation (Line(
              points={{50,8},{50,-1.83697e-015},{10,-1.83697e-015}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_b, flange) annotation (Line(
              points={{90,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(heatPort, motor_With_Inverter.heatPort) annotation (Line(
              points={{-59,-100},{-59,-46},{-20,-46},{-20,10},{-10,10}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(support, motor_With_Inverter.support) annotation (Line(
              points={{-100,0},{-55,0},{-55,1.83697e-015},{-10,1.83697e-015}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_a, speedSensor.flange) annotation (Line(
              points={{70,0},{50,0},{50,8}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,68},{32,68},{32,106}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(currentSensor.i, i) annotation (Line(
              points={{10,-48},{22,-48},{22,-46},{40,-46},{40,80},{68,80},{68,106}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(motor_With_Inverter.demand, demand) annotation (Line(
              points={{8,12},{8,30},{106,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor.w, w) annotation (Line(
              points={{50,29},{50,78},{106,78}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tau, torqueSensor.tau) annotation (Line(
              points={{106,56},{72,56},{72,11}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-100,80},{64,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,128,255}),
                Rectangle(
                  extent={{64,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95})}),
            Documentation(info="<html>
<p>Electric motor transforms electrical energy into rotational mechanical energy. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection.</p>
</html>"));
        end Electric_Motor;

        model Electric_Motor_As_Generator

          Base_Classes.Motor_With_Inverter_As_Generator
                                           motor_With_Inverter(
            v_nom=v_nom,
            pow_max=pow_max,
            trq_max=trq_max,
            efficiency=efficiency,
            useSupport=useSupport,
            use_heat_port=use_heat_port) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,0})));
          Modelica.Electrical.Analog.Interfaces.PositivePin p annotation (Placement(transformation(
                origin={0,100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,80})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
            annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
          Modelica.Electrical.Analog.Interfaces.NegativePin n annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-80})));
          Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
            "Support/housing of emf shaft"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor
            "measures voltage across electric motor" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,68})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor
            "measures current through electric motor" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-48})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor
            "measures rotational speed of electric motor shaft" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,18})));
          Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
            "measures torque at the shaft of electric motor"
            annotation (Placement(transformation(extent={{70,10},{90,-10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort if use_heat_port
            "Optional port to which dissipated losses are transported in form of heat"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-59,-100}),
             iconTransformation(extent={{-90,-90},{-70,-70}})));
          parameter SI.Voltage v_nom=100
            "Nominal voltage at which data was generated";
          parameter SI.Voltage v_cutoff=v_nom*0.1
            "Supply voltage below which power limit cannot be reached";
          parameter SI.Power pow_max=100000 "Maximum input power at v_nom";
          parameter SI.Torque trq_max=100 "Maximum output torque";
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion";
          parameter Boolean use_heat_port=true "=true, if HeatPort is enabled";
          parameter Boolean useSupport=true
            "= true, if support flange enabled, otherwise implicitly grounded";
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={34,104})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={70,104})));
          Modelica.Blocks.Interfaces.RealOutput w
            annotation (Placement(transformation(extent={{98,66},{118,86}})));
          Modelica.Blocks.Interfaces.RealOutput tau
            annotation (Placement(transformation(extent={{98,44},{118,64}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=180,
                origin={108,28})));
        equation
          connect(p, motor_With_Inverter.p) annotation (Line(
              points={{0,100},{0,10},{1.83697e-015,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.n, p) annotation (Line(
              points={{20,78},{20,84},{0,84},{0,100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(voltageSensor.p, n) annotation (Line(
              points={{20,58},{20,-88},{0,-88},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, motor_With_Inverter.n) annotation (Line(
              points={{6.12323e-016,-38},{6.12323e-016,-24},{-1.83697e-015,-24},{
                  -1.83697e-015,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.p, n) annotation (Line(
              points={{-6.12323e-016,-58},{0,-58},{0,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(speedSensor.flange, motor_With_Inverter.flange) annotation (Line(
              points={{50,8},{50,-1.83697e-015},{10,-1.83697e-015}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_b, flange) annotation (Line(
              points={{90,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(heatPort, motor_With_Inverter.heatPort) annotation (Line(
              points={{-59,-100},{-59,-46},{-20,-46},{-20,10},{-10,10}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(support, motor_With_Inverter.support) annotation (Line(
              points={{-100,0},{-55,0},{-55,1.83697e-015},{-10,1.83697e-015}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torqueSensor.flange_a, speedSensor.flange) annotation (Line(
              points={{70,0},{50,0},{50,8}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(currentSensor.i,i)  annotation (Line(
              points={{10,-48},{42,-48},{42,78},{70,78},{70,104}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor.w,w)  annotation (Line(
              points={{50,29},{50,76},{108,76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tau, torqueSensor.tau) annotation (Line(
              points={{108,54},{72,54},{72,11}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(demand, motor_With_Inverter.demand) annotation (Line(
              points={{108,28},{8,28},{8,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(voltageSensor.v, v) annotation (Line(
              points={{30,68},{34,68},{34,104}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-100,80},{64,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,128,255}),
                Rectangle(
                  extent={{64,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95}),
                Text(
                  extent={{-170,88},{194,4}},
                  lineColor={255,0,0},
                  textString="GEN")}),
            Documentation(info="<html>
<p>Electric motor transforms electrical energy into rotational mechanical energy. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection.</p>
</html>"));
        end Electric_Motor_As_Generator;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;

          model Test_Electric_Generator
            "Tests the voltage and current limiting behavior of the Internal_Regulator_EMF component"
          extends Icons.Simple_Test_Case;
            Modelica.Mechanics.Rotational.Components.Inertia inertia(w(start=0), J=0.1)
                                                                          annotation (
                Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-14,0})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={80,8})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{114,-30},{134,-10}})));
            Modelica.Blocks.Sources.Sine ramp(
              startTime=0,
              freqHz=0.05,
              amplitude=2000,
              offset=2100)
              annotation (Placement(transformation(extent={{-112,20},{-92,40}})));
            C2M2L_OM.MSL_Extend.Electrical.Electric_Machines.Electric_Generator
                                                           emf(useSupport=true,
              v_nom=610,
              max_torque=1790,
              useHeatPort=true)
              annotation (Placement(transformation(extent={{50,-10},{30,10}})));
            Modelica.Mechanics.Rotational.Sensors.PowerSensor powerSensor
              annotation (Placement(transformation(extent={{2,10},{22,-10}})));
            inner Environments.Lumped_Thermal_Fixed_HTC_Infinite env
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed
              annotation (Placement(transformation(extent={{52,-16},{72,4}})));
            Modelica.Blocks.Sources.Ramp step(
              duration=500,
              startTime=0,
              height=-0.199,
              offset=0.2)
              annotation (Placement(transformation(extent={{60,80},{80,100}})));
            Modelica.Blocks.Sources.Constant const1(k=-1)
              annotation (Placement(transformation(extent={{-14,28},{6,48}})));
            Modelica.Blocks.Sources.Ramp ramp1(
                                              duration=100, height=300)
              annotation (Placement(transformation(extent={{-100,50},{-80,70}})));
            Modelica.Blocks.Sources.Constant const2(k=10)
              annotation (Placement(transformation(extent={{60,50},{80,70}})));
            Mechanics.Rotational.Components.Dyno dyno(
              Ti=0.1,
              controllerType=Modelica.Blocks.Types.SimpleController.PI,
              Td=1,
              k=10,
              max_res_trq=1000,
              J=0.1)
                    annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(final T=
                  573.15)
              annotation (Placement(transformation(extent={{84,-72},{64,-52}})));
          equation
            connect(ground.p, resistor.n) annotation (Line(
                points={{124,-10},{102,-10},{102,-2},{80,-2}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(emf.n, resistor.n) annotation (Line(
                points={{40,-8},{40,-26},{80,-26},{80,-2}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(emf.p, resistor.p) annotation (Line(
                points={{40,8},{40,40},{80,40},{80,18}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inertia.flange_a, powerSensor.flange_a) annotation (Line(
                points={{-4,-1.22465e-015},{-2,-1.22465e-015},{-2,0},{2,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(powerSensor.flange_b, emf.flange) annotation (Line(
                points={{22,0},{30,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fixed.flange, emf.support) annotation (Line(
                points={{62,-6},{56,-6},{56,0},{50,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(const2.y, resistor.R) annotation (Line(
                points={{81,60},{96,60},{96,8},{91,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(dyno.flange, inertia.flange_b) annotation (Line(
                points={{-40,0},{-32,0},{-32,1.22465e-015},{-24,1.22465e-015}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(ramp1.y, dyno.request_speed) annotation (Line(
                points={{-79,60},{-50,60},{-50,12}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(fixedTemperature.port, emf.heatPort) annotation (Line(
                points={{64,-62},{48,-62},{48,-8}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(emf.demand, const1.y) annotation (Line(
                points={{29.4,-7.3},{24,-7.3},{24,38},{7,38}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Electric_Generator;

          model Test_Electric_Motor
            "Tests the voltage and current limiting behavior of the EMF_motor component"
          extends Icons.Simple_Test_Case;
            Modelica.Mechanics.Rotational.Components.Inertia inertia(      w(start=0,
                  fixed=true), J=0.01)                                    annotation (
                Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-18,2})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{70,-54},{90,-34}})));
            inner Environments.Lumped_Thermal_Fixed_HTC_Infinite env
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed
              annotation (Placement(transformation(extent={{50,-18},{60,-8}})));

            Modelica.Blocks.Sources.Pulse pulse1(
              offset=0,
              amplitude=1,
              period=100,
              width=50)
              annotation (Placement(transformation(extent={{-30,32},{-10,52}})));
            Modelica.Electrical.Machines.Sensors.MechanicalPowerSensor
              mechanicalPowerSensor
              annotation (Placement(transformation(extent={{8,8},{20,-4}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed1
              annotation (Placement(transformation(extent={{-84,-20},{-64,0}})));
            Modelica.Mechanics.Rotational.Components.Damper damper(d=1, useHeatPort=false)
              annotation (Placement(transformation(extent={{-58,-8},{-38,12}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=450)
              annotation (Placement(transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=270,
                  origin={80,0})));
            Modelica.Electrical.Analog.Sensors.PowerSensor powerSensor
              annotation (Placement(transformation(extent={{72,26},{60,38}})));
            Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heatFlowSensor
              annotation (Placement(transformation(extent={{-8,-48},{8,-32}})));
            Modelica.Blocks.Math.Add3 sumPower
              annotation (Placement(transformation(extent={{76,-82},{88,-70}})));
            Modelica.Blocks.Sources.Sine ramp(
              startTime=0,
              freqHz=0.01,
              amplitude=0.5,
              offset=0.5)
              annotation (Placement(transformation(extent={{-32,64},{-12,84}})));
            Electric_Motor electric_Motor(use_heat_port=true)
              annotation (Placement(transformation(extent={{50,-8},{30,12}})));
          equation
            connect(inertia.flange_a, mechanicalPowerSensor.flange_a) annotation (Line(
                points={{-8,2},{0,2},{0,2},{8,2}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(damper.flange_a, fixed1.flange) annotation (Line(
                points={{-58,2},{-74,2},{-74,-10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(damper.flange_b, inertia.flange_b) annotation (Line(
                points={{-38,2},{-33,2},{-33,2},{-28,2}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(constantVoltage.n, ground.p) annotation (Line(
                points={{80,-10},{80,-34}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.pv, constantVoltage.p) annotation (Line(
                points={{66,38},{80,38},{80,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nv, ground.p) annotation (Line(
                points={{66,26},{66,-34},{80,-34}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(sumPower.u2, mechanicalPowerSensor.P) annotation (Line(
                points={{74.8,-76},{14,-76},{14,-4.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(heatFlowSensor.Q_flow, sumPower.u3) annotation (Line(
                points={{0,-48},{0,-80.8},{74.8,-80.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(powerSensor.pc, constantVoltage.p) annotation (Line(
                points={{72,32},{80,32},{80,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(sumPower.u1, powerSensor.power) annotation (Line(
                points={{74.8,-71.2},{70.8,-71.2},{70.8,25.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(heatFlowSensor.port_a, env.heat_port) annotation (Line(
                points={{-8,-40},{-98,-40},{-98,79.8}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(electric_Motor.flange, mechanicalPowerSensor.flange_b) annotation (
                Line(
                points={{30,2},{20,2}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(electric_Motor.p, powerSensor.nc) annotation (Line(
                points={{40,10},{40,32},{60,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(electric_Motor.n, ground.p) annotation (Line(
                points={{40,-6},{40,-34},{80,-34}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(electric_Motor.support, fixed.flange) annotation (Line(
                points={{50,2},{55,2},{55,-13}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(electric_Motor.heatPort, heatFlowSensor.port_b) annotation (Line(
                points={{48,-6},{48,-40},{8,-40}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(electric_Motor.demand, pulse1.y) annotation (Line(
                points={{29.4,5},{18,5},{18,42},{-9,42}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Electric_Motor;
        end Tests;
      end Electric_Machines;

      package Circuit_Devices
        extends Modelica.Icons.Package;

        model Fuse "Provides overcurrent protection in an electrical circuit"
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;

          Modelica.Electrical.Analog.Interfaces.PositivePin pos_in
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pos_out
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        public
          Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch switch(
            useHeatPort=false)
            annotation (Placement(transformation(extent={{10,-10},{-10,10}})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-60,14})));

          parameter SI.Current i_max = 100 "Maximum current";
          SI.Current i_in "Input current";
          SI.Current i_out "Output current";
          Boolean exceeded(start = false, fixed = true);
          Boolean exceededCurrent = currentSensor.i > i_max;

        algorithm
            when pre(exceededCurrent) then
              exceeded :=true;
            end when;
        equation
            i_out = pos_out.i;
            i_in = pos_in.i;
            switch.control = exceeded;

          loss_power = -(i_in*pos_in.v);

          connect(currentSensor.p, pos_in) annotation (Line(
              points={{-70,14},{-86,14},{-86,0},{-100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(switch.p, pos_out)               annotation (Line(
              points={{10,0},{100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, switch.n1) annotation (Line(
              points={{-50,14},{-32,14},{-32,5},{-10,5}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                Text(
                  extent={{-100,-10},{-38,-36}},
                  lineColor={0,0,255},
                  textString="pos"),
                Text(
                  extent={{42,-12},{98,-36}},
                  lineColor={0,0,255},
                  textString="neg"),
                Line(
                  points={{0,-22},{0,-86},{0,-88}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Open}),
                Line(
                  points={{-90,0},{-60,0},{-60,40},{-50,60},{-40,20},{-30,60},{-20,20},{
                      -10,60},{0,20},{10,60},{20,20},{30,60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{30,60},{40,20},{50,60},{60,40},{60,0},{90,0},{92,4}},
                  color={0,0,255},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>The fuser provides&nbsp;overcurrent&nbsp;protection&nbsp;in&nbsp;an&nbsp;electrical&nbsp;circuit. It can not be reset during simulation.</p>
</html>"));
        end Fuse;

        model Circuit_Breaker
          "Provides resettable overcurrent protection in an electrical circuit"
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;

          Modelica.Electrical.Analog.Interfaces.PositivePin pos_in
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pos_out
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        public
          Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch switch(useHeatPort=
                use_heat_port)
            annotation (Placement(transformation(extent={{10,-10},{-10,10}})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-64,10})));

          parameter SI.Current i_max=100 "Maximum current";
          SI.Current i_in "Input current";
          SI.Current i_out "Output current";
          Boolean over_current "True if over current";
          Modelica.Blocks.Interfaces.BooleanInput reset
            annotation (Placement(transformation(extent={{-120,60},{-80,100}})));
        equation
          when {pre(over_current), reset, not reset} then
            if pre(over_current) then
              // ALWAYS open breaker if over_current even if reset is held.
              switch.control = true;
            else
              if reset then
                switch.control = false;
              else
                switch.control = pre(switch.control);
              end if;

            end if;
          end when;
          over_current = currentSensor.i >= i_max;
          i_out = pos_out.i;
          i_in = pos_in.i;

          if not use_heat_port then
            loss_power = switch.LossPower;
          end if;

          connect(currentSensor.p, pos_in) annotation (Line(
              points={{-74,10},{-86,10},{-86,0},{-100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(switch.p, pos_out)               annotation (Line(
              points={{10,0},{100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, switch.n1) annotation (Line(
              points={{-54,10},{-34,10},{-34,5},{-10,5}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(switch.heatPort, heatPort) annotation (Line(
              points={{0,-10},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}),
                    graphics),
            Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                Text(
                  extent={{-100,-10},{-38,-36}},
                  lineColor={0,0,255},
                  textString="pos"),
                Text(
                  extent={{42,-12},{98,-36}},
                  lineColor={0,0,255},
                  textString="neg"),
                Line(
                  points={{0,-22},{0,-86},{0,-88}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Open}),
                Line(
                  points={{-90,0},{-60,0},{-60,40},{-50,60},{-40,20},{-30,60},{-20,20},{
                      -10,60},{0,20},{10,60},{20,20},{30,60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{30,60},{40,20},{50,60},{60,40},{60,0},{90,0},{92,4}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{-72,94},{-10,68}},
                  lineColor={0,0,127},
                  textString="reset")}),
            Documentation(info="<html>
<p>The circuit breaker provides&nbsp;resettable&nbsp;overcurrent&nbsp;protection&nbsp;in&nbsp;an&nbsp;electrical&nbsp;circuit. The reset input must be high before the ciruit can be reset. After it has been reset, the reset input must be low before current flow throught the break can resume (i.e. the circuit breaker can not resume current flow and be reset simultaneously).</p>
</html>"));
        end Circuit_Breaker;

        model Relay "A switch controlled by a low power electrical signal"
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;

          Modelica.Electrical.Analog.Interfaces.PositivePin pos_in
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pos_out
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-62,0})));

          parameter SI.Current i_max = 100 "Maximum current";
          SI.Current i_in "Input current";
          SI.Current i_out "Output current";
          Boolean exceeded(start = false, fixed = true);

          Modelica.Electrical.Analog.Ideal.ControlledIdealCommutingSwitch switch(level=
                v_enable)
            annotation (Placement(transformation(extent={{10,-10},{-10,10}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin control
            annotation (Placement(transformation(extent={{-110,70},{-90,90}})));
          parameter SI.Voltage v_enable=0.5 "Relay enable voltage";
        algorithm
          when currentSensor.i > i_max then
              exceeded := true;
          end when;

        equation
            i_out = pos_out.i;
            i_in = pos_in.i;
            //switch.control = exceeded;

          loss_power = -(i_in*pos_in.v);

          connect(currentSensor.p, pos_in) annotation (Line(
              points={{-72,1.22465e-015},{-86,1.22465e-015},{-86,0},{-100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(switch.p, pos_out) annotation (Line(
              points={{10,0},{100,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(control, switch.control) annotation (Line(
              points={{-100,80},{0,80},{0,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(currentSensor.n, switch.n2) annotation (Line(
              points={{-52,-1.22465e-015},{-31,-1.22465e-015},{-31,0},{-10,0}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                Text(
                  extent={{-100,-10},{-38,-36}},
                  lineColor={0,0,255},
                  textString="pos"),
                Text(
                  extent={{42,-12},{98,-36}},
                  lineColor={0,0,255},
                  textString="neg"),
                Line(
                  points={{0,-22},{0,-86},{0,-88}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Open}),
                Line(
                  points={{-90,0},{-40,0},{20,40},{20,40}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{20,0},{90,0},{90,0}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-42,2},{-38,-2}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,2},{22,-2}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-88,78},{-62,72},{-38,60},{-26,46},{-14,26},{-12,22},{-4,6}},
                  color={0,0,255},
                  smooth=Smooth.Bezier,
                  arrow={Arrow.None,Arrow.Filled},
                  pattern=LinePattern.Dash),
                Text(
                  extent={{-90,80},{-6,54}},
                  lineColor={0,0,255},
                  textString="control")}),
            Documentation(info="<html>
<p>The relay is a switch&nbsp;controlled&nbsp;by&nbsp;a&nbsp;low&nbsp;power&nbsp;electrical&nbsp;signal.The switch level is set as a parameter.</p>
</html>"));
        end Relay;

        package Tests
        extends Icons.Package_For_Simple_Test_Cases;

          model Test_Relay "Tests the basic voltage behavior of the relay"
          extends Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-24,-26},{-4,-6}})));
            Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
                Placement(transformation(
                  extent={{-6,6},{6,-6}},
                  rotation=270,
                  origin={54,26})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
              annotation (Placement(transformation(extent={{-100,-28},{-80,-8}})));
            Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                              battery2_1(
              R_thermal=0.01,
              R_batt=0.065,
              mass_batt=100,
              cp_batt=66,
              soc_init=1,
              useHeatPort=true,
              v_battery(
                e_max=428,
                e_nom=381,
                soc_init=0.6,
                e_exp=342,
                q_max=3600*59.1))            annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-42,-8})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor1
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=180,
                  origin={74,38})));
            Modelica.Blocks.Sources.Step const4(
              offset=1000,
              height=-996,
              startTime=0)
              annotation (Placement(transformation(extent={{14,72},{34,92}})));
            Modelica.Blocks.Sources.Constant const(k=0.0001)
              annotation (Placement(transformation(extent={{46,70},{66,90}})));
            Relay relay(use_heat_port=true)
              annotation (Placement(transformation(extent={{4,28},{24,48}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=5)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-80,42})));
            Modelica.Electrical.Analog.Basic.Ground ground1
              annotation (Placement(transformation(extent={{-90,4},{-70,24}})));
            Modelica.Blocks.Sources.Step const1(
              height=200,
              offset=200,
              startTime=0)
              annotation (Placement(transformation(extent={{-54,-48},{-34,-28}})));
            Modelica.Thermal.HeatTransfer.Components.Convection convection
              annotation (Placement(transformation(extent={{-28,-72},{-8,-52}})));
          equation
            connect(battery2_1.rtn, ground.p) annotation (Line(
                points={{-34,2},{-34,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.p, resistor1.p) annotation (Line(
                points={{54,32},{54,38},{64,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor1.n, ground.p) annotation (Line(
                points={{84,38},{90,38},{90,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.n, ground.p) annotation (Line(
                points={{54,20},{54,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(relay.pos_out, voltageSensor.p) annotation (Line(
                points={{24,38},{54,38},{54,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ground1.p, constantVoltage.n) annotation (Line(
                points={{-80,24},{-80,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(relay.control, constantVoltage.p) annotation (Line(
                points={{4,46},{-6,46},{-6,66},{-80,66},{-80,52}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(relay.pos_in, battery2_1.v_batt) annotation (Line(
                points={{4,38},{-50,38},{-50,2}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(const1.y, convection.Gc) annotation (Line(
                points={{-33,-38},{-18,-38},{-18,-52}},
                color={0,0,127},
                pattern=LinePattern.Dash,
                smooth=Smooth.None,
                arrow={Arrow.None,Arrow.Filled}));
            connect(convection.fluid, relay.heatPort) annotation (Line(
                points={{-8,-62},{14,-62},{14,28}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(fixedTemperature.port, battery2_1.heatPort) annotation (Line(
                points={{-80,-18},{-52,-18}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(convection.solid, fixedTemperature.port) annotation (Line(
                points={{-28,-62},{-66,-62},{-66,-18},{-80,-18}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(const.y, resistor1.R) annotation (Line(
                points={{67,80},{74,80},{74,49}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Relay;

          model Test_Circuit_Breaker
            "Tests the basic voltage behavior of the circuit breaker"
          extends Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-24,-26},{-4,-6}})));
            Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
                Placement(transformation(
                  extent={{-6,6},{6,-6}},
                  rotation=270,
                  origin={54,26})));
            Modelica.Electrical.Analog.Sensors.PowerSensor powerSensor
              annotation (Placement(transformation(extent={{-34,28},{-14,48}})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
              annotation (Placement(transformation(extent={{-100,-28},{-80,-8}})));
            Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                              battery2_1(
              R_thermal=0.01,
              R_batt=0.065,
              mass_batt=100,
              cp_batt=66,
              soc_init=1,
              useHeatPort=true,
              v_battery(
                e_max=428,
                e_nom=381,
                soc_init=0.6,
                e_exp=342,
                q_max=3600*59.1))            annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-42,-8})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor1
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=180,
                  origin={74,38})));
            C2M2L_OM.MSL_Extend.Electrical.Circuit_Devices.Circuit_Breaker
                            curcuit_Breaker(use_heat_port=true)
              annotation (Placement(transformation(extent={{6,28},{26,48}})));
            Modelica.Blocks.Sources.Ramp ramp(
              offset=1000,
              duration=100,
              height=-997)
              annotation (Placement(transformation(extent={{12,78},{32,98}})));
            Modelica.Blocks.Math.Add add
              annotation (Placement(transformation(extent={{60,64},{66,70}})));
            Modelica.Blocks.Sources.Ramp ramp1(
              duration=100,
              offset=0,
              height=100,
              startTime=290)
              annotation (Placement(transformation(extent={{12,54},{32,74}})));
            Modelica.Blocks.Math.Add add1
              annotation (Placement(transformation(extent={{76,66},{82,72}})));
            Modelica.Blocks.Sources.Ramp ramp2(
              duration=100,
              startTime=390,
              offset=0,
              height=-99.9)
              annotation (Placement(transformation(extent={{48,94},{68,114}})));
            Modelica.Blocks.Sources.BooleanStep booleanStep(startTime=300)
              annotation (Placement(transformation(extent={{-86,70},{-66,90}})));
            Modelica.Blocks.Sources.BooleanTable booleanTable(table={300,546,650})
              annotation (Placement(transformation(extent={{-88,32},{-68,52}})));
            Modelica.Blocks.Sources.Trapezoid trapezoid(
              amplitude=-997,
              rising=100,
              width=100,
              falling=100,
              period=400,
              offset=1000,
              nperiod=2)
              annotation (Placement(transformation(extent={{18,-76},{38,-56}})));
          equation
            connect(battery2_1.v_batt, powerSensor.pc) annotation (Line(
                points={{-50,2},{-50,38},{-34,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nv, ground.p) annotation (Line(
                points={{-24,28},{-24,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.rtn, ground.p) annotation (Line(
                points={{-34,2},{-34,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.pv, battery2_1.v_batt) annotation (Line(
                points={{-24,48},{-24,64},{-50,64},{-50,2}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.heatPort, fixedTemperature.port) annotation (Line(
                points={{-52,-18},{-80,-18}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(voltageSensor.p, resistor1.p) annotation (Line(
                points={{54,32},{54,38},{64,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor1.n, ground.p) annotation (Line(
                points={{84,38},{90,38},{90,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.n, ground.p) annotation (Line(
                points={{54,20},{54,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nc, curcuit_Breaker.pos_in) annotation (Line(
                points={{-14,38},{6,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(curcuit_Breaker.heatPort, battery2_1.heatPort) annotation (Line(
                points={{16,28},{16,-34},{-52,-34},{-52,-18}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(curcuit_Breaker.pos_out, resistor1.p) annotation (Line(
                points={{26,38},{64,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ramp.y, add.u1) annotation (Line(
                points={{33,88},{59.4,88},{59.4,68.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp1.y, add.u2) annotation (Line(
                points={{33,64},{46.2,64},{46.2,65.2},{59.4,65.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, add1.u2) annotation (Line(
                points={{66.3,67},{71.15,67},{71.15,67.2},{75.4,67.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp2.y, add1.u1) annotation (Line(
                points={{69,104},{72,104},{72,70.8},{75.4,70.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(booleanTable.y, curcuit_Breaker.reset) annotation (Line(
                points={{-67,42},{0,42},{0,46},{6,46}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(trapezoid.y, resistor1.R) annotation (Line(
                points={{39,-66},{56,-66},{56,49},{74,49}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput);
          end Test_Circuit_Breaker;

          model Test_Fuse "Tests the basic voltage behavior of the fuse"
          extends Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-24,-26},{-4,-6}})));
            Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
                Placement(transformation(
                  extent={{-6,6},{6,-6}},
                  rotation=270,
                  origin={54,26})));
            Modelica.Electrical.Analog.Sensors.PowerSensor powerSensor
              annotation (Placement(transformation(extent={{-34,28},{-14,48}})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
              annotation (Placement(transformation(extent={{-100,-32},{-80,-12}})));
            Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                              battery2_1(
              R_thermal=0.01,
              R_batt=0.065,
              mass_batt=100,
              cp_batt=66,
              soc_init=1,
              useHeatPort=true,
              v_battery(
                e_max=428,
                e_nom=381,
                soc_init=0.6,
                e_exp=342,
                q_max=3600*59.1))            annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-42,-8})));
            Fuse fuse(use_heat_port=true, i_max=10)
              annotation (Placement(transformation(extent={{6,28},{26,48}})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor1
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=180,
                  origin={74,38})));
            Modelica.Blocks.Sources.Step const4(
              offset=1000,
              startTime=250,
              height=-996)
              annotation (Placement(transformation(extent={{-8,56},{12,76}})));
            Modelica.Blocks.Sources.Ramp ramp(
              offset=1000,
              height=-996,
              duration=100)
              annotation (Placement(transformation(extent={{-24,80},{-4,100}})));
          equation
            connect(battery2_1.v_batt, powerSensor.pc) annotation (Line(
                points={{-50,2},{-50,38},{-34,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nv, ground.p) annotation (Line(
                points={{-24,28},{-24,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.rtn, ground.p) annotation (Line(
                points={{-34,2},{-34,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.pv, battery2_1.v_batt) annotation (Line(
                points={{-24,48},{-24,64},{-50,64},{-50,2}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.heatPort, fixedTemperature.port) annotation (Line(
                points={{-52,-18},{-60,-18},{-60,-22},{-80,-22}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(fuse.heatPort, battery2_1.heatPort) annotation (Line(
                points={{16,28},{16,-50},{-52,-50},{-52,-18}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(resistor1.p, fuse.pos_out) annotation (Line(
                points={{64,38},{26,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.p, resistor1.p) annotation (Line(
                points={{54,32},{54,38},{64,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor1.n, ground.p) annotation (Line(
                points={{84,38},{90,38},{90,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(voltageSensor.n, ground.p) annotation (Line(
                points={{54,20},{54,-6},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nc, fuse.pos_in) annotation (Line(
                points={{-14,38},{6,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ramp.y, resistor1.R) annotation (Line(
                points={{-3,90},{74,90},{74,49}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Fuse;
        end Tests;
      end Circuit_Devices;

      package Power_Converters
        "Contains devices that convert dc or ac voltages"
        extends Modelica.Icons.Package;

        model DC_DC_Converter
          "Converts a DC voltage source from one level to another"
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;
          Modelica.Electrical.Analog.Interfaces.PositivePin pos_in
            annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin neg_in
            annotation (Placement(transformation(extent={{-110,-70},{-90,-50}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin neg_out
            annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pos_out
            annotation (Placement(transformation(extent={{90,50},{110,70}})));
          SI.Voltage v_in;
          SI.Voltage v_out;
          SI.Current i_in;
          SI.Current i_out;
          parameter Real gain = 0.5 "Converter gain";
          parameter Real eff = 1 "Converter efficiency";

        equation
          v_in = pos_in.v - neg_in.v;
          v_out = pos_out.v - neg_out.v;

          i_in = pos_in.i;
          i_out = pos_out.i;

          v_out = v_in * gain;

          if i_in < 0 then
            eff * i_out = -i_in / gain;
          else
            (2-eff) * i_out = -i_in / gain;
          end if;

          loss_power = -(i_in*v_in + i_out*v_out);

          connect(neg_in, neg_out) annotation (Line(
              points={{-100,-60},{100,-60}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(graphics), Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                Text(
                  extent={{-98,12},{-36,-14}},
                  lineColor={0,0,255},
                  textString="High"),
                Text(
                  extent={{44,12},{100,-12}},
                  lineColor={0,0,255},
                  textString="Low"),
                Line(
                  points={{-100,60},{-40,60},{-40,-60},{-96,-60},{-96,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{100,60},{96,60},{40,60},{40,-60},{98,-60},{98,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{0,-22},{0,-86},{0,-88}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Open}),
                Line(
                  points={{-104,-102},{104,104}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-106,104},{104,-104}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5)}),
            Documentation(info="<html>
<p>DC DC Converter is an&nbsp;<a href=\"http://en.wikipedia.org/wiki/Electronic_circuit\">electronic circuit</a>&nbsp;which converts a DC source from one&nbsp;<a href=\"http://en.wikipedia.org/wiki/Voltage\">voltage</a>&nbsp;level to another. It contains an efficiency parameter and power loss as heat.</p>
</html>"));
        end DC_DC_Converter;

        model Inverter
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.ConditionalHeatPort;
          extends Modelica.Electrical.Analog.Interfaces.TwoPort;
          parameter Real eff=0.9 "Inverter efficiency";

          Real n(start=v_cutoff/v_targ);
          //Real cut_factor;
          parameter SI.Voltage v_targ=200 "Target voltage on the output side";
          parameter SI.Voltage v_cutoff=100
            "Minimum allowed voltage on the input side";

          SI.Power pow1;
          SI.Power pow2;
        equation
          n = max(v_cutoff/v_targ, (v1/v_targ));

          eff*i1 = -i2/n;

          v2 = v1/n;

          loss_power = abs((v1*i1) + (v2*i2));
          pow1 = v1*i1;
          pow2 = v2*i2;

          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}),
                    graphics),
            Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                Text(
                  extent={{-98,12},{-36,-14}},
                  lineColor={0,0,255},
                  textString="DC"),
                Text(
                  extent={{44,12},{100,-12}},
                  lineColor={0,0,255},
                  textString="AC"),
                Line(
                  points={{-100,60},{-40,60},{-40,-60},{-96,-60},{-96,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{100,60},{96,60},{40,60},{40,-60},{98,-60},{98,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{0,-22},{0,-86},{0,-88}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Open}),
                Text(
                  extent={{-54,94},{52,70}},
                  lineColor={0,0,255},
                  textString="Inverter")}),
            Documentation(info="<html>
<p>The inverter is an&nbsp;electrical power converter&nbsp;which changes DC current to psuedo AC root mean square (RMS) current. It contains an efficiency parameter and power loss as heat.</p>
</html>"));
        end Inverter;

        package Tests
        extends C2M2L_OM.MSL_Extend.Icons.Package_For_Simple_Test_Cases;

          model Test_DC_DC_Converter_basic
            "Tests the basic voltagen behavior of the DC DC Converter "
          extends Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-24,-26},{-4,-6}})));
            Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation (
                Placement(transformation(
                  extent={{-6,6},{6,-6}},
                  rotation=270,
                  origin={54,10})));
            Modelica.Electrical.Analog.Basic.Resistor resistor(R=1)
              annotation (Placement(transformation(extent={{64,12},{84,32}})));
            Modelica.Electrical.Analog.Sensors.PowerSensor powerSensor
              annotation (Placement(transformation(extent={{-34,28},{-14,48}})));
            DC_DC_Converter dC_DC_Converter(
              use_heat_port=true,
              gain=0.5,
              eff=0.95)
              annotation (Placement(transformation(extent={{4,6},{24,26}})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
              annotation (Placement(transformation(extent={{-100,-32},{-80,-12}})));
            Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                              battery2_1(
              R_thermal=0.01,
              R_batt=0.065,
              mass_batt=100,
              cp_batt=66,
              soc_init=1,
              v_battery(
                e_max=428,
                q_max=3600*59.1,
                e_nom=381,
                soc_init=0.6,
                e_exp=342),
              useHeatPort=false)             annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-42,-8})));
          equation
            connect(resistor.p, voltageSensor.p) annotation (Line(
                points={{64,22},{54,22},{54,16}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor.n, voltageSensor.n) annotation (Line(
                points={{84,22},{88,22},{88,-2},{54,-2},{54,4}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(dC_DC_Converter.neg_out, voltageSensor.n) annotation (Line(
                points={{24,10},{30,10},{30,-2},{54,-2},{54,4}},
                color={0,0,255},
                pattern=LinePattern.None,
                smooth=Smooth.None));
            connect(dC_DC_Converter.neg_in, ground.p) annotation (Line(
                points={{4,10},{-14,10},{-14,-6}},
                color={0,0,255},
                pattern=LinePattern.None,
                smooth=Smooth.None));
            connect(powerSensor.nc, dC_DC_Converter.pos_in) annotation (Line(
                points={{-14,38},{-4,38},{-4,22},{4,22}},
                color={0,0,255},
                pattern=LinePattern.None,
                smooth=Smooth.None));
            connect(dC_DC_Converter.heatPort, fixedTemperature.port) annotation (Line(
                points={{14,6},{14,-30},{-60,-30},{-60,-22},{-80,-22}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(dC_DC_Converter.pos_out, resistor.p) annotation (Line(
                points={{24,22},{64,22}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.v_batt, powerSensor.pc) annotation (Line(
                points={{-50,2},{-50,38},{-34,38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.nv, ground.p) annotation (Line(
                points={{-24,28},{-24,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(battery2_1.rtn, ground.p) annotation (Line(
                points={{-34,2},{-34,10},{-14,10},{-14,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(powerSensor.pv, battery2_1.v_batt) annotation (Line(
                points={{-24,48},{-24,64},{-50,64},{-50,2}},
                color={0,0,255},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_DC_DC_Converter_basic;

          model Test_Inverter_basic
            "Tests the basic voltage behavior of the Inverter"
          extends Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-50,-26},{-30,-6}})));
            Modelica.Electrical.Analog.Basic.Resistor resistor(R=0.5, useHeatPort=true)
              annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                  rotation=270,
                  origin={60,30})));
            Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=293.15)
              annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
            Inverter  inverter2_1(use_heat_port=true)
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=150)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-40,30})));
          equation
            connect(inverter2_1.p2, resistor.p) annotation (Line(
                points={{20,35},{40,35},{40,40},{60,40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inverter2_1.n2, resistor.n) annotation (Line(
                points={{20,25},{30,25},{30,24},{40,24},{40,20},{60,20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inverter2_1.heatPort, fixedTemperature.port) annotation (Line(
                points={{10,20},{10,-50},{-80,-50}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(resistor.heatPort, fixedTemperature.port) annotation (Line(
                points={{70,30},{80,30},{80,-50},{-80,-50}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(ground.p, inverter2_1.n2) annotation (Line(
                points={{-40,-6},{-40,8},{24,8},{24,25},{20,25}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(constantVoltage.n, ground.p) annotation (Line(
                points={{-40,20},{-40,-6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(constantVoltage.p, inverter2_1.p1) annotation (Line(
                points={{-40,40},{-20,40},{-20,35},{0,35}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inverter2_1.n1, constantVoltage.n) annotation (Line(
                points={{0,25},{-20,25},{-20,20},{-40,20}},
                color={0,0,255},
                smooth=Smooth.None));
            annotation (Diagram(graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Inverter_basic;
        end Tests;
      end Power_Converters;
    end Electrical;

    package Mechanics "Holds extensions to the MSL package of the same name"
        extends Modelica.Icons.Package;

      package Rotational
        "Provides extensions to the MSL package of the same name"
          extends Modelica.Icons.Package;
      import SI = Modelica.SIunits;

        package Components
          "Provides extensions to the MSL package of the same name"
            extends Modelica.Icons.Package;

          package Clutches "Various clutch related components"
          extends Modelica.Icons.Package;

            model Free_Wheel_Clutch_Based
              "Convenience wrapper around MSL OneWayClutch that acts as pure 1 way free wheel"
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;
              Modelica.Mechanics.Rotational.Components.OneWayClutch oneWayClutch(fn_max=1)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
              Modelica.Blocks.Sources.Constant const(k=0)
                annotation (Placement(transformation(extent={{-64,30},{-44,50}})));
            equation
              connect(flange_a, oneWayClutch.flange_a) annotation (Line(
                  points={{-100,0},{-10,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(oneWayClutch.flange_b, flange_b) annotation (Line(
                  points={{10,0},{100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(oneWayClutch.f_normalized, const.y) annotation (Line(
                  points={{0,11},{0,40},{-43,40}},
                  color={0,0,127},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                      extent={{-100,-100},{100,100}}),
                                  graphics), Icon(graphics={
                    Rectangle(
                      extent={{-80,100},{-10,-100}},
                      lineColor={175,175,175},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={175,175,175}),
                    Rectangle(
                      extent={{10,100},{80,-100}},
                      lineColor={175,175,175},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={175,175,175}),
                    Polygon(
                      points={{-66,62},{74,0},{-66,-60},{-66,62}},
                      smooth=Smooth.None,
                      fillColor={255,85,85},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{-80,30},{42,-30}},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={255,85,85},
                      textString="+ve",
                      lineColor={0,0,0})}));
            end Free_Wheel_Clutch_Based;

            model Clutch_Simple_Friction
              "Same interface as MSL Clutch but does not use discrete states."
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              import Modelica.Fluid.Utilities.regStep;
              import interp = Modelica.Math.tempInterpol1;
              parameter SI.AngularVelocity w_small(min=0) = 1e-3
                "Rotational speed near w_rel=0 where locking should be approximated"
                annotation (Dialog(tab="Advanced"));
              parameter SI.CoefficientOfFriction mue_pos[:, 2]=[0, 0.5]
                "[w,mue] positive sliding friction coefficient (w_rel>=0)";
              parameter SI.Force fn_max(final min=0, start=1)
                "Maximum normal force";

              parameter Real peak(final min=1) = 1
                "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
              parameter Real cgeo(final min=0) = 1
                "Geometry constant containing friction distribution assumption";
              SI.CoefficientOfFriction mu "coefficient of friction";

              Modelica.Blocks.Interfaces.RealInput f_normalized
                "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)"
                                                     annotation (Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,120}), iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,110})));
              SI.Force fn "Normal force (fn=fn_max*f_normalized)";
            protected
              SI.Torque tau_a;
              SI.Torque tau_b;
            equation
              // Look up mu from table based on relative rotational velocity
              mu = interp(abs(w_rel), mue_pos, 2);

              // Calculate actual normal force from signal and fn_max parameter
              fn = max(f_normalized, 0.0) * fn_max;

              // tau_a is the torque that should be applied when sliding
              tau_a = mu * fn  * cgeo;

              // Use a regularized step function to smooth torque thru zero within -w_small < w_rel < w_small
              tau_b = regStep(w_rel, tau_a, -tau_a, w_small);

              // Use another step to increase torque to account for static friction when locked
              // Step will give maximum static torque at w_rel = w_small, not until w_rel > (2*w_small)
              // will the torque have all static influence removed.
              tau = regStep(abs(w_rel) - (1.5 * w_small), tau_b, tau_b * peak, w_small / 2);

              // Loss power is the same as the MSL clutch
              lossPower = tau*w_rel;
              annotation (Diagram(graphics), Icon(graphics={
                    Rectangle(extent={{-100,10},{-30,-10}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{30,10},{100,-10}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{0,90},{-90,70},{-90,40},{-30,40}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,90},{90,70},{90,40},{30,40}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Polygon(
                      points={{-30,40},{-50,50},{-50,30},{-30,40}},
                      lineColor={0,0,0},
                      smooth=Smooth.None,
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{30,40},{50,50},{50,30},{30,40}},
                      lineColor={0,0,0},
                      smooth=Smooth.None,
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),Line(visible=useHeatPort,
                      points={{-100,-100},{-100,-40},{0,-40}},
                      color={191,0,0},
                      pattern=LinePattern.Dot,
                      smooth=Smooth.None),
                    Text(
                      extent={{-150,-100},{150,-60}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(extent={{-30,60},{-10,-60}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{10,60},{30,-60}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid)}));
            end Clutch_Simple_Friction;
          end Clutches;

          package Gear_Ratios "Various components that simulate gears"
          extends Modelica.Icons.Package;

            model Ideal_Gear_Variable_Ratio
              "Same as MSL IdealGear but with a signal port to determine the ratio.  Ratio will be always be +ve above min_ratio"
              extends Modelica.Mechanics.Rotational.Icons.Gear;
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;
              parameter Real min_ratio(min=0.0) = 0.001
                "Minimum allowed ratio magnitude (flange_a.phi/flange_b.phi)";
              Modelica.Blocks.Interfaces.RealInput ratio "Gear ratio input" annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,120})));
              Real internal_ratio(start=1,fixed=true);
            equation

             internal_ratio = max(min_ratio, abs(ratio));

              der(flange_a.phi) = internal_ratio*der(flange_b.phi);
              0 = internal_ratio*flange_a.tau + flange_b.tau;

              annotation (
                Documentation(info="<html>
<p>
This element characterices any type of gear box which is fixed in the
ground and which has one driving shaft and one driven shaft.
The gear is <b>ideal</b>, i.e., it does not have inertia, elasticity, damping
or backlash. If these effects have to be considered, the gear has to be
connected to other elements in an appropriate way.
</p>

</HTML>
"),             Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Text(
                      extent={{-153,145},{147,105}},
                      lineColor={0,0,255},
                      textString="%name")}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics));
            end Ideal_Gear_Variable_Ratio;

            model Lossy_Gear_Efficiency_Multiplier
              "Same as MSL LossyGear but includes and signal input that can vary the efficiency"

              extends Modelica.Mechanics.Rotational.Icons.Gear;
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
                "Array for mesh efficiencies and bearing friction depending on speed";
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              Modelica.SIunits.Angle phi_a
                "Angle between left shaft flange and support";
              Modelica.SIunits.Angle phi_b
                "Angle between right shaft flange and support";

              Real sa(final unit="1")
                "Path parameter for acceleration and torque loss";
              SI.AngularVelocity w_a
                "Angular velocity of flange_a with respect to support";
              SI.AngularAcceleration a_a
                "Angular acceleration of flange_a with respect to support";

              Real interpolation_result[1, size(lossTable, 2) - 1];
              Real eta_mf1;
              Real eta_mf2;
              Real tau_bf_a "Bearing friction torque on flange_a side";
              Real tau_eta
                "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau)";

              Real tau_bf1;
              Real tau_bf2;

              Real quadrant1;
              Real quadrant2;
              Real quadrant3;
              Real quadrant4;

              // quadrant values for angular verlocities near zero
              Real quadrant1_p; // w=0+
              Real quadrant2_p; // w=0+
              Real quadrant3_m; // w=0-
              Real quadrant4_m; // w=0-

              SI.Torque tauLoss
                "Torque loss due to friction in the gear teeth and in the bearings";
              SI.Torque tauLossMax "Torque loss for positive speed";
              SI.Torque tauLossMin "Torque loss for negative speed";

              SI.Torque tauLossMax_p "Torque loss for positive speed";
              SI.Torque tauLossMin_m "Torque loss for negative speed";

              Boolean tau_aPos(start=true)
                "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative)";
              Boolean tau_etaPos(start=true)
                "true, if torque tau_eta is not negative";
              Boolean startForward(start=false)
                "true, if starting to roll forward";
              Boolean startBackward(start=false)
                "true, if starting to roll backward";
              Boolean locked(start=false) "true, if gear is locked";

              Boolean ideal "true, if losses are neglected";

              constant Integer Unknown=3 "Value of mode is not known";
              constant Integer Free=2 "Element is not active";
              constant Integer Forward=1 "w_a > 0 (forward rolling)";
              constant Integer Stuck=0
                "w_a = 0 (forward rolling, locked or backward rolling)";
              constant Integer Backward=-1 "w_a < 0 (backward rolling)";
              Integer mode(
                final min=Backward,
                final max=Unknown,
                start=Free,
                fixed=true);

              SI.Torque tau_eta_p "tau_eta assuming positive omega";
              SI.Torque tau_eta_m "tau_eta assuming negative omega";
            protected
              constant SI.AngularAcceleration unitAngularAcceleration = 1;
              constant SI.Torque unitTorque = 1;

              // get friction and eta information for omega=0
              parameter Real interpolation_result_0[1, size(lossTable, 2) - 1] =  Modelica.Math.tempInterpol2(0, lossTable, {2,3,4,5});
              parameter Real eta_mf1_0 = interpolation_result_0[1, 1];
              parameter Real eta_mf2_0 = interpolation_result_0[1, 2];
              parameter Real tau_bf1_0 = abs(interpolation_result_0[1, 3]);
              parameter Real tau_bf2_0 = abs(interpolation_result_0[1, 4]);
              parameter Real tau_bf_a_0= if Modelica.Math.isEqual(eta_mf1_0, 1.0, Modelica.Constants.eps) and
                                            Modelica.Math.isEqual(eta_mf2_0, 1.0, Modelica.Constants.eps) then
                                            tau_bf1_0/2 else
                                            (tau_bf1_0-tau_bf2_0)/(eta_mf1_0-1.0/eta_mf2_0);
                                         // For eta_mf1_0=eta_mf2_0=1 the given bearing
                                         // friction can not be separated into a part
                                         // on side A or B, so it is done arbitrarily.
                                         // Calculate tau_bf_a_0 from the following equations
                                         //  tau_bf1_0=eta_mf1_0*tau_bf_a_0 + 1/ratio a_0
                                         //  tau_bf2_0=1/eta_mf2*tau_bf_a_0 + 1/ratio tau_bf_a_0
            public
              Modelica.Blocks.Interfaces.RealInput eff_mult
                "0-1 value to multiply efficiency by"
                annotation (Placement(transformation(extent={{-139,60},{-99,100}})));
            equation
              assert(abs(ratio) > 0,
                "Error in initialization of LossyGear: ratio may not be zero");
              assert(eff_mult >=0 and eff_mult <=1,
                "Error in Loss_Gear_Efficiency_Multiplier - efficiency supplied was outside [0-1]");
              ideal = false;

              interpolation_result = if ideal then [1, 1, 0, 0] else
                Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
              eta_mf1 = interpolation_result[1, 1] * eff_mult;
              eta_mf2 = interpolation_result[1, 2] * eff_mult;
              tau_bf1 = noEvent(abs(interpolation_result[1, 3]));
              tau_bf2 = noEvent(abs(interpolation_result[1, 4]));

              if Modelica.Math.isEqual(eta_mf1, 1.0, Modelica.Constants.eps) and
                 Modelica.Math.isEqual(eta_mf2, 1.0, Modelica.Constants.eps) then
                 // For eta_mf1=eta_mf2=1 the given bearing friction can not be
                 // separated into a part on side A or B, so it is done arbitrarily.
                 tau_bf_a = tau_bf1/2;
              else
                //calculate tau_bf_a from the following equations
                //tau_bf1 = eta_mf1*tau_bf_a + tau_bf_b / ratio
                //tau_bf2 = 1/eta_mf2*tau_bf_a + tau_bf_b / ratio
                tau_bf_a=(tau_bf1-tau_bf2)/(eta_mf1-1.0/eta_mf2);
              end if;

              phi_a = flange_a.phi - phi_support;
              phi_b = flange_b.phi - phi_support;
              phi_a = ratio*phi_b;

              // Torque balance (no inertias)
              0 = flange_b.tau + ratio*(flange_a.tau - tauLoss);

              // Speed for friction element
              w_a = der(phi_a);
              a_a = der(w_a);

              // Determine driving side
                 //assuming positive omega
                 tau_eta_p=flange_a.tau-tau_bf_a_0;
                 //assuming negative omega
                 tau_eta_m=flange_a.tau+tau_bf_a_0;

              // assuming w>=0, take value at w=0 to decide rolling/stuck mode
              quadrant1_p = (1 - eta_mf1_0)*flange_a.tau + tau_bf1_0;
              quadrant2_p = (1 - 1/eta_mf2_0)*flange_a.tau + tau_bf2_0;
              tauLossMax_p = if noEvent(tau_eta_p>0) then quadrant1_p else quadrant2_p;

              // assuming w<=0, take value at w=0 to decide rolling/stuck mode
              quadrant4_m = (1 - 1/eta_mf2_0)*flange_a.tau - tau_bf2_0;
              quadrant3_m = (1 - eta_mf1_0)*flange_a.tau - tau_bf1_0;
              tauLossMin_m = if noEvent(tau_eta_m>0) then quadrant4_m else quadrant3_m;

              quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
              quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
              quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
              quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

              //tau eta: only for determination of driving side for calculation of tauloss
              tau_eta = if ideal then flange_a.tau else
                             (if locked then flange_a.tau else
                             (if (startForward or pre(mode) == Forward) then flange_a.tau-tau_bf_a else
                             flange_a.tau+tau_bf_a));

              // Torque Losses
              tau_etaPos = tau_eta >= 0;
              tau_aPos   = tau_etaPos;
              tauLossMax = if tau_etaPos then quadrant1 else quadrant2;
              tauLossMin = if tau_etaPos then quadrant4 else quadrant3;

              // Determine rolling/stuck mode when w_rel = 0
              startForward = pre(mode) == Stuck and sa > tauLossMax_p/unitTorque or initial() and w_a > 0;
              startBackward = pre(mode) == Stuck and sa < tauLossMin_m/unitTorque or initial() and w_a < 0;
              locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);

              /* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */
              tauLoss = if ideal then 0 else (if locked then sa*unitTorque else (if (startForward or
                    pre(mode) == Forward) then tauLossMax else tauLossMin));

              a_a = unitAngularAcceleration*(if locked then 0 else sa - tauLoss/unitTorque);

              /* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */
              mode = if ideal then Free else (if (pre(mode) == Forward or startForward)
                 and w_a > 0 then Forward else if (pre(mode) == Backward or startBackward)
                 and w_a < 0 then Backward else Stuck);

              lossPower = tauLoss*w_a;
              annotation (Documentation(info="<HTML>
<p>
This component models the gear ratio and the <b>losses</b> of
a standard gear box in a <b>reliable</b> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handeled are fixed in the ground or on a moving support, have one input and one
output shaft, and are essentially described by the equations:
</p>
<blockquote><pre>
             flange_a.phi  = i*flange_b.phi;
-(flange_b.tau - tau_bf_b) = i*eta_mf*(flange_a.tau - tau_bf_a);

// or        -flange_b.tau = i*eta_mf*(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));
</pre></blockquote>
<p>
where
</p>

<ul>
<li> <b>i</b> is the constant <b>gear ratio</b>, </li>

<li> <b>eta_mf</b> = eta_mf(w_a) is the <b>mesh efficiency</b> due to the
     friction between the teeth of the gear wheels, </li>

<li> <b>tau_bf_a</b> = tau_bf_a(w_a) is the <b>bearing friction torque</b>
     on the flange_a side,</li>

<li> <b>tau_bf_b</b> = tau_bf_b(w_a) is the <b>bearing friction torque</b>
     on the flange_b side, and</li>

<li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
</ul>

<p>
The loss terms \"eta_mf\", \"tau_bf_a\" and \"tau_bf_b\" are functions of the
<i>absolute value</i> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <b>lossTable[:,5]
</b> where the columns of this table have the following
meaning:
</p>

<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\">|tau_bf2|</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
  </tbody>
</table>

<p>with</p>
<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">Mesh efficiency in case that flange_a is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">Mesh efficiency in case that flange_b is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_a is driving<br>
                        (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)
                        </td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf2|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_b is driving<br>
                        (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)
                        </td>
    </tr>
  </tbody>
</table>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>

<blockquote><pre>
<b>if</b> (flange_a.tau - tau_bf_a)*w_a &gt; 0 <b>or</b>
   (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &gt; 0 <b>then</b>
   eta_mf := eta_mf1
   tau_bf := tau_bf1
<b>elseif</b> (flange_a.tau - tau_bf_a)*w_a &lt; 0 <b>or</b>
       (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &lt; 0 <b>then</b>
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
<b>else</b> // w_a == 0
   eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
<b>end if</b>;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);
</pre></blockquote>

<p>
Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>

<h4>Acknowledgement:</h4>
<ul>
<li> The essential idea to model efficiency
     in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li> The article (Pelchen et.al. 2002), see Literature below,
     and the first implementation of LossyGear (up to version 3.1 of package Modelica)
     contained a bug leading to a non-converging solution in cases where the
     driving side is not obvious.
     This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch,
     and Christian Bertsch proposed a concrete solution how to fix this
     bug, see Literature below.</li>
</ul>

<h4>Literature</h4>

<ul>
<li>Pelchen C.,
<a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
&quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
<I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</li>

<li>Bertsch C. (2009):
&quot;<a href=\"modelica://Modelica/Resources/Documentation/Mechanics/Lossy-Gear-Bug_Solution.pdf\">Problem
with model LossyGear and a proposed solution</a>&quot;,
Ticket <a href=\"http://trac.modelica.org/Modelica/ticket/108\">#108</a>,
Sept. 11, 2009.</li>
</ul>

</HTML>
"),             Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{
                          -60,80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-80,20},{-60,20}}, color={0,0,0}),
                    Text(
                      extent={{-148,145},{152,105}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-145,-49},{155,-79}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Line(visible=useHeatPort,
                      points={{-100,-100},{-100,-30},{0,-30},{0,0}},
                      color={191,0,0},
                      pattern=LinePattern.Dot,
                      smooth=Smooth.None)}),
                Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                        100}},
                    grid={1,1}), graphics));
            end Lossy_Gear_Efficiency_Multiplier;

            model Lossy_Gear_With_Environment_simple
              "Same as lossy gear in MSL but with capability to exchange heat to the environment"
              extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(                      thermal_To_Environment(area_for_heat_transfer=area_for_heat_transfer));
              extends C2M2L_OM.MSL_Extend.Mechanics.Rotational.Icons.Gear;
            extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
                "Array for mesh efficiencies and bearing friction depending on speed";
                parameter SI.Area area_for_heat_transfer = 0.1
                "Area available for heat transfer to the environment";
              extends
                C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

              LossyGear_simple                                   lossyGear(
                  useSupport=useSupport,
                  useHeatPort=useHeatPort or use_environment_heat_port,
                  lossTable=lossTable,
                ratio=ratio)
                annotation (Placement(transformation(extent={{-12,-10},{10,10}})));
            equation
              if not useHeatPort then
                lossPower = lossyGear.lossPower;
              end if;
              connect(flange_a, lossyGear.flange_a) annotation (Line(
                  points={{-100,0},{-12,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.flange_b, flange_b) annotation (Line(
                  points={{10,0},{100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(heatPort, lossyGear.heatPort) annotation (Line(
                  points={{-100,-100},{-100,-55},{-12,-55},{-12,-10}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.heatPort, thermal_To_Environment.solid) annotation (Line(
                  points={{-12,-10},{-12,-90},{40,-90}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.support, internalSupport) annotation (Line(
                  points={{-1,-10},{0,-10},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(graphics), Icon(graphics={Text(
                      extent={{-88,-40},{90,-74}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{-60,
                          80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                     Polygon(
                       points={{-22,174},{-36,184},{-54,182},{-62,176},{-64,174},{-72,176},
                          {-74,176},{-82,176},{-88,172},{-96,176},{-106,178},{-120,174},{
                          -128,164},{-128,156},{-124,148},{-118,142},{-116,142},{-112,138},
                          {-112,134},{-116,126},{-114,112},{-104,102},{-92,100},{-80,102},{
                          -74,108},{-70,112},{-62,108},{-50,108},{-38,112},{-28,118},{-26,
                          132},{-28,142},{-30,144},{-32,146},{-22,152},{-18,162},{-20,172},
                          {-22,174}},
                       lineColor={0,0,0},
                       smooth=Smooth.Bezier,
                       lineThickness=0.5),
                     Line(
                       points={{-28,138},{-30,140},{-38,148},{-40,150},{-52,152},{-64,148},
                          {-74,142},{-78,130},{-76,120},{-70,114},{-68,112}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-76,138},{-86,144},{-94,144},{-104,142},{-108,138},{-112,
                          134}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-90,144},{-86,150},{-84,158},{-84,164},{-88,170},{-92,174}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-60,150},{-66,156},{-68,166},{-66,172},{-64,174}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                    Text(
                      extent={{-126,180},{-16,114}},
                      lineColor={0,0,0},
                      textString="env")}));
            end Lossy_Gear_With_Environment_simple;

            model Lossy_Gear_With_Variable_Efficiency
              "Same as MSL lossy gear but with a signal port so the efficiency can be calculated externally instead of using a table"

              extends Modelica.Mechanics.Rotational.Icons.Gear;
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:,5]=[0,1,1,0,0]
                "Array for mesh efficiencies and bearing friction depending on speed"
                annotation (Dialog(enable=false));
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              Modelica.SIunits.Angle phi_a
                "Angle between left shaft flange and support";
              Modelica.SIunits.Angle phi_b
                "Angle between right shaft flange and support";

              Real sa(final unit="1")
                "Path parameter for acceleration and torque loss";
              SI.AngularVelocity w_a
                "Angular velocity of flange_a with respect to support";
              SI.AngularAcceleration a_a
                "Angular acceleration of flange_a with respect to support";

              Real interpolation_result[1, size(lossTable, 2) - 1];
              Real eta_mf1;
              Real eta_mf2;
              Real tau_bf_a "Bearing friction torque on flange_a side";
              Real tau_eta
                "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau)";

              Real tau_bf1;
              Real tau_bf2;

              Real quadrant1;
              Real quadrant2;
              Real quadrant3;
              Real quadrant4;

              // quadrant values for angular verlocities near zero
              Real quadrant1_p; // w=0+
              Real quadrant2_p; // w=0+
              Real quadrant3_m; // w=0-
              Real quadrant4_m; // w=0-

              SI.Torque tauLoss
                "Torque loss due to friction in the gear teeth and in the bearings";
              SI.Torque tauLossMax "Torque loss for positive speed";
              SI.Torque tauLossMin "Torque loss for negative speed";

              SI.Torque tauLossMax_p "Torque loss for positive speed";
              SI.Torque tauLossMin_m "Torque loss for negative speed";

              Boolean tau_aPos(start=true)
                "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative)";
              Boolean tau_etaPos(start=true)
                "true, if torque tau_eta is not negative";
              Boolean startForward(start=false)
                "true, if starting to roll forward";
              Boolean startBackward(start=false)
                "true, if starting to roll backward";
              Boolean locked(start=false) "true, if gear is locked";

              Boolean ideal "true, if losses are neglected";

              constant Integer Unknown=3 "Value of mode is not known";
              constant Integer Free=2 "Element is not active";
              constant Integer Forward=1 "w_a > 0 (forward rolling)";
              constant Integer Stuck=0
                "w_a = 0 (forward rolling, locked or backward rolling)";
              constant Integer Backward=-1 "w_a < 0 (backward rolling)";
              Integer mode(
                final min=Backward,
                final max=Unknown,
                start=Free,
                fixed=true);

              SI.Torque tau_eta_p "tau_eta assuming positive omega";
              SI.Torque tau_eta_m "tau_eta assuming negative omega";
            protected
              constant SI.AngularAcceleration unitAngularAcceleration = 1;
              constant SI.Torque unitTorque = 1;

              // get friction and eta information for omega=0
              parameter Real interpolation_result_0[1, size(lossTable, 2) - 1] =  Modelica.Math.tempInterpol2(0, lossTable, {2,3,4,5});
              parameter Real eta_mf1_0 = interpolation_result_0[1, 1];
              parameter Real eta_mf2_0 = interpolation_result_0[1, 2];
              parameter Real tau_bf1_0 = abs(interpolation_result_0[1, 3]);
              parameter Real tau_bf2_0 = abs(interpolation_result_0[1, 4]);
              parameter Real tau_bf_a_0= if Modelica.Math.isEqual(eta_mf1_0, 1.0, Modelica.Constants.eps) and
                                            Modelica.Math.isEqual(eta_mf2_0, 1.0, Modelica.Constants.eps) then
                                            tau_bf1_0/2 else
                                            (tau_bf1_0-tau_bf2_0)/(eta_mf1_0-1.0/eta_mf2_0);
                                         // For eta_mf1_0=eta_mf2_0=1 the given bearing
                                         // friction can not be separated into a part
                                         // on side A or B, so it is done arbitrarily.
                                         // Calculate tau_bf_a_0 from the following equations
                                         //  tau_bf1_0=eta_mf1_0*tau_bf_a_0 + 1/ratio a_0
                                         //  tau_bf2_0=1/eta_mf2*tau_bf_a_0 + 1/ratio tau_bf_a_0
            public
              Modelica.Blocks.Interfaces.RealInput efficiency "between 0 and 1"
                                                                                annotation (Placement(
                    transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,120})));
            equation
              assert(abs(ratio) > 0,
                "Error in initialization of LossyGear: ratio may not be zero");

              ideal = false;

              interpolation_result = if ideal then [1, 1, 0, 0] else
                Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
              // eta_mf1 = interpolation_result[1, 1];
              // eta_mf2 = interpolation_result[1, 2];
              // tau_bf1 = noEvent(abs(interpolation_result[1, 3]));
              // tau_bf2 = noEvent(abs(interpolation_result[1, 4]));
              eta_mf1 = efficiency;
              eta_mf2 = efficiency;
              tau_bf1 = 0.0;
              tau_bf2 = 0.0;

              if Modelica.Math.isEqual(eta_mf1, 1.0, Modelica.Constants.eps) and
                 Modelica.Math.isEqual(eta_mf2, 1.0, Modelica.Constants.eps) then
                 // For eta_mf1=eta_mf2=1 the given bearing friction can not be
                 // separated into a part on side A or B, so it is done arbitrarily.
                 tau_bf_a = tau_bf1/2;
              else
                //calculate tau_bf_a from the following equations
                //tau_bf1 = eta_mf1*tau_bf_a + tau_bf_b / ratio
                //tau_bf2 = 1/eta_mf2*tau_bf_a + tau_bf_b / ratio
                tau_bf_a=(tau_bf1-tau_bf2)/(eta_mf1-1.0/eta_mf2);
              end if;

              phi_a = flange_a.phi - phi_support;
              phi_b = flange_b.phi - phi_support;
              phi_a = ratio*phi_b;

              // Torque balance (no inertias)
              0 = flange_b.tau + ratio*(flange_a.tau - tauLoss);

              // Speed for friction element
              w_a = der(phi_a);
              a_a = der(w_a);

              // Determine driving side
                 //assuming positive omega
                 tau_eta_p=flange_a.tau-tau_bf_a_0;
                 //assuming negative omega
                 tau_eta_m=flange_a.tau+tau_bf_a_0;

              // assuming w>=0, take value at w=0 to decide rolling/stuck mode
              quadrant1_p = (1 - eta_mf1_0)*flange_a.tau + tau_bf1_0;
              quadrant2_p = (1 - 1/eta_mf2_0)*flange_a.tau + tau_bf2_0;
              tauLossMax_p = if noEvent(tau_eta_p>0) then quadrant1_p else quadrant2_p;

              // assuming w<=0, take value at w=0 to decide rolling/stuck mode
              quadrant4_m = (1 - 1/eta_mf2_0)*flange_a.tau - tau_bf2_0;
              quadrant3_m = (1 - eta_mf1_0)*flange_a.tau - tau_bf1_0;
              tauLossMin_m = if noEvent(tau_eta_m>0) then quadrant4_m else quadrant3_m;

              quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
              quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
              quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
              quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

              //tau eta: only for determination of driving side for calculation of tauloss
              tau_eta = if ideal then flange_a.tau else
                             (if locked then flange_a.tau else
                             (if (startForward or pre(mode) == Forward) then flange_a.tau-tau_bf_a else
                             flange_a.tau+tau_bf_a));

              // Torque Losses
              tau_etaPos = tau_eta >= 0;
              tau_aPos   = tau_etaPos;
              tauLossMax = if tau_etaPos then quadrant1 else quadrant2;
              tauLossMin = if tau_etaPos then quadrant4 else quadrant3;

              // Determine rolling/stuck mode when w_rel = 0
              startForward = pre(mode) == Stuck and sa > tauLossMax_p/unitTorque or initial() and w_a > 0;
              startBackward = pre(mode) == Stuck and sa < tauLossMin_m/unitTorque or initial() and w_a < 0;
              locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);

              /* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */
              tauLoss = if ideal then 0 else (if locked then sa*unitTorque else (if (startForward or
                    pre(mode) == Forward) then tauLossMax else tauLossMin));

              a_a = unitAngularAcceleration*(if locked then 0 else sa - tauLoss/unitTorque);

              /* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */
              mode = if ideal then Free else (if (pre(mode) == Forward or startForward)
                 and w_a > 0 then Forward else if (pre(mode) == Backward or startBackward)
                 and w_a < 0 then Backward else Stuck);

              lossPower = tauLoss*w_a;
              annotation (Documentation(info="<HTML>
<p>
This component models the gear ratio and the <b>losses</b> of
a standard gear box in a <b>reliable</b> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handeled are fixed in the ground or on a moving support, have one input and one
output shaft, and are essentially described by the equations:
</p>
<blockquote><pre>
             flange_a.phi  = i*flange_b.phi;
-(flange_b.tau - tau_bf_b) = i*eta_mf*(flange_a.tau - tau_bf_a);

// or        -flange_b.tau = i*eta_mf*(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));
</pre></blockquote>
<p>
where
</p>

<ul>
<li> <b>i</b> is the constant <b>gear ratio</b>, </li>

<li> <b>eta_mf</b> = eta_mf(w_a) is the <b>mesh efficiency</b> due to the
     friction between the teeth of the gear wheels, </li>

<li> <b>tau_bf_a</b> = tau_bf_a(w_a) is the <b>bearing friction torque</b>
     on the flange_a side,</li>

<li> <b>tau_bf_b</b> = tau_bf_b(w_a) is the <b>bearing friction torque</b>
     on the flange_b side, and</li>

<li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
</ul>

<p>
The loss terms \"eta_mf\", \"tau_bf_a\" and \"tau_bf_b\" are functions of the
<i>absolute value</i> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <b>lossTable[:,5]
</b> where the columns of this table have the following
meaning:
</p>

<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\">|tau_bf2|</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
  </tbody>
</table>

<p>with</p>
<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">Mesh efficiency in case that flange_a is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">Mesh efficiency in case that flange_b is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_a is driving<br>
                        (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)
                        </td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf2|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_b is driving<br>
                        (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)
                        </td>
    </tr>
  </tbody>
</table>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>

<blockquote><pre>
<b>if</b> (flange_a.tau - tau_bf_a)*w_a &gt; 0 <b>or</b>
   (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &gt; 0 <b>then</b>
   eta_mf := eta_mf1
   tau_bf := tau_bf1
<b>elseif</b> (flange_a.tau - tau_bf_a)*w_a &lt; 0 <b>or</b>
       (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &lt; 0 <b>then</b>
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
<b>else</b> // w_a == 0
   eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
<b>end if</b>;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);
</pre></blockquote>

<p>
Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>

<h4>Acknowledgement:</h4>
<ul>
<li> The essential idea to model efficiency
     in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li> The article (Pelchen et.al. 2002), see Literature below,
     and the first implementation of LossyGear (up to version 3.1 of package Modelica)
     contained a bug leading to a non-converging solution in cases where the
     driving side is not obvious.
     This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch,
     and Christian Bertsch proposed a concrete solution how to fix this
     bug, see Literature below.</li>
</ul>

<h4>Literature</h4>

<ul>
<li>Pelchen C.,
<a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
&quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
<I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</li>

<li>Bertsch C. (2009):
&quot;<a href=\"modelica://Modelica/Resources/Documentation/Mechanics/Lossy-Gear-Bug_Solution.pdf\">Problem
with model LossyGear and a proposed solution</a>&quot;,
Ticket <a href=\"http://trac.modelica.org/Modelica/ticket/108\">#108</a>,
Sept. 11, 2009.</li>
</ul>

</HTML>
"),             Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{
                          -60,80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-80,20},{-60,20}}, color={0,0,0}),
                    Text(
                      extent={{-148,145},{152,105}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-145,-49},{155,-79}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Line(visible=useHeatPort,
                      points={{-100,-100},{-100,-30},{0,-30},{0,0}},
                      color={191,0,0},
                      pattern=LinePattern.Dot,
                      smooth=Smooth.None)}),
                Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                        {100,100}},
                    grid={1,1}), graphics));
            end Lossy_Gear_With_Variable_Efficiency;

            model LossyGear_simple
              "Gear with mesh efficiency and bearing friction (stuck/rolling possible)"

              extends Modelica.Mechanics.Rotational.Icons.Gear;
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
                "Array for mesh efficiencies and bearing friction depending on speed";
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

            public
              GearEfficiency gearEfficiency(
                eta=lossTable[1, 2],
                useHeatPort=false,
                useSupport=true)
                annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
              Modelica.Mechanics.Rotational.Components.IdealGear idealGear(
                  ratio=ratio, useSupport=true)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

            equation
              lossPower = gearEfficiency.lossPower;

              connect(gearEfficiency.flange_a, flange_a) annotation (Line(
                  points={{-64,0},{-100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(idealGear.flange_b, flange_b) annotation (Line(
                  points={{10,0},{100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(gearEfficiency.support, internalSupport) annotation (Line(
                  points={{-54,-10},{-54,-30},{0,-30},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(idealGear.support, internalSupport) annotation (Line(
                  points={{0,-10},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(gearEfficiency.flange_b, idealGear.flange_a) annotation (Line(
                  points={{-44,0},{-10,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Documentation(info="<HTML>
<p>
This component models the gear ratio and the <b>losses</b> of
a standard gear box in a <b>reliable</b> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handeled are fixed in the ground or on a moving support, have one input and one
output shaft, and are essentially described by the equations:
</p>
<blockquote><pre>
             flange_a.phi  = i*flange_b.phi;
-(flange_b.tau - tau_bf_b) = i*eta_mf*(flange_a.tau - tau_bf_a);

// or        -flange_b.tau = i*eta_mf*(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));
</pre></blockquote>
<p>
where
</p>

<ul>
<li> <b>i</b> is the constant <b>gear ratio</b>, </li>

<li> <b>eta_mf</b> = eta_mf(w_a) is the <b>mesh efficiency</b> due to the
     friction between the teeth of the gear wheels, </li>

<li> <b>tau_bf_a</b> = tau_bf_a(w_a) is the <b>bearing friction torque</b>
     on the flange_a side,</li>

<li> <b>tau_bf_b</b> = tau_bf_b(w_a) is the <b>bearing friction torque</b>
     on the flange_b side, and</li>

<li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
</ul>

<p>
The loss terms \"eta_mf\", \"tau_bf_a\" and \"tau_bf_b\" are functions of the
<i>absolute value</i> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <b>lossTable[:,5]
</b> where the columns of this table have the following
meaning:
</p>

<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\">|tau_bf2|</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
  </tbody>
</table>

<p>with</p>
<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">Mesh efficiency in case that flange_a is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">Mesh efficiency in case that flange_b is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_a is driving<br>
                        (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)
                        </td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf2|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_b is driving<br>
                        (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)
                        </td>
    </tr>
  </tbody>
</table>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>

<blockquote><pre>
<b>if</b> (flange_a.tau - tau_bf_a)*w_a &gt; 0 <b>or</b>
   (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &gt; 0 <b>then</b>
   eta_mf := eta_mf1
   tau_bf := tau_bf1
<b>elseif</b> (flange_a.tau - tau_bf_a)*w_a &lt; 0 <b>or</b>
       (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &lt; 0 <b>then</b>
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
<b>else</b> // w_a == 0
   eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
<b>end if</b>;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);
</pre></blockquote>

<p>
Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>

<h4>Acknowledgement:</h4>
<ul>
<li> The essential idea to model efficiency
     in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li> The article (Pelchen et.al. 2002), see Literature below,
     and the first implementation of LossyGear (up to version 3.1 of package Modelica)
     contained a bug leading to a non-converging solution in cases where the
     driving side is not obvious.
     This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch,
     and Christian Bertsch proposed a concrete solution how to fix this
     bug, see Literature below.</li>
</ul>

<h4>Literature</h4>

<ul>
<li>Pelchen C.,
<a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
&quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
<I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</li>

<li>Bertsch C. (2009):
&quot;<a href=\"modelica://Modelica/Resources/Documentation/Mechanics/Lossy-Gear-Bug_Solution.pdf\">Problem
with model LossyGear and a proposed solution</a>&quot;,
Ticket <a href=\"http://trac.modelica.org/Modelica/ticket/108\">#108</a>,
Sept. 11, 2009.</li>
</ul>

</HTML>
"),             Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{
                          -60,80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-80,20},{-60,20}}, color={0,0,0}),
                    Text(
                      extent={{-148,145},{152,105}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-145,-49},{155,-79}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Line(visible=useHeatPort,
                      points={{-100,-100},{-100,-30},{0,-30},{0,0}},
                      color={191,0,0},
                      pattern=LinePattern.Dot,
                      smooth=Smooth.None)}),
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                        100,100}},
                    grid={1,1}), graphics));
            end LossyGear_simple;

            model GearEfficiency
              "Obsolete component (use model LossyGear instead)"
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              parameter Real eta(
                min=Modelica.Constants.small,
                max=1) = 1 "Efficiency";
              SI.Angle phi;
              SI.Power power_a "Energy flowing into flange_a (= power)";
              Boolean driving_a(start=true)
                "True, if energy is flowing INTO and not out of flange flange_a";

            equation
              lossPower = abs(flange_b.tau+flange_a.tau)*der(phi);
              phi = flange_a.phi;
              phi = flange_b.phi;
              power_a = flange_a.tau*der(phi);
              driving_a = power_a >= 0;
              flange_b.tau = -(if driving_a then eta*flange_a.tau else flange_a.tau/eta);
              annotation (
                Coordsys(
                  extent=[-100, -100; 100, 100],
                  grid=[1, 1],
                  component=[20, 20]),
                Window(
                  x=0.23,
                  y=0.06,
                  width=0.69,
                  height=0.62),
                Icon(
                  Text(extent=[0, 130; 0, 70], string="%name"),
                  Rectangle(extent=[-90, 20; 90, -20], style(
                      gradient=2,
                      fillColor=8,
                      fillPattern=1)),
                  Line(points=[-30, -40; 30, -40], style(color=0)),
                  Line(points=[0, -40; 0, -90], style(color=0)),
                  Polygon(points=[-30, -20; 60, -20; 60, -80; 70, -80; 50, -100; 30, -80;
                         40, -80; 40, -30; -30, -30; -30, -20; -30, -20], style(
                      color=1,
                      gradient=0,
                      fillColor=1,
                      fillPattern=1)),
                  Text(
                    extent=[0, 70; 0, 20],
                    string="eta=%eta",
                    style(color=0)),
                  Line(points=[30, -50; 20, -60], style(color=0)),
                  Line(points=[30, -40; 10, -60], style(color=0)),
                  Line(points=[20, -40; 0, -60], style(color=0)),
                  Line(points=[10, -40; -10, -60], style(color=0)),
                  Line(points=[0, -40; -20, -60], style(color=0)),
                  Line(points=[-10, -40; -30, -60], style(color=0)),
                  Line(points=[-20, -40; -30, -50], style(color=0))),
                obsolete=
                    "This model can get stuck due when the torque direction varies, use LossyGear instead.",
                Documentation(info="<html>
<p>
THIS COMPONENT IS <b>OBSOLETE</b> and should <b>no longer be used</b>. It is only
kept for <b>backward compatibility</b> purposes. Use model
Modelica.Mechanics.Rotational.LossyGear instead which implements
gear efficiency in a much more reliable way.
</p>

<p>
This component consists of two rigidly connected flanges flange_a and flange_b without
inertia where an <b>efficency</b> coefficient <b>eta</b> reduces the driven
torque as function of the driving torque depending on the direction
of the energy flow, i.e., energy is always lost. This can be seen as a
simple model of the Coulomb friction acting between the teeth of a
gearbox.
</p>

<p>
Note, that most gearbox manufacturers provide tables of the
efficiency of a gearbox as function of the angular velocity
(efficiency becomes zero, if the angular velocity is zero).
However, such a table is practically useless for simulation purposes,
because in gearboxes always two types of friction is present:
(1) Friction in the <b>bearings</b> and (2) friction between
the teeth of the gear. (1) leads to a velocity dependent, additive
loss-torque, whereas (2) leads to a torque-dependent reduction of the
driving torque. The gearbox manufacturers measure both effects
together and determine the gear efficiency from it, although for
simulation purposes the two effects need to be separated.
Assume for example that only constant bearing friction, i.e.,
bearingTorque=const., is present, i.e.,
</p>

<pre>
   (1)  loadTorque = motorTorque - sign(w)*bearingTorque
</pre>

<p>
Gearbox manufacturers use the loss-formula
</p>

<pre>
   (2)  loadTorque = eta*motorTorque
</pre>

<p>
Comparing (1) and (2) gives a formulat for the efficiency eta:
</p>

<pre>
   eta = (1 - sign(w)*bearingTorque/motorTorque)
</pre>

<p>
When the motorTorque becomes smaller as the bearingTorque,
(2) is useless, because the efficiency is zero. To summarize,
be careful to determine the gear <b>efficiency</b> of this element
from tables of the gear manufacturers.
</p>

<p><b>Release Notes:</b></p>
<ul>
<li><i>July 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.
</li>
</ul>

</HTML>
"),             Diagram(
                  coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  Rectangle(extent=[-90, 20; 90, -20], style(
                      gradient=2,
                      fillColor=8,
                      fillPattern=1)),
                  Line(points=[-30, -40; 30, -40], style(color=0)),
                  Line(points=[0, 60; 0, 40], style(color=0)),
                  Line(points=[-30, 40; 29, 40], style(color=0)),
                  Line(points=[0, -40; 0, -90], style(color=0)),
                  Polygon(points=[-30, -20; 60, -20; 60, -80; 70, -80; 50, -100; 30, -80;
                         40, -80; 40, -30; -30, -30; -30, -20; -30, -20], style(
                      color=1,
                      gradient=0,
                      fillColor=1,
                      fillPattern=1)),
                  Text(
                    extent=[16, 83; 84, 70],
                    string="rotation axis",
                    style(color=10)),
                  Polygon(points=[12, 76; -8, 81; -8, 71; 12, 76], style(color=10,
                        fillColor=10)),
                  Line(points=[-78, 76; -7, 76], style(color=10, fillColor=10)),
                  Line(points=[30, -50; 20, -60], style(color=0)),
                  Line(points=[30, -40; 10, -60], style(color=0)),
                  Line(points=[20, -40; 0, -60], style(color=0)),
                  Line(points=[10, -40; -10, -60], style(color=0)),
                  Line(points=[0, -40; -20, -60], style(color=0)),
                  Line(points=[-10, -40; -30, -60], style(color=0)),
                  Line(points=[-20, -40; -30, -50], style(color=0)),
                  graphics));
            end GearEfficiency;

            model Lossy_Gear_B
              "Gear with mesh efficiency and bearing friction (stuck/rolling possible)"
              import Modelica.Fluid.Utilities.regStep;
              //extends Modelica.Mechanics.Rotational.Icons.Gear;
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
                "Array for mesh efficiencies and bearing friction depending on speed";
              extends
                Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              Modelica.SIunits.Angle phi_a
                "Angle between left shaft flange and support";
              Modelica.SIunits.Angle phi_b
                "Angle between right shaft flange and support";

              //Real sa(final unit="1") "Path parameter for acceleration and torque loss";
              SI.AngularVelocity w_a
                "Angular velocity of flange_a with respect to support";
            //   SI.AngularAcceleration a_a
            //     "Angular acceleration of flange_a with respect to support";

              Real interpolation_result[1, size(lossTable, 2) - 1];
              Real eta_mf1;
              Real eta_mf2;
              Real tau_bf_a "Bearing friction torque on flange_a side";
              Real tau_eta
                "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau)";

              Real tau_bf1;
              Real tau_bf2;

              Real quadrant1;
              Real quadrant2;
              Real quadrant3;
              Real quadrant4;

              // quadrant values for angular verlocities near zero
              Real quadrant1_p; // w=0+
              Real quadrant2_p; // w=0+
              Real quadrant3_m; // w=0-
              Real quadrant4_m; // w=0-

              SI.Torque tauLoss
                "Torque loss due to friction in the gear teeth and in the bearings";
              SI.Torque tauLossMax "Torque loss for positive speed";
              SI.Torque tauLossMin "Torque loss for negative speed";

              SI.Torque tauLossMax_p "Torque loss for positive speed";
              SI.Torque tauLossMin_m "Torque loss for negative speed";

            //  Boolean tau_aPos(start=true)
            //    "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative)";
            //  Boolean tau_etaPos(start=true) "true, if torque tau_eta is not negative";
            //   Boolean startForward(start=false) "true, if starting to roll forward";
            //   Boolean startBackward(start=false) "true, if starting to roll backward";
            //   Boolean locked(start=false) "true, if gear is locked";

              Boolean ideal "true, if losses are neglected";

              constant Integer Unknown=3 "Value of mode is not known";
              constant Integer Free=2 "Element is not active";
              constant Integer Forward=1 "w_a > 0 (forward rolling)";
              constant Integer Stuck=0
                "w_a = 0 (forward rolling, locked or backward rolling)";
              constant Integer Backward=-1 "w_a < 0 (backward rolling)";
            //   Integer mode(
            //     final min=Backward,
            //     final max=Unknown,
            //     start=Free,
            //     fixed=true);

              SI.Torque tau_eta_p "tau_eta assuming positive omega";
              SI.Torque tau_eta_m "tau_eta assuming negative omega";

              constant SI.AngularAcceleration unitAngularAcceleration = 1;
              constant SI.Torque unitTorque = 1;

              parameter Real smoother = 1e-4;

              // get friction and eta information for omega=0
              parameter Real interpolation_result_0[1, size(lossTable, 2) - 1] =  Modelica.Math.tempInterpol2(0, lossTable, {2,3,4,5});
              parameter Real eta_mf1_0 = interpolation_result_0[1, 1];
              parameter Real eta_mf2_0 = interpolation_result_0[1, 2];
              parameter Real tau_bf1_0 = abs(interpolation_result_0[1, 3]);
              parameter Real tau_bf2_0 = abs(interpolation_result_0[1, 4]);
              parameter Real tau_bf_a_0= if Modelica.Math.isEqual(eta_mf1_0, 1.0, Modelica.Constants.eps) and
                                            Modelica.Math.isEqual(eta_mf2_0, 1.0, Modelica.Constants.eps) then
                                            tau_bf1_0/2 else
                                            (tau_bf1_0-tau_bf2_0)/(eta_mf1_0-1.0/eta_mf2_0);
                                         // For eta_mf1_0=eta_mf2_0=1 the given bearing
                                         // friction can not be separated into a part
                                         // on side A or B, so it is done arbitrarily.
                                         // Calculate tau_bf_a_0 from the following equations
                                         //  tau_bf1_0=eta_mf1_0*tau_bf_a_0 + 1/ratio a_0
                                         //  tau_bf2_0=1/eta_mf2*tau_bf_a_0 + 1/ratio tau_bf_a_0
            equation
              assert(abs(ratio) > 0,
                "Error in initialization of LossyGear: ratio may not be zero");

              ideal = Modelica.Math.Matrices.isEqual(lossTable, [0, 1, 1, 0, 0], Modelica.Constants.eps);

              interpolation_result = if ideal then [1, 1, 0, 0] else
                Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
              eta_mf1 = interpolation_result[1, 1];
              eta_mf2 = interpolation_result[1, 2];
              tau_bf1 = noEvent(abs(interpolation_result[1, 3]));
              tau_bf2 = noEvent(abs(interpolation_result[1, 4]));

              if Modelica.Math.isEqual(eta_mf1, 1.0, Modelica.Constants.eps) and
                 Modelica.Math.isEqual(eta_mf2, 1.0, Modelica.Constants.eps) then
                 // For eta_mf1=eta_mf2=1 the given bearing friction can not be
                 // separated into a part on side A or B, so it is done arbitrarily.
                 tau_bf_a = tau_bf1/2;
              else
                //calculate tau_bf_a from the following equations
                //tau_bf1 = eta_mf1*tau_bf_a + tau_bf_b / ratio
                //tau_bf2 = 1/eta_mf2*tau_bf_a + tau_bf_b / ratio
                tau_bf_a=(tau_bf1-tau_bf2)/(eta_mf1-1.0/eta_mf2);
              end if;

              phi_a = flange_a.phi - phi_support;
              phi_b = flange_b.phi - phi_support;
              phi_a = ratio*phi_b;

              // Torque balance (no inertias)
              0 = flange_b.tau + ratio*(flange_a.tau - tauLoss);

              // Speed for friction element
              w_a = der(phi_a);
              //a_a = der(w_a);

              // Determine driving side
                 //assuming positive omega
                 tau_eta_p=flange_a.tau-tau_bf_a_0;
                 //assuming negative omega
                 tau_eta_m=flange_a.tau+tau_bf_a_0;

              // assuming w>=0, take value at w=0 to decide rolling/stuck mode
              quadrant1_p = (1 - eta_mf1_0)*flange_a.tau + tau_bf1_0;
              quadrant2_p = (1 - 1/eta_mf2_0)*flange_a.tau + tau_bf2_0;
              tauLossMax_p = if noEvent(tau_eta_p>0) then quadrant1_p else quadrant2_p;

              // assuming w<=0, take value at w=0 to decide rolling/stuck mode
              quadrant4_m = (1 - 1/eta_mf2_0)*flange_a.tau - tau_bf2_0;
              quadrant3_m = (1 - eta_mf1_0)*flange_a.tau - tau_bf1_0;
              tauLossMin_m = if noEvent(tau_eta_m>0) then quadrant4_m else quadrant3_m;

              quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
              quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
              quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
              quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

            // REPLACED WITH SMOOTH STEP
              //tau eta: only for determination of driving side for calculation of tauloss
            //   tau_eta = if ideal then flange_a.tau else
            //                  (if locked then flange_a.tau else
            //                  (if (startForward or pre(mode) == Forward) then flange_a.tau-tau_bf_a else
            //                  flange_a.tau+tau_bf_a));

              // Replace above with a smooth step
              tau_eta = regStep(w_a, flange_a.tau-tau_bf_a, flange_a.tau+tau_bf_a, smoother);

              // Torque Losses
             // tau_etaPos = tau_eta >= 0;
             // tau_aPos   = tau_etaPos;
            // REPLACED WITH SMOOTH STEP
            //  tauLossMax = if tau_etaPos then quadrant1 else quadrant2;
            //  tauLossMin = if tau_etaPos then quadrant4 else quadrant3;

              // Replace above with a smooth step
              tauLossMax = regStep(tau_eta, quadrant1, quadrant2, smoother);
              tauLossMin = regStep(tau_eta, quadrant4, quadrant3, smoother);

              // Determine rolling/stuck mode when w_rel = 0
              // startForward = pre(mode) == Stuck and sa > tauLossMax_p/unitTorque or initial() and w_a > 0;
              // startBackward = pre(mode) == Stuck and sa < tauLossMin_m/unitTorque or initial() and w_a < 0;
            //   startForward = false;
            //   startBackward = false;
            //   locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);

              /* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */
            //   tauLoss = if ideal then 0 else (if locked then sa*unitTorque else (if (startForward or
            //         pre(mode) == Forward) then tauLossMax else tauLossMin));

              // Replace above with a smooth step
              tauLoss = regStep(w_a,tauLossMax, tauLossMin, smoother);

              //a_a = unitAngularAcceleration*(if locked then 0 else sa - tauLoss/unitTorque);

              /* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */
            //   mode = if ideal then Free else (if (pre(mode) == Forward or startForward)
            //      and w_a > 0 then Forward else if (pre(mode) == Backward or startBackward)
            //      and w_a < 0 then Backward else Stuck);

              lossPower = tauLoss*w_a;
              annotation (Documentation(info="<HTML>
<p>
This component models the gear ratio and the <b>losses</b> of
a standard gear box in a <b>reliable</b> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handeled are fixed in the ground or on a moving support, have one input and one
output shaft, and are essentially described by the equations:
</p>
<blockquote><pre>
             flange_a.phi  = i*flange_b.phi;
-(flange_b.tau - tau_bf_b) = i*eta_mf*(flange_a.tau - tau_bf_a);

// or        -flange_b.tau = i*eta_mf*(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));
</pre></blockquote>
<p>
where
</p>

<ul>
<li> <b>i</b> is the constant <b>gear ratio</b>, </li>

<li> <b>eta_mf</b> = eta_mf(w_a) is the <b>mesh efficiency</b> due to the
     friction between the teeth of the gear wheels, </li>

<li> <b>tau_bf_a</b> = tau_bf_a(w_a) is the <b>bearing friction torque</b>
     on the flange_a side,</li>

<li> <b>tau_bf_b</b> = tau_bf_b(w_a) is the <b>bearing friction torque</b>
     on the flange_b side, and</li>

<li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
</ul>

<p>
The loss terms \"eta_mf\", \"tau_bf_a\" and \"tau_bf_b\" are functions of the
<i>absolute value</i> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <b>lossTable[:,5]
</b> where the columns of this table have the following
meaning:
</p>

<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\">|tau_bf2|</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
    <tr>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
      <td align=\"center\">...</td>
    </tr>
  </tbody>
</table>

<p>with</p>
<table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign=\"top\">|w_a|</td>
      <td valign=\"top\">Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf1</td>
      <td valign=\"top\">Mesh efficiency in case that flange_a is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">eta_mf2</td>
      <td valign=\"top\">Mesh efficiency in case that flange_b is driving</td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf1|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_a is driving<br>
                        (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)
                        </td>
    </tr>
    <tr>
      <td valign=\"top\">|tau_bf2|</td>
      <td valign=\"top\"> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_b is driving<br>
                        (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)
                        </td>
    </tr>
  </tbody>
</table>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>

<blockquote><pre>
<b>if</b> (flange_a.tau - tau_bf_a)*w_a &gt; 0 <b>or</b>
   (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &gt; 0 <b>then</b>
   eta_mf := eta_mf1
   tau_bf := tau_bf1
<b>elseif</b> (flange_a.tau - tau_bf_a)*w_a &lt; 0 <b>or</b>
       (flange_a.tau - tau_bf_a) == 0 <b>and</b> w_a &lt; 0 <b>then</b>
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
<b>else</b> // w_a == 0
   eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
<b>end if</b>;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);
</pre></blockquote>

<p>
Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>

<h4>Acknowledgement:</h4>
<ul>
<li> The essential idea to model efficiency
     in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li> The article (Pelchen et.al. 2002), see Literature below,
     and the first implementation of LossyGear (up to version 3.1 of package Modelica)
     contained a bug leading to a non-converging solution in cases where the
     driving side is not obvious.
     This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch,
     and Christian Bertsch proposed a concrete solution how to fix this
     bug, see Literature below.</li>
</ul>

<h4>Literature</h4>

<ul>
<li>Pelchen C.,
<a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
&quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
<I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</li>

<li>Bertsch C. (2009):
&quot;<a href=\"modelica://Modelica/Resources/Documentation/Mechanics/Lossy-Gear-Bug_Solution.pdf\">Problem
with model LossyGear and a proposed solution</a>&quot;,
Ticket <a href=\"http://trac.modelica.org/Modelica/ticket/108\">#108</a>,
Sept. 11, 2009.</li>
</ul>

</HTML>
"),             Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(extent={{34,70},{-36,50}},  lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{
                          -60,80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-80,20},{-60,20}}, color={0,0,0}),
                    Text(
                      extent={{-148,145},{152,105}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-145,-49},{155,-79}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Line(visible=useHeatPort,
                      points={{-100,-100},{-100,-30},{0,-30},{0,0}},
                      color={191,0,0},
                      pattern=LinePattern.Dot,
                      smooth=Smooth.None),
                    Line(
                      points={{-80,-20},{-60,-20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,-20},{80,-20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,20},{80,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-10,80},{10,80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-10,40},{11,40}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,40},{0,-90}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-70,-20},{-70,-86},{70,-86},{70,-20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Rectangle(extent={{-100,10},{-32,-10}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{100,10},{30,-10}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{20,40},{40,-40}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{20,80},{40,40}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{-40,20},{-20,-20}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(extent={{-40,100},{-20,20}}, lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid)}),
                Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                        {100,100}},
                    grid={1,1}), graphics));
            end Lossy_Gear_B;

            model Lossy_Gear_With_Environment
              "Same as lossy gear in MSL but with capability to exchange heat to the environment"
              extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(                      thermal_To_Environment(area_for_heat_transfer=area_for_heat_transfer));
              extends C2M2L_OM.MSL_Extend.Mechanics.Rotational.Icons.Gear;
            extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

              parameter Real ratio(start=1)
                "Transmission ratio (flange_a.phi/flange_b.phi)";
              parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
                "Array for mesh efficiencies and bearing friction depending on speed";
                parameter SI.Area area_for_heat_transfer = 0.1
                "Area available for heat transfer to the environment";
              extends
                C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

              Modelica.Mechanics.Rotational.Components.LossyGear lossyGear(
                  useSupport=useSupport,
                  useHeatPort=useHeatPort or use_environment_heat_port,
                  lossTable=lossTable,
                ratio=ratio)
                annotation (Placement(transformation(extent={{-12,-10},{10,10}})));
            equation
              if not useHeatPort then
                lossPower = lossyGear.lossPower;
              end if;
              connect(flange_a, lossyGear.flange_a) annotation (Line(
                  points={{-100,0},{-12,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.flange_b, flange_b) annotation (Line(
                  points={{10,0},{100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(heatPort, lossyGear.heatPort) annotation (Line(
                  points={{-100,-100},{-100,-55},{-12,-55},{-12,-10}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.heatPort, thermal_To_Environment.solid) annotation (Line(
                  points={{-12,-10},{-12,-90},{40,-90}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(lossyGear.support, internalSupport) annotation (Line(
                  points={{-1,-10},{0,-10},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(graphics), Icon(graphics={Text(
                      extent={{-88,-40},{90,-74}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Polygon(
                      points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{-60,
                          80},{-60,20},{-109,20},{-109,40}},
                      lineColor={0,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                     Polygon(
                       points={{-22,174},{-36,184},{-54,182},{-62,176},{-64,174},{-72,176},
                          {-74,176},{-82,176},{-88,172},{-96,176},{-106,178},{-120,174},{
                          -128,164},{-128,156},{-124,148},{-118,142},{-116,142},{-112,138},
                          {-112,134},{-116,126},{-114,112},{-104,102},{-92,100},{-80,102},{
                          -74,108},{-70,112},{-62,108},{-50,108},{-38,112},{-28,118},{-26,
                          132},{-28,142},{-30,144},{-32,146},{-22,152},{-18,162},{-20,172},
                          {-22,174}},
                       lineColor={0,0,0},
                       smooth=Smooth.Bezier,
                       lineThickness=0.5),
                     Line(
                       points={{-28,138},{-30,140},{-38,148},{-40,150},{-52,152},{-64,148},
                          {-74,142},{-78,130},{-76,120},{-70,114},{-68,112}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-76,138},{-86,144},{-94,144},{-104,142},{-108,138},{-112,
                          134}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-90,144},{-86,150},{-84,158},{-84,164},{-88,170},{-92,174}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                     Line(
                       points={{-60,150},{-66,156},{-68,166},{-66,172},{-64,174}},
                       color={0,0,0},
                       smooth=Smooth.Bezier),
                    Text(
                      extent={{-126,180},{-16,114}},
                      lineColor={0,0,0},
                      textString="env")}));
            end Lossy_Gear_With_Environment;

            model Selectable_Gear
              "Simulates a gear that can be clutched in and out"
              extends
                Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;
              extends
                C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
              parameter Integer gear_num=-1000
                "Which gear is this.  Reverse = -1, First = 1, second = 2 etc. DO NOT USE 0";
              parameter Real ratio
                "Transmission ratio (flange_a.phi/flange_b.phi) of contained gear"
                annotation (Dialog(group="Gear"));
              parameter Real lossTable[:,5]=[0,1,1,0,0]
                "Array for mesh efficiencies and bearing friction depending on speed for contained gear"
                annotation (Dialog(group="Gear"));
              parameter SI.Torque locked_max_torque
                "Max torque transmitted when locked"
                annotation (Dialog(group="Clutch"));

              parameter SI.Torque synchronizer_max_torque
                "Max torque transmitted while synchronizing"
                annotation (Dialog(group="Clutch"));

              parameter SI.Torque drag_torque = 0
                "Max torque transmitted when disengaged"
                annotation (Dialog(group="Clutch"));

              Modelica.Blocks.Interfaces.IntegerInput gear_selected annotation (Placement(
                    transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={-46,100}),
                                     iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={-60,100})));

              MSL_Extend.Mechanics.Rotational.Components.Clutches.Clutch_Simple_Friction
                                                              clutch(fn_max=locked_max_torque / unit_length,
                mue_pos=mue_pos,
                peak=1,
                useHeatPort=useHeatPort)
                annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
              Modelica.Mechanics.Rotational.Components.IdealGear gear(
                useSupport=useSupport,
                ratio=ratio)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            protected
              constant SI.Length unit_length = 1;
              parameter Real drag_factor = drag_torque/synchronizer_max_torque
                "Modifies the minimum value sent to the clutch actuator";

              parameter Real mue_pos[:,2]=[0,synchronizer_max_torque/locked_max_torque]
                "[w,mue] positive sliding friction coefficient (w_rel>=0)";
                //Modelica.Blocks.Interfaces.RealOutput engaged(start=0)
                //"0.0 if clutch is open, 1.0 if clutch is closed";
            public
              Modelica.Blocks.Logical.TriggeredTrapezoid triggeredTrapezoid(
                amplitude=1 - drag_factor,
                rising=engage_time,
                falling=disengage_time,
                offset=drag_factor)
                          annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-50,28})));
              Modelica.Blocks.Sources.IntegerExpression gear_num_for_diagram(y=gear_num)
                annotation (Placement(transformation(extent={{-94,58},{-74,78}})));
              MSL_Extend.Blocks.Logical.Integer_Equality
                                              integer_Equality annotation (Placement(
                    transformation(
                    extent={{-6,-6},{6,6}},
                    rotation=270,
                    origin={-50,54})));
              parameter SI.Time engage_time=0.05 "time_to_fully_engage_clutch" annotation (Dialog(group="Clutch"));
              parameter SI.Time disengage_time=0.0
                "Time to fully disengage clutch"                                    annotation (Dialog(group="Clutch"));
            equation
              assert(gear_num <> -1000, "Must assign gear_num in Selectable_Gear");
              assert(abs(ratio) > 1e-6, "Gear ratio cannot be zero");
              assert(locked_max_torque >= synchronizer_max_torque, "Locked_Max_Torque must be >= Synchronizer_Max_Torque");

              if not useHeatPort then
                lossPower = clutch.lossPower;
              end if;

              //connect(clutch.f_normalized, engaged);
              connect(clutch.heatPort, heatPort) annotation (Line(
                  points={{-60,-10},{-60,-100},{-100,-100}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(integer_Equality.y, triggeredTrapezoid.u) annotation (Line(
                  points={{-50.03,47.43},{-50.03,43.715},{-50,43.715},{-50,40}},
                  color={255,0,255},
                  smooth=Smooth.None));
              connect(gear_num_for_diagram.y, integer_Equality.u2) annotation (Line(
                  points={{-73,68},{-54,68},{-54,61.2},{-53.6,61.2}},
                  color={255,127,0},
                  smooth=Smooth.None));
              connect(gear_selected, integer_Equality.u1) annotation (Line(
                  points={{-46,100},{-46,61.2},{-46.4,61.2}},
                  color={255,127,0},
                  smooth=Smooth.None));
              connect(triggeredTrapezoid.y, clutch.f_normalized) annotation (Line(
                  points={{-50,17},{-50,11}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(gear.flange_a, clutch.flange_b) annotation (Line(
                  points={{-10,0},{-40,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(gear.flange_b, flange_b) annotation (Line(
                  points={{10,0},{100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(clutch.flange_a, flange_a) annotation (Line(
                  points={{-60,0},{-100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(gear.support, internalSupport) annotation (Line(
                  points={{0,-10},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}),
                                  graphics), Icon(graphics={
                    Rectangle(
                      extent={{-8,20},{12,-20}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-8,100},{12,20}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{52,80},{72,39}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{52,40},{72,-40}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{72,10},{94,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{12,70},{52,50}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-32,10},{-8,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-32,20},{-12,20}}, color={0,0,0}),
                    Line(points={{-30,-20},{-10,-20}}, color={0,0,0}),
                    Line(points={{-20,-20},{-20,-84}}, color={0,0,0}),
                    Line(points={{30,40},{30,-92}},color={0,0,0}),
                    Line(points={{22,40},{42,40}},  color={0,0,0}),
                    Line(points={{22,80},{42,80}},  color={0,0,0}),
                    Line(points={{74,-20},{94,-20}}, color={0,0,0}),
                    Line(points={{74,20},{94,20}}, color={0,0,0}),
                    Line(points={{86,-20},{86,-84}}, color={0,0,0}),
                    Line(points={{86,-84},{-20,-84}}, color={0,0,0}),
                    Text(
                      extent={{-186,154},{157,115}},
                      lineColor={0,0,255},
                      textString="%name, =%gear_num"),
                    Text(
                      extent={{-166,-127},{134,-157}},
                      lineColor={0,0,0},
                      textString="ratio=%ratio"),
                    Line(
                      points={{30,-92},{0,-92},{0,-100}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-100,0},{-60,0}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-80,40},{-80,-38},{-80,-40}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-60,40},{-60,-38},{-60,-40}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-50,50},{-50,6}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-70,50},{-70,6}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-70,-10},{-70,-54}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-50,-10},{-50,-54}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-70,-54},{-34,-54},{-34,0},{-24,0}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-70,50},{-34,50},{-34,0}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5)}));
            end Selectable_Gear;
          end Gear_Ratios;

          package Planetaries "Planetary gear sets"
          extends Modelica.Icons.Package;

            model Ideal_Planetary_Simple
              "Ideal planetary gear box. Simple arrangement"
              parameter Integer N_sun "Number of teeth on Sun gear";
              parameter Integer N_annulus "Number of teeth on Annulus gear";
              parameter Integer N_planet "Number of teeth on Planet gear";

              SI.AngularVelocity nPlanet "Planet Speed";
              SI.AngularVelocity nSun "Sun Speed";
              SI.AngularVelocity nAnnulus "Annulus Speed";
              SI.AngularVelocity nCarrier "Carrier Speed";

              // kinematic relationship
              Modelica.Mechanics.Rotational.Interfaces.Flange_a sun
                "Flange of sun shaft"
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                      rotation=0)));
              Modelica.Mechanics.Rotational.Interfaces.Flange_a carrier
                "Flange of carrier shaft"
                annotation (Placement(transformation(extent={{-110,30},{-90,50}},
                      rotation=0)));
              Modelica.Mechanics.Rotational.Interfaces.Flange_b annulus
                "Flange of annulus shaft"
                annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=
                       0)));

            equation
              sun.phi = (((N_annulus+N_sun)/N_sun)*carrier.phi)-((N_annulus/N_sun)*annulus.phi);
              nPlanet = (nSun-nCarrier)*(-1)*(N_sun/N_planet);
              nSun = der(sun.phi);
              nAnnulus = der(annulus.phi);
              nCarrier = der(carrier.phi);

              // torque balance (no inertias)
              annulus.tau = (N_annulus/N_sun)*sun.tau;
              carrier.tau = (-1)*((N_annulus+N_sun)/N_sun)*sun.tau;
              annotation (
                Documentation(info="<HTML>
<p>
The IdealPlanetary gear box is an ideal gear without inertia,
elasticity, damping or backlash consisting
of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
<b>planet</b> wheel located between sun and ring wheel. The bearing
of the planet wheel shaft is fixed in the planet <b>carrier</b>.
The component can be connected to other elements at the
sun, ring and/or carrier flanges. It is not possible to connect
to the planet wheel. If inertia shall not be neglected,
the sun, ring and carrier inertias can be easily added by attaching
inertias (= model Inertia) to the corresponding connectors.
The inertias of the planet wheels are always neglected.
</p>
<p>
The icon of the planetary gear signals that the sun and carrier
flanges are on the left side and the ring flange is on the right side
of the gear box. However, this component is generic and is valid
independantly how the flanges are actually placed (e.g., sun wheel
may be placed on the right side instead on the left side in reality).
</p>
<p>
The ideal planetary gearbox is uniquely defined by the ratio
of the number of ring teeth zr with respect to the number of
sun teeth zs. For example, if there are 100 ring teeth and
50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
zp has to fulfill the following relationship:
</p>
<pre>
   <b>zp := (zr - zs) / 2</b>
</pre>
<p>
Therefore, in the above example zp = 25 is required.
</p>
<p>
According to the overall convention, the positive direction of all
vectors, especially the absolute angular velocities and cut-torques
in the flanges, are along the axis vector displayed in the icon.
</p>

</HTML>
"),             Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{50,100},{10,-100}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,45},{-50,85}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,30},{-50,-30}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-50,10},{-100,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{100,10},{50,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{50,100},{-50,105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{50,-100},{-50,-105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-80,70},{-50,60}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-90,40},{-70,40}}, color={0,0,0}),
                    Line(points={{-80,50},{-60,50}}, color={0,0,0}),
                    Line(points={{-70,50},{-70,40}}, color={0,0,0}),
                    Line(points={{-80,80},{-59,80}}, color={0,0,0}),
                    Line(points={{-70,100},{-70,80}}, color={0,0,0}),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{50,100},{10,-100}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,45},{-50,85}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,30},{-50,-30}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-50,10},{-100,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{100,10},{50,-10}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{50,100},{-50,105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{50,-100},{-50,-105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-80,70},{-50,60}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-90,40},{-70,40}}, color={0,0,0}),
                    Line(points={{-80,50},{-60,50}}, color={0,0,0}),
                    Line(points={{-70,50},{-70,40}}, color={0,0,0}),
                    Line(points={{-80,80},{-59,80}}, color={0,0,0}),
                    Line(points={{-70,90},{-70,80}}, color={0,0,0}),
                    Line(
                      points={{-26,-42},{-32,-2}},
                      pattern=LinePattern.Dot,
                      color={0,0,255}),
                    Line(
                      points={{36,-26},{64,-60}},
                      pattern=LinePattern.Dot,
                      color={0,0,255}),
                    Text(
                      extent={{58,-66},{98,-78}},
                      lineColor={0,0,255},
                      textString="annulus gear"),
                    Text(
                      extent={{-112,111},{-56,87}},
                      textString="planet carrier ",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-47,-42},{-3,-56}},
                      textString="sun gear",
                      lineColor={0,0,255}),
                    Polygon(
                      points={{58,130},{28,140},{28,120},{58,130}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-52,130},{28,130}}, color={0,0,0}),
                    Line(
                      points={{-92,93},{-70,80}},
                      pattern=LinePattern.Dot,
                      color={0,0,255}),
                    Polygon(
                      points={{-7,-86},{-27,-81},{-27,-91},{-7,-86}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-97,-86},{-26,-86}}, color={128,128,128}),
                    Text(
                      extent={{-96,-71},{-28,-84}},
                      lineColor={128,128,128},
                      textString="rotation axis")}));
            end Ideal_Planetary_Simple;

            model Ideal_Planetary_Double_Planet
              "Ideal planetary gear box. Double planet arrangement"
              parameter Integer N_sun "Number of teeth on Sun gear";
              parameter Integer N_annulus "Number of teeth on Annulus gear";
              parameter Integer N_inPlanet
                "Number of teeth on inner planet gear";
              parameter Integer N_outPlanet
                "Number of teeth on outer planet gear";

              SI.AngularVelocity nInPlanet "Inner Planet Speed";
              SI.AngularVelocity nOutPlanet "Outer Planet Speed";
              SI.AngularVelocity nSun "Sun Speed";
              SI.AngularVelocity nAnnulus "Annulus Speed";
              SI.AngularVelocity nCarrier "Carrier Speed";

              // kinematic relationship
              Modelica.Mechanics.Rotational.Interfaces.Flange_a sun
                "Flange of sun shaft"
                annotation (Placement(transformation(extent={{-111,-80},{-91,-60}},
                      rotation=0), iconTransformation(extent={{-110,-78},{-90,-58}})));
              Modelica.Mechanics.Rotational.Interfaces.Flange_a carrier
                "Flange of carrier shaft"
                annotation (Placement(transformation(extent={{-109,25},{-89,45}},
                      rotation=0), iconTransformation(extent={{-110,25},{-90,45}})));
              Modelica.Mechanics.Rotational.Interfaces.Flange_b annulus
                "Flange of annulus shaft"
                annotation (Placement(transformation(extent={{89,-81},{109,-61}},rotation=
                       0), iconTransformation(extent={{90,-78},{110,-58}})));

            equation
              sun.phi = ((N_annulus/N_sun)*annulus.phi)-(((N_annulus-N_sun)/N_sun)*carrier.phi);
              nInPlanet = (nSun-nCarrier)*((-1)*(N_sun/N_inPlanet));
              nOutPlanet = (nSun-nCarrier)*((-1)*(N_sun/N_inPlanet))*((-1)*(N_inPlanet/N_outPlanet));
              nSun = der(sun.phi);
              nAnnulus = der(annulus.phi);
              nCarrier = der(carrier.phi);

              // torque balance (no inertias)
              annulus.tau = (-1)*(N_annulus/N_sun)*sun.tau;
              carrier.tau = ((N_annulus-N_sun)/N_sun)*sun.tau;

              annotation (
                Documentation(info="<HTML>
<p>
The IdealPlanetary gear box is an ideal gear without inertia,
elasticity, damping or backlash consisting
of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
<b>planet</b> wheel located between sun and ring wheel. The bearing
of the planet wheel shaft is fixed in the planet <b>carrier</b>.
The component can be connected to other elements at the
sun, ring and/or carrier flanges. It is not possible to connect
to the planet wheel. If inertia shall not be neglected,
the sun, ring and carrier inertias can be easily added by attaching
inertias (= model Inertia) to the corresponding connectors.
The inertias of the planet wheels are always neglected.
</p>
<p>
The icon of the planetary gear signals that the sun and carrier
flanges are on the left side and the ring flange is on the right side
of the gear box. However, this component is generic and is valid
independantly how the flanges are actually placed (e.g., sun wheel
may be placed on the right side instead on the left side in reality).
</p>
<p>
The ideal planetary gearbox is uniquely defined by the ratio
of the number of ring teeth zr with respect to the number of
sun teeth zs. For example, if there are 100 ring teeth and
50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
zp has to fulfill the following relationship:
</p>
<pre>
   <b>zp := (zr - zs) / 2</b>
</pre>
<p>
Therefore, in the above example zp = 25 is required.
</p>
<p>
According to the overall convention, the positive direction of all
vectors, especially the absolute angular velocities and cut-torques
in the flanges, are along the axis vector displayed in the icon.
</p>

</HTML>
"),             Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{50,100},{10,-100}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,45},{-50,85}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,-38},{-50,-98}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-50,-58},{-100,-78}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{100,-58},{50,-78}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{50,100},{-50,105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-80,70},{-50,60}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-90,35},{-70,35}}, color={0,0,0}),
                    Line(points={{-80,-10},{-60,-10}},
                                                     color={0,0,0}),
                    Line(points={{-70,-10},{-70,-30}},
                                                     color={0,0,0}),
                    Line(points={{-80,80},{-59,80}}, color={0,0,0}),
                    Line(points={{-70,100},{-70,80}}, color={0,0,0}),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(
                      extent={{-10,-15},{-50,25}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-80,10},{-50,0}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-80,20},{-59,20}}, color={0,0,0}),
                    Line(points={{-81,50},{-60,50}}, color={0,0,0}),
                    Line(points={{-70,50},{-70,20}},  color={0,0,0})}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{49,99},{-51,104}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-11,44},{-51,84}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-81,69},{-51,59}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-81,9},{-51,-1}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-11,-16},{-51,24}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{49,99},{9,-101}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{99,-59},{49,-79}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-11,-39},{-51,-99}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-51,-59},{-101,-79}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Text(
                      extent={{14,77},{54,65}},
                      lineColor={0,0,255},
                      textString="annulus gear"),
                    Text(
                      extent={{-112,111},{-56,87}},
                      textString="planet carrier ",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-50,-63},{-6,-77}},
                      textString="sun gear",
                      lineColor={0,0,255}),
                    Polygon(
                      points={{58,130},{28,140},{28,120},{58,130}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-52,130},{28,130}}, color={0,0,0}),
                    Line(
                      points={{-92,93},{-88,34}},
                      pattern=LinePattern.Dot,
                      color={0,0,255}),
                    Polygon(
                      points={{-20,-104},{-40,-99},{-40,-109},{-20,-104}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-110,-104},{-39,-104}},
                                                       color={128,128,128}),
                    Text(
                      extent={{-109,-89},{-41,-102}},
                      lineColor={128,128,128},
                      textString="rotation axis"),
                    Line(points={{-81,79},{-60,79}}, color={0,0,0}),
                    Line(points={{-71,99},{-71,79}},  color={0,0,0}),
                    Line(points={{-82,49},{-61,49}}, color={0,0,0}),
                    Line(points={{-71,49},{-71,19}},  color={0,0,0}),
                    Line(points={{-81,19},{-60,19}}, color={0,0,0}),
                    Line(points={{-91,34},{-71,34}}, color={0,0,0}),
                    Line(points={{-81,-11},{-61,-11}},
                                                     color={0,0,0}),
                    Line(points={{-71,-11},{-71,-31}},
                                                     color={0,0,0}),
                    Text(
                      extent={{-61,69},{-21,57}},
                      lineColor={0,0,255},
                      textString="outer planet gear"),
                    Text(
                      extent={{-58,10},{-18,-2}},
                      lineColor={0,0,255},
                      textString="inner planet gear")}));
            end Ideal_Planetary_Double_Planet;

            model Ideal_Planetary_Double_Planet_ratio
              "Ideal planetary gear box. Double planet arrangement. Ratio input rather than teeth count"
              parameter Real ratio
                "torque front / torque rear .:or:. [(R-S)/S]";

              SI.AngularVelocity nSun "Sun Speed";
              SI.AngularVelocity nAnnulus "Annulus Speed";
              SI.AngularVelocity nCarrier "Carrier Speed";

              // kinematic relationship
              Modelica.Mechanics.Rotational.Interfaces.Flange_a sun
                "Flange of sun shaft"
                annotation (Placement(transformation(extent={{-111,-80},{-91,-60}},
                      rotation=0), iconTransformation(extent={{-110,-78},{-90,-58}})));
              Modelica.Mechanics.Rotational.Interfaces.Flange_a carrier
                "Flange of carrier shaft"
                annotation (Placement(transformation(extent={{-109,25},{-89,45}},
                      rotation=0), iconTransformation(extent={{-110,25},{-90,45}})));
              Modelica.Mechanics.Rotational.Interfaces.Flange_b annulus
                "Flange of annulus shaft"
                annotation (Placement(transformation(extent={{89,-81},{109,-61}},rotation=
                       0), iconTransformation(extent={{90,-78},{110,-58}})));

            equation
              sun.phi = ((1+ratio)*annulus.phi)-((ratio)*carrier.phi);
              nSun = der(sun.phi);
              nAnnulus = der(annulus.phi);
              nCarrier = der(carrier.phi);

              // torque balance (no inertias)
              annulus.tau = (-1)*(1+ratio)*sun.tau;
              carrier.tau = ratio*sun.tau;

              annotation (
                Documentation(info="<HTML>
<p>
The IdealPlanetary gear box is an ideal gear without inertia,
elasticity, damping or backlash consisting
of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
<b>planet</b> wheel located between sun and ring wheel. The bearing
of the planet wheel shaft is fixed in the planet <b>carrier</b>.
The component can be connected to other elements at the
sun, ring and/or carrier flanges. It is not possible to connect
to the planet wheel. If inertia shall not be neglected,
the sun, ring and carrier inertias can be easily added by attaching
inertias (= model Inertia) to the corresponding connectors.
The inertias of the planet wheels are always neglected.
</p>
<p>
The icon of the planetary gear signals that the sun and carrier
flanges are on the left side and the ring flange is on the right side
of the gear box. However, this component is generic and is valid
independantly how the flanges are actually placed (e.g., sun wheel
may be placed on the right side instead on the left side in reality).
</p>
<p>
The ideal planetary gearbox is uniquely defined by the ratio
of the number of ring teeth zr with respect to the number of
sun teeth zs. For example, if there are 100 ring teeth and
50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
zp has to fulfill the following relationship:
</p>
<pre>
   <b>zp := (zr - zs) / 2</b>
</pre>
<p>
Therefore, in the above example zp = 25 is required.
</p>
<p>
According to the overall convention, the positive direction of all
vectors, especially the absolute angular velocities and cut-torques
in the flanges, are along the axis vector displayed in the icon.
</p>

</HTML>
"),             Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{50,100},{10,-100}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,45},{-50,85}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-10,-38},{-50,-98}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-50,-58},{-100,-78}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{100,-58},{50,-78}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{50,100},{-50,105}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-80,70},{-50,60}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-90,35},{-70,35}}, color={0,0,0}),
                    Line(points={{-80,-10},{-60,-10}},
                                                     color={0,0,0}),
                    Line(points={{-70,-10},{-70,-30}},
                                                     color={0,0,0}),
                    Line(points={{-80,80},{-59,80}}, color={0,0,0}),
                    Line(points={{-70,100},{-70,80}}, color={0,0,0}),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(
                      extent={{-10,-15},{-50,25}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-80,10},{-50,0}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Line(points={{-80,20},{-59,20}}, color={0,0,0}),
                    Line(points={{-81,50},{-60,50}}, color={0,0,0}),
                    Line(points={{-70,50},{-70,20}},  color={0,0,0})}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}), graphics={
                    Rectangle(
                      extent={{49,99},{-51,104}},
                      lineColor={160,160,164},
                      fillColor={160,160,164},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-11,44},{-51,84}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-81,69},{-51,59}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-81,9},{-51,-1}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-11,-16},{-51,24}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{49,99},{9,-101}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{99,-59},{49,-79}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-11,-39},{-51,-99}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Rectangle(
                      extent={{-51,-59},{-101,-79}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={192,192,192}),
                    Text(
                      extent={{14,77},{54,65}},
                      lineColor={0,0,255},
                      textString="annulus gear"),
                    Text(
                      extent={{-112,111},{-56,87}},
                      textString="planet carrier ",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-50,-63},{-6,-77}},
                      textString="sun gear",
                      lineColor={0,0,255}),
                    Polygon(
                      points={{58,130},{28,140},{28,120},{58,130}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-52,130},{28,130}}, color={0,0,0}),
                    Line(
                      points={{-92,93},{-88,34}},
                      pattern=LinePattern.Dot,
                      color={0,0,255}),
                    Polygon(
                      points={{-20,-104},{-40,-99},{-40,-109},{-20,-104}},
                      lineColor={128,128,128},
                      fillColor={128,128,128},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-110,-104},{-39,-104}},
                                                       color={128,128,128}),
                    Text(
                      extent={{-109,-89},{-41,-102}},
                      lineColor={128,128,128},
                      textString="rotation axis"),
                    Line(points={{-81,79},{-60,79}}, color={0,0,0}),
                    Line(points={{-71,99},{-71,79}},  color={0,0,0}),
                    Line(points={{-82,49},{-61,49}}, color={0,0,0}),
                    Line(points={{-71,49},{-71,19}},  color={0,0,0}),
                    Line(points={{-81,19},{-60,19}}, color={0,0,0}),
                    Line(points={{-91,34},{-71,34}}, color={0,0,0}),
                    Line(points={{-81,-11},{-61,-11}},
                                                     color={0,0,0}),
                    Line(points={{-71,-11},{-71,-31}},
                                                     color={0,0,0}),
                    Text(
                      extent={{-61,69},{-21,57}},
                      lineColor={0,0,255},
                      textString="outer planet gear"),
                    Text(
                      extent={{-58,10},{-18,-2}},
                      lineColor={0,0,255},
                      textString="inner planet gear")}));
            end Ideal_Planetary_Double_Planet_ratio;
          end Planetaries;

          model Dyno
            "Simple dynamometer model that uses a controller to apply a flange load to achieve a requested speed."
            extends Interfaces.PartialOneFlangeAndSupport_Left;
            Modelica.Blocks.Interfaces.RealInput request_speed "In rad/s" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={0,120})));
            Modelica.Blocks.Continuous.LimPID
                                          PI(
              k=k,
              Ti=Ti,
              yMax=max_res_trq,
              yMin=max_mot_trq,
              y_start=trq_start,
              Td=Td,
              controllerType=controllerType,
              initType=initType)
              annotation (Placement(transformation(extent={{20,50},{40,70}})));
            Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-80,20})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=true)
                                                                annotation (Placement(
                  transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=180,
                  origin={0,0})));
            parameter Real k=1 "Gain of controller";
            parameter SI.Time Ti=0.1 "Time constant of integrator block";
            parameter Real max_res_trq=1000 "Maximum resisting torque";
            parameter Real max_mot_trq=-max_res_trq "Maximum motoring torque";
            parameter Real trq_start=0 "Initial value of torque output";
            parameter SI.Time Td=1 "Time constant of derivative block";
            parameter Modelica.Blocks.Types.SimpleController controllerType=Modelica.Blocks.Types.SimpleController.PID
              "Type of controller";
            Modelica.Blocks.Interfaces.RealOutput actual_speed annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-100,110})));
            Modelica.Blocks.Interfaces.RealOutput actual_torque annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-50,110})));
            parameter Modelica.Blocks.Types.InitPID initType=Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
              "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
            Modelica.Mechanics.Rotational.Components.Inertia inertia(J=J, w(fixed=true,
                  start=w)) if                                               use_inertia
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
            parameter Boolean use_inertia=true
              "= True, if inertia should be added to flange";
            parameter SI.Inertia J "Moment of inertia"
              annotation (Dialog(enable=use_inertia));
            parameter SI.AngularVelocity w=1 "start speed";
          equation
            connect(request_speed, PI.u_s) annotation (Line(
                points={{0,120},{0,60},{18,60}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(speedSensor.w, PI.u_m) annotation (Line(
                points={{-80,31},{-80,40},{30,40},{30,48}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(torque.tau, PI.y) annotation (Line(
                points={{12,-1.46958e-015},{12,0},{60,0},{60,60},{41,60}},
                color={0,0,127},
                smooth=Smooth.None));

            connect(speedSensor.flange, flange) annotation (Line(
                points={{-80,10},{-80,0},{-100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(flange, torque.flange) annotation (Line(
                points={{-100,0},{-78,0},{-78,1.22465e-015},{-10,1.22465e-015}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torque.support, internalSupport) annotation (Line(
                points={{-1.33227e-015,-10},{-1.33227e-015,-20},{0,-20},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(actual_speed, speedSensor.w) annotation (Line(
                points={{-100,110},{-100,80},{-80,80},{-80,31}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(PI.y, actual_torque) annotation (Line(
                points={{41,60},{60,60},{60,80},{-50,80},{-50,110}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia.flange_a, flange) annotation (Line(
                points={{-80,-20},{-80,0},{-100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics), Icon(graphics={Rectangle(extent={{-100,100},{
                        100,-100}}, lineColor={0,0,255}), Text(
                    extent={{-180,40},{180,-40}},
                    lineColor={0,0,255},
                    textString="DYNO")}));
          end Dyno;

          model Pulley_System_1D
            "1D rotational pulley system with up to 6 selectable pulleys.  Includes optional losses and inertia.  Change direction using -ve diameters."
            extends
              C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.Partial_Support;
            parameter Boolean use_pulley_2=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_3=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_4=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_5=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_6=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter SI.Length drive_pulley_diameter = 0.05
              "Diameter of the nominally driven pulley" annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)"));
            parameter SI.Length pulley_1_diameter = 0.05 "Diameter of pulley 1"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)"));
            parameter SI.Length pulley_2_diameter = 0.05 "Diameter of pulley 2"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_2));
            parameter SI.Length pulley_3_diameter = 0.05 "Diameter of pulley 3"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_3));
            parameter SI.Length pulley_4_diameter = 0.05 "Diameter of pulley 4"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_4));
            parameter SI.Length pulley_5_diameter = 0.05 "Diameter of pulley 5"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_5));
            parameter SI.Length pulley_6_diameter = 0.05 "Diameter of pulley 6"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_6));
            parameter Real commonlossTable[:, 5]=[0, 1, 1, 0, 0]
              "Used for all pulleys unless overridden" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real drivenpulley_losses[:,5] = commonlossTable
              "Loss array for driven pulley"                                                            annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real pulley1_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 1" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real pulley2_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_2));
            parameter Real pulley3_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_3));
            parameter Real pulley4_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_4));
            parameter Real pulley5_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_5));
            parameter Real pulley6_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 6" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_6));

            Modelica.Mechanics.Rotational.Interfaces.Flange_a nominally_driven_pulley
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_1_flange
              annotation (Placement(transformation(extent={{90,90},{110,110}}),
                  iconTransformation(extent={{90,90},{110,110}})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley1(               ratio=
                  pulley_1_diameter/drive_pulley_diameter, lossTable=pulley1_lossTable,
              useSupport=true,
              use_environment_heat_port=true)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,100})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley2(               ratio=
                  pulley_2_diameter/drive_pulley_diameter, lossTable=pulley2_lossTable,
              useSupport=true,
              use_environment_heat_port=true) if                                           use_pulley_2
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,60})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley3(               ratio=
                  pulley_3_diameter/drive_pulley_diameter, lossTable=pulley3_lossTable,
              useSupport=true,
              use_environment_heat_port=true) if                                           use_pulley_3
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,20})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley4(               ratio=
                  pulley_4_diameter/drive_pulley_diameter, lossTable=pulley4_lossTable,
              useSupport=true,
              use_environment_heat_port=true) if                                           use_pulley_4
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-20})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley5(               ratio=
                  pulley_5_diameter/drive_pulley_diameter, lossTable=pulley5_lossTable,
              useSupport=true,
              use_environment_heat_port=true) if                                           use_pulley_5
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-60})));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley6(               ratio=
                  pulley_6_diameter/drive_pulley_diameter, lossTable=pulley6_lossTable,
              useSupport=true,
              use_environment_heat_port=true) if                                           use_pulley_6
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-100})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_2_flange if use_pulley_2
              annotation (Placement(transformation(extent={{90,50},{110,70}}),
                  iconTransformation(extent={{90,50},{110,70}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_3_flange if use_pulley_3
              annotation (Placement(transformation(extent={{90,10},{110,30}}),
                  iconTransformation(extent={{90,12},{110,32}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_4_flange if use_pulley_4
              annotation (Placement(transformation(extent={{90,-30},{110,-10}}),
                  iconTransformation(extent={{90,-30},{110,-10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_5_flange if use_pulley_5
              annotation (Placement(transformation(extent={{90,-70},{110,-50}}),
                  iconTransformation(extent={{90,-70},{110,-50}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_6_flange if use_pulley_6
              annotation (Placement(transformation(extent={{90,-110},{110,-90}}),
                  iconTransformation(extent={{90,-110},{110,-90}})));
            parameter Boolean use_inertia = false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Effective lumped inertia seen at driven pulley (optional)"));
            Modelica.Mechanics.Rotational.Components.Inertia inertia(J=lumped_inertia) if use_inertia
              annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            parameter SI.Inertia lumped_inertia = 0.1
              "Lumped Moment of Inertia as seen by the drive pulley"
              annotation (Dialog(enable=use_inertia, group="Effective lumped inertia seen at driven pulley (optional)"));
            Gear_Ratios.Lossy_Gear_With_Environment_simple     pulley_driven(ratio=1,
                lossTable=drivenpulley_losses,
              useSupport=true,
              use_environment_heat_port=true)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={0,0})));
          equation
            connect(pulley4.flange_b, pulley_4_flange)
                                                    annotation (Line(
                points={{80,-20},{100,-20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.flange_b, pulley_3_flange)
                                                    annotation (Line(
                points={{80,20},{100,20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_2_flange, pulley2.flange_b)
                                                    annotation (Line(
                points={{100,60},{80,60}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley1.flange_b, pulley_1_flange)
                                                  annotation (Line(
                points={{80,100},{100,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.flange_b, pulley_6_flange) annotation (Line(
                points={{80,-100},{100,-100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.flange_b, pulley_5_flange) annotation (Line(
                points={{80,-60},{100,-60}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(nominally_driven_pulley, pulley_driven.flange_a) annotation (Line(
                points={{-100,0},{-10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_driven.flange_b, pulley1.flange_a) annotation (Line(
                points={{10,0},{50,0},{50,100},{60,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley2.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,60},{50,60},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,20},{50,20},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley4.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-20},{50,-20},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-60},{50,-60},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-100},{50,-100},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia.flange_b, pulley_driven.flange_b) annotation (Line(
                points={{10,40},{20,40},{20,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_driven.support, internalSupport) annotation (Line(
                points={{0,-10},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley1.support, internalSupport) annotation (Line(
                points={{70,90},{36,90},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley2.support, internalSupport) annotation (Line(
                points={{70,50},{36,50},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.support, internalSupport) annotation (Line(
                points={{70,10},{36,10},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley4.support, internalSupport) annotation (Line(
                points={{70,-30},{36,-30},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.support, internalSupport) annotation (Line(
                points={{70,-70},{36,-70},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.support, internalSupport) annotation (Line(
                points={{70,-110},{36,-110},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(support, support) annotation (Line(
                points={{0,-100},{0,-100},{0,-100}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                      -100},{100,100}}), graphics),
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}),
                  graphics={
                  Line(
                    points={{-28,-66},{-72,-4}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-70,10},{-42,66}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-4,56},{0,4}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{36,2},{44,50}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{56,-6},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{84,-40},{56,-14}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-2,-78},{72,-70}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Ellipse(
                    extent={{-32,-78},{22,-28}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-72,-16},{-36,20}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{54,-16},{66,-4}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-44,38},{-4,76}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{0,-14},{36,22}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{44,30},{80,66}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{52,-70},{88,-34}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{-98,0},{-80,0},{-80,-54},{-4,-54}},
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.Dash),
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}),
                  Text(
                    extent={{-140,160},{140,100}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end Pulley_System_1D;

          model Efficiency_Loss_Controlled
            "Applies an efficiency loss to rotational energy flowing through it, efficiency (0-1) supplied on a signal port"
            extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(
                thermal_To_Environment(area_for_heat_transfer=0.1));
            extends
              Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

            parameter SI.Area area_for_heat_transfer = 0.1
              "Area available for heat transfer to the environment";
            extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

            Gear_Ratios.Lossy_Gear_With_Variable_Efficiency    lossyGear(
                useSupport=useSupport,
                useHeatPort=useHeatPort or use_environment_heat_port,
              ratio=1)
              annotation (Placement(transformation(extent={{-12,-10},{10,10}})));
            Modelica.Blocks.Interfaces.RealInput efficiency "between 0 and 1"
              annotation (Placement(transformation(
                  extent={{-21,-20},{21,20}},
                  rotation=270,
                  origin={-1,116}),iconTransformation(
                  extent={{-21,-20},{21,20}},
                  rotation=270,
                  origin={41,120})));
          equation
            if not useHeatPort then
              lossPower = lossyGear.lossPower;
            end if;
            connect(flange_a, lossyGear.flange_a) annotation (Line(
                points={{-100,0},{-12,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(lossyGear.flange_b, flange_b) annotation (Line(
                points={{10,0},{100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(heatPort, lossyGear.heatPort) annotation (Line(
                points={{-100,-100},{-100,-55},{-12,-55},{-12,-10}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(lossyGear.heatPort, thermal_To_Environment.solid) annotation (Line(
                points={{-12,-10},{-12,-90},{40,-90}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(lossyGear.support, internalSupport) annotation (Line(
                points={{-1,-10},{0,-10},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(efficiency, lossyGear.efficiency) annotation (Line(
                points={{-1,116},{-1,64},{-1,64},{-1,12}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={
                  Polygon(
                    points={{-109,40},{-80,40},{-80,80},{-90,80},{-70,100},{-50,80},{-60,
                        80},{-60,20},{-109,20},{-109,40}},
                    lineColor={0,0,0},
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid),
                   Polygon(
                     points={{-22,174},{-36,184},{-54,182},{-62,176},{-64,174},{-72,176},
                        {-74,176},{-82,176},{-88,172},{-96,176},{-106,178},{-120,174},{
                        -128,164},{-128,156},{-124,148},{-118,142},{-116,142},{-112,138},
                        {-112,134},{-116,126},{-114,112},{-104,102},{-92,100},{-80,102},{
                        -74,108},{-70,112},{-62,108},{-50,108},{-38,112},{-28,118},{-26,
                        132},{-28,142},{-30,144},{-32,146},{-22,152},{-18,162},{-20,172},
                        {-22,174}},
                     lineColor={0,0,0},
                     smooth=Smooth.Bezier,
                     lineThickness=0.5),
                   Line(
                     points={{-28,138},{-30,140},{-38,148},{-40,150},{-52,152},{-64,148},
                        {-74,142},{-78,130},{-76,120},{-70,114},{-68,112}},
                     color={0,0,0},
                     smooth=Smooth.Bezier),
                   Line(
                     points={{-76,138},{-86,144},{-94,144},{-104,142},{-108,138},{-112,
                        134}},
                     color={0,0,0},
                     smooth=Smooth.Bezier),
                   Line(
                     points={{-90,144},{-86,150},{-84,158},{-84,164},{-88,170},{-92,174}},
                     color={0,0,0},
                     smooth=Smooth.Bezier),
                   Line(
                     points={{-60,150},{-66,156},{-68,166},{-66,172},{-64,174}},
                     color={0,0,0},
                     smooth=Smooth.Bezier),
                  Text(
                    extent={{-126,180},{-16,114}},
                    lineColor={0,0,0},
                    textString="env"),
                Rectangle(
                  extent={{-100,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Line(points={{-20,20},{20,20}},  color={0,0,0}),
                Line(points={{-20,-20},{20,-20}},color={0,0,0}),
                Line(points={{-74,10},{-10,10}}, color={0,0,0},
                    origin={10,-10},
                    rotation=90),                         Text(
                    extent={{-52,100},{126,66}},
                    lineColor={0,0,0},
                    textString="eff")}));
          end Efficiency_Loss_Controlled;

          model Pulley_System_1D_ideal
            "1D rotational pulley system with up to 6 selectable pulleys.  Includes optional losses and inertia.  Change direction using -ve diameters."
            extends
              C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.Partial_Support;
            parameter Boolean use_pulley_2=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_3=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_4=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_5=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter Boolean use_pulley_6=false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Select Pulleys"));
            parameter SI.Length drive_pulley_diameter = 0.05
              "Diameter of the nominally driven pulley" annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)"));
            parameter SI.Length pulley_1_diameter = 0.05 "Diameter of pulley 1"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)"));
            parameter SI.Length pulley_2_diameter = 0.05 "Diameter of pulley 2"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_2));
            parameter SI.Length pulley_3_diameter = 0.05 "Diameter of pulley 3"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_3));
            parameter SI.Length pulley_4_diameter = 0.05 "Diameter of pulley 4"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_4));
            parameter SI.Length pulley_5_diameter = 0.05 "Diameter of pulley 5"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_5));
            parameter SI.Length pulley_6_diameter = 0.05 "Diameter of pulley 6"
                                                                                annotation (
                Dialog(group="Pulley Diameters (Use negative diameter to place 'outside' of belt on pulley)",
                  enable=use_pulley_6));
            parameter Real commonlossTable[:, 5]=[0, 1, 1, 0, 0]
              "Used for all pulleys unless overridden" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real drivenpulley_losses[:,5] = commonlossTable
              "Loss array for driven pulley"                                                            annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real pulley1_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 1" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]"));
            parameter Real pulley2_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_2));
            parameter Real pulley3_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_3));
            parameter Real pulley4_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_4));
            parameter Real pulley5_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 2" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_5));
            parameter Real pulley6_lossTable[:, 5]=commonlossTable
              "Loss array for pulley 6" annotation (
                Dialog(group="Pulley to belt loss tables vs speed [speed,fwd_eff,rev_eff,fwd_trq,rev_trq]",
                  enable=use_pulley_6));

            Modelica.Mechanics.Rotational.Interfaces.Flange_a nominally_driven_pulley
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_1_flange
              annotation (Placement(transformation(extent={{90,90},{110,110}}),
                  iconTransformation(extent={{90,90},{110,110}})));
            Modelica.Mechanics.Rotational.Components.IdealGear pulley1(               ratio=
                  pulley_1_diameter/drive_pulley_diameter, useSupport=true)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,100})));
            Modelica.Mechanics.Rotational.Components.IdealGear pulley2(               ratio=
                  pulley_2_diameter/drive_pulley_diameter, useSupport=true) if             use_pulley_2
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,60})));
            Modelica.Mechanics.Rotational.Components.IdealGear            pulley3(               ratio=
                  pulley_3_diameter/drive_pulley_diameter, useSupport=true) if             use_pulley_3
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,20})));
            Modelica.Mechanics.Rotational.Components.IdealGear            pulley4(               ratio=
                  pulley_4_diameter/drive_pulley_diameter, useSupport=true) if             use_pulley_4
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-20})));
            Modelica.Mechanics.Rotational.Components.IdealGear            pulley5(               ratio=
                  pulley_5_diameter/drive_pulley_diameter, useSupport=true) if             use_pulley_5
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-60})));
            Modelica.Mechanics.Rotational.Components.IdealGear            pulley6(               ratio=
                  pulley_6_diameter/drive_pulley_diameter, useSupport=true) if             use_pulley_6
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={70,-100})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_2_flange if use_pulley_2
              annotation (Placement(transformation(extent={{90,50},{110,70}}),
                  iconTransformation(extent={{90,50},{110,70}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_3_flange if use_pulley_3
              annotation (Placement(transformation(extent={{90,10},{110,30}}),
                  iconTransformation(extent={{90,12},{110,32}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_4_flange if use_pulley_4
              annotation (Placement(transformation(extent={{90,-30},{110,-10}}),
                  iconTransformation(extent={{90,-30},{110,-10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_5_flange if use_pulley_5
              annotation (Placement(transformation(extent={{90,-70},{110,-50}}),
                  iconTransformation(extent={{90,-70},{110,-50}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b pulley_6_flange if use_pulley_6
              annotation (Placement(transformation(extent={{90,-110},{110,-90}}),
                  iconTransformation(extent={{90,-110},{110,-90}})));
            parameter Boolean use_inertia = false
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),
              Dialog(group="Effective lumped inertia seen at driven pulley (optional)"));
            Modelica.Mechanics.Rotational.Components.Inertia inertia(J=lumped_inertia) if use_inertia
              annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            parameter SI.Inertia lumped_inertia = 0.1
              "Lumped Moment of Inertia as seen by the drive pulley"
              annotation (Dialog(enable=use_inertia, group="Effective lumped inertia seen at driven pulley (optional)"));
            Modelica.Mechanics.Rotational.Components.IdealGear pulley_driven(ratio=1,
              useSupport=true)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={0,0})));
          equation
            connect(pulley4.flange_b, pulley_4_flange)
                                                    annotation (Line(
                points={{80,-20},{100,-20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.flange_b, pulley_3_flange)
                                                    annotation (Line(
                points={{80,20},{100,20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_2_flange, pulley2.flange_b)
                                                    annotation (Line(
                points={{100,60},{80,60}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley1.flange_b, pulley_1_flange)
                                                  annotation (Line(
                points={{80,100},{100,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.flange_b, pulley_6_flange) annotation (Line(
                points={{80,-100},{100,-100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.flange_b, pulley_5_flange) annotation (Line(
                points={{80,-60},{100,-60}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(nominally_driven_pulley, pulley_driven.flange_a) annotation (Line(
                points={{-100,0},{-10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_driven.flange_b, pulley1.flange_a) annotation (Line(
                points={{10,0},{50,0},{50,100},{60,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley2.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,60},{50,60},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,20},{50,20},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley4.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-20},{50,-20},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-60},{50,-60},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.flange_a, pulley_driven.flange_b) annotation (Line(
                points={{60,-100},{50,-100},{50,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia.flange_b, pulley_driven.flange_b) annotation (Line(
                points={{10,40},{20,40},{20,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley_driven.support, internalSupport) annotation (Line(
                points={{0,-10},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley1.support, internalSupport) annotation (Line(
                points={{70,90},{36,90},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley2.support, internalSupport) annotation (Line(
                points={{70,50},{36,50},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley3.support, internalSupport) annotation (Line(
                points={{70,10},{36,10},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley4.support, internalSupport) annotation (Line(
                points={{70,-30},{36,-30},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley5.support, internalSupport) annotation (Line(
                points={{70,-70},{36,-70},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pulley6.support, internalSupport) annotation (Line(
                points={{70,-110},{36,-110},{36,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                      -100},{100,100}}), graphics),
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}),
                  graphics={
                  Line(
                    points={{-28,-66},{-72,-4}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-70,10},{-42,66}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-4,56},{0,4}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{36,2},{44,50}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{56,-6},{80,44}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{84,-40},{56,-14}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Line(
                    points={{-2,-78},{72,-70}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    thickness=0.5),
                  Ellipse(
                    extent={{-32,-78},{22,-28}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-72,-16},{-36,20}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{54,-16},{66,-4}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-44,38},{-4,76}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{0,-14},{36,22}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{44,30},{80,66}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{52,-70},{88,-34}},
                    fillColor={255,230,230},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{-98,0},{-80,0},{-80,-54},{-4,-54}},
                    smooth=Smooth.None,
                    color={0,0,0},
                    pattern=LinePattern.Dash),
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}),
                  Text(
                    extent={{-140,160},{140,100}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end Pulley_System_1D_ideal;

          model Damper_Adjustable
            "Rotational damper with a signal input to control damping"

            Modelica.Blocks.Interfaces.RealInput u annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=90,
                  origin={10,-50})));
            extends
              Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
            SI.RotationalDampingConstant d(final min=0, start=0)
              "Damping constant";
            extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
          equation
            d = u;
            tau = d*w_rel;
            lossPower = tau*w_rel;
            annotation (
              Documentation(info="<html>
<p>The same as MSL component Mechanics.Rotational.Components.Damper except the damping coefficient is adjustable using the input port &apos;u&apos;.</p>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(points={{-90,0},{-60,0}}, color={0,0,0}),
                  Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                  Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                  Line(points={{-60,30},{60,30}}, color={0,0,0}),
                  Rectangle(
                    extent={{-60,30},{30,-30}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{30,0},{90,0}}, color={0,0,0}),
                  Text(
                    extent={{-150,80},{150,40}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(visible=useHeatPort,
                    points={{-100,-100},{-100,-40},{-20,-40},{-20,0}},
                    color={191,0,0},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dot)}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(points={{-96,0},{-60,0}}, color={0,0,0}),
                  Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                  Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                  Line(points={{-60,30},{60,30}}, color={0,0,0}),
                  Rectangle(
                    extent={{-60,30},{30,-30}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{30,0},{96,0}}, color={0,0,0}),
                  Line(points={{-70,0},{-70,65}}, color={128,128,128}),
                  Text(
                    extent={{-40,66},{40,86}},
                    lineColor={0,0,255},
                    textString="phi_rel"),
                  Line(points={{-70,60},{70,60}}, color={128,128,128}),
                  Line(points={{70,0},{70,65}}, color={128,128,128}),
                  Polygon(
                    points={{60,63},{70,60},{60,57},{60,63}},
                    lineColor={128,128,128},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid)}));
          end Damper_Adjustable;
        end Components;

        package Icons
          extends Modelica.Icons.Package;

          partial class Gear "Rotational gear icon"

          annotation (             Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(
                  extent={{-40,20},{-20,-20}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-40,100},{-20,20}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{20,80},{40,39}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{20,40},{40,-40}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{40,10},{100,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-20,70},{20,50}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,10},{-40,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Line(points={{-80,20},{-60,20}}, color={0,0,0}),
                Line(points={{-80,-20},{-60,-20}}, color={0,0,0}),
                Line(points={{-70,-20},{-70,-86}}, color={0,0,0}),
                Line(points={{0,40},{0,-86}},  color={0,0,0}),
                Line(points={{-10,40},{10,40}}, color={0,0,0}),
                Line(points={{-10,80},{10,80}}, color={0,0,0}),
                Line(points={{60,-20},{80,-20}}, color={0,0,0}),
                Line(points={{60,20},{80,20}}, color={0,0,0}),
                Line(points={{70,-20},{70,-86}}, color={0,0,0}),
                Line(points={{70,-86},{-70,-86}}, color={0,0,0})}),
            Documentation(info="<html>
<p>
This is the icon of a gear from the rotational package.
</p>
</html>"));
          end Gear;

          model Multi_Plate_Clutch "Icon for a multi plate clutch"

            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={ Line(visible=useHeatPort,
                    points={{-100,-100},{-100,-40},{0,-40}},
                    color={191,0,0},
                    pattern=LinePattern.Dot,
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-99,10},{41,-10}},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-3,40},{5,-40}},
                    pattern=LinePattern.None,
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-39,40},{41,34}},
                    pattern=LinePattern.None,
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-39,-34},{41,-40}},
                    pattern=LinePattern.None,
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-31,86},{81,80}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{75,86},{81,-80}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-31,-80},{81,-86}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{81,20},{101,-20}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{33,80},{41,44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{25,76},{33,40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{17,80},{25,44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{9,76},{17,40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{1,80},{9,44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-7,76},{1,40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-15,80},{-7,44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-23,76},{-15,40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-31,80},{-23,44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-39,76},{-31,40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-39,-76},{-31,-40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-31,-80},{-23,-44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-23,-76},{-15,-40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-15,-80},{-7,-44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{-7,-76},{1,-40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{1,-80},{9,-44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{9,-76},{17,-40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{17,-80},{25,-44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{25,-76},{33,-40}},
                    pattern=LinePattern.None,
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135}),
                  Rectangle(
                    extent={{33,-80},{41,-44}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={135,135,135})}),
              Documentation(info="<html>
<p>
This component models a <b>clutch</b>, i.e., a component with
two flanges where friction is present between the two flanges
and these flanges are pressed together via a normal force.
The normal force fn has to be provided as input signal f_normalized in a normalized form
(0 &le; f_normalized &le; 1),
fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
clutch is modelled in the following way:
</p>
<p>
When the relative angular velocity is not zero, the friction torque is a
function of the velocity dependent friction coefficient  mue(w_rel) , of
the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
account the geometry of the device and the assumptions on the friction
distributions:
</p>
<pre>
        frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
</pre>
<p>
   Typical values of coefficients of friction:
</p>
<pre>
      dry operation   :  <b>mue</b> = 0.2 .. 0.4
      operating in oil:  <b>mue</b> = 0.05 .. 0.1
</pre>
<p>
   When plates are pressed together, where  <b>ri</b>  is the inner radius,
   <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
   the geometry constant is calculated in the following way under the
   assumption of a uniform rate of wear at the interfaces:
</p>
<pre>
         <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
</pre>
<p>
    The positive part of the friction characteristic <b>mue</b>(w_rel),
    w_rel >= 0, is defined via table mue_pos (first column = w_rel,
    second column = mue). Currently, only linear interpolation in
    the table is supported.
</p>
<p>
   When the relative angular velocity becomes zero, the elements
   connected by the friction element become stuck, i.e., the relative
   angle remains constant. In this phase the friction torque is
   calculated from a torque balance due to the requirement, that
   the relative acceleration shall be zero.  The elements begin
   to slide when the friction torque exceeds a threshold value,
   called the  maximum static friction torque, computed via:
</p>
<pre>
       frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
</pre>
<p>
This procedure is implemented in a \"clean\" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled. The method is described in:
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
<dd><b>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
</dl>
<p>
More precise friction models take into account the elasticity of the
material when the two elements are \"stuck\", as well as other effects,
like hysteresis. This has the advantage that the friction element can
be completely described by a differential equation without events. The
drawback is that the system becomes stiff (about 10-20 times slower
simulation) and that more material constants have to be supplied which
requires more sophisticated identification. For more details, see the
following references, especially (Armstrong and Canudas de Witt 1996):
</p>
<dl>
<dt>Armstrong B. (1991):
<dd><b>Control of Machines with Friction</b>. Kluwer Academic
    Press, Boston MA.<br><br>
<dt>Armstrong B., and Canudas de Wit C. (1996):
<dd><b>Friction Modeling and Compensation.</b>
    The Control Handbook, edited by W.S.Levine, CRC Press,
    pp. 1369-1382.<br><br>
<dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
<dd><b>A new model for control of systems with friction.</b>
    IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
</dl>
<br>

</HTML>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics));
          end Multi_Plate_Clutch;
        end Icons;

        package Interfaces
          "Provides extensions to the MSL package of the same name"
        extends Modelica.Icons.InterfacesPackage;

          partial model PartialOneFlangeAndSupport_Left
            "Same as PartialOneFlangeAndSupport in the MSL except for the flange is on the left"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a flange
              "Flange of shaft"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                                                                               rotation=0),
                  iconTransformation(extent={{-110,-10},{-90,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
              "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
          equation
            connect(support, internalSupport) annotation (Line(
                points={{0,-100},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, fixed.flange) annotation (Line(
                points={{0,-80},{20,-80},{20,-84}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              Documentation(info="<html>
<p>
This is a 1-dim. rotational component with one flange and a support/housing.
It is used e.g., to build up parts of a drive train graphically consisting
of several components.
</p>

<p>
If <i>useSupport=true</i>, the support connector is conditionally enabled
and needs to be connected.<br>
If <i>useSupport=false</i>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>

</html>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={Text(
                    extent={{-38,-98},{-6,-96}},
                    lineColor={95,95,95},
                    textString="(if useSupport)"), Text(
                    extent={{21,-95},{61,-96}},
                    lineColor={95,95,95},
                    textString="(if not useSupport)")}),
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    visible=not useSupport,
                    points={{-50,-120},{-30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-120},{-10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-10,-120},{10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{10,-120},{30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-100},{30,-100}},
                    color={0,0,0})}));
          end PartialOneFlangeAndSupport_Left;

          partial model Partial_Support
            "Partial model for a support used for graphical modeling, i.e., the model is build up by drag-and-drop from elementary components"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
              "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
          equation
            connect(support, internalSupport) annotation (Line(
                points={{0,-100},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, fixed.flange) annotation (Line(
                points={{0,-80},{20,-80},{20,-84}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              Documentation(info="<html>
<p>
This is a 1-dim. rotational component with one flange and a support/housing.
It is used e.g., to build up parts of a drive train graphically consisting
of several components.
</p>

<p>
If <i>useSupport=true</i>, the support connector is conditionally enabled
and needs to be connected.<br>
If <i>useSupport=false</i>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>

</html>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={Text(
                    extent={{-38,-98},{-6,-96}},
                    lineColor={95,95,95},
                    textString="(if useSupport)"), Text(
                    extent={{21,-95},{61,-96}},
                    lineColor={95,95,95},
                    textString="(if not useSupport)")}),
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    visible=not useSupport,
                    points={{-50,-120},{-30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-120},{-10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-10,-120},{10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{10,-120},{30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-100},{30,-100}},
                    color={0,0,0})}));
          end Partial_Support;

          partial model PartialOneFlangeAndSupport_Top
            "Same as PartialOneFlangeAndSupport in the MSL except for the flange is on the left"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a flange
              "Flange of shaft"
              annotation (Placement(transformation(extent={{-10,90},{10,110}}, rotation=0),
                  iconTransformation(extent={{-10,90},{10,110}})));
            Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
              "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
            Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-94},{30,-74}})));
          equation
            connect(support, internalSupport) annotation (Line(
                points={{0,-100},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, fixed.flange) annotation (Line(
                points={{0,-80},{20,-80},{20,-84}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              Documentation(info="<html>
<p>
This is a 1-dim. rotational component with one flange and a support/housing.
It is used e.g., to build up parts of a drive train graphically consisting
of several components.
</p>

<p>
If <i>useSupport=true</i>, the support connector is conditionally enabled
and needs to be connected.<br>
If <i>useSupport=false</i>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>

</html>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={Text(
                    extent={{-38,-98},{-6,-96}},
                    lineColor={95,95,95},
                    textString="(if useSupport)"), Text(
                    extent={{21,-95},{61,-96}},
                    lineColor={95,95,95},
                    textString="(if not useSupport)")}),
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    visible=not useSupport,
                    points={{-50,-120},{-30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-120},{-10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-10,-120},{10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{10,-120},{30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-100},{30,-100}},
                    color={0,0,0})}));
          end PartialOneFlangeAndSupport_Top;

          partial model PartialElementaryOneFlangeAndSupport_Top
            "Partial model for a component with one rotational 1-dim. shaft flange and a support used for textual modeling, i.e., for elementary models"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
              "Flange of shaft"
              annotation (Placement(transformation(extent={{-10,90},{10,110}}, rotation=0)));
            Modelica.Mechanics.Rotational.Interfaces.Support support(phi=phi_support, tau=
                 -flange.tau) if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.SIunits.Angle phi_support
              "Absolute angle of support flange";
          equation
            if not useSupport then
               phi_support = 0;
            end if;
            annotation (
              Documentation(info="<html>
<p>
This is a 1-dim. rotational component with one flange and a support/housing.
It is used to build up elementary components of a drive train with
equations in the text layer.
</p>

<p>
If <i>useSupport=true</i>, the support connector is conditionally enabled
and needs to be connected.<br>
If <i>useSupport=false</i>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>

</html>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics),
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    visible=not useSupport,
                    points={{-50,-120},{-30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-120},{-10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-10,-120},{10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{10,-120},{30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-100},{30,-100}},
                    color={0,0,0})}));
          end PartialElementaryOneFlangeAndSupport_Top;
        end Interfaces;
      end Rotational;

      package Translational
        "Components that extend the capabilities of the similarly named package in the MSL"
          extends Modelica.Icons.Package;

        package Components "Translational mechanical components"
            extends Modelica.Icons.Package;

          model Quadratic_Damper
            "1D translational damper with a linear resistance (d*v) and quadratic (dq * v * |v|)"
            extends
              Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates;
            parameter SI.TranslationalDampingConstant d(final min=0, start = 0)
              "Damping constant";
            parameter Real dq(final min=0, start = 0, unit="N.s2/m2")
              "Quadratic damping constant (d) in f = d * v * |v|";

          equation
            f = (d * v_rel) +  dq*(v_rel * abs(v_rel));

            annotation (
              Documentation(info="<html>
<p>
<i>Linear, velocity dependent damper</i> element. It can be either connected
between a sliding mass and the housing (model Fixed), or
between two sliding masses.
</p>

</HTML>
"),           Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={
                  Line(points={{-90,0},{-60,0}}, color={0,0,0}),
                  Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                  Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                  Line(points={{-60,30},{60,30}}, color={0,0,0}),
                  Rectangle(
                    extent={{-60,30},{30,-30}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{30,0},{90,0}}, color={0,0,0}),
                  Polygon(
                    points={{50,-90},{20,-80},{20,-100},{50,-90}},
                    lineColor={128,128,128},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-60,-90},{20,-90}}, color={0,0,0}),
                  Text(
                    extent={{-150,90},{150,50}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-150,-45},{150,-75}},
                    lineColor={0,0,0},
                    textString="d=%d"),
                  Line(visible=useHeatPort,
                    points={{-100,-100},{-100,-20},{-14,-20}},
                    color={191,0,0},
                    pattern=LinePattern.Dot,
                    smooth=Smooth.None)}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={
                  Line(points={{-90,0},{-60,0}}, color={0,0,0}),
                  Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                  Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                  Line(points={{-60,30},{60,30}}, color={0,0,0}),
                  Rectangle(
                    extent={{-60,30},{30,-30}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{30,0},{90,0}}, color={0,0,0}),
                  Line(points={{-50,60},{50,60}}, color={128,128,128}),
                  Polygon(
                    points={{50,63},{60,60},{50,57},{50,63}},
                    lineColor={128,128,128},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-58,68},{42,78}},
                    lineColor={128,128,128},
                    textString="der(s_rel)")}));
          end Quadratic_Damper;
        end Components;

        package Interfaces
          "Holds extensions to the MSL package of the same name"
        extends Modelica.Icons.InterfacesPackage;
          partial model PartialElementaryOneFlangeAndSupport_Top
            "Same as PartialElementaryOneFlangeAndSupport2 in MSL but with flange at top"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
                annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.SIunits.Length s = flange.s - s_support
              "Distance between flange and support (= flange.s - support.s)";
            Modelica.Mechanics.Translational.Interfaces.Flange_b flange
              "Flange of component"
              annotation (Placement(transformation(extent={{-10,90},{10,110}},
                    rotation=0)));
            Modelica.Mechanics.Translational.Interfaces.Support support(s=s_support, f=-
                  flange.f) if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.SIunits.Length s_support
              "Absolute position of support flange";
          equation
            if not useSupport then
               s_support = 0;
            end if;

            annotation (
              Documentation(info="<html>
<p>
This is a 1-dim. translational component with one flange and a support/housing.
It is used to build up elementary components of a drive train with
equations in the text layer.
</p>

<p>
If <i>useSupport=true</i>, the support connector is conditionally enabled
and needs to be connected.<br>
If <i>useSupport=false</i>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>

</HTML>
"),           Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics),
              Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    visible=not useSupport,
                    points={{-50,-120},{-30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-120},{-10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-10,-120},{10,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{10,-120},{30,-100}},
                    color={0,0,0}),
                  Line(
                    visible=not useSupport,
                    points={{-30,-100},{30,-100}},
                    color={0,0,0})}));
          end PartialElementaryOneFlangeAndSupport_Top;
        end Interfaces;
      end Translational;

      package Planar "Components for planar mechanical systems"
        extends Modelica.Icons.Package;

        model World
          "World coordinate system + gravity field + default animation definition"

          import SI = Modelica.SIunits;
        //   import C2M2L_OM.MSL_Extend.Mechanics.Planar.Types.GravityTypes;
           import Modelica.Mechanics.MultiBody.Types;

            Interfaces.Frame_b                              frame_b
            "Coordinate system fixed in the origin of the world frame"
                                       annotation (Placement(transformation(extent={{84,
                    -16},{116,16}}, rotation=0)));

          parameter Boolean enableAnimation=true
            "= true, if animation of all components is enabled";
          parameter Boolean animateWorld=true
            "= true, if world coordinate system shall be visualized" annotation(Dialog(enable=enableAnimation));
          parameter Boolean animateGravity=true
            "= true, if gravity field shall be visualized (acceleration vector or field center)"
                                                                                                  annotation(Dialog(enable=enableAnimation));
          parameter Types.AxisLabel label1="x"
            "Label of horizontal axis in icon";
          parameter Types.AxisLabel label2="y" "Label of vertical axis in icon";
        //   parameter Types.GravityTypes gravityType=C2M2L_OM.MSL_Extend.Mechanics.Planar.Types.GravityTypes.UniformGravity
        //     "Type of gravity field" annotation (Evaluate=true);
          parameter Modelica.SIunits.Acceleration g=9.81
            "Constant gravity acceleration"
            annotation (Dialog(enable=gravityType == C2M2L_OM.MSL_Extend.Mechanics.Planar.Types.GravityTypes.UniformGravity));
          parameter Real[2] n={0,-1}
            "Direction of gravity resolved in world frame (gravity = g*n/length(n))"
            annotation (Evaluate=true, Dialog(enable=gravityType == Modelica.Mechanics.
                  MultiBody.Types.GravityTypes.UniformGravity));
        //   parameter Real mue(
        //     unit="m3/s2",
        //     min=0) = 3.986e14
        //     "Gravity field constant (default = field constant of earth)"
        //     annotation (Dialog(enable=gravityType == C2M2L_OM.MSL_Extend.Mechanics.Planar.Types.GravityTypes.PointGravity));
          parameter Boolean driveTrainMechanics2D=true
            "= true, if 2-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account";

          parameter Modelica.SIunits.Distance axisLength=nominalLength/2
            "Length of world axes arrows"
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
          parameter Modelica.SIunits.Distance axisDiameter=axisLength/defaultFrameDiameterFraction
            "Diameter of world axes arrows"
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
          parameter Boolean axisShowLabels=true
            "= true, if labels shall be shown"
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
          input Types.Color axisColor_x=Modelica.Mechanics.MultiBody.Types.Defaults.FrameColor
            "Color of x-arrow"
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
          input Types.Color axisColor_y=axisColor_x
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));
          input Types.Color axisColor_z=axisColor_x "Color of z-arrow"
            annotation (Dialog(tab="Animation", group="if animateWorld = true", enable=enableAnimation and animateWorld));

          parameter Modelica.SIunits.Position gravityArrowTail[3]={0,0,0}
            "Position vector from origin of world frame to arrow tail, resolved in world frame"
            annotation (Dialog(tab="Animation", group=
                  "if animateGravity = true and gravityType = UniformGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.UniformGravity));
          parameter Modelica.SIunits.Length gravityArrowLength=axisLength/2
            "Length of gravity arrow"
            annotation (Dialog(tab="Animation", group=
                  "if animateGravity = true and gravityType = UniformGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.UniformGravity));
          parameter Modelica.SIunits.Diameter gravityArrowDiameter=gravityArrowLength/
              defaultWidthFraction "Diameter of gravity arrow" annotation (Dialog(tab=
                  "Animation", group=
                  "if animateGravity = true and gravityType = UniformGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.UniformGravity));
          input Types.Color gravityArrowColor={0,230,0}
            "Color of gravity arrow"
            annotation (Dialog(tab="Animation", group=
                  "if animateGravity = true and gravityType = UniformGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.UniformGravity));
          parameter Modelica.SIunits.Diameter gravitySphereDiameter=12742000
            "Diameter of sphere representing gravity center (default = mean diameter of earth)"
            annotation (Dialog(tab="Animation", group=
                  "if animateGravity = true and gravityType = PointGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.PointGravity));
          input Types.Color gravitySphereColor={0,230,0}
            "Color of gravity sphere"
            annotation (Dialog(tab="Animation", group=
                  "if animateGravity = true and gravityType = PointGravity",
                  enable=enableAnimation and animateGravity and gravityType == GravityTypes.PointGravity));

          parameter Modelica.SIunits.Length nominalLength=1
            "\"Nominal\" length of multi-body system"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultAxisLength=nominalLength/5
            "Default for length of a frame axis (but not world frame)"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultJointLength=nominalLength/10
            "Default for the fixed length of a shape representing a joint"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultJointWidth=nominalLength/20
            "Default for the fixed width of a shape representing a joint"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultForceLength=nominalLength/10
            "Default for the fixed length of a shape representing a force (e.g., damper)"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultForceWidth=nominalLength/20
            "Default for the fixed width of a shape represening a force (e.g., spring, bushing)"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultBodyDiameter=nominalLength/9
            "Default for diameter of sphere representing the center of mass of a body"
            annotation (Dialog(tab="Defaults"));
          parameter Real defaultWidthFraction=20
            "Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)"
            annotation (Dialog(tab="Defaults"));
          parameter Modelica.SIunits.Length defaultArrowDiameter=nominalLength/40
            "Default for arrow diameter (e.g., of forces, torques, sensors)"
            annotation (Dialog(tab="Defaults"));
          parameter Real defaultFrameDiameterFraction=40
            "Default for arrow diameter of a coordinate system as a fraction of axis length"
            annotation (Dialog(tab="Defaults"));
          parameter Real defaultSpecularCoefficient(min=0) = 0.7
            "Default reflection of ambient light (= 0: light is completely absorbed)"
            annotation (Dialog(tab="Defaults"));
          parameter Real defaultN_to_m(unit="N/m", min=0) = 1000
            "Default scaling of force arrows (length = force/defaultN_to_m)"
            annotation (Dialog(tab="Defaults"));
          parameter Real defaultNm_to_m(unit="N.m/m", min=0) = 1000
            "Default scaling of torque arrows (length = torque/defaultNm_to_m)"
            annotation (Dialog(tab="Defaults"));

        //   function gravityAcceleration =
        //       C2M2L_OM.MSL_Extend.Mechanics.Planar.Forces.Internal.standardGravityAcceleration
        //       (     gravityType=gravityType, g=g*Modelica.Math.Vectors.normalize(n,0.0), mue=mue);

          /* The World object can only use the Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape model, but no
     other models in package Modelica.Mechanics.MultiBody.Visualizers, since the other models access
     data of the "outer Modelica.Mechanics.MultiBody.World world" object, i.e., there are
     mutually dependent classes. For this reason, the higher level visualization
     objects cannot be used.
  */
        protected
          parameter Integer ndim=if enableAnimation and animateWorld then 1 else 0;
          parameter Integer ndim2=if enableAnimation and animateWorld and
              axisShowLabels then 1 else 0;

          // Parameters to define axes
          parameter Modelica.SIunits.Length headLength=min(axisLength, axisDiameter*Types.Defaults.
              FrameHeadLengthFraction);
          parameter Modelica.SIunits.Length headWidth=axisDiameter*Types.Defaults.
              FrameHeadWidthFraction;
          parameter Modelica.SIunits.Length lineLength=max(0, axisLength - headLength);
          parameter Modelica.SIunits.Length lineWidth=axisDiameter;

          // Parameters to define axes labels
          parameter Modelica.SIunits.Length scaledLabel=Modelica.Mechanics.MultiBody.Types.Defaults.FrameLabelHeightFraction*
              axisDiameter;
          parameter Modelica.SIunits.Length labelStart=1.05*axisLength;
          parameter Real[3] n_3d = cat(1,n,{0});
          // x-axis
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowLine(
            shapeType="cylinder",
            length=lineLength,
            width=lineWidth,
            height=lineWidth,
            lengthDirection={1,0,0},
            widthDirection={0,1,0},
            color=axisColor_x,
            specularCoefficient=0) if enableAnimation and animateWorld;
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowHead(
            shapeType="cone",
            length=headLength,
            width=headWidth,
            height=headWidth,
            lengthDirection={1,0,0},
            widthDirection={0,1,0},
            color=axisColor_x,
            r={lineLength,0,0},
            specularCoefficient=0) if enableAnimation and animateWorld;
          Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines x_label(
            lines=scaledLabel*{[0, 0; 1, 1],[0, 1; 1, 0]},
            diameter=axisDiameter,
            color=axisColor_x,
            r_lines={labelStart,0,0},
            n_x={1,0,0},
            n_y={0,1,0},
            specularCoefficient=0) if enableAnimation and animateWorld and axisShowLabels;

          // y-axis
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowLine(
            shapeType="cylinder",
            length=lineLength,
            width=lineWidth,
            height=lineWidth,
            lengthDirection={0,1,0},
            widthDirection={1,0,0},
            color=axisColor_y,
            specularCoefficient=0) if enableAnimation and animateWorld;
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowHead(
            shapeType="cone",
            length=headLength,
            width=headWidth,
            height=headWidth,
            lengthDirection={0,1,0},
            widthDirection={1,0,0},
            color=axisColor_y,
            r={0,lineLength,0},
            specularCoefficient=0) if enableAnimation and animateWorld;
          Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines y_label(
            lines=scaledLabel*{[0, 0; 1, 1.5],[0, 1.5; 0.5, 0.75]},
            diameter=axisDiameter,
            color=axisColor_y,
            r_lines={0,labelStart,0},
            n_x={0,1,0},
            n_y={-1,0,0},
            specularCoefficient=0) if enableAnimation and animateWorld and axisShowLabels;

        //   // z-axis
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowLine(
        //     shapeType="cylinder",
        //     length=lineLength,
        //     width=lineWidth,
        //     height=lineWidth,
        //     lengthDirection={0,0,1},
        //     widthDirection={0,1,0},
        //     color=axisColor_z,
        //     specularCoefficient=0) if enableAnimation and animateWorld;
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowHead(
        //     shapeType="cone",
        //     length=headLength,
        //     width=headWidth,
        //     height=headWidth,
        //     lengthDirection={0,0,1},
        //     widthDirection={0,1,0},
        //     color=axisColor_z,
        //     r={0,0,lineLength},
        //     specularCoefficient=0) if enableAnimation and animateWorld;
        //   Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines z_label(
        //     lines=scaledLabel*{[0, 0; 1, 0],[0, 1; 1, 1],[0, 1; 1, 0]},
        //     diameter=axisDiameter,
        //     color=axisColor_z,
        //     r_lines={0,0,labelStart},
        //     n_x={0,0,1},
        //     n_y={0,1,0},
        //     specularCoefficient=0) if enableAnimation and animateWorld and axisShowLabels;

          // Uniform gravity visualization
          parameter Modelica.SIunits.Length gravityHeadLength=min(gravityArrowLength,
              gravityArrowDiameter*Types.Defaults.ArrowHeadLengthFraction);
          parameter Modelica.SIunits.Length gravityHeadWidth=gravityArrowDiameter*Types.Defaults.ArrowHeadWidthFraction;
          parameter Modelica.SIunits.Length gravityLineLength=max(0, gravityArrowLength - gravityHeadLength);
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowLine(
            shapeType="cylinder",
            length=gravityLineLength,
            width=gravityArrowDiameter,
            height=gravityArrowDiameter,
            lengthDirection=n_3d,
            widthDirection={0,1,0},
            color=gravityArrowColor,
            r_shape=gravityArrowTail,
            specularCoefficient=0) if enableAnimation and animateGravity;
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowHead(
            shapeType="cone",
            length=gravityHeadLength,
            width=gravityHeadWidth,
            height=gravityHeadWidth,
            lengthDirection=n_3d,
            widthDirection={0,1,0},
            color=gravityArrowColor,
            r_shape=gravityArrowTail + Modelica.Math.Vectors.normalize(
                                                        n_3d)*gravityLineLength,
            specularCoefficient=0) if enableAnimation and animateGravity;

          // Point gravity visualization
        //   parameter Integer ndim_pointGravity=if enableAnimation and animateGravity
        //        and gravityType == 2 then 1 else 0;
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravitySphere(
        //     shapeType="sphere",
        //     r_shape={-gravitySphereDiameter/2,0,0},
        //     lengthDirection={1,0,0},
        //     length=gravitySphereDiameter,
        //     width=gravitySphereDiameter,
        //     height=gravitySphereDiameter,
        //     color=gravitySphereColor,
        //     specularCoefficient=0) if enableAnimation and animateGravity and gravityType == GravityTypes.PointGravity;

        /*
  function gravityAcceleration = gravityAccelerationTypes (
      gravityType=gravityType,
      g=g*Modelica.Math.Vectors.normalize(
                                     n),
      mue=mue);
*/

        equation
        //   Connections.root(frame_b.R);

          assert(Modelica.Math.Vectors.length(
                               n) > 1.e-10,
            "Parameter n of World object is wrong (lenght(n) > 0 required)");

        //   frame_b.r_0 = zeros(3);
        //   frame_b.R = Modelica.Mechanics.MultiBody.Frames.nullRotation();
          frame_b.s = zeros(2);
          frame_b.phi = 0;
          annotation (
            defaultComponentName="world",
            defaultComponentPrefixes="inner",
            missingInnerMessage="No \"world\" component is defined. A default world
component with the default gravity field will be used
(g=9.81 in negative y-axis). If this is not desired,
drag Modelica.Mechanics.MultiBody.World into the top level of your model.",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-100,-118},{-100,61}},
                  color={0,0,0},
                  thickness=0.5),
                Polygon(
                  points={{-100,100},{-120,60},{-80,60},{-100,100},{-100,100}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-119,-100},{59,-100}},
                  color={0,0,0},
                  thickness=0.5),
                Polygon(
                  points={{99,-100},{59,-80},{59,-120},{99,-100}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,145},{150,105}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{95,-113},{144,-162}},
                  lineColor={0,0,0},
                  textString="%label1"),
                Text(
                  extent={{-170,127},{-119,77}},
                  lineColor={0,0,0},
                  textString="%label2"),
                Line(points={{-56,78},{-56,-26}}, color={0,0,255}),
                Polygon(
                  points={{-68,-26},{-56,-66},{-44,-26},{-68,-26}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Line(points={{2,78},{2,-26}}, color={0,0,255}),
                Polygon(
                  points={{-10,-26},{2,-66},{14,-26},{-10,-26}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Line(points={{66,80},{66,-26}}, color={0,0,255}),
                Polygon(
                  points={{54,-26},{66,-66},{78,-26},{54,-26}},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255})}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics),
            Documentation(info="<html>
<p>Model <b>World</b> represents a global coordinate system fixed in ground.</p>
<p>It is comparable to the MultiBody <a href=\"Modelica.Mechanics.MultiBody.World\">World</a> component, but differs in that it only supports a uniform gravity field.</p>
</html>"));
        end World;

        package Interfaces
          extends Modelica.Icons.Package;

          connector PlanarFrame
            "Planar coordinate system fixed to the component with one cut-force and cut-torque (no icon)"
            Modelica.SIunits.Position s[2]
              "Absolute position of frame, resolved in world frame";
            Modelica.SIunits.Angle phi
              "Absolute angle to rotate the world frame into the connector frame";
            flow Modelica.SIunits.Force f[2]
              "Cut-force resolved in world frame";
            flow Modelica.SIunits.Torque tau
              "Cut-torqe resolved in world frame";
            annotation (Documentation(info="<html>
<p>Basic definition of a coordinate system that is fixed to a mechanical component. In the origin of the coordinate system the cut-force and the cut-torque is acting. This component has no icon definition and is only used by inheritance from frame connectors to define different icons.</p>
</html>"));
          end PlanarFrame;

          connector Frame_a
            "Planar coordinate system fixed to the component with one cut-force and cut-torque (filled icon)"
            extends PlanarFrame;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                      {100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-10,10},{10,-10}},
                    lineColor={95,95,95},
                    lineThickness=0.5),
                            Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,127,0},
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid), Ellipse(
                    extent={{-80,-80},{80,80}},
                    lineColor={0,0,0},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid)}), Diagram(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-40,-40},{40,40}},
                    lineColor={0,127,0},
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-32,32},{32,-32}},
                    lineColor={0,0,0},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-160,110},{40,50}},
                    lineColor={0,127,0},
                    textString="%name")}));
          end Frame_a;

          connector Frame_b
            "Planar coordinate system fixed to the component with one cut-force and cut-torque (non-filled icon)"
            extends PlanarFrame;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                      {100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-10,10},{10,-10}},
                    lineColor={95,95,95},
                    lineThickness=0.5),
                            Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,127,0},
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid), Ellipse(
                    extent={{-80,-80},{80,80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}), Diagram(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-40,-40},{40,40}},
                    lineColor={0,127,0},
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-32,32},{32,-32}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-160,110},{40,50}},
                    lineColor={0,127,0},
                    textString="%name")}));
          end Frame_b;

          connector FlangeWithBearing
            "Connector consisting of 1-dim. rotational flange and its bearing frame"
            parameter Boolean includeBearingConnector=false
              "= true, if bearing frame connector is present, otherwise not present";
            Modelica.Mechanics.Rotational.Interfaces.Flange_a flange
              "1-dim. rotational flange";
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.PlanarFrame bearingFrame if
              includeBearingConnector
              "2-dim. frame in which the 1-dim. shaft is mounted";

            annotation (
              defaultComponentName="flange",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-20,1},{20,-1}},
                    lineColor={135,135,135},
                    lineThickness=0.5),
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-100,25},{100,-24}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={175,175,175}),
                  Line(points={{-80,60},{80,60}}, color={0,0,0}),
                  Line(points={{-80,-60},{80,-60}}, color={0,0,0}),
                  Line(points={{0,100},{0,60}}, color={0,0,0}),
                  Line(points={{0,-60},{0,-100}}, color={0,0,0}),
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={135,135,135}),
                  Rectangle(extent={{-100,25},{100,-24}}, lineColor={0,0,0}),
                  Polygon(
                    points={{-100,100},{-100,-100},{100,-100},{100,100},{-100,100},{-96,96},{96,96},
                        {96,-96},{-96,-96},{-96,96},{-100,100}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(
                    points={{-50,-40},{50,-40}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-50,40},{50,40}},
                    color={0,0,0},
                    thickness=0.5),
                  Text(
                    extent={{-158,-66},{158,-124}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    textString="%name"),
                  Rectangle(
                    extent={{-60,60},{61,-61}},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-60,15},{60,-15}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={175,175,175}),
                  Line(points={{0,60},{0,40}}, color={0,0,0}),
                  Line(points={{0,-40},{0,-60}}, color={0,0,0}),
                  Line(points={{-50,40},{50,40}}, color={0,0,0}),
                  Line(points={{-50,-40},{50,-40}}, color={0,0,0}),
                  Rectangle(extent={{-60,60},{60,-60}}, lineColor={135,135,135}),
                  Rectangle(extent={{-60,15},{60,-15}}, lineColor={0,0,0}),
                  Polygon(
                    points={{-60,60},{-60,-60},{60,-60},{60,60},{-60,60},{-56,56},{56,56},
                        {56,-56},{-56,-56},{-56,56},{-60,60}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(info="<html>
<p>
This hierarchical connector models a 1-dim. rotational flange
connector and its optional bearing defined by a 2-dim. frame connector.
</p>
</html>"));

          end FlangeWithBearing;

          model FlangeWithBearingAdaptor
            "Adaptor to allow direct connections to the sub-connectors of FlangeWithBearing"
            parameter Boolean includeBearingConnector=false
              "= true, if bearing frame connector is present, otherwise not present";

            FlangeWithBearing                                         flangeAndFrame(
                includeBearingConnector=includeBearingConnector)
              "Compound connector consisting of 1-dim. rotational flange and 2-dim. frame mounting"
                                           annotation (Placement(transformation(extent=
                      {{-130,-30},{-70,30}}, rotation=0)));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b flange
              "1-dim. rotational flange"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}}, rotation=
                     0)));
            Frame_a frame if includeBearingConnector
              "2-dim. frame in which the 1-dim. shaft is mounted"             annotation (Placement(
                  transformation(
                  origin={0,-100},
                  extent={{-16,-16},{16,16}},
                  rotation=90), iconTransformation(
                  extent={{-16,-16},{16,16}},
                  rotation=90,
                  origin={0,-100})));

          equation
            connect(flange, flangeAndFrame.flange) annotation (Line(
                points={{0,0},{-100,0}},
                color={0,0,0}));
            connect(frame, flangeAndFrame.bearingFrame) annotation (Line(
                points={{0,-100},{0,-40},{-100,-40},{-100,0}},
                color={0,0,0},
                thickness=0.5));
            annotation (
              defaultComponentName="adaptor",
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics),
              Icon(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-100,30},{20,-100}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,-10},{-100,-40},{0,-40},{0,-100}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(points={{-90,0},{0,0}}, color={0,0,0}),
                  Text(
                    extent={{-216,88},{86,36}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(info="<html>
<p>
Adaptor object to make a more visible connection to the flange and frame
subconnectors of a
<a href=\"modelica://C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing\">FlangeWithBearing</a>
connector.
</p>
</html>"));
          end FlangeWithBearingAdaptor;

          connector Flange_With_Bearing_Translational
            "Connector consisting of 1-dim. translational flange and its bearing frame"
            parameter Boolean includeBearingConnector=false
              "= true, if bearing frame connector is present, otherwise not present";
            Modelica.Mechanics.Translational.Interfaces.Flange_a flange
              "1-dim. translational flange";
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a bearingFrame if
              includeBearingConnector
              "2-dim. frame in which the 1-dim. shaft is mounted";

            annotation (
              defaultComponentName="flange",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-20,1},{20,-1}},
                    lineColor={135,135,135},
                    lineThickness=0.5),
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-100,25},{100,-24}},
                    lineColor={0,255,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={0,127,0}),
                  Line(points={{-80,60},{80,60}}, color={0,0,0}),
                  Line(points={{-80,-60},{80,-60}}, color={0,0,0}),
                  Line(points={{0,100},{0,60}}, color={0,0,0}),
                  Line(points={{0,-60},{0,-100}}, color={0,0,0}),
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={135,135,135}),
                  Rectangle(extent={{-100,25},{100,-24}}, lineColor={0,255,0}),
                  Polygon(
                    points={{-100,100},{-100,-100},{100,-100},{100,100},{-100,100},{-96,96},{96,96},
                        {96,-96},{-96,-96},{-96,96},{-100,100}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(
                    points={{-50,-40},{50,-40}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-50,40},{50,40}},
                    color={0,0,0},
                    thickness=0.5),
                  Text(
                    extent={{-158,-66},{158,-124}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    textString="%name"),
                  Rectangle(
                    extent={{-60,60},{60,-60}},
                    lineColor={255,255,255},
                    lineThickness=0.5,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-60,15},{60,-15}},
                    lineColor={128,255,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={0,127,0}),
                  Line(points={{0,60},{0,40}}, color={0,0,0}),
                  Line(points={{0,-40},{0,-60}}, color={0,0,0}),
                  Line(points={{-50,40},{50,40}}, color={0,0,0}),
                  Line(points={{-50,-40},{50,-40}}, color={0,0,0}),
                  Rectangle(extent={{-60,60},{60,-60}}, lineColor={135,135,135}),
                  Rectangle(extent={{-60,15},{60,-15}}, lineColor={128,255,0}),
                  Polygon(
                    points={{-60,60},{-60,-60},{60,-60},{60,60},{-60,60},{-56,56},{56,56},
                        {56,-56},{-56,-56},{-56,56},{-60,60}},
                    lineThickness=0.5,
                    smooth=Smooth.None,
                    fillColor={0,127,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(info="<html>
<p>This hierarchical connector models a 1-dim. rotational flange connector and its optional bearing defined by a 2-dim. frame connector.</p>
</html>"));

          end Flange_With_Bearing_Translational;

          partial model PartialTwoFrames
            "Base model for components providing two frame connectors + outer world"

            Frame_a frame_a
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{
                      -116,-16},{-84,16}}, rotation=0)));
            Frame_b frame_b
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,
                      -16},{116,16}}, rotation=0)));
          protected
            outer World world;
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={Text(
                    extent={{-136,-25},{-100,-50}},
                    lineColor={128,128,128},
                    textString="a"), Text(
                    extent={{100,-25},{136,-50}},
                    lineColor={128,128,128},
                    textString="b")}),
              Documentation(info="<HTML>
<p>
This partial model provides two frame connectors and access to the world
object. Therefore, inherit from this partial model if the two frame connectors are
needed.
</p>
</HTML>"),    Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics));
          end PartialTwoFrames;
        end Interfaces;

        package Sensors
          extends Modelica.Icons.Package;

          model CutForce "Measure cut force vector"

            Modelica.Blocks.Interfaces.RealOutput force[2](final quantity="Force", final unit="N")
              "Cut force resolved in frame defined by resolveInFrame"
                 annotation (Placement(transformation(
                  origin={-80,-110},
                  extent={{10,-10},{-10,10}},
                  rotation=90)));

            parameter Boolean animation=true
              "= true, if animation shall be enabled (show arrow)";
            parameter Boolean positiveSign=true
              "= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)";

            input Real N_to_m(unit="N/m") = 1000
              " Force arrow scaling (length = force/N_to_m)"
              annotation (Dialog(group="if animation = true", enable=animation));
          //   input SI.Diameter forceDiameter=world.defaultArrowDiameter
          //     " Diameter of force arrow" annotation (Dialog(group="if animation = true", enable=animation));
          //   input Modelica.Mechanics.MultiBody.Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor
          //     " Color of force arrow"
          //     annotation (Dialog(group="if animation = true", enable=animation));
          //   input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          //     "Reflection of ambient light (= 0: light is completely absorbed)"
          //     annotation (Dialog(group="if animation = true", enable=animation));

          //  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor;

            extends Modelica.Icons.RotationalSensor;
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
              "Coordinate system a"                                                          annotation (Placement(
                  transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
              "Coordinate system b"                                                          annotation (Placement(
                  transformation(extent={{84,-16},{116,16}}, rotation=0)));

          protected
            parameter Integer csign=if positiveSign then +1 else -1;
          equation
            force = frame_a.f*csign;

            frame_b.s = frame_a.s;
            frame_b.phi = frame_a.phi;

            /* Force and torque balance */
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={Text(
                    extent={{-190,-70},{-74,-96}},
                    lineColor={0,0,0},
                    textString="force"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                        127})}),
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}),
                      graphics),
              Documentation(info="<html>
<p>The cut-force acting between the two frames to which this model is connected, is determined and provided at the output signal connector <b>force</b> (= frame_a.f). If parameter <b>positiveSign</b> = <b>false</b>, the negative cut-force is provided (= frame_b.f). </p>
<p>The force vector is resolved in world frame.</p>
</html>"));
          end CutForce;

          model CutForce_frameA "Measure cut force vector"

            import SI = Modelica.SIunits;

            Modelica.Blocks.Interfaces.RealOutput force[2](final quantity="Force", final unit="N")
              "Cut force resolved in frame defined by resolveInFrame"
                 annotation (Placement(transformation(
                  origin={-80,-110},
                  extent={{10,-10},{-10,10}},
                  rotation=90)));

            parameter Boolean animation=true
              "= true, if animation shall be enabled (show arrow)";
            parameter Boolean positiveSign=true
              "= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)";

            input Real N_to_m(unit="N/m") = 1000
              " Force arrow scaling (length = force/N_to_m)"
              annotation (Dialog(group="if animation = true", enable=animation));
          //   input SI.Diameter forceDiameter=world.defaultArrowDiameter
          //     " Diameter of force arrow" annotation (Dialog(group="if animation = true", enable=animation));
          //   input Modelica.Mechanics.MultiBody.Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor
          //     " Color of force arrow"
          //     annotation (Dialog(group="if animation = true", enable=animation));
          //   input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          //     "Reflection of ambient light (= 0: light is completely absorbed)"
          //     annotation (Dialog(group="if animation = true", enable=animation));

          //  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor;
            extends Modelica.Icons.RotationalSensor;
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
              "Coordinate system a"                                                          annotation (Placement(
                  transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
              "Coordinate system b"                                                          annotation (Placement(
                  transformation(extent={{84,-16},{116,16}}, rotation=0)));

          protected
            parameter Integer csign=if positiveSign then +1 else -1;
          equation
            force = csign*C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, frame_a.f);

            frame_b.s = frame_a.s;
            frame_b.phi = frame_a.phi;

            /* Force and torque balance */
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={Text(
                    extent={{-190,-70},{-74,-96}},
                    lineColor={0,0,0},
                    textString="force"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                        127})}),
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}),
                      graphics),
              Documentation(info="<html>
<p>The cut-force acting between the two frames to which this model is connected, is determined and provided at the output signal connector <b>force</b> (= frame_a.f). If parameter <b>positiveSign</b> = <b>false</b>, the negative cut-force is provided (= frame_b.f). </p>
<p>The force vector is resolved in frame_a.</p>
</html>"));
          end CutForce_frameA;

          block Vector_Magnitude
            "Takes a vector length 2 and calculates its magnitude (useful add on for torque and force sensors)"
            extends Modelica.Blocks.Interfaces.MISO(nin=2);
          equation
            y = sqrt(u*u);
            annotation (Icon(graphics={Text(
                    extent={{-84,24},{86,-20}},
                    lineColor={0,0,255},
                    textString="mag"), Text(
                    extent={{-170,22},{0,-22}},
                    lineColor={0,0,255},
                    textString="2")}));
          end Vector_Magnitude;

          model CutTorque "Measure cut torque vector"

            import SI = Modelica.SIunits;

            Modelica.Blocks.Interfaces.RealOutput torque(final quantity="Torque", final unit="N.m")
              "Cut torque"
                 annotation (Placement(transformation(
                  origin={-80,-110},
                  extent={{10,-10},{-10,10}},
                  rotation=90)));

            parameter Boolean positiveSign=true
              "= true, if torque with positive sign is returned (= frame_a.tau), otherwise with negative sign (= frame_b.tau)";

            extends Modelica.Icons.RotationalSensor;
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
              "Coordinate system a"                                                          annotation (Placement(
                  transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
              "Coordinate system b"                                                          annotation (Placement(
                  transformation(extent={{84,-16},{116,16}}, rotation=0)));

          protected
            parameter Integer csign=if positiveSign then +1 else -1;
          equation
            torque = frame_a.tau*csign;

            frame_b.s = frame_a.s;
            frame_b.phi = frame_a.phi;

            /* Force and torque balance */
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={Text(
                    extent={{-190,-70},{-74,-96}},
                    lineColor={0,0,0},
                    textString="force"), Line(points={{-80,-100},{-80,0}}, color={0,0,
                        127})}),
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}),
                      graphics),
              Documentation(info="<html>
<p>Measures the cut-torque acting between the two frames to which this model is connected. If parameter <b>positiveSign</b> = <b>false</b>, the negative cut-torque is provided.</p>
</html>"));
          end CutTorque;
        end Sensors;

        package Frames
          extends Modelica.Icons.Package;

          function resolve1 "Transform vector from frame 2 to frame 1"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Angle phi
              "Angle to rotate frame 1 into frame 2";
            input Real v2[2] "Vector in frame 2";
            output Real v1[2] "Vector in frame 1";
          algorithm
            v1 := [cos(phi), -sin(phi); sin(phi), cos(phi)]*v2;
          end resolve1;

          function resolve2 "Transform vector from frame 1 to frame 2"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Angle phi
              "Angle to rotate frame 1 into frame 2";
            input Real v1[2] "Vector in frame 1";
            output Real v2[2] "Vector in frame 2";
          algorithm
            v2 := [cos(phi), sin(phi); -sin(phi), cos(phi)]*v1;
          end resolve2;

          function rotation
            "Returns an orientation object describing a planar rotation"

            input Modelica.SIunits.Angle angle
              "Rotation angle to rotate frame 1 into frame 2 along axis e";
            input Modelica.SIunits.AngularVelocity der_angle=0 "= der(angle)";
            input Real e[3](each final unit="1") = {0,0,1}
              "Normalized axis of rotation (must have length=1)";
            output Modelica.Mechanics.MultiBody.Frames.Orientation R
              "Orientation object to rotate frame 1 into frame 2";
          algorithm
            R :=Modelica.Mechanics.MultiBody.Frames.planarRotation(
              e,
              angle,
              der_angle);

            annotation (Documentation(info="<html>
<p>This function is useful when adding MultiBody visualizations to planar mechanical models.</p>
</html>"));
          end rotation;
        end Frames;

        package Parts
          extends Modelica.Icons.Package;

          model Body "Rigid body with mass, inertia and one frame connector"
            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Types;
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
              "Left frame of shaft"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                    rotation=0)));
            parameter Modelica.SIunits.Mass m(min=0, start=1) "Mass";
            parameter Modelica.SIunits.Inertia J(min=0, start=1)
              "Moment of inertia";
            parameter StateSelect stateSelect=StateSelect.default
              "Priority to use s, phi, v and w as states" annotation(HideResult=true,Dialog(tab="Advanced"));
            Modelica.SIunits.Angle phi(stateSelect=stateSelect)
              "Absolute rotation angle of component" annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.AngularVelocity w(stateSelect=stateSelect)
              "Absolute angular velocity of component (= der(phi))" annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.AngularAcceleration z
              "Absolute angular acceleration of component (= der(w))" annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.Position[2] s(start={0,0}, each stateSelect=stateSelect) annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.Velocity[2] v(start={0,0}, each stateSelect=stateSelect)
              "Absolute velocity of component" annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.Acceleration[2] a(start={0,0})
              "Absolute acceleration of component"                                               annotation(Dialog(group="Initialization", showStartAttribute=true));
            Modelica.SIunits.Acceleration[2] g_0
              "Gravity vector resolved in world frame";
            Modelica.SIunits.Force[2] f_g;

            parameter Boolean animation=true
              "= true, if animation shall be enabled (show sphere)";
            parameter Modelica.SIunits.Diameter sphereDiameter=world.defaultBodyDiameter
              "Diameter of sphere" annotation (Dialog(
                tab="Animation",
                group="if animation = true",
                enable=animation));
            input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor
              "Color of sphere" annotation (Dialog(
                tab="Animation",
                group="if animation = true",
                enable=animation));
            parameter Modelica.SIunits.Diameter cylinderDiameter=sphereDiameter/Types.Defaults.
                BodyCylinderDiameterFraction "Diameter of cylinder"
              annotation (Dialog(
                tab="Animation",
                group="if animation = true",
                enable=animation));
            input Types.Color cylinderColor=sphereColor "Color of cylinder"
              annotation (Dialog(
                tab="Animation",
                group="if animation = true",
                enable=animation));
            input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
              annotation (Dialog(
                tab="Animation",
                group="if animation = true",
                enable=animation));
          protected
            outer World world;
            // Declarations for animation
            // Visualizers.Advanced.Shape cylinder(
            //   shapeType="cylinder",
            //   color=cylinderColor,
            //   specularCoefficient=specularCoefficient,
            //   length=if Modelica.Math.Vectors.length(r_CM) > sphereDiameter/2 then
            //             Modelica.Math.Vectors.length(r_CM) - (if cylinderDiameter > 1.1*
            //       sphereDiameter then sphereDiameter/2 else 0) else 0,
            //   width=cylinderDiameter,
            //   height=cylinderDiameter,
            //   lengthDirection=r_CM,
            //   widthDirection={0,1,0},
            //   r=frame_a.r_0,
            //   R=frame_a.R) if world.enableAnimation and animation;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape sphere(
              shapeType="sphere",
              color=sphereColor,
              specularCoefficient=specularCoefficient,
              length=sphereDiameter,
              width=sphereDiameter,
              height=sphereDiameter,
              lengthDirection={1,0,0},
              widthDirection={0,1,0},
              r_shape={-1,0,0}*sphereDiameter/2,
              r=cat(1, frame_a.s, {0}),
              R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation and sphereDiameter > 0;

          equation
            //g_0 = world.gravityAcceleration(frame_a.s);
            g_0 = world.g*world.n;

            phi = frame_a.phi;
            w = der(phi);
            z = der(w);

            J*z = frame_a.tau;

            frame_a.s = s;
            v = der(s);
            a = der(v);

            f_g = m*g_0;
            m*a = frame_a.f + m*g_0;
            annotation (
              Documentation(info="<html>
<p>Rigid body with mass and rotational inertia.</p>
<p>This component is a planar adaptation of the MultiBody component <a href=\"Modelica.Mechanics.MultiBody.Parts.Body\">Body</a>, but with some differences:</p>
<p><ul>
<li>The model has only one rotational axis. Thus the rotational inertia is represented by a scalar instead of a second order tensor.</li>
<li>The center of mass is placed at frame_a. Translation is not included in the model.</li>
</ul></p>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-100,30},{-3,-31}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={175,175,175}),
                  Text(
                    extent={{150,-100},{-150,-70}},
                    lineColor={0,0,0},
                    textString="m=%m"),
                  Text(
                    extent={{-150,110},{150,70}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Ellipse(
                    extent={{-20,60},{100,-60}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={175,175,175})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics));
          end Body;

          model Fixed "Fixed frame"
            parameter Modelica.SIunits.Position[2] s0={0, 0}
              "Fixed offset position of housing";
            parameter Modelica.SIunits.Angle phi0=0
              "Fixed offset angle of housing";

            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame
                                         annotation (Placement(transformation(
                  origin={0,0},
                  extent={{-10,10},{10,-10}},
                  rotation=180)));
          equation
            frame.s = s0;
            frame.phi = phi0;
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={
                  Line(points={{-80,-40},{80,-40}}, color={0,0,0}),
                  Line(points={{80,-40},{40,-80}}, color={0,0,0}),
                  Line(points={{40,-40},{0,-80}}, color={0,0,0}),
                  Line(points={{0,-40},{-40,-80}}, color={0,0,0}),
                  Line(points={{-40,-40},{-80,-80}}, color={0,0,0}),
                  Line(points={{0,-40},{0,-10}}, color={0,0,0}),
                  Text(
                    extent={{-150,-90},{150,-130}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics),
              Documentation(info="<html>
<p>The frame of a 2D planar mechanical system fixed at a position s0 and rotation phi0 in world frame.</p>
</html>"));
          end Fixed;

          model FixedRotation
            "Fixed translation followed by a fixed rotation of frame_b with respect to frame_a"

            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Types;
            Interfaces.Frame_a frame_a
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{
                      -116,-16},{-84,16}}, rotation=0)));
            Interfaces.Frame_b frame_b
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,
                      -16},{116,16}}, rotation=0)));

            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Modelica.SIunits.Position r[2](start={0,0})
              "Vector from frame_a to frame_b resolved in frame_a";
          //   parameter Modelica.Mechanics.MultiBody.Types.RotationTypes rotationType=
          //             Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis
          //     "Type of rotation description"
          //     annotation (Evaluate=true);
          //   parameter Types.Axis n={1,0,0}
          //     " Axis of rotation in frame_a (= same as in frame_b)"
          //     annotation (Evaluate=true, Dialog(group="if rotationType = RotationAxis",
          //                 enable=rotationType==Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis));
            parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg angle=0
              " Angle to rotate frame_a around axis n into frame_b"
              annotation (Dialog(group="if rotationType = RotationAxis",
                          enable=rotationType==Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis));

          //   parameter Types.Axis n_x={1,0,0}
          //     " Vector along x-axis of frame_b resolved in frame_a"
          //     annotation (Evaluate=true, Dialog(group="if rotationType = TwoAxesVectors",
          //                 enable=rotationType==Types.RotationTypes.TwoAxesVectors));
          //   parameter Types.Axis n_y={0,1,0}
          //     " Vector along y-axis of frame_b resolved in frame_a"
          //     annotation (Evaluate=true, Dialog(group="if rotationType = TwoAxesVectors",
          //                 enable=rotationType==Types.RotationTypes.TwoAxesVectors));
          //
          //   parameter Types.RotationSequence sequence(
          //     min={1,1,1},
          //     max={3,3,3}) = {1,2,3} " Sequence of rotations"
          //     annotation (Evaluate=true, Dialog(group=
          //                 "if rotationType = PlanarRotationSequence",
          //                 enable=rotationType==Types.RotationTypes.PlanarRotationSequence));
          //   parameter Cv.NonSIunits.Angle_deg angles[3]={0,0,0}
          //     " Rotation angles around the axes defined in 'sequence'"
          //     annotation (Dialog(group="if rotationType = PlanarRotationSequence",
          //                 enable=rotationType==Types.RotationTypes.PlanarRotationSequence));
             parameter Types.ShapeType shapeType="cylinder" " Type of shape"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             parameter Modelica.SIunits.Position r_shape[3]={0,0,0}
              " Vector from frame_a to shape origin, resolved in frame_a"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             parameter Types.Axis lengthDirection=cat(1, r, {0}) - r_shape
              " Vector in length direction of shape, resolved in frame_a"
               annotation (Evaluate=true, Dialog(tab="Animation", group=
                     "if animation = true", enable=animation));
             parameter Types.Axis widthDirection={0,1,0}
              " Vector in width direction of shape, resolved in frame_a"
               annotation (Evaluate=true, Dialog(tab="Animation", group=
                     "if animation = true", enable=animation));
             parameter Modelica.SIunits.Length length=Modelica.Math.Vectors.length(
                                                      cat(1, r, {0}) - r_shape)
              " Length of shape"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             parameter Modelica.SIunits.Distance width=length/world.defaultWidthFraction
              " Width of shape"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             parameter Modelica.SIunits.Distance height=width
              " Height of shape."
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             parameter Types.ShapeExtra extra=0.0
              " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)."
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          /*
  parameter Boolean checkTotalPower=false
    "= true, if total power flowing into this component shall be determined (must be zero)"
    annotation (Dialog(tab="Advanced"));
*/

             input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor
              " Color of shape"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
             input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          //   final parameter Frames.Orientation R_rel=if rotationType == 1 then
          //       Frames.planarRotation(Modelica.Math.Vectors.normalize(
          //                                              n,0.0), Cv.from_deg(angle), 0) else
          //       if rotationType == 2 then Frames.from_nxy(n_x, n_y) else
          //       Frames.axesRotations(sequence, Cv.from_deg(angles), zeros(3))
          //     "Fixed rotation object from frame_a to frame_b";
          /*
  Modelica.SIunits.Power totalPower
    "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";
*/
          protected
             outer World world;

            /*
  parameter Frames.Orientation R_rel_inv=
      Frames.inverseRotation(R_rel)
*/
          //   parameter Frames.Orientation R_rel_inv=Frames.from_T(transpose(R_rel.T),
          //       zeros(3)) "Inverse of R_rel (rotate from frame_b to frame_a)";
             Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape(
               shapeType=shapeType,
               color=color,
               specularCoefficient=specularCoefficient,
               r_shape=r_shape,
               lengthDirection=lengthDirection,
               widthDirection=widthDirection,
               length=length,
               width=width,
               height=height,
               extra=extra,
               r=cat(1, frame_a.s, {0}),
               R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;

          equation
            frame_b.s = frame_a.s + [cos(frame_a.phi), -sin(frame_a.phi); sin(frame_a.phi), cos(frame_a.phi)] * r;
            frame_b.phi = frame_a.phi+Modelica.SIunits.Conversions.from_deg(angle);

            /* Force and torque balance */
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau + C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, r)*{frame_b.f[2], - frame_b.f[1]};
            annotation (
              Documentation(info="<html>
<p>Component for a <b>fixed translation</b> and <b>fixed rotation</b> of frame_b with respect to frame_a, i.e., the relationship between connectors frame_a and frame_b remains constant. Compared to the <a href=\"Modelica.Mechanics.MultiBody.Parts.FixedRotation\">MultiBody FixedRotation</a>, this planar component only allows rotating frame_b with respect to frame_a along the plane normal with a fixed angle &apos;angle&apos;.</p>
</html>",         revisions="<HTML><p><b>Release Notes:</b></p>
<ul>
  <li><i>July 28, 2003</i><br>
         Bug fixed: if rotationType = PlanarRotationSequence, then 'angles'
         was used with unit [rad] instead of [deg].</li>
</ul>
</HTML>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Text(
                    extent={{-150,80},{150,120}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-100,5},{100,-4}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{80,20},{129,50}}, color={0,0,0}),
                  Line(points={{80,20},{57,59}}, color={0,0,0}),
                  Polygon(
                    points={{144,60},{117,59},{132,37},{144,60}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{43,80},{46,50},{68,65},{43,80}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-50},{150,-80}},
                    lineColor={0,0,0},
                    textString="r=%r"),
                  Text(
                    extent={{-117,51},{-81,26}},
                    lineColor={128,128,128},
                    textString="a"),
                  Text(
                    extent={{84,-24},{120,-49}},
                    lineColor={128,128,128},
                    textString="b")}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(points={{-100,-1},{-100,-66}}, color={128,128,128}),
                  Line(points={{100,0},{100,-65}}, color={128,128,128}),
                  Line(points={{-100,-60},{89,-60}}, color={128,128,128}),
                  Text(
                    extent={{-22,-36},{16,-60}},
                    lineColor={128,128,128},
                    textString="r"),
                  Rectangle(
                    extent={{-100,5},{100,-5}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{69,29},{97,45}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Line(
                    points={{70,27},{55,54}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{95,42},{109,31}},
                    lineColor={128,128,128},
                    textString="x"),
                  Text(
                    extent={{42,70},{57,58}},
                    lineColor={128,128,128},
                    textString="y"),
                  Line(
                    points={{-95,22},{-58,22}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Line(
                    points={{-94,20},{-94,52}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{-72,37},{-58,26}},
                    lineColor={128,128,128},
                    textString="x"),
                  Text(
                    extent={{-113,59},{-98,47}},
                    lineColor={128,128,128},
                    textString="y"),
                  Polygon(
                    points={{88,-56},{88,-65},{100,-60},{88,-56}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid)}));
          end FixedRotation;

          model FixedTranslation
            "Fixed translation of frame_b with respect to frame_a"

            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Types;
            Interfaces.Frame_a frame_a
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{
                      -116,-16},{-84,16}}, rotation=0)));
            Interfaces.Frame_b frame_b
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,
                      -16},{116,16}}, rotation=0)));

            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Modelica.SIunits.Position r[2](start={0,0})
              "Vector from frame_a to frame_b resolved in frame_a";
            parameter Types.ShapeType shapeType="cylinder" " Type of shape"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Position r_shape[3]={0,0,0}
              " Vector from frame_a to shape origin, resolved in frame_a"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Types.Axis lengthDirection=cat(1,r,{0}) - r_shape
              " Vector in length direction of shape, resolved in frame_a"
              annotation (Evaluate=true, Dialog(tab="Animation", group=
                    "if animation = true", enable=animation));
            parameter Types.Axis widthDirection={0,1,0}
              " Vector in width direction of shape, resolved in frame_a"
              annotation (Evaluate=true, Dialog(tab="Animation", group=
                    "if animation = true", enable=animation));
            parameter Modelica.SIunits.Length length=Modelica.Math.Vectors.length(
                                                     r - r_shape[1:2])
              " Length of shape"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance width=length/world.defaultWidthFraction
              " Width of shape"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance height=width
              " Height of shape."
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Types.ShapeExtra extra=0.0
              " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)."
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor
              " Color of shape"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
                 annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

          protected
            outer Planar.World world;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape(
              shapeType=shapeType,
              color=color,
              specularCoefficient=specularCoefficient,
              r_shape=r_shape,
              lengthDirection=lengthDirection,
              widthDirection=widthDirection,
              length=length,
              width=width,
              height=height,
              extra=extra,
              r=cat(1,frame_a.s,{0}),
              R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;
          equation
            frame_b.s = frame_a.s + Frames.resolve1(frame_a.phi, r);
            frame_b.phi = frame_a.phi;

            /* Force and torque balance */
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau + Frames.resolve1(frame_a.phi, r)*{frame_b.f[2],-frame_b.f[1]};
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-99,5},{101,-5}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,85},{150,45}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{150,-50},{-150,-20}},
                    lineColor={0,0,0},
                    textString="%=r"),
                  Text(
                    extent={{-89,38},{-53,13}},
                    lineColor={128,128,128},
                    textString="a"),
                  Text(
                    extent={{57,39},{93,14}},
                    lineColor={128,128,128},
                    textString="b")}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-100,5},{100,-5}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-95,20},{-58,20}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Line(
                    points={{-94,18},{-94,50}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{-72,35},{-58,24}},
                    lineColor={128,128,128},
                    textString="x"),
                  Text(
                    extent={{-113,57},{-98,45}},
                    lineColor={128,128,128},
                    textString="y"),
                  Line(points={{-100,-4},{-100,-69}}, color={128,128,128}),
                  Line(points={{-100,-63},{90,-63}}, color={128,128,128}),
                  Text(
                    extent={{-22,-39},{16,-63}},
                    lineColor={128,128,128},
                    textString="r"),
                  Polygon(
                    points={{88,-59},{88,-68},{100,-63},{88,-59}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{100,-3},{100,-68}}, color={128,128,128}),
                  Line(
                    points={{69,20},{106,20}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Line(
                    points={{70,18},{70,50}},
                    color={128,128,128},
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{92,35},{106,24}},
                    lineColor={128,128,128},
                    textString="x"),
                  Text(
                    extent={{51,57},{66,45}},
                    lineColor={128,128,128},
                    textString="y")}),
              Documentation(info="<html>
<p>Component for a <b>fixed translation</b> of frame_b with respect to frame_a, i.e., the relationship between connectors frame_a and frame_b remains constant and frame_a is always <b>parallel</b> to frame_b. </p>
</html>"));
          end FixedTranslation;

          model Mounting_1D_Rotational
            "Propagate 1-dim. support torque to 2-dim. system (provided world.driveTrainMechanics2D=true)"
            parameter Modelica.SIunits.Angle phi0=0
              "Fixed offset angle of housing";
          //   parameter Modelica.Mechanics.MultiBody.Types.Axis n={1,0,0}
          //     "Axis of rotation = axis of support torque (resolved in frame_a)";

            Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b
              "(right) flange fixed in housing" annotation (Placement(transformation(
                    extent={{110,10},{90,-10}}, rotation=0)));
            Interfaces.Frame_a                              frame_a if world.driveTrainMechanics2D
              "Frame in which housing is fixed (connector is removed, if world.driveTrainMechanics2D=false)"
              annotation (Placement(transformation(
                  origin={0,-100},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          protected
            outer World world;

            encapsulated model Housing
              import Modelica;
              import C2M2L_OM;
              input Modelica.SIunits.Torque t;
              C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a
                                                              frame_a
                                         annotation (Placement(transformation(extent={{
                        -116,-16},{-84,16}}, rotation=0)));
            equation
              frame_a.f=zeros(2);
              frame_a.tau=t;
              annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                        -100},{100,100}}), graphics={Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid), Text(
                      extent={{-150,110},{150,150}},
                      lineColor={0,0,255},
                      textString="%name")}));
            end Housing;
            Housing housing(t=-flange_b.tau) if world.driveTrainMechanics2D
                            annotation (Placement(transformation(extent={{20,-60},{40,-40}},
                    rotation=0)));
          equation
            flange_b.phi = phi0;
            connect(housing.frame_a, frame_a) annotation (Line(
                points={{20,-50},{0,-50},{0,-100}},
                color={95,95,95},
                thickness=0.5,
                smooth=Smooth.None));
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={
                  Rectangle(
                    extent={{-80,-60},{80,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,60},{150,20}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Line(points={{80,-60},{40,-100}}, color={0,0,0}),
                  Line(points={{40,-60},{0,-100}}, color={0,0,0}),
                  Line(points={{0,-60},{-40,-100}}, color={0,0,0}),
                  Line(points={{-40,-60},{-80,-100}}, color={0,0,0}),
                  Line(points={{0,-60},{0,0}}, color={0,0,0}),
                  Line(points={{0,0},{90,0}}, color={0,0,0})}),
              Documentation(info="<html>
<p>This component is used to acquire support torques from a 1-dim.-rotational mechanical system (e.g., components from Modelica.Mechanics.Rotational) and to propagate them to a carrier body.</p>
<p>The 1-dim. support torque at <code>flange_b</code> is transformed into 2-dim. space under consideration of the planar rotation axis.</p>
<p>See also the <a href=\"Modelica.Mechanics.MultiBody.Parts.Mounting1D\">MultiBody variant</a> of this component, from which this model was adapted.</p>
</html>"),    Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics));
          end Mounting_1D_Rotational;

          model Mounting_1D_Translational
            "Propagate 1-dim. support force to 2-dim. system (provided world.driveTrainMechanics2D=true)"
            parameter Modelica.SIunits.Position s0=0
              "Fixed offset distance of housing";
            parameter Real n[2]={1,0}
              "Axis of translation = axis of support force (resolved in frame_a)";

            Modelica.Mechanics.Translational.Interfaces.Flange_b flange_b
              "(right) flange fixed in housing" annotation (Placement(transformation(
                    extent={{110,10},{90,-10}}, rotation=0)));
            Interfaces.Frame_a frame_a if world.driveTrainMechanics2D
              "Frame in which housing is fixed (connector is removed, if world.driveTrainMechanics2D=false)"
              annotation (Placement(transformation(
                  origin={0,-100},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          protected
            outer World world;

            encapsulated model Housing
              import Modelica;
              import C2M2L_OM;
              input Modelica.SIunits.Force f[2];
              C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
                                         annotation (Placement(transformation(extent={{
                        -116,-16},{-84,16}}, rotation=0)));
            equation
              frame_a.f=f;
              frame_a.tau=0;
              annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                        -100},{100,100}}), graphics={Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid), Text(
                      extent={{-150,110},{150,150}},
                      lineColor={0,0,255},
                      textString="%name")}));
            end Housing;
            // Housing housing(f=-n*flange_b.f) if world.driveTrainMechanics2D
            //                 annotation (Placement(transformation(extent={{20,-60},{40,-40}},
            //         rotation=0)));
          Housing housing(f=if initial() then zeros(2) else C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, -n*flange_b.f)) if world.driveTrainMechanics2D
                          annotation (Placement(transformation(extent={{20,-60},{40,-40}},
                  rotation=0)));
          equation
            flange_b.s = s0;
            connect(housing.frame_a, frame_a) annotation (Line(
                points={{20,-50},{0,-50},{0,-100}},
                color={95,95,95},
                thickness=0.5,
                smooth=Smooth.None));
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={
                  Rectangle(
                    extent={{-80,-60},{80,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,60},{150,20}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Line(points={{80,-60},{40,-100}}, color={0,0,0}),
                  Line(points={{40,-60},{0,-100}}, color={0,0,0}),
                  Line(points={{0,-60},{-40,-100}}, color={0,0,0}),
                  Line(points={{-40,-60},{-80,-100}}, color={0,0,0}),
                  Line(points={{0,-60},{0,0}}, color={0,0,0}),
                  Line(points={{0,0},{90,0}}, color={0,0,0})}),
              Documentation(info="<html>
<p>This component is used to acquire support forces from a 1-dim.-translational mechanical system (e.g., components from Modelica.Mechanics.Translational) and to propagate them to a carrier body.</p>
<p>Compare with <a href=\"C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational\">Mounting_1D_Rotational</a>.</p>
</html>"),    Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics));
          end Mounting_1D_Translational;
        end Parts;

        package Joints
          extends Modelica.Icons.Package;

          model Revolute
            "Revolute joint (1 rotational degree-of-freedom, 2 potential states, optional axis flange)"

          Modelica.Mechanics.Rotational.Interfaces.Flange_a axis if useAxisFlange
              "1-dim. rotational flange that drives the joint"
            annotation (Placement(transformation(extent={{10,90},{-10,110}}, rotation=
                   0)));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b support if useAxisFlange
              "1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)"
            annotation (Placement(transformation(extent={{-70,90},{-50,110}},
                  rotation=0)));

          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
            annotation (Placement(transformation(extent={{-116,-16},{-84,16}},
                  rotation=0)));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
            annotation (Placement(transformation(extent={{84,-16},{116,16}},
                  rotation=0)));

          parameter Boolean useAxisFlange=false
              "= true, if axis flange is enabled"
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Boolean animation=true
              "= true, if animation shall be enabled (show axis as cylinder)";
          constant Modelica.SIunits.Angle phi_offset=0
              "Relative angle offset (angle = phi_offset + phi)";
          parameter StateSelect stateSelect=StateSelect.prefer
              "Priority to use joint angle phi and w=der(phi) as states"
                                                                       annotation(Dialog(tab="Advanced"));

          Modelica.SIunits.Angle phi(start=0, final stateSelect=stateSelect)
              "Relative rotation angle from frame_a to frame_b"
             annotation (unassignedMessage="
The rotation angle phi of a revolute joint cannot be determined.
Possible reasons:
- A non-zero mass might be missing on either side of the parts
  connected to the revolute joint.
- Too many StateSelect.always are defined and the model
  has less degrees of freedom as specified with this setting
  (remove all StateSelect.always settings).
");
          Modelica.SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
              "First derivative of angle phi (relative angular velocity)";
          Modelica.SIunits.AngularAcceleration a(start=0)
              "Second derivative of angle phi (relative angular acceleration)";
          Modelica.SIunits.Torque tau
              "Driving torque in direction of axis of rotation";
          Modelica.SIunits.Angle angle "= phi_offset + phi";

            parameter Modelica.SIunits.Distance cylinderLength=world.defaultJointLength
              "Length of cylinder representing the joint axis"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance cylinderDiameter=world.defaultJointWidth
              "Diameter of cylinder representing the joint axis"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Color of cylinder representing the joint axis"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient
              specularCoefficient =                                                            world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
               annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

          protected
            outer World world;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
              shapeType="cylinder",
              color=cylinderColor,
              specularCoefficient=specularCoefficient,
              length=cylinderLength,
              width=cylinderDiameter,
              height=cylinderDiameter,
              lengthDirection={0,0,1},
              widthDirection={0,1,0},
              r_shape={0,0,-1}*(cylinderLength/2),
              r=cat(1,frame_a.s,{0}),
              R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;

          protected
          Modelica.Mechanics.Rotational.Components.Fixed fixed
              "support flange is fixed to ground"
            annotation (Placement(transformation(extent={{-70,70},{-50,90}})));
          Modelica.Mechanics.Rotational.Interfaces.InternalSupport internalAxis(tau=tau)
            annotation (Placement(transformation(extent={{-10,90},{10,70}})));
          Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
              tau_constant=0) if not useAxisFlange
            annotation (Placement(transformation(extent={{40,70},{20,90}})));
          equation
          angle = phi_offset + phi;
          w = der(phi);
          a = der(w);

          // relationships between quantities of frame_a and of frame_b
          frame_b.s = frame_a.s;
          frame_b.phi = frame_a.phi + phi;

          frame_a.f + frame_b.f = zeros(2);
          frame_a.tau + frame_b.tau = 0;
          frame_a.tau = tau;

          // Connection to internal connectors
          phi = internalAxis.phi;

          connect(fixed.flange, support) annotation (Line(
              points={{-60,80},{-60,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(internalAxis.flange, axis) annotation (Line(
              points={{0,80},{0,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(constantTorque.flange, internalAxis.flange) annotation (Line(
              points={{20,80},{0,80}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Rectangle(
                  extent={{-100,-60},{-30,60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{30,-60},{100,60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(extent={{-100,59},{-30,-60}}, lineColor={0,0,0}),
                Rectangle(extent={{30,60},{100,-60}}, lineColor={0,0,0}),
                Text(
                  extent={{-90,14},{-54,-11}},
                  lineColor={128,128,128},
                  textString="a"),
                Text(
                  extent={{51,11},{87,-14}},
                  lineColor={128,128,128},
                  textString="b"),
                Line(
                  visible=useAxisFlange,
                  points={{-20,80},{-20,60}},
                  color={0,0,0}),
                Line(
                  visible=useAxisFlange,
                  points={{20,80},{20,60}},
                  color={0,0,0}),
                Rectangle(
                  visible=useAxisFlange,
                  extent={{-10,100},{10,50}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={192,192,192}),
                Polygon(
                  visible=useAxisFlange,
                  points={{-10,30},{10,30},{30,50},{-30,50},{-10,30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,11},{30,-10}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  visible=useAxisFlange,
                  points={{10,30},{30,50},{30,-50},{10,-30},{10,30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-110},{150,-80}},
                  lineColor={0,0,0},
                  textString="n=%n"),
                Text(
                  visible=useAxisFlange,
                  extent={{-150,-155},{150,-115}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  visible=useAxisFlange,
                  points={{-20,70},{-60,70},{-60,60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=useAxisFlange,
                  points={{20,70},{50,70},{50,60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=useAxisFlange,
                  points={{-90,100},{-30,100}},
                  color={0,0,0}),
                Line(
                  visible=useAxisFlange,
                  points={{-30,100},{-50,80}},
                  color={0,0,0}),
                Line(
                  visible=useAxisFlange,
                  points={{-49,100},{-70,80}},
                  color={0,0,0}),
                Line(
                  visible=useAxisFlange,
                  points={{-70,100},{-90,80}},
                  color={0,0,0}),
                Text(
                  visible=not useAxisFlange,
                  extent={{-150,70},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
            Documentation(info="<html>
<p>Joint that rotates in the plane. The frames frame_a and frame_b coincide when the rotation angle &QUOT;phi = 0&QUOT;. </p>
<p>Optionally, two additional 1-dimensional mechanical flanges (flange &QUOT;axis&QUOT; represents the driving flange and flange &QUOT;support&QUOT; represents the bearing) can be enabled via parameter <b>useAxisFlange</b>. The enabled axis flange can be driven with elements of the <a href=\"modelica://Modelica.Mechanics.Rotational\">Modelica.Mechanics.Rotational</a> library. </p>
<p>In the &QUOT;Advanced&QUOT; menu it can be defined via parameter <b>stateSelect</b> that the rotation angle &QUOT;phi&QUOT; and its derivative shall be definitely used as states by setting stateSelect=StateSelect.always. Default is StateSelect.prefer to use the joint angle and its derivative as preferred states. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the StateSelect.always setting. </p>
</html>"));
          end Revolute;

          model Prismatic "Prismatic joint"

            import SI = Modelica.SIunits;
            //extends Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint;
            Modelica.Mechanics.Translational.Interfaces.Flange_a axis if useAxisFlange
              "1-dim. translational flange that drives the joint"
              annotation (Placement(transformation(extent={{90,50},{70,70}}, rotation=0)));
            Modelica.Mechanics.Translational.Interfaces.Flange_b support if useAxisFlange
              "1-dim. translational flange of the drive drive support (assumed to be fixed in the world frame, NOT in the joint)"
              annotation (Placement(transformation(extent={{-30,50},{-50,70}}, rotation=
                     0)));

            parameter Boolean useAxisFlange=false
              "= true, if axis flange is enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Real[2] n={1,0}
              "Axis of translation resolved in frame_a (= same as in frame_b)"
              annotation (Evaluate=true);
            constant Modelica.SIunits.Position s_offset=0
              "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
              annotation (Evaluate=false);
            parameter Modelica.Mechanics.MultiBody.Types.Axis boxWidthDirection={0,1,0}
              "Vector in width direction of box, resolved in frame_a"
              annotation (Evaluate=true, Dialog(tab="Animation", group=
                    "if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxWidth=world.defaultJointWidth
              "Width of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxHeight=boxWidth
              "Height of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color boxColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Color of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter StateSelect stateSelect=StateSelect.prefer
              "Priority to use distance s and v=der(s) as states" annotation(Dialog(tab="Advanced"));
            final parameter Real e[2](each final unit="1")=
               Modelica.Math.Vectors.normalize(n,0.0)
              "Unit vector in direction of prismatic axis n";

            Modelica.SIunits.Position s(start=0, final stateSelect=stateSelect)
              "Relative distance between frame_a and frame_b"
              annotation (unassignedMessage="
The relative distance s of a prismatic joint cannot be determined.
Possible reasons:
- A non-zero mass might be missing on either side of the parts
  connected to the prismatic joint.
- Too many StateSelect.always are defined and the model
  has less degrees of freedom as specified with this setting
  (remove all StateSelect.always settings).
");

            Modelica.SIunits.Velocity v(start=0,final stateSelect=stateSelect)
              "First derivative of s (relative velocity)";
            Modelica.SIunits.Acceleration a(start=0)
              "Second derivative of s (relative acceleration)";
            Modelica.SIunits.Force f
              "Actuation force in direction of joint axis";

          protected
            outer World world;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape box(
              shapeType="box",
              color=boxColor,
              specularCoefficient=specularCoefficient,
              length=if noEvent(abs(s + s_offset) > 1.e-6) then s + s_offset else 1.e-6,
              width=boxWidth,
              height=boxHeight,
              lengthDirection=cat(1, e, {0}),
              widthDirection=boxWidthDirection,
              r=cat(1, frame_a.s, {0}),
              R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;
            Modelica.Mechanics.Translational.Components.Fixed fixed
              annotation (Placement(transformation(extent={{-50,30},{-30,50}})));
            Modelica.Mechanics.Translational.Interfaces.InternalSupport internalAxis(f=f)
              annotation (Placement(transformation(extent={{70,50},{90,30}})));
            Modelica.Mechanics.Translational.Sources.ConstantForce constantForce(
                f_constant=0) if not useAxisFlange
              annotation (Placement(transformation(extent={{40,30},{60,50}})));
          public
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a
                               frame_a
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{-116,
                      -16},{-84,16}},      rotation=0)));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b
                               frame_b
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,-16},
                      {116,16}},      rotation=0)));
          equation
            v = der(s);
            a = der(v);

            // relationships between kinematic quantities of frame_a and of frame_b
            frame_b.s = frame_a.s + Frames.resolve1(frame_a.phi,
              e*(s_offset + s));
            frame_b.phi = frame_a.phi;

            // Force and torque balance
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau + C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, e*(s_offset + s))*{frame_b.f[2], - frame_b.f[1]};

            // d'Alemberts principle
            f = -C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, e)*frame_b.f;

            // Connection to internal connectors
            s = internalAxis.s;

            connect(fixed.flange, support) annotation (Line(
                points={{-40,40},{-40,60}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(internalAxis.flange, axis)    annotation (Line(
                points={{80,40},{80,60}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(constantForce.flange, internalAxis.flange)    annotation (Line(
                points={{60,40},{80,40}},
                color={0,127,0},
                smooth=Smooth.None));
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-100,-50},{-30,41}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-100,40},{-30,50}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-30,-30},{100,20}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-30,20},{100,30}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Line(points={{-30,-50},{-30,50}}, color={0,0,0}),
                  Line(points={{100,-30},{100,21}}, color={0,0,0}),
                  Text(
                    extent={{60,12},{96,-13}},
                    lineColor={128,128,128},
                    textString="b"),
                  Text(
                    extent={{-95,13},{-60,-9}},
                    lineColor={128,128,128},
                    textString="a"),
                  Text(
                    visible=useAxisFlange,
                    extent={{-150,-135},{150,-95}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-150,-90},{150,-60}},
                    lineColor={0,0,0},
                    textString="n=%n"),
                  Rectangle(
                    visible=useAxisFlange,
                    extent={{90,30},{100,70}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Text(
                    visible=not useAxisFlange,
                    extent={{-150,60},{150,100}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics),
              Documentation(info="<html>
<p>Joint where frame_b is translated along axis n which is fixed in frame_a. The two frames coincide when the relative distance &QUOT;s = 0&QUOT;. </p>
<p>Optionally, two additional 1-dimensional mechanical flanges (flange &QUOT;axis&QUOT; represents the driving flange and flange &QUOT;support&QUOT; represents the bearing) can be enabled via parameter <b>useAxisFlange</b>. The enabled axis flange can be driven with elements of the <a href=\"modelica://Modelica.Mechanics.Translational\">Modelica.Mechanics.Translational</a> library. </p>
<p>In the &QUOT;Advanced&QUOT; menu it can be defined via parameter <b>stateSelect</b> that the relative distance &QUOT;s&QUOT; and its derivative shall be definitely used as states by setting stateSelect=StateSelect.always. Default is StateSelect.prefer to use the relative distance and its derivative as preferred states. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the StateSelect.always setting. </p>
</html>"));
          end Prismatic;

          model Prismatic_Dynamic_Color
            "Same as Prismatic but allows the color to change dynamically"

            import SI = Modelica.SIunits;
            //extends Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint;
            Modelica.Mechanics.Translational.Interfaces.Flange_a axis if useAxisFlange
              "1-dim. translational flange that drives the joint"
              annotation (Placement(transformation(extent={{90,50},{70,70}}, rotation=0)));
            Modelica.Mechanics.Translational.Interfaces.Flange_b support if useAxisFlange
              "1-dim. translational flange of the drive drive support (assumed to be fixed in the world frame, NOT in the joint)"
              annotation (Placement(transformation(extent={{-30,50},{-50,70}}, rotation=
                     0)));

            parameter Boolean useAxisFlange=false
              "= true, if axis flange is enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Real[2] n={1,0}
              "Axis of translation resolved in frame_a (= same as in frame_b)"
              annotation (Evaluate=true);
            constant Modelica.SIunits.Position s_offset=0
              "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
              annotation (Evaluate=false);
            parameter Modelica.Mechanics.MultiBody.Types.Axis boxWidthDirection={0,1,0}
              "Vector in width direction of box, resolved in frame_a"
              annotation (Evaluate=true, Dialog(tab="Animation", group=
                    "if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxWidth=world.defaultJointWidth
              "Width of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxHeight=boxWidth
              "Height of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color boxColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Color of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Real color_thresh= 0
              "Value of u below which to use alt color"                              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color alt_color=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Alt Color of prismatic joint box"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter StateSelect stateSelect=StateSelect.prefer
              "Priority to use distance s and v=der(s) as states" annotation(Dialog(tab="Advanced"));
            final parameter Real e[2](each final unit="1")=
               Modelica.Math.Vectors.normalize(n,0.0)
              "Unit vector in direction of prismatic axis n";

            Modelica.SIunits.Position s(start=0, final stateSelect=stateSelect)
              "Relative distance between frame_a and frame_b"
              annotation (unassignedMessage="
The relative distance s of a prismatic joint cannot be determined.
Possible reasons:
- A non-zero mass might be missing on either side of the parts
  connected to the prismatic joint.
- Too many StateSelect.always are defined and the model
  has less degrees of freedom as specified with this setting
  (remove all StateSelect.always settings).
");

            Modelica.SIunits.Velocity v(start=0,final stateSelect=stateSelect)
              "First derivative of s (relative velocity)";
            Modelica.SIunits.Acceleration a(start=0)
              "Second derivative of s (relative acceleration)";
            Modelica.SIunits.Force f
              "Actuation force in direction of joint axis";

          protected
            outer World world;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape box(
              shapeType="box",
              color=if noEvent(u >= color_thresh) then boxColor else alt_color,
              specularCoefficient=specularCoefficient,
              length=if noEvent(abs(s + s_offset) > 1.e-6) then s + s_offset else 1.e-6,
              width=boxWidth,
              height=boxHeight,
              lengthDirection=cat(1, e, {0}),
              widthDirection=boxWidthDirection,
              r=cat(1, frame_a.s, {0}),
              R=Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;
            Modelica.Mechanics.Translational.Components.Fixed fixed
              annotation (Placement(transformation(extent={{-50,30},{-30,50}})));
            Modelica.Mechanics.Translational.Interfaces.InternalSupport internalAxis(f=f)
              annotation (Placement(transformation(extent={{70,50},{90,30}})));
            Modelica.Mechanics.Translational.Sources.ConstantForce constantForce(
                f_constant=0) if not useAxisFlange
              annotation (Placement(transformation(extent={{40,30},{60,50}})));
          public
            Modelica.Blocks.Interfaces.RealInput u
              "use normal color if u >=0 else alt_color" annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=90,
                  origin={0,-119})));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a
                               frame_a
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{-116,
                      -16},{-84,16}},      rotation=0)));
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b
                               frame_b
              "Coordinate system fixed to the joint with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,-16},
                      {116,16}},      rotation=0)));
          equation
            v = der(s);
            a = der(v);

            // relationships between kinematic quantities of frame_a and of frame_b
            frame_b.s = frame_a.s + Frames.resolve1(frame_a.phi,
              e*(s_offset + s));
            frame_b.phi = frame_a.phi;

            // Force and torque balance
            zeros(2) = frame_a.f + frame_b.f;
            0 = frame_a.tau + frame_b.tau + C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, e*(s_offset + s))*{frame_b.f[2], - frame_b.f[1]};

            // d'Alemberts principle
            f = -C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, e)*frame_b.f;

            // Connection to internal connectors
            s = internalAxis.s;

            connect(fixed.flange, support) annotation (Line(
                points={{-40,40},{-40,60}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(internalAxis.flange, axis)    annotation (Line(
                points={{80,40},{80,60}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(constantForce.flange, internalAxis.flange)    annotation (Line(
                points={{60,40},{80,40}},
                color={0,127,0},
                smooth=Smooth.None));
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-100,-50},{-30,41}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-100,40},{-30,50}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-30,-30},{100,20}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-30,20},{100,30}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Line(points={{-30,-50},{-30,50}}, color={0,0,0}),
                  Line(points={{100,-30},{100,21}}, color={0,0,0}),
                  Text(
                    extent={{60,12},{96,-13}},
                    lineColor={128,128,128},
                    textString="b"),
                  Text(
                    extent={{-95,13},{-60,-9}},
                    lineColor={128,128,128},
                    textString="a"),
                  Text(
                    visible=useAxisFlange,
                    extent={{-150,-135},{150,-95}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-150,-90},{150,-60}},
                    lineColor={0,0,0},
                    textString="n=%n"),
                  Rectangle(
                    visible=useAxisFlange,
                    extent={{90,30},{100,70}},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,255}),
                  Text(
                    visible=not useAxisFlange,
                    extent={{-150,60},{150,100}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics),
              Documentation(info="<html>
<p>Joint where frame_b is translated along axis n which is fixed in frame_a. The two frames coincide when the relative distance &QUOT;s = 0&QUOT;. </p>
<p>Optionally, two additional 1-dimensional mechanical flanges (flange &QUOT;axis&QUOT; represents the driving flange and flange &QUOT;support&QUOT; represents the bearing) can be enabled via parameter <b>useAxisFlange</b>. The enabled axis flange can be driven with elements of the <a href=\"modelica://Modelica.Mechanics.Translational\">Modelica.Mechanics.Translational</a> library. </p>
<p>In the &QUOT;Advanced&QUOT; menu it can be defined via parameter <b>stateSelect</b> that the relative distance &QUOT;s&QUOT; and its derivative shall be definitely used as states by setting stateSelect=StateSelect.always. Default is StateSelect.prefer to use the relative distance and its derivative as preferred states. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the StateSelect.always setting. </p>
</html>"));
          end Prismatic_Dynamic_Color;

          model Planar
            "Planar joint (3 degrees-of-freedom, 6 potential states)"
            import SI = Modelica.SIunits;

            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,0,1}
              "Axis orthogonal to unconstrained plane, resolved in frame_a (= same as in frame_b)"
              annotation (Evaluate=true);
            parameter Modelica.Mechanics.MultiBody.Types.Axis n_x={1,0,0}
              "Vector in direction of x-axis of plane, resolved in frame_a (n_x shall be orthogonal to n)"
              annotation (Evaluate=true);
            parameter Modelica.SIunits.Distance cylinderLength=world.defaultJointLength
              "Length of revolute cylinder"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance cylinderDiameter=world.defaultJointWidth
              "Diameter of revolute cylinder"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Color of revolute cylinder"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxWidth=0.3*cylinderDiameter
              "Width of prismatic joint boxes"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter Modelica.SIunits.Distance boxHeight=boxWidth
              "Height of prismatic joint boxes"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color boxColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor
              "Color of prismatic joint boxes"
              annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
            parameter StateSelect stateSelect=StateSelect.prefer
              "Priority to use joint coordinates (s_x, s_y, phi, v_x, v_y, w) as states"
                                                                                         annotation(Dialog(tab="Advanced"));

            Prismatic prismatic_x(
              stateSelect=StateSelect.never,
              n={1,0},
              animation=false) annotation (Placement(transformation(extent={{-69,-20},
                      {-29,20}}, rotation=0)));
            Prismatic prismatic_y(
              stateSelect=StateSelect.never,
              n={0,1},
              animation=false) annotation (Placement(transformation(
                  origin={0,50},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
            Revolute revolute(
              stateSelect=StateSelect.never,
              animation=false) annotation (Placement(transformation(extent={{41,-20},{
                      81,20}}, rotation=0)));

            Modelica.SIunits.Position s_x(start=0, stateSelect=stateSelect)
              "Relative distance along first prismatic joint starting at frame_a";
            Modelica.SIunits.Position s_y(start=0, stateSelect=stateSelect)
              "Relative distance along second prismatic joint starting at first prismatic joint";
            Modelica.SIunits.Angle phi(start=0, stateSelect=stateSelect)
              "Relative rotation angle from frame_a to frame_b";
            Modelica.SIunits.Velocity v_x(start=0, stateSelect=stateSelect)
              "First derivative of s_x (relative velocity in s_x direction)";
            Modelica.SIunits.Velocity v_y(start=0, stateSelect=stateSelect)
              "First derivative of s_y (relative velocity in s_y direction)";
            Modelica.SIunits.AngularVelocity w(start=0, stateSelect=stateSelect)
              "First derivative of angle phi (relative angular velocity)";
            Modelica.SIunits.Acceleration a_x(start=0)
              "Second derivative of s_x (relative acceleration in s_x direction)";
            Modelica.SIunits.Acceleration a_y(start=0)
              "Second derivative of s_y (relative acceleration in s_y direction)";
            Modelica.SIunits.AngularAcceleration wd(start=0)
              "Second derivative of angle phi (relative angular acceleration)";

            Interfaces.Frame_a frame_a
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{
                      -116,-16},{-84,16}}, rotation=0)));
            Interfaces.Frame_b frame_b
              "Coordinate system fixed to the component with one cut-force and cut-torque"
                                       annotation (Placement(transformation(extent={{84,
                      -16},{116,16}}, rotation=0)));
          protected
            parameter Integer ndim=if world.enableAnimation and animation then 1 else 0;
            outer World world;

          protected
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape box_x[ndim](
              each shapeType="box",
              each color=boxColor,
              each length=prismatic_x.s,
              each width=boxWidth,
              each height=boxWidth,
              each lengthDirection={1,0,0},
              each widthDirection={0,1,0},
              each r=cat(1,frame_a.s,{0}),
              each R=C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.rotation(frame_a.phi)) annotation (Placement(transformation(extent={{-80,30},{
                      -60,50}}, rotation=0)));
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape box_y[ndim](
              each shapeType="box",
              each color=boxColor,
              each length=prismatic_y.s,
              each width=boxWidth,
              each height=boxWidth,
              each lengthDirection={0,1,0},
              each widthDirection={1,0,0},
              each r=cat(1,prismatic_y.frame_a.s,{0}),
              each R=C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.rotation(prismatic_y.frame_a.phi)) annotation (Placement(transformation(extent=
                     {{-46,69},{-26,89}}, rotation=0)));
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder[ndim](
              each shapeType="cylinder",
              each color=cylinderColor,
              each length=cylinderLength,
              each width=cylinderDiameter,
              each height=cylinderDiameter,
              each lengthDirection={0,0,1},
              each widthDirection={0,1,0},
              each r_shape=-{0,0,1}*(cylinderLength/2),
              each r=cat(1, revolute.frame_b.s, {0}),
              each R=C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.rotation(revolute.frame_b.phi)) annotation (Placement(transformation(extent={{
                      50,30},{70,50}}, rotation=0)));
          equation
            s_x = prismatic_x.s;
            s_y = prismatic_y.s;
            phi = revolute.phi;
            v_x = der(s_x);
            v_y = der(s_y);
            w   = der(phi);
            a_x = der(v_x);
            a_y = der(v_y);
            wd  = der(w);

            connect(frame_a, prismatic_x.frame_a)
              annotation (Line(
                points={{-100,0},{-69,0}},
                color={95,95,95},
                thickness=0.5));
            connect(prismatic_x.frame_b, prismatic_y.frame_a) annotation (Line(
                points={{-29,0},{-1.22465e-015,0},{-1.22465e-015,30}},
                color={95,95,95},
                thickness=0.5));
            connect(prismatic_y.frame_b, revolute.frame_a) annotation (Line(
                points={{1.22465e-015,70},{0,80},{30,80},{30,0},{41,0}},
                color={95,95,95},
                thickness=0.5));
            connect(revolute.frame_b, frame_b)
              annotation (Line(
                points={{81,0},{100,0}},
                color={95,95,95},
                thickness=0.5));
            annotation (
              Documentation(info="<html>
<p>Joint where frame_b can move in the plane and can rotate around an axis orthogonal to the plane. frame_a and frame_b coincide when s_x=prismatic_x.s=0, s_y=prismatic_y.s=0 and phi=revolute.phi=0. This joint has the following potential states: </p>
<p><ul>
<li>the relative distance s_x = prismatic_x.s [m] along axis {1,0}, </li>
<li>the relative distance s_y = prismatic_y.s [m] along axis {0,1}, </li>
<li>the relative angle phi = revolute.phi [rad], </li>
<li>the relative velocity v_x (= der(s_x)).</li>
<li>the relative velocity v_y (= der(s_y)).</li>
<li>the relative angular velocity w (= der(phi))</li>
</ul></p>
<p>They are used as candidates for automatic selection of states from the tool. This may be enforced by setting &QUOT;stateSelect=StateSelect.<b>always</b>&QUOT; in the <b>Advanced</b> menu. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the &QUOT;StateSelect.always&QUOT; setting.</p>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Rectangle(
                    extent={{-30,-60},{-10,60}},
                    lineColor={0,0,0},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{10,-60},{30,60}},
                    lineColor={0,0,0},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-100,-10},{-30,10}},
                    lineColor={0,0,0},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{100,-10},{30,10}},
                    lineColor={0,0,0},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-75},{150,-105}},
                    lineColor={0,0,0},
                    textString="n=%n"),
                  Text(
                    extent={{-150,110},{150,70}},
                    textString="%name",
                    lineColor={0,0,255})}));
          end Planar;
        end Joints;

        package Forces
          extends Modelica.Icons.Package;

          model Force
            "External force acting on frame_b, defined by two input signals and resolved in world frame"

            Modelica.Blocks.Interfaces.RealInput[2] f
              "x- and y-coordinates of force resolved in world"
                                              annotation (Placement(transformation(
                    extent={{-140,-20},{-100,20}}, rotation=0)));

            Interfaces.Frame_b frame_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            frame_b.f = -f;
            frame_b.tau = 0;
            annotation (
              Documentation(info="<html>
<p>The 2 signals of the <b>f</b> connector are interpreted as the x- and y-coordinates of a <b>force</b> acting at the frame connector to which frame_b of this component is attached. These coordinates are resolved in world frame.</p>
<p>This component provides no visualization.</p>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics={
                  Polygon(
                    points={{-100,10},{20,10},{20,41},{90,0},{20,-41},{20,-10},{-100,
                        -10},{-100,10}},
                    lineColor={0,127,0},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-32},{-80,-62}},
                    lineColor={0,0,0},
                    textString="f"),
                  Text(
                    extent={{-150,90},{150,50}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(points={{-30,-60},{30,-60}}, color={0,0,0}),
                  Line(points={{0,-60},{0,-101}}, color={0,0,0}),
                  Line(points={{-30,-80},{-10,-60}}, color={0,0,0}),
                  Line(points={{-10,-80},{10,-60}}, color={0,0,0}),
                  Line(points={{10,-80},{30,-60}}, color={0,0,0}),
                  Polygon(
                    points={{-61,-50},{-30,-40},{-30,-60},{-61,-50}},
                    lineColor={0,0,0},
                    fillColor={128,128,128},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-31,-50},{50,-50}}, color={0,0,0}),
                  Line(points={{-50,-80},{-30,-60}}, color={0,0,0})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={2,2}), graphics));
          end Force;

          model LineForceWithMass
            "General line force component with an optional point mass on the connection line"

            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Types;
            extends Interfaces.PartialTwoFrames;
            Modelica.Mechanics.Translational.Interfaces.Flange_a flange_b
              "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
              annotation (Placement(transformation(
                  origin={60,100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Mechanics.Translational.Interfaces.Flange_b flange_a
              "1-dim. translational flange (connect force of Translational library between flange_a and flange_b)"
              annotation (Placement(transformation(
                  origin={-60,100},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));

            parameter Boolean animateLine=true
              "= true, if a line shape between frame_a and frame_b shall be visualized";
            parameter Boolean animateMass=true
              "= true, if point mass shall be visualized as sphere provided m > 0";
            parameter Modelica.SIunits.Mass m(min=0)=0
              "Mass of point mass on the connetion line between the origin of frame_a and the origin of frame_b";
            parameter Real lengthFraction(
              unit="1",
              min=0,
              max=1) = 0.5
              "Location of point mass with respect to frame_a as a fraction of the distance from frame_a to frame_b";
            input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
              annotation (Dialog(tab="Animation"));
            parameter Types.ShapeType lineShapeType="cylinder"
              "Type of shape visualizing the line from frame_a to frame_b"
              annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
            input Modelica.SIunits.Length lineShapeWidth=world.defaultArrowDiameter
              "Width of shape"
              annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
            input Modelica.SIunits.Length lineShapeHeight=lineShapeWidth
              "Height of shape"
              annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
            parameter Types.ShapeExtra lineShapeExtra=0.0
              "Extra parameter for shape"
              annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
            input Types.Color lineShapeColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor
              "Color of line shape"
              annotation (Dialog(tab="Animation", group="if animateLine = true", enable=animateLine));
            input Real massDiameter=world.defaultBodyDiameter
              "Diameter of point mass sphere"
              annotation (Dialog(tab="Animation", group="if animateMass = true", enable=animateMass));
            input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor
              "Color of point mass"
              annotation (Dialog(tab="Animation", group="if animateMass = true", enable=animateMass));
            parameter Modelica.SIunits.Position s_small=1.E-10
              "Prevent zero-division if distance between frame_a and frame_b is zero"
              annotation (Dialog(tab="Advanced"));
            parameter Boolean fixedRotationAtFrame_a=false
              "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
               annotation (Evaluate=true, choices(__Dymola_checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
            parameter Boolean fixedRotationAtFrame_b=false
              "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
               annotation (Evaluate=true, choices(__Dymola_checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));

            Modelica.SIunits.Distance length
              "Distance between the origin of frame_a and the origin of frame_b";
            Modelica.SIunits.Position r_rel_0[2]
              "Position vector from frame_a to frame_b resolved in world frame";
            Real e_rel_0[3](each final unit="1")
              "Unit vector in direction from frame_a to frame_b, resolved in world frame";
          protected
            Modelica.SIunits.Force fa "Force from flange_a";
            Modelica.SIunits.Force fb "Force from flange_b";
            Modelica.SIunits.Position r_CM_0[2](stateSelect=StateSelect.avoid)
              "Position vector from world frame to point mass, resolved in world frame";
            Modelica.SIunits.Velocity v_CM_0[2](stateSelect=StateSelect.avoid)
              "First derivative of r_CM_0";
            Modelica.SIunits.Acceleration ag_CM_0[2]
              "der(v_CM_0) - gravityAcceleration";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape lineShape(
              shapeType=lineShapeType,
              color=lineShapeColor,
              specularCoefficient=specularCoefficient,
              length=length,
              width=lineShapeWidth,
              height=lineShapeHeight,
              lengthDirection=e_rel_0,
              widthDirection=cat(1, MSL_Extend.Mechanics.Planar.Frames.resolve1(frame_a.phi, {0,1}), {0}),
              extra=lineShapeExtra,
              r=cat(1, frame_a.s, {0})) if world.enableAnimation and animateLine;

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape massShape(
              shapeType="sphere",
              color=massColor,
              specularCoefficient=specularCoefficient,
              length=massDiameter,
              width=massDiameter,
              height=massDiameter,
              lengthDirection=e_rel_0,
              widthDirection={0,1,0},
              r_shape=e_rel_0*(length*lengthFraction - massDiameter/2),
              r=cat(1, frame_a.s, {0})) if world.enableAnimation and animateMass and m > 0;
          equation
            assert(noEvent(length > s_small), "
The distance between the origin of frame_a and the origin of frame_b
of a LineForceWithMass component became smaller as parameter s_small
(= a small number, defined in the \"Advanced\" menu). The distance is
set to s_small, although it is smaller, to avoid a division by zero
when computing the direction of the line force. Possible reasons
for this situation:
- At initial time the distance may already be zero: Change the initial
  positions of the bodies connected by this element.
- Hardware stops are not modeled or are modeled not stiff enough.
  Include stops, e.g., stiff springs, or increase the stiffness
  if already present.
- Another error in your model may lead to unrealistically large forces
  and torques that would in reality destroy the stops.
- The flange_b connector might be defined by a pre-defined motion,
  e.g., with Modelica.Mechanics.Translational.Position and the
  predefined flange_b.s is zero or negative.
");

            // Determine relative position vector between the two frames
            r_rel_0 = frame_b.s - frame_a.s;
            length = Modelica.Math.Vectors.length(
                                   r_rel_0);
            flange_a.s = 0;
            flange_b.s = length;
            e_rel_0 = cat(1, r_rel_0, {0})/
              Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(length,
              s_small);

            // Determine translational flange forces
              fa = flange_a.f;
              fb = flange_b.f;

            /* Force and torque balance of point mass
     - Kinematics for center of mass CM of point mass including gravity
       r_CM_0 = frame_a.r0 + r_rel_CM_0;
       v_CM_0 = der(r_CM_0);
       ag_CM_0 = der(v_CM_0) - world.gravityAcceleration(r_CM_0);
     - Power balance for the connection line
       (f1=force on frame_a side, f2=force on frame_b side, h=lengthFraction)
       0 = f1*va - m*ag_CM*(va+(vb-va)*h) + f2*vb
         = (f1 - m*ag_CM*(1-h))*va + (f2 - m*ag_CM*h)*vb
       since va and vb are completely indepedent from other
       the paranthesis must vanish:
         f1 := m*ag_CM*(1-h)
         f2 := m*ag_CM*h
     - Force balance on frame_a and frame_b finally results in
         0 = frame_a.f + e_rel_a*fa - f1_a
         0 = frame_b.f + e_rel_b*fb - f2_b
       and therefore
         frame_a.f = -e_rel_a*fa + m*ag_CM_a*(1-h)
         frame_b.f = -e_rel_b*fb + m*ag_CM_b*h
  */
            if m > 0 then
              r_CM_0 = frame_a.s + r_rel_0*lengthFraction;
              v_CM_0 = der(r_CM_0);
              ag_CM_0 = der(v_CM_0) - world.g*world.n;
              frame_a.f = MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, (m*(1 -
                lengthFraction))*ag_CM_0 - e_rel_0[1:2]*fa);
              frame_b.f = MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_b.phi, (m*
                lengthFraction)*ag_CM_0 - e_rel_0[1:2]*fb);
            else
              r_CM_0 = zeros(2);
              v_CM_0 = zeros(2);
              ag_CM_0 = zeros(2);
              frame_a.f = -MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi,
                e_rel_0[1:2]*fa);
              frame_b.f = -MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_b.phi,
                e_rel_0[1:2]*fb);
            end if;

            // Provide appropriate equations, if direct connections of line forces
            if fixedRotationAtFrame_a then
              frame_a.phi = 0;
            else
              frame_a.tau = 0;
            end if;

            if fixedRotationAtFrame_b then
              frame_b.phi = 0;
            else
              frame_b.tau = 0;
            end if;
            annotation (
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Ellipse(
                    extent={{-95,-40},{-15,40}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{-85,-30},{-25,30}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{15,-40},{95,40}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{23,-30},{83,29}},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-55},{150,-95}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-40,41},{44,-40}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-70,15},{-41,-13}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{40,14},{69,-14}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Line(points={{-56,0},{-56,23},{-30,23},{-30,70},{-60,70},{-60,101}},
                      color={0,0,0}),
                  Line(points={{55,-1},{55,20},{30,20},{30,70},{60,70},{60,100}}, color=
                       {0,0,0}),
                  Line(
                    points={{-56,0},{55,-1}},
                    color={0,0,0},
                    pattern=LinePattern.Dot),
                  Ellipse(
                    extent={{-8,8},{8,-8}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
                  Text(visible=fixedRotationAtFrame_a,
                    extent={{-62,50},{-140,30}},
                    lineColor={255,0,0},
                    textString="R=0"),
                  Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
                  Text(visible=fixedRotationAtFrame_b,
                    extent={{62,50},{140,30}},
                    lineColor={255,0,0},
                    textString="R=0")}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Line(points={{-60,80},{46,80}}, color={0,0,255}),
                  Polygon(
                    points={{60,80},{45,86},{45,74},{60,80}},
                    lineColor={0,0,255},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-50,93},{32,78}},
                    textString="length",
                    lineColor={0,0,255}),
                  Ellipse(
                    extent={{-100,-40},{-20,40}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{-90,-30},{-30,30}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{20,-40},{100,40}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{31,-29},{91,30}},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-50,39},{50,-41}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-74,15},{-45,-13}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Ellipse(
                    extent={{45,15},{74,-13}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Sphere,
                    fillColor={192,192,192}),
                  Line(points={{-60,0},{-60,24},{-40,24},{-40,60},{-60,60},{-60,100}},
                      color={0,0,0}),
                  Line(points={{60,1},{60,21},{40,21},{40,60},{60,60},{60,100}}, color=
                        {0,0,0}),
                  Line(
                    points={{-60,0},{60,0}},
                    color={0,0,0},
                    pattern=LinePattern.Dot),
                  Ellipse(
                    extent={{-8,8},{8,-8}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-60,0},{-31,0}}, color={0,0,255}),
                  Polygon(points={{-19,0},{-31,3},{-31,-3},{-19,0}}, lineColor={0,0,255}),
                  Line(points={{-60,16},{0,16}}, color={0,0,255}),
                  Line(points={{0,0},{0,20}}, color={0,0,255}),
                  Text(
                    extent={{-49,-11},{-8,-21}},
                    lineColor={0,0,0},
                    textString="e_rel_0"),
                  Polygon(points={{0,16},{-12,19},{-12,13},{0,16}}, lineColor={0,0,255}),
                  Text(
                    extent={{-50,35},{51,26}},
                    lineColor={0,0,0},
                    textString="length*lengthFraction"),
                  Line(
                    points={{-17,26},{-26,16}},
                    pattern=LinePattern.Dot,
                    color={0,0,255}),
                  Line(
                    points={{-31,-13},{-40,0}},
                    pattern=LinePattern.Dot,
                    color={0,0,255})}),
              Documentation(info="<html>
<p>
This component is used to exert a <b>line force</b>
between the origin of frame_a and the origin of frame_b
by attaching components of the <b>1-dimensional translational</b>
mechanical library of Modelica (Modelica.Mechanics.Translational)
between the two flange connectors <b>flange_a</b> and
<b>flange_b</b>. Optionally, there is a <b>point mass</b> on the line
connecting the origin of frame_a and the origin of frame_b.
This point mass approximates the <b>mass</b> of the <b>force element</b>.
The distance of the point mass from frame_a as a fraction of the
distance between frame_a and frame_b is defined via
parameter <b>lengthFraction</b> (default is 0.5, i.e., the point
mass is in the middle of the line).
</p>
<p>
In the translational library there is the implicit assumption that
forces of components that have only one flange connector act with
opposite sign on the bearings of the component. This assumption
is also used in the LineForceWithMass component: If a connection
is present to only one of the flange connectors, then the force
in this flange connector acts implicitly with opposite sign also
in the other flange connector.
</p>
</html>"));
          end LineForceWithMass;

          package Internal
            extends Modelica.Icons.Package;
            function standardGravityAcceleration
              "Standard gravity fields (no/parallel/point field)"
              import Modelica.Mechanics.MultiBody.Types.GravityTypes;
               input Modelica.SIunits.Position r[2]
                "Position vector from world frame to actual point, resolved in world frame";
              input GravityTypes gravityType "Type of gravity field" annotation(Dialog);
              input Modelica.SIunits.Acceleration g[2]
                "Constant gravity acceleration, resolved in world frame, if gravityType=UniformGravity"
                                                                                                        annotation(Dialog);
              input Real mue(unit="m3/s2")
                "Field constant of point gravity field, if gravityType=PointGravity"
                                                                                     annotation(Dialog);
              output Modelica.SIunits.Acceleration gravity[2]
                "Gravity acceleration at position r, resolved in world frame";
            algorithm
            gravity := if gravityType == GravityTypes.UniformGravity then g else
                       if gravityType == GravityTypes.PointGravity then
                          -(mue/(r*r))*(r/Modelica.Math.Vectors.length(r)) else zeros(2);
              annotation(Inline=true, Documentation(info="<html>
<p>
This function defines the standard gravity fields for the World object.
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b><i>gravityType</i></b></td>
    <td><b><i>gravity [m/s2]</i></b></td>
    <td><b><i>description</i></b></td></tr>
<tr><td>Types.GravityType.NoGravity</td>
    <td>= {0,0,0}</td>
    <td>No gravity</td></tr>

<tr><td>Types.GravityType.UniformGravity</td>
    <td>= g</td>
    <td> Constant parallel gravity field</td></tr>

<tr><td>Types.GravityType.PointGravity</td>
    <td>= -(mue/(r*r))*r/|r|</td>
    <td> Point gravity field with spherical mass</td></tr>
</table>

</html>"));
            end standardGravityAcceleration;
          end Internal;
        end Forces;

        package Visualizers
          extends Modelica.Icons.Package;
          model VoluminousWheel "Visualizing a voluminous wheel"
            import SI = Modelica.SIunits;
          //   extends Modelica.Mechanics.MultiBody.Interfaces.PartialVisualizer;

            parameter Boolean animation=true
              "= true, if animation shall be enabled";

            parameter Modelica.SIunits.Radius rTire=0.25 "Radius of the tire";
            parameter Modelica.SIunits.Radius rRim= 0.14 "Radius of the rim";
            parameter Modelica.SIunits.Radius width=0.25 "Width of the tire";
            parameter Modelica.SIunits.Radius rCurvature=0.30
              "Radius of the curvature of the tire";

            parameter Modelica.Mechanics.MultiBody.Types.RealColor color={64,64,64}
              "Color of tire"  annotation(Dialog(enable=animation,__Dymola_colorSelector=true,group="Material properties", enable=not multiColoredSurface));
            parameter Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=0.5
              "Reflection of ambient light (= 0: light is completely absorbed)"
                                                                                annotation(Dialog(enable=animation,group="Material properties"));
            parameter Integer n_rTire=40 "Number of points along rTire" annotation(Dialog(enable=animation,tab="Discretization"));
            parameter Integer n_rCurvature=20
              "Number of points along rCurvature"                                 annotation(Dialog(enable=animation,tab="Discretization"));

            Interfaces.Frame_a frame_a
              "Coordinate system in which visualization data is resolved"                          annotation (Placement(
                  transformation(extent={{-116,-16},{-84,16}}, rotation=0)));
          protected
            parameter Modelica.SIunits.Radius rw = (width/2);
            parameter Modelica.SIunits.Radius rCurvature2 = if rCurvature > rw then rCurvature else rw;
            parameter Modelica.SIunits.Radius h =     sqrt(1-(rw/rCurvature2)*(rw/rCurvature2))*rCurvature2;
            parameter Modelica.SIunits.Radius ri =    rTire-rCurvature2;
            parameter Modelica.SIunits.Radius rRim2 = if rRim < 0 then 0 else if rRim > ri+h then ri+h else rRim;
            outer World world;

              Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape pipe(
              shapeType="pipe",
              color=color,
              length=width,
              width=2*(ri + h),
              height=2*(ri + h),
              lengthDirection={0,1,0},
              widthDirection={0,0,1},
              extra=(rRim2)/(ri + h),
              r=cat(1, frame_a.s, {0}),
              r_shape=-{0,1,0}*(width/2),
              R=Modelica.Mechanics.MultiBody.Frames.axesRotations({3, 1, 2}, {frame_a.phi, 0.5*Modelica.Constants.pi, 0}, {0, 0, 0}),
              specularCoefficient=specularCoefficient) if world.enableAnimation and
              animation
                    annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

              Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface torus(
              redeclare function surfaceCharacteristic =
                  Modelica.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.torus
                  (
                  ri=ri,
                  ro=rCurvature2,
                  opening=Modelica.Constants.pi - Modelica.Math.asin(rw/rCurvature2)),
              nu=n_rTire,
              nv=n_rCurvature,
              multiColoredSurface=false,
              wireframe=false,
              color=color,
              specularCoefficient=specularCoefficient,
              transparency=0,
              R=Modelica.Mechanics.MultiBody.Frames.axesRotations({3, 1, 2}, {frame_a.phi, 0.5*Modelica.Constants.pi, 0}, {0, 0, 0}),
              r_0=cat(1, frame_a.s, {0})) if world.enableAnimation and animation
              annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));

          equation
            // No forces and torques
            frame_a.f = zeros(2);
            frame_a.tau = 0;
            annotation (Icon(graphics={
                    Text(
                    extent={{-150,100},{150,140}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Bitmap(extent={{-96,96},{102,-96}}, fileName=
                        "modelica://Modelica/Resources/Images/MultiBody/Visualizers/VoluminousWheelIcon.png"),
                  Rectangle(
                    extent={{-96,8},{-18,-8}},
                    lineColor={95,95,95},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.HorizontalCylinder)}),
                                           Documentation(info="<html>
<p>Model <b>VoluminousWheel</b> provides a simple visualization of a tire using a torus and a pipe shape object. The center of the wheel is located at connector frame_a. Note that while this is a planar 2d adaptation of the <a href=\"Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">MultiBody wheel</a>, the coordinate system is rotated so that the wheel&apos;s axis of rotation coincides with the planar axis of rotation (z-axis). </p>
</html>",           revisions="<html>
  <ul>
  <li> July 2010 by Martin Otter<br>
       Adapted to the new Surface model.</li>
  <li> July 2005 by Dirk Zimmer (practical training at DLR)<br>
       First version to visualize a multi-level tyre wheel model.</li>
  </ul>
</html>"));
          end VoluminousWheel;

          model FixedShape
            "Visualizing an elementary shape with dynamically varying shape attributes (has one frame connector)"
            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Types;
          //   extends Modelica.Mechanics.MultiBody.Interfaces.PartialVisualizer;

            parameter Boolean animation=true
              "= true, if animation shall be enabled";
            parameter Types.ShapeType shapeType="box" "Type of shape"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Modelica.SIunits.Position r_shape[3]={0,0,0}
              "Vector from frame_a to shape origin, resolved in frame_a"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Types.Axis lengthDirection={1,0,0}
              "Vector in length direction of shape, resolved in frame_a"
              annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
            input Types.Axis widthDirection={0,1,0}
              "Vector in width direction of shape, resolved in frame_a"
              annotation (Evaluate=true, Dialog(group="if animation = true", enable=animation));
            input Modelica.SIunits.Distance length(start=1) "Length of shape"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Modelica.SIunits.Distance width(start=0.1) "Width of shape"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Modelica.SIunits.Distance height(start=0.1) "Height of shape"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Modelica.Mechanics.MultiBody.Types.Color color={0,128,255}
              "Color of shape"
              annotation (Dialog(__Dymola_colorSelector=true, group="if animation = true", enable=animation));
            input Types.ShapeExtra extra=0.0
              "Additional data for cylinder, cone, pipe, gearwheel and spring"
              annotation (Dialog(group="if animation = true", enable=animation));
            input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
              "Reflection of ambient light (= 0: light is completely absorbed)"
              annotation (Dialog(group="if animation = true", enable=animation));
            Interfaces.Frame_a frame_a
              "Coordinate system in which visualization data is resolved"                          annotation (Placement(
                  transformation(extent={{-116,-16},{-84,16}}, rotation=0)));

          protected
            outer World world;
            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape vis(
              shapeType=shapeType,
              r_shape=r_shape,
              lengthDirection=lengthDirection,
              widthDirection=widthDirection,
              length=length,
              width=width,
              height=height,
              color=color,
              extra=extra,
              specularCoefficient=specularCoefficient,
              r=cat(1, frame_a.s, {0}),
              R=Modelica.Mechanics.MultiBody.Frames.axesRotations({3, 2, 1}, {frame_a.phi, 0.5*Modelica.Constants.pi, 0}, zeros(3))) if world.enableAnimation and animation;
          equation
            // No forces and torques
            frame_a.f = zeros(2);
            frame_a.tau = 0;
            annotation (
              Documentation(info="<html>
<p>Model <b>FixedShape</b> defines a visual shape that is shown at the location of its frame_a. All describing data such as size and color can vary dynamically by providing appropriate expressions in the input fields of the parameter menu. The only exception is parameter shapeType that cannot be changed during simulation.</p>
<p>The model is a planar 2d adaptation of the <a href=\"Modelica.Mechanics.MultiBody.Visualizers.FixedShape\">MultiBody FixedShape</a> but rotated 1/4 turn around the y-axis. See the MultiBody model for parameter details.</p>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={
                  Polygon(
                    points={{-100,33},{-100,-61},{-10,-41},{50,-61},{50,33},{-10,11},{-100,
                        33}},
                    lineColor={0,127,255},
                    fillColor={0,127,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-98,34},{-64,46},{0,30},{74,56},{50,32},{-10,12},{-98,34}},
                    lineColor={255,255,255},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{72,54},{50,32},{50,-60},{72,-32},{72,54}},
                    lineColor={255,255,255},
                    fillColor={160,160,164},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-65},{150,-95}},
                    lineColor={0,0,0},
                    textString="%shapeType"),
                  Text(
                    extent={{-150,100},{150,60}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Diagram(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics));
          end FixedShape;
        end Visualizers;

        package Types
          extends Modelica.Icons.Package;
          type GravityTypes = enumeration(
              NoGravity "No gravity field",
              UniformGravity "Uniform gravity field",
              PointGravity "Point gravity field")
            "Enumeration defining the type of the gravity field"
              annotation (Documentation(info="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.GravityTypes.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">NoGravity</td>
    <td valign=\"top\">No gravity field</td></tr>

<tr><td valign=\"top\">UniformGravity</td>
    <td valign=\"top\">Gravity field is described by a vector of constant gravity acceleration</td></tr>

<tr><td valign=\"top\">PointGravity</td>
    <td valign=\"top\">Central gravity field. The gravity acceleration vector is directed to
        the field center and the gravity is proportional to 1/r^2, where
        r is the distance to the field center.</td></tr>
</table>
</html>"));
        end Types;
      end Planar;
    end Mechanics;

    package Media
      extends Modelica.Icons.Package;

      record Constant_Property_JP8 "Medium: JP8 as a simple fluid"
      extends Modelica.Thermal.FluidHeatFlow.Media.Medium(
        cp=2010,
        cv=2010,
        rho=840,
        nue=8.e-3/840,
        lamda=0.598)
        annotation (Documentation(info="<html>
Medium: properties of air at 30 degC
</html>"));

      end Constant_Property_JP8;

      record Essotherm650_80degC "Medium: Essotherm thermal oil at 80 degC"
      extends Modelica.Thermal.FluidHeatFlow.Media.Medium(
        cp=2060,
        cv=2060,
        rho=859,
        nue=54.5/859,
        lamda=0.1246)
        annotation (Documentation(info="<html>
Medium: properties of air at 30 degC
</html>"));

      end Essotherm650_80degC;

      record Glykol47_20degC "Medium: Glykol47 at 20 degC"
      extends Modelica.Thermal.FluidHeatFlow.Media.Medium(
        cp=3287.72,
        cv=3287.72,
        rho=1066.64,
        nue=0.00115/1066.64,
        lamda=0.42361)
        annotation (Documentation(info="<html>
Medium: properties of air at 30 degC
</html>"));

      end Glykol47_20degC;
    end Media;

    package Thermal
      extends Modelica.Icons.Package;

      package FluidHeatFlow
        extends Modelica.Icons.Package;

        package Sensors
          "Provides extensions to the MSL package of the same name"
        extends Modelica.Icons.SensorsPackage;

          model Flow_Heat_Capacity "Calculate m_dot * cp for a given fluid"
            extends
              Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor;
            Real m_dot_cp(final quantity="Flow heat capacity", final unit="W/K")
              "Flow heat capacity";
            Modelica.SIunits.SpecificHeatCapacity Cp;

          equation
            y = m_dot_cp;
            Cp = medium.cp;
            m_dot_cp = abs(flowPort_a.m_flow) * Cp;
          annotation (defaultComponentName="specificEntropy",
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
                                  graphics),
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
                              graphics={
                  Text(
                    extent={{140,102},{-140,62}},
                    lineColor={128,128,128},
                    textString="m_dot.Cp"),
                  Line(
                    points={{0,70},{0,102}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-100,0},{-70,0}},
                    color={0,128,255},
                    smooth=Smooth.None),
                  Line(
                    points={{70,0},{100,0}},
                    color={0,128,255},
                    smooth=Smooth.None)}),
            Documentation(info="<HTML>
<p>
This component monitors the specific entropy of the fluid passing its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</HTML>
"));
          end Flow_Heat_Capacity;

          model DensitySensor "Absolute temperature sensor"

            extends
              Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor;
          equation
            medium.rho = y;
          annotation (Documentation(info="<HTML>
TSensor measures the absolute temperature (Kelvin).<br>
Thermodynamic equations are defined by Partials.AbsoluteSensor.
</HTML>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}),
                         graphics),
                       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics={Text(
                    extent={{-22,-20},{20,-60}},
                    lineColor={0,0,255},
                    textString="T")}));
          end DensitySensor;
        end Sensors;

        package Sources
          extends Modelica.Icons.Package;
          model MassFlowSource "Ambient with constant properties"

            extends Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient;
            parameter Boolean useMassFlowInput=false
              "Enable / disable mass flow input"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.MassFlowRate constantMassFlow(start=0)
              "Ambient pressure"
              annotation(Dialog(enable=not usePressureInput));
            parameter Boolean useTemperatureInput=false
              "Enable / disable temperature input"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.Temperature constantAmbientTemperature(start=293.15, displayUnit="degC")
              "Ambient temperature"
              annotation(Dialog(enable=not useTemperatureInput));
            Modelica.Blocks.Interfaces.RealInput massflow=massFlow if useMassFlowInput
              annotation (Placement(transformation(extent={{110,60},{90,80}},
                    rotation=0)));
            Modelica.Blocks.Interfaces.RealInput ambientTemperature=TAmbient if useTemperatureInput
              annotation (Placement(transformation(extent={{110,-60},{90,-80}},
                    rotation=0)));
          protected
            Modelica.SIunits.MassFlowRate massFlow;
            Modelica.SIunits.Temperature TAmbient;
          equation
            if not useMassFlowInput then
              massFlow = constantMassFlow;
            end if;
            if not useTemperatureInput then
              TAmbient = constantAmbientTemperature;
            end if;
            flowPort.m_flow = - massFlow;
            T = TAmbient;
          annotation (Documentation(info="<HTML>
Mass flow and temperature source<br>
Thermodynamic equations are defined by Partials.Ambient.
</HTML>"),           Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}), graphics),
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={Text(
                    extent={{20,80},{80,20}},
                    lineColor={0,0,0},
                    textString="m_dot"),
                                     Text(
                    extent={{20,-20},{80,-80}},
                    lineColor={0,0,0},
                    textString="T")}));
          end MassFlowSource;
        end Sources;

        package Components
          extends Modelica.Icons.Package;

          package Heat_Exchangers
            "Contains parts that exchange heat between fluid streams"
            extends Modelica.Icons.Package;

            model Heat_Exchanger_Map_Based_Latest_Effectiveness

              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    hot_fluid_out(medium=medium_hot_fluid)
                                                                   annotation (Placement(
                    transformation(extent={{210,70},{230,90}}),  iconTransformation(extent={{210,110},
                        {230,130}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    cold_fluid_in(medium=medium_cold_fluid)
                annotation (Placement(transformation(extent={{-150,-90},{-130,-70}}),
                    iconTransformation(extent={{-150,-130},{-130,-110}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    cold_fluid_out(medium=medium_cold_fluid)
                annotation (Placement(transformation(extent={{210,-90},{230,-70}}),
                    iconTransformation(extent={{210,-130},{230,-110}})));

              Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor
                                                  sensor_massflow_a(medium=medium_hot_fluid)
                annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                    rotation=0,
                    origin={-90,80})));
              Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor
                                                  sensor_massflow_b(medium=
                    medium_cold_fluid)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={-90,-80})));
              Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heat_flow_a
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={164,54})));
              Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heat_flow_b
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={164,-54})));
              Modelica.Thermal.HeatTransfer.Sensors.RelTemperatureSensor avg_delta_T
                "temperature difference between the average a and b stream temperatures"
                annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                    rotation=270,
                    origin={182,-18})));
              parameter Real effectiveness_table[:,:]=fill(
                  0.0,
                  0,
                  2) "(Q/ITD.m2)";

              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec
                flow_effec_spec "choose flow type for heat rejection map";
              parameter SI.Length height_ab_hot=0
                annotation (Dialog(tab="Side_Hot_Fluid", group="Orientation"));
              parameter SI.Length height_ab_cold=0
                annotation (Dialog(tab="Side_Cold_Fluid", group="Orientation"));
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium_hot_fluid
                "Fluid media in side A";
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium_cold_fluid
                "Fluid media in side B";
              parameter SI.Length core_length=1
                "Length (along tubes) of the core";
              parameter SI.Length core_width=1
                "Width (across tubes) of the core";
              parameter SI.Length core_depth=1
                "Depth (or thickness) of the core";
              parameter Modelica.Media.Interfaces.PartialMedium.Temperature T_start_hot_fluid annotation (Dialog(tab="Initialisation"));
              parameter Modelica.Media.Interfaces.PartialMedium.Temperature T_start_cold_fluid annotation (Dialog(tab="Initialisation"));

              Modelica.Blocks.Math.Gain sign_conv(k=-1)
                "+ve heat flow is from a to b"
                annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={164,26})));
              Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                        T_a_up(medium=medium_hot_fluid)
                "temperature of stream a on the nominally upstream side"
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={-120,90})));
              Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                        T_a_dn(medium=medium_hot_fluid)
                "temperature of stream a on the nominally downstream side"
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={194,90})));
              Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                        T_b_up(medium=medium_cold_fluid)
                "temperature of stream b on the nominally upstream side"
                annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                    rotation=270,
                    origin={-120,-90})));
              Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                        T_b_dn(medium=medium_cold_fluid)
                "temperature of stream b on the nominally downstream side"
                annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                    rotation=270,
                    origin={192,-90})));
              Blocks.Math.Reg_Step           T_actual_upstream_a
                "the actual inlet temperature for stream a"
                annotation (Placement(transformation(extent={{-60,120},{-40,140}})));
              Blocks.Math.Reg_Step           T_actual_upstream_b
                "the actual inlet temperature for stream b"
                annotation (Placement(transformation(extent={{-60,-120},{-40,-140}})));

              Valves_and_pipes.Fluid_Transport             fluid_Transport1(
                medium=medium_cold_fluid,
                h_g=0,
                T0=T_start_cold_fluid,
                isCircular=false,
                crossArea=core_length*core_width,
                length=core_depth)
                annotation (Placement(transformation(extent={{154,-70},{174,-90}})));

              Valves_and_pipes.Fluid_Transport             fluid_Transport(
                h_g=0,
                medium=medium_hot_fluid,
                T0=T_start_hot_fluid)
                annotation (Placement(transformation(extent={{154,70},{174,90}})));

              Sensors.Flow_Heat_Capacity hot_mcp(medium=medium_hot_fluid)
                annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                    rotation=180,
                    origin={10,80})));
              Sensors.Flow_Heat_Capacity cold_mcp(medium=medium_cold_fluid)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=180,
                    origin={8,-80})));
              Modelica.Blocks.Sources.Constant length(k=core_length)
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={20,150})));
              Modelica.Blocks.Sources.Constant width(k=core_width)
                annotation (Placement(transformation(extent={{10,110},{30,130}})));
              Modelica.Blocks.Math.Product calc_area
                "calculate core frontal area"
                annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={70,130})));
              Modelica.Blocks.Tables.CombiTable2D heat_rejection_map(table=
                    effectiveness_table)
                annotation (Placement(transformation(extent={{-58,-6},{-38,14}})));
              Modelica.Blocks.Math.Abs abs_b
                annotation (Placement(transformation(extent={{-98,-30},{-78,-10}})));
              Modelica.Blocks.Math.Abs abs_a
                annotation (Placement(transformation(extent={{-96,20},{-76,40}})));
              Modelica.Blocks.Math.Min min_cp
                annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
              Modelica.Blocks.Math.Add ITD_actual(k2=-1)
                "the actual ITD of the hx taking into consideration the flow direction"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec
                effec_spec "choose effectiveness type";
              Q_exchanged q_exchanged1(effec_spec=effec_spec)
                annotation (Placement(transformation(extent={{80,32},{100,52}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a hot_fluid_in(medium=
                    medium_hot_fluid)
                annotation (Placement(transformation(extent={{-152,110},{-132,130}}),
                    iconTransformation(extent={{-152,110},{-132,130}})));
            equation

              connect(sign_conv.y, heat_flow_a.Q_flow) annotation (Line(
                  points={{164,37},{164,44}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(abs_a.y,heat_rejection_map. u1) annotation (Line(
                  points={{-75,30},{-66.5,30},{-66.5,10},{-60,10}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(abs_b.y,heat_rejection_map. u2) annotation (Line(
                  points={{-77,-20},{-68,-20},{-68,-2},{-60,-2}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_actual_upstream_a.y, ITD_actual.u1) annotation (Line(
                  points={{-39,136},{-24,136},{-24,16},{18,16}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_actual_upstream_b.y, ITD_actual.u2) annotation (Line(
                  points={{-39,-136},{-24,-136},{-24,4},{18,4}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(length.y, calc_area.u1) annotation (Line(
                  points={{31,150},{40,150},{40,136},{58,136}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(width.y, calc_area.u2) annotation (Line(
                  points={{31,120},{40,120},{40,124},{58,124}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(min_cp.y, q_exchanged1.min_cp) annotation (Line(
                  points={{41,-30},{90,-30},{90,30}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(ITD_actual.y, q_exchanged1.ITD) annotation (Line(
                  points={{41,10},{50,10},{50,36},{78,36}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(q_exchanged1.area, calc_area.y) annotation (Line(
                  points={{84,54},{84,130},{81,130}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(heat_rejection_map.y, q_exchanged1.heat_in) annotation (Line(
                  points={{-37,4},{-30,4},{-30,48},{78,48}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(hot_fluid_out, T_a_dn.flowPort) annotation (Line(
                  points={{220,80},{194,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(T_a_dn.flowPort, fluid_Transport.flowPort_b) annotation (Line(
                  points={{194,80},{174,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(T_a_up.flowPort, hot_fluid_in) annotation (Line(
                  points={{-120,80},{-131,80},{-131,120},{-142,120}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(T_a_up.y, T_actual_upstream_a.a) annotation (Line(
                  points={{-120,101},{-120,138},{-62,138}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(cold_fluid_out, T_b_dn.flowPort) annotation (Line(
                  points={{220,-80},{192,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(T_b_up.flowPort, cold_fluid_in) annotation (Line(
                  points={{-120,-80},{-140,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(sensor_massflow_a.y, abs_a.u) annotation (Line(
                  points={{-90,91},{-90,52},{-114,52},{-114,30},{-98,30}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(sensor_massflow_a.y, T_actual_upstream_a.u) annotation (Line(
                  points={{-90,91},{-90,52},{-50,52},{-50,118}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_a_dn.y, T_actual_upstream_a.b) annotation (Line(
                  points={{194,101},{194,100},{-80,100},{-80,122},{-62,122}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(sensor_massflow_b.y, abs_b.u) annotation (Line(
                  points={{-90,-91},{-90,-54},{-120,-54},{-120,-20},{-100,-20}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(sensor_massflow_b.y, T_actual_upstream_b.u) annotation (Line(
                  points={{-90,-91},{-90,-54},{-50,-54},{-50,-118}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_b_up.y, T_actual_upstream_b.a) annotation (Line(
                  points={{-120,-101},{-120,-138},{-62,-138}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_b_dn.y, T_actual_upstream_b.b) annotation (Line(
                  points={{192,-101},{192,-108},{-76,-108},{-76,-122},{-62,-122}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(T_b_dn.flowPort, fluid_Transport1.flowPort_b) annotation (Line(
                  points={{192,-80},{174,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(fluid_Transport.heatPort, heat_flow_a.port) annotation (Line(
                  points={{164,70},{164,64}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(heat_flow_b.port, fluid_Transport1.heatPort) annotation (Line(
                  points={{164,-64},{164,-70}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(avg_delta_T.port_b, heat_flow_b.port) annotation (Line(
                  points={{182,-28},{182,-64},{164,-64}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(avg_delta_T.port_a, heat_flow_a.port) annotation (Line(
                  points={{182,-8},{182,64},{164,64}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(cold_mcp.flowPort_a, fluid_Transport1.flowPort_a) annotation (Line(
                  points={{18,-80},{154,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(cold_mcp.y, min_cp.u2) annotation (Line(
                  points={{8,-69},{8,-36},{18,-36}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(hot_mcp.flowPort_a, fluid_Transport.flowPort_a) annotation (Line(
                  points={{20,80},{154,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(hot_mcp.y, min_cp.u1) annotation (Line(
                  points={{10,69},{10,-24},{18,-24}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(q_exchanged1.y, sign_conv.u) annotation (Line(
                  points={{101,42},{120,42},{120,-18},{164,-18},{164,14}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(q_exchanged1.y, heat_flow_b.Q_flow) annotation (Line(
                  points={{101,42},{120,42},{120,-18},{164,-18},{164,-44}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(sensor_massflow_a.flowPort_a, T_a_up.flowPort) annotation (Line(
                  points={{-100,80},{-120,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(sensor_massflow_a.flowPort_b, hot_mcp.flowPort_b) annotation (
                  Line(
                  points={{-80,80},{0,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(sensor_massflow_b.flowPort_a, T_b_up.flowPort) annotation (Line(
                  points={{-100,-80},{-120,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(sensor_massflow_b.flowPort_b, cold_mcp.flowPort_b) annotation (
                  Line(
                  points={{-80,-80},{-2,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (Icon(coordinateSystem(extent={{-140,-160},{220,160}},
                      preserveAspectRatio=false),
                               graphics={
                    Rectangle(extent={{-100,80},{180,-80}}, lineColor={0,0,0},
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-140,120},{-80,120},{-80,32},{-40,-10},{0,30},{40,-10},{78,
                          30},{120,-10},{160,30},{160,120},{220,120}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-140,-120},{-80,-120},{-80,10},{-38,-32},{0,10},{40,-30},{80,
                          10},{120,-30},{160,10},{160,-120},{220,-120}},
                      color={0,128,255},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Polygon(
                      points={{60,-46},{100,-61},{60,-76},{60,-46}},
                      lineColor={0,128,255},
                      smooth=Smooth.None,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{60,-51},{90,-61},{60,-71},{60,-51}},
                      lineColor={255,255,255},
                      smooth=Smooth.None,
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid,
                      visible=allowFlowReversal),
                    Line(
                      points={{95,-61},{-20,-61}},
                      color={0,128,255},
                      smooth=Smooth.None,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{60,76},{100,61},{60,46},{60,76}},
                      lineColor={255,0,0},
                      smooth=Smooth.None,
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{60,71},{90,61},{60,51},{60,71}},
                      lineColor={255,255,255},
                      smooth=Smooth.None,
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid,
                      visible=allowFlowReversal),
                    Line(
                      points={{95,61},{-20,61}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      visible=showDesignFlowDirection),
                    Text(
                      extent={{-60,80},{-20,40}},
                      lineColor={255,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      textString="a"),
                    Text(
                      extent={{-60,-40},{-20,-80}},
                      lineColor={0,128,255},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      textString="b"),
                    Text(
                      extent={{-200,170},{280,130}},
                      lineColor={0,0,255},
                      lineThickness=0.5,
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      textString="%name")}), Diagram(coordinateSystem(extent={{-140,-160},{
                        220,160}}, preserveAspectRatio=false),
                                                     graphics));
            end Heat_Exchanger_Map_Based_Latest_Effectiveness;

            block Q_exchanged
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec
                effec_spec "choose effectiveness type";
              Modelica.Blocks.Math.Product Q_over_ITD
                "Q_over_ITD or Q_over_ITD_over_area"
                annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
              Modelica.Blocks.Math.Product Q_over_ITD_over_area
                "multiply Q/A by A to get Q"
                annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
              Modelica.Blocks.Math.Product max_Q
                "The maximum heat transfer possible if effectiveness was 100%"
                annotation (Placement(transformation(extent={{0,-20},{20,0}})));
              Modelica.Blocks.Interfaces.RealInput area annotation (Placement(
                    transformation(extent={{-20,-20},{20,20}},
                    rotation=-90,
                    origin={-60,120}),                         iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=-90,
                    origin={-60,120})));
              Modelica.Blocks.Interfaces.RealInput heat_in annotation (Placement(
                    transformation(extent={{-140,40},{-100,80}}),iconTransformation(extent={{-140,40},
                        {-100,80}})));
              Modelica.Blocks.Interfaces.RealInput ITD annotation (Placement(transformation(
                      extent={{-140,-80},{-100,-40}}), iconTransformation(extent={{-140,-80},
                        {-100,-40}})));
              Modelica.Blocks.Interfaces.RealInput min_cp annotation (Placement(
                    transformation(extent={{20,-20},{-20,20}},
                    rotation=-90,
                    origin={-40,-120}),                           iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=90,
                    origin={0,-120})));
              Modelica.Blocks.Math.Product Q_over_area_over_ITD
                "The maximum heat transfer possible if effectiveness was 100%"
                annotation (Placement(transformation(extent={{0,20},{20,40}})));
              Modelica.Blocks.Math.Product Q_effectiveness
                "Q_over_ITD or Q_over_ITD_over_area"
                annotation (Placement(transformation(extent={{40,-30},{60,-10}})));
              C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Min_Signed_Abs_Comparison
                                                    limit_Q
                "prevent Q from exceeding an amount that would need effectiveness > 100%"
                annotation (Placement(transformation(extent={{80,-60},{100,-40}})));
              Modelica.Blocks.Interfaces.RealOutput y
                annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                    iconTransformation(extent={{100,-10},{120,10}})));
            equation
              if effec_spec == C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.effectiveness then

               limit_Q.u2 = Q_effectiveness.y;

              elseif effec_spec == C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area then

              limit_Q.u2 = Q_over_area_over_ITD.y;

             else

               limit_Q.u2 = Q_over_ITD.y;

             end if;

              connect(heat_in, Q_over_ITD_over_area.u2) annotation (Line(
                  points={{-120,60},{-80,60},{-80,44},{-42,44}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash));
              connect(Q_over_ITD_over_area.y, Q_over_area_over_ITD.u1) annotation (Line(
                  points={{-19,50},{-10,50},{-10,36},{-2,36}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(ITD, Q_over_area_over_ITD.u2) annotation (Line(
                  points={{-120,-60},{-70,-60},{-70,24},{-2,24}},
                  color={85,170,255},
                  smooth=Smooth.None));
              connect(ITD, max_Q.u1) annotation (Line(
                  points={{-120,-60},{-70,-60},{-70,-4},{-2,-4}},
                  color={85,170,255},
                  smooth=Smooth.None));
              connect(heat_in, Q_over_ITD.u1) annotation (Line(
                  points={{-120,60},{-80,60},{-80,-44},{-2,-44}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash));
              connect(ITD, Q_over_ITD.u2) annotation (Line(
                  points={{-120,-60},{-70,-60},{-70,-56},{-2,-56}},
                  color={85,170,255},
                  smooth=Smooth.None));
              connect(Q_effectiveness.u2, heat_in) annotation (Line(
                  points={{38,-26},{-80,-26},{-80,60},{-120,60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash));
              connect(max_Q.y, Q_effectiveness.u1) annotation (Line(
                  points={{21,-10},{28,-10},{28,-14},{38,-14}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(max_Q.y, limit_Q.u1) annotation (Line(
                  points={{21,-10},{28,-10},{28,-44},{78,-44}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(min_cp, max_Q.u2) annotation (Line(
                  points={{-40,-120},{-40,-16},{-2,-16}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(area, Q_over_ITD_over_area.u1) annotation (Line(
                  points={{-60,120},{-60,56},{-42,56}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(limit_Q.y, y) annotation (Line(
                  points={{101,-50},{108,-50},{108,-20},{88,-20},{88,0},{110,0}},
                  color={0,0,127},
                  smooth=Smooth.None));
              annotation (Diagram(graphics={
                    Line(
                      points={{22,30},{70,30},{70,-54},{76,-54}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      pattern=LinePattern.Dash),
                    Line(
                      points={{58,-20},{68,-20},{68,-56},{74,-56}},
                      color={255,0,0},
                      pattern=LinePattern.Dash,
                      smooth=Smooth.None),
                    Line(
                      points={{24,-50},{62,-50},{62,-58},{76,-58}},
                      color={255,0,0},
                      pattern=LinePattern.Dash,
                      smooth=Smooth.None),
                    Text(
                      extent={{38,-74},{96,-94}},
                      lineColor={255,0,0},
                      pattern=LinePattern.Dash,
                      textString="Q to use is chosen
 in text layer")}),                          Icon(graphics={
                                                           Text(
                      extent={{-80,80},{160,40}},
                      lineColor={255,0,0},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Q/ITD"),
                    Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255}),
                    Text(
                      extent={{0,148},{160,108}},
                      lineColor={128,128,128},
                      textString="area"),
                    Text(
                      extent={{8,-100},{168,-140}},
                      lineColor={128,128,128},
                      textString="minCP"),
                    Text(
                      extent={{-232,-80},{-72,-120}},
                      lineColor={128,128,128},
                      textString="ITD"),
                    Text(
                      extent={{-238,124},{-78,84}},
                      lineColor={128,128,128},
                      textString="table"),                 Text(
                      extent={{-80,-40},{160,-80}},
                      lineColor={255,0,0},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Effec"),                 Text(
                      extent={{-80,20},{180,-20}},
                      lineColor={255,0,0},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Q/(ITD.A)"),
                    Text(
                      extent={{108,40},{148,0}},
                      lineColor={255,0,0},
                      textString="Q")}));
            end Q_exchanged;

            model Base_Heat_Exchanger
              "Base map based heat exchanger intended to be extended to make specific delivered implementations"

              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    cold_fluid_in(medium=medium_cold_fluid)
                "Port that nominally flows fluid into the container"
                annotation (Placement(transformation(extent={{-210,-90},{-190,-70}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    cold_fluid_out(medium=medium_cold_fluid)
                "Port that nominally flows fluid out of the container"
                annotation (Placement(transformation(extent={{190,-90},{210,-70}})));
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium_cold_fluid=Modelica.Thermal.FluidHeatFlow.Media.Medium();

              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium_hot_fluid=Modelica.Thermal.FluidHeatFlow.Media.Medium();
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    hot_fluid_in(medium=medium_hot_fluid)
                "Port that nominally flows fluid B into the container"
                annotation (Placement(transformation(extent={{-210,70},{-190,90}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    hot_fluid_out(medium=medium_hot_fluid)
                "Port that nominally flows fluid out of the container"
                annotation (Placement(transformation(extent={{190,70},{210,90}})));
              parameter Real effectiveness_table[:,:]=fill(
                  0.0,
                  0,
                  2)
                "2D Table [side_A_mflow (kg/s), side_B_mflow (kg/s), (Q/ITD.A) (W/m2.degC)]"
                annotation (Dialog(tab="Heat Exchanger", group="Thermal"));
              parameter SI.Length core_length
                "Length (along tubes) of the core"
                annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              parameter SI.Length core_width "Width (across tubes) of the core"
                annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              parameter SI.Length core_depth=1
                "Depth (or thickness) of the core"                                   annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              parameter SI.Length ref_core_length
                "Length (along tubes) of the core"
                annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              parameter SI.Length ref_core_width
                "Width (across tubes) of the core"
                annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              parameter SI.Length ref_core_depth=1
                "Depth (or thickness) of the core"
                annotation (Dialog(tab="Heat Exchanger", group="Geometry"));
              C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Heat_Exchanger_Map_Based_Latest_Effectiveness
                heat_Exchanger_Map_Based_Area(
                core_length=core_length,
                core_width=core_width,
                core_depth=core_depth,
                effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
                effectiveness_table=effectiveness_table,
                flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
                medium_hot_fluid=medium_hot_fluid,
                medium_cold_fluid=medium_cold_fluid)
                annotation (Placement(transformation(extent={{-20,-14},{16,18}})));

              parameter Real pressure_drop_a[:,:]=[0.67,23.7931452; 1.34,67.5075852; 2.01,124.430031;
                  2.68,191.9688408; 3.35,268.7501322; 4.02,353.7122688; 4.68,446.1058602; 5.35,
                  545.4000882; 6.02,641.3220594; 6.69,740.647512]
                "dp (Pa) vs. mass flow (kg/s)"
                annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));
              parameter Real pressure_drop_b[:,:]=[0.67,23.7931452; 1.34,67.5075852; 2.01,124.430031;
                  2.68,191.9688408; 3.35,268.7501322; 4.02,353.7122688; 4.68,446.1058602; 5.35,
                  545.4000882; 6.02,641.3220594; 6.69,740.647512]
                "dp (Pa) vs. mass flow (kg/s)"
                annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec
                loss_spec_side_a "choose loss spec for side a"                                      annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec
                loss_spec_side_b "choose loss spec for side b"                                      annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec
                flow_spec_side_a "choose flow spec for side a"                                      annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));
              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec
                flow_spec_side_b "choose flow spec for side b"                                      annotation (Dialog(tab="Heat Exchanger", group="Flow restriction"));

              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec
                effec_spec "choose effectiveness type"
                                             annotation (Dialog(tab="Heat Exchanger", group="Thermal"));

              parameter
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec
                flow_effec_spec "choose flow type for heat rejection map"
                 annotation (Dialog(tab="Heat Exchanger", group="Thermal"));
            protected
              parameter Real pressure_scaling_factor_side_a= ((ref_core_width*ref_core_depth)/(core_width*core_depth))^2;
              parameter Real pressure_scaling_factor_side_b=((ref_core_width*ref_core_length)/(core_width*core_length))^2;
            equation
              connect(cold_fluid_out, heat_Exchanger_Map_Based_Area.cold_fluid_out)
                annotation (Line(
                  points={{200,-80},{109,-80},{109,-10},{16,-10}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(hot_fluid_out, heat_Exchanger_Map_Based_Area.hot_fluid_out)
                annotation (Line(
                  points={{200,80},{108,80},{108,14},{16,14}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(heat_Exchanger_Map_Based_Area.cold_fluid_in, cold_fluid_in)
                annotation (Line(
                  points={{-20,-10},{-108,-10},{-108,-80},{-200,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(heat_Exchanger_Map_Based_Area.hot_fluid_in, hot_fluid_in) annotation (
                 Line(
                  points={{-20.2,14},{-110,14},{-110,80},{-200,80}},
                  color={255,0,0},
                  smooth=Smooth.None));

                annotation (Dialog(tab="Heat Exchanger", group="Geometry"),
                              choicesAllMatching=true, Dialog(tab="Fluid Model"),
                              choicesAllMatching=true, Dialog(tab="Fluid Model"),
                          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                        {200,280}}), graphics),
                Icon(graphics={
                    Rectangle(extent={{-140,80},{140,-80}}, lineColor={0,0,0},
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-202,84},{-120,84},{-120,32},{-80,-10},{-40,30},{0,
                          -10},{38,30},{80,-10},{120,30},{120,84},{198,84}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Line(
                      points={{-202,-76},{-120,-76},{-120,10},{-78,-32},{-40,10},{0,
                          -30},{40,10},{80,-30},{120,10},{120,-76},{198,-76}},
                      color={0,128,255},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Polygon(
                      points={{20,-46},{60,-61},{20,-76},{20,-46}},
                      lineColor={0,128,255},
                      smooth=Smooth.None,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{20,-51},{50,-61},{20,-71},{20,-51}},
                      lineColor={255,255,255},
                      smooth=Smooth.None,
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid,
                      visible=allowFlowReversal),
                    Line(
                      points={{55,-61},{-60,-61}},
                      color={0,128,255},
                      smooth=Smooth.None,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{20,76},{60,61},{20,46},{20,76}},
                      lineColor={255,0,0},
                      smooth=Smooth.None,
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      visible=showDesignFlowDirection),
                    Polygon(
                      points={{20,71},{50,61},{20,51},{20,71}},
                      lineColor={255,255,255},
                      smooth=Smooth.None,
                      fillColor={250,250,250},
                      fillPattern=FillPattern.Solid,
                      visible=allowFlowReversal),
                    Line(
                      points={{55,61},{-60,61}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      visible=showDesignFlowDirection),
                    Text(
                      extent={{-100,80},{-60,40}},
                      lineColor={255,0,0},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      textString="a"),
                    Text(
                      extent={{-100,-40},{-60,-80}},
                      lineColor={0,128,255},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid,
                      textString="b")}));
            end Base_Heat_Exchanger;

            model Contact_Cooler
              "Links a fluid stream thermally with a solid component via a simplified relationship.  Also includes a pressure vs flow characteristic."

              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort;
              parameter SI.Temperature ambient_water_temperature;

              parameter SI.Length length=1 "length along the flow";
              parameter SI.Length width=1 "length across the tubes";
              parameter SI.Length height=1 "height of the tubes";
              Real kc "heat transfer coeff";
              Real kc_turb "turbulent heat transfer coeff";
              Real kc_lam "laminar heat transfer coeff";
              SI.Velocity fluid_velocity
                "avg velocity of coolant through pipes";

              parameter SI.VolumeFlowRate V_dot_nom=0.001;

              parameter SI.Pressure dp_nom=2000
                "Nominal pressure drop of fluid";

              SI.Temperature t_avg;
              SI.PrandtlNumber Pr=medium.nue*medium.rho*medium.cp/medium.lamda;
              SI.ReynoldsNumber Re=max(1e-3, medium.rho*fluid_velocity*length/(medium.nue*medium.rho));
            protected
              parameter Real a(unit="(Pa.s2)/m6") = dp_nom/V_dot_nom^2
                "Coefficient for quadratic term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
              parameter Real b(unit="(Pa.s)/m3") = 0
                "Coefficient for linear term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
            equation
              //heat transfer coeff
              kc_turb = abs((medium.lamda/length))*(0.037*Re^0.8*Pr)/(1 + 2.443/(max(Re^0.1, 1e-6))*(Pr^(2/3) - 1));
              kc_lam = (medium.lamda/length)*(0.664*abs(Re)^0.5*Pr^(1/3));
              kc = sqrt((kc_lam)^2 + (kc_turb)^2);

                 // convection equation
              Q_flow = -(t_avg - ambient_water_temperature)*kc*width*length;

              fluid_velocity = abs(flowPort_a.m_flow/(medium.rho*width*height));

              t_avg = (T_a + T_b)*0.5;

              dp = a*V_flow*abs(V_flow) + b*V_flow;

              annotation (
                Documentation(info="<html>
<p>
This component models a generic resistance parameterized
with the volume flow rate:
</p>

<pre>
    dp     = a*V_flow^2 + b*V_flow
    m_flow = rho*V_flow
</pre>

<p>
with
</p>

<table>
<tr><td><b> a              </b></td><td> as quadratic coefficient [Pa*s^2/m^6],</td></tr>
<tr><td><b> b              </b></td><td> as linear coefficient [Pa*s/m3],</td></tr>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> V_flow         </b></td><td> as volume flow rate [m3/s].</td></tr>
</table>

<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known. Therefore the modelling of the detailed pressure loss calculation has to be simplified. This components use a linear and a quadratic dependence of the pressure loss on the volume flow rate. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the 
<a href=\"modelica://Modelica.Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">documentation of the underlying function</a>.
</p>

</html>"),      Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                        100}}), graphics),
                Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                     graphics={
                    Rectangle(
                      extent={{-80,-16},{90,-100}},
                      lineColor={0,0,255},
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,40},{90,40}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      arrow={Arrow.None,Arrow.Filled}),
                    Line(
                      points={{-82,0},{88,0}},
                      color={255,0,0},
                      smooth=Smooth.None,
                      arrow={Arrow.None,Arrow.Filled}),
                    Rectangle(extent={{-80,60},{90,-16}}, lineColor={0,0,0})}));
            end Contact_Cooler;

            package Types
              "Base components used to build other Fluid components"
              extends Modelica.Icons.Package;

              type Effec_Spec = enumeration(
                  Q_per_ITD,
                  Q_per_ITD_Area,
                  effectiveness) annotation (Icon(graphics={
                                                       Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={215,230,240},
                        fillPattern=FillPattern.Solid), Text(
                        extent={{-94,94},{94,-94}},
                        lineColor={0,0,0},
                        fillColor={181,181,181},
                        fillPattern=FillPattern.Solid,
                      textString="E")}));
              type Flow_Spec = enumeration(
                  mass_flow_rate,
                  volume_flow_rate,
                  velocity,
                  Reynolds_number) annotation (Icon(graphics={
                                                       Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={215,230,240},
                        fillPattern=FillPattern.Solid), Text(
                        extent={{-94,94},{94,-94}},
                        lineColor={0,0,0},
                        fillColor={181,181,181},
                        fillPattern=FillPattern.Solid,
                      textString="E")}));
              type Loss_Spec = enumeration(
                  friction_factor_darcy,
                  deltaP,
                  deltaP_per_length)
                    annotation (Icon(graphics={        Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={215,230,240},
                        fillPattern=FillPattern.Solid), Text(
                        extent={{-94,94},{94,-94}},
                        lineColor={0,0,0},
                        fillColor={181,181,181},
                        fillPattern=FillPattern.Solid,
                      textString="E")}));
            end Types;

            package Tests
              extends Modelica.Icons.Package;

              model Test_Heat_Exchanger_Map_Based_Latest_Eff
                extends Icons.Simple_Test_Case;
              //replaceable package medium_cold_fluid = C2M2L_Ext.Media.SimpleAir_Tmax_200C;

                Heat_Exchanger_Map_Based_Latest_Effectiveness heatexchanger(
                  effectiveness_table=[0,0.322,0.646,0.968,1.292,1.938,2.586,3.232; 0.495,
                      0.93,0.81,0.69,0.66,0.75,0.81,0.84; 0.99,0.96,0.9,0.82,0.74,0.62,0.58,
                      0.63; 1.485,0.97,0.93,0.87,0.81,0.7,0.6,0.53; 1.98,0.98,0.95,0.89,0.84,
                      0.74,0.65,0.58; 2.97,0.99,0.99,0.96,0.93,0.85,0.77,0.7; 3.9675,1,0.99,
                      0.98,0.95,0.89,0.83,0.77; 4.9575,1,0.99,0.98,0.96,0.91,0.86,0.81],
                  flow_effec_spec=Types.Flow_Spec.volume_flow_rate,
                  core_length=0.3,
                  core_width=0.3,
                  effec_spec=Types.Effec_Spec.effectiveness,
                  medium_hot_fluid=Modelica.Thermal.FluidHeatFlow.Media.Water(),
                  medium_cold_fluid=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
                  T_start_hot_fluid=353.15,
                  T_start_cold_fluid=303.15)
                  annotation (Placement(transformation(extent={{-42,16},{-6,48}})));

                Modelica.Blocks.Sources.Ramp sine(
                  duration=100,
                  height=1.0003e5,
                  offset=0.00001)
                  annotation (Placement(transformation(extent={{-138,52},{-118,72}})));

                inner Modelica.Fluid.System system(m_flow_small=1e-4)
                  annotation (Placement(transformation(extent={{80,80},{100,100}})));
                Modelica.Thermal.FluidHeatFlow.Sources.Ambient ambient(
                  medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
                  constantAmbientPressure=100000,
                  constantAmbientTemperature=353.15)
                  annotation (Placement(transformation(extent={{14,34},{34,54}})));
                Modelica.Thermal.FluidHeatFlow.Sources.Ambient ambient1(
                  medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
                  constantAmbientPressure=100000,
                  constantAmbientTemperature=303.15)
                  annotation (Placement(transformation(extent={{20,10},{40,30}})));
                Sources.MassFlowSource
                               massFlowSource(
                  medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
                  constantMassFlow=2,
                  constantAmbientTemperature=353.15) annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={-84,44})));
                Sources.MassFlowSource
                               massFlowSource1(
                  medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
                  constantMassFlow=2,
                  constantAmbientTemperature=303.15) annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={-88,20})));
                Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                  T_hot_fluid_in(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-42,68})));
                Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                  temperature_hot_fluid_out(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Water()) annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-6,68})));
                Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                  T_cold_fluid_in(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-42,0})));
                Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                  temperature_cold_fluid_out(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-6,-2})));
              equation
                connect(ambient.flowPort, heatexchanger.hot_fluid_out) annotation (Line(
                    points={{14,44},{-6,44}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(ambient1.flowPort, heatexchanger.cold_fluid_out) annotation (Line(
                    points={{20,20},{-6,20}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(massFlowSource.flowPort, heatexchanger.hot_fluid_in) annotation (
                    Line(
                    points={{-74,44},{-42.2,44}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(massFlowSource1.flowPort, heatexchanger.cold_fluid_in) annotation (
                    Line(
                    points={{-78,20},{-42,20}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(temperature_hot_fluid_out.flowPort, heatexchanger.hot_fluid_out)
                  annotation (Line(
                    points={{-6,58},{-6,44}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(T_hot_fluid_in.flowPort, heatexchanger.hot_fluid_in)
                  annotation (Line(
                    points={{-42,58},{-42,44},{-42.2,44}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(T_cold_fluid_in.flowPort, heatexchanger.cold_fluid_in)
                  annotation (Line(
                    points={{-42,10},{-42,20}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(temperature_cold_fluid_out.flowPort, heatexchanger.cold_fluid_out)
                  annotation (Line(
                    points={{-6,8},{-6,20}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                          -100},{100,100}}),
                                    graphics), Icon(graphics),
                  experiment(StopTime=200),
                  __Dymola_experimentSetupOutput);
              end Test_Heat_Exchanger_Map_Based_Latest_Eff;
            end Tests;
            annotation ();
          end Heat_Exchangers;

          package Volumes
            extends Modelica.Icons.Package;

            partial model OnePort "Partial model of two port"

              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Medium()
                "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true);

              parameter Modelica.SIunits.Temperature T0(start=293.15, displayUnit="degC")
                "Initial temperature of medium"
                annotation(Dialog(enable=m>Modelica.Constants.small));
              Modelica.SIunits.VolumeFlowRate V_flow=flowPort_a.m_flow/medium.rho
                "Volume flow a->b";
              Modelica.SIunits.HeatFlowRate Q_flow "Heat exchange with ambient";
              output Modelica.SIunits.Temperature T(start=T0, fixed=false)
                "Temperature at flowPort_a";

            protected
              Modelica.SIunits.SpecificEnthalpy h = medium.cp*T
                "Medium's specific enthalpy";

            public
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(final medium=
                    medium)
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                      rotation=0)));
            equation
              flowPort_a.h = h;

            annotation (Documentation(info="<HTML>
Partial model with two flowPorts.<br>
Possible heat exchange with the ambient is defined by Q_flow; setting this = 0 means no energy exchange.<br>
Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
Mixing rule is applied.<br>
Parameter 0 &lt; tapT &lt; 1 defines temperature of heatPort between medium's inlet and outlet temperature.
</HTML>"),             Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                        {100,100}}), graphics));
            end OnePort;

            model OpenTank "Volume with heat exchange"

              extends
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Volumes.OnePort;
              parameter SI.Height level_start;
              Modelica.SIunits.Mass m(start=level_start*crossArea*medium.rho)
                "Mass of medium";
              parameter Modelica.SIunits.Pressure p_atm = 101325
                "atmospheric pressure";
              parameter SI.Height height "Height of fuel tank";
              parameter SI.Area crossArea
                "Constant cross sectional area of tank";

              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
                      rotation=0)));
              Modelica.Blocks.Interfaces.RealOutput level_output
                annotation (Placement(transformation(extent={{88,-20},{128,20}})));
            equation
              // mass balance
              der(m) = flowPort_a.m_flow;
              // energy balance
              flowPort_a.H_flow + Q_flow = m*medium.cv*der(T);

              flowPort_a.p = p_atm;

              m=level_output*crossArea*medium.rho;

              // energy exchange with medium
              Q_flow = heatPort.Q_flow;
              // defines heatPort's temperature
              heatPort.T = T;
            annotation (Documentation(info="<HTML>
Pipe with heat exchange.<br>
Thermodynamic equations are defined by Partials.TwoPort.<br>
Q_flow is defined by heatPort.Q_flow.<br>
<b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
<b>Note:</b> Injecting heat into a pipe with zero massflow causes
temperature rise defined by storing heat in medium's mass.
</HTML>"),    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                        100}}), graphics={    Text(
                      extent={{-150,150},{150,90}},
                      lineColor={0,0,255},
                      textString="%name"), Ellipse(
                      extent={{-90,90},{90,-90}},
                      lineColor={255,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid)}),
                                        Diagram(coordinateSystem(preserveAspectRatio=false,
                               extent={{-100,-100},{100,100}}),
                                                graphics));
            end OpenTank;

            model Volume "Volume with heat exchange"

              extends
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Volumes.OnePort;
              parameter Modelica.SIunits.Volume V = 1 "Volume of medium";
              parameter Modelica.SIunits.Pressure p = 101325
                "Pressure in volume";
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
                      rotation=0)));
            equation
              // mass balance
              //0 = flowPort_a.m_flow;
              // energy balance
              flowPort_a.H_flow + Q_flow = V*medium.rho*medium.cv*der(T);

              flowPort_a.p = p;

              // energy exchange with medium
              Q_flow = heatPort.Q_flow;
              // defines heatPort's temperature
              heatPort.T = T;
            annotation (Documentation(info="<HTML>
Pipe with heat exchange.<br>
Thermodynamic equations are defined by Partials.TwoPort.<br>
Q_flow is defined by heatPort.Q_flow.<br>
<b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
<b>Note:</b> Injecting heat into a pipe with zero massflow causes
temperature rise defined by storing heat in medium's mass.
</HTML>"),    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                        100}}), graphics={    Text(
                      extent={{-150,150},{150,90}},
                      lineColor={0,0,255},
                      textString="%name"), Ellipse(
                      extent={{-90,90},{90,-90}},
                      lineColor={255,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid)}),
                                        Diagram(coordinateSystem(preserveAspectRatio=false,
                               extent={{-100,-100},{100,100}}),
                                                graphics));
            end Volume;

            model Degas_Bottle
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium = Modelica.Thermal.FluidHeatFlow.Media.Water();
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    port_a(medium=medium)
                annotation (Placement(transformation(extent={{-110,-80},{-90,-60}}),
                    iconTransformation(extent={{-110,-80},{-90,-60}})));
              parameter
                Modelica.Media.Interfaces.PartialMedium.AbsolutePressure
                p_degas_bottle=1e5
                "degas bottle pressure - sets the system pressure";

              Modelica.Blocks.Sources.Constant const(k=1)
                annotation (Placement(transformation(extent={{-96,18},{-76,38}})));
              Modelica.Thermal.FluidHeatFlow.Components.Valve valve(
                y1=1,
                LinearCharacteristic=true,
                dp0(displayUnit="Pa") = 1000,
                kv0=1e-3,
                medium=medium,
                Kv1=1/medium.rho,
                rho0=medium.rho,
                m=1e-6,
                T0=293.15)
                annotation (Placement(transformation(extent={{-60,-22},{-40,-2}})));
              Modelica.Thermal.FluidHeatFlow.Sources.Ambient degas_bottle(
                                                                  constantAmbientPressure=
                    p_degas_bottle, medium=medium,
                constantAmbientTemperature=293.15)
                annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            equation
              connect(valve.flowPort_a, port_a) annotation (Line(
                  points={{-60,-12},{-80,-12},{-80,-70},{-100,-70}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(valve.flowPort_b, degas_bottle.flowPort) annotation (Line(
                  points={{-40,-12},{-20,-12},{-20,0},{0,0}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(const.y, valve.y) annotation (Line(
                  points={{-75,28},{-50,28},{-50,-3}},
                  color={0,0,127},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}),
                                  graphics), Icon(graphics={
                    Polygon(
                      points={{-100,58},{80,58},{80,-80},{-34,-80},{-100,58}},
                      lineColor={0,0,255},
                      smooth=Smooth.None,
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      extent={{-50,92},{-16,68}},
                      lineColor={0,0,255},
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-36,72},{-28,58}},
                      lineColor={0,0,255},
                      fillColor={0,0,0},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-92,-64},{-48,-52},{-44,-60},{-90,-72},{-92,-64}},
                      lineColor={0,0,255},
                      smooth=Smooth.None,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-24,82},{2,86}},
                      lineColor={0,0,255},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid,
                      textString="pressure cap"),
                    Text(
                      extent={{-58,0},{-32,4}},
                      lineColor={0,0,255},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid,
                      textString="degas inlet")}));
            end Degas_Bottle;
          end Volumes;

          package Valves_and_pipes
            extends Modelica.Icons.Package;
            model Fluid_Transport "Pipe with heat exchange"

              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort(      m=length*medium.rho*(if isCircular then diameter^2*Modelica.Constants.pi/4 else crossArea));
              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction;
              parameter Modelica.SIunits.Length h_g(start=0)
                "Geodetic height (heigth difference from flowPort_a to flowPort_b)";
              parameter Boolean isCircular=true
                "= true if cross sectional area is circular"
                annotation (Dialog(group="Geometry"));
              parameter SI.Diameter diameter = 0.01
                "Diameter if pipe is circular"                                     annotation (Dialog(group="Geometry",  enable= isCircular));
              parameter SI.Area crossArea=Modelica.Constants.pi*diameter*diameter/4
                "Inner cross section area" annotation (Dialog(group="Geometry", enable= not
                      isCircular));
              parameter SI.Length length = 1 "transport length" annotation (Dialog(group="Geometry"));

              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
                      rotation=0)));
            equation
              // coupling with FrictionModel
              volumeFlow = V_flow;
              dp = pressureDrop + medium.rho*Modelica.Constants.g_n*h_g;
              // energy exchange with medium
              Q_flow = heatPort.Q_flow + Q_friction;
              // defines heatPort's temperature
              heatPort.T = T_q;
            annotation (Documentation(info="<HTML>
Pipe with heat exchange.<br>
Thermodynamic equations are defined by Partials.TwoPort.<br>
Q_flow is defined by heatPort.Q_flow.<br>
<b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
<b>Note:</b> Injecting heat into a pipe with zero massflow causes
temperature rise defined by storing heat in medium's mass.
</HTML>"),    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                        100}}), graphics={
                    Rectangle(
                      extent={{-90,20},{90,-20}},
                      lineColor={255,0,0},
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Text(extent={{-150,100},{150,40}}, textString="%name"),
                    Polygon(
                      points={{-10,-90},{-10,-40},{0,-20},{10,-40},{10,-90},{-10,-90}},
                      lineColor={255,0,0})}),
                                        Diagram(coordinateSystem(preserveAspectRatio=false,
                               extent={{-100,-100},{100,100}}),
                                                graphics));
            end Fluid_Transport;

            model Volume_Flow_Rate_With_Heat_Addition
              "Default small pressure drop for regularization of laminar and zero flow (calculated from m_flow_small)"

              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort(      m(start=0),
                  final tapT=1);
              parameter SI.CoefficientOfHeatTransfer alpha0=100
                "heat transfer coefficient at m_flow_nom";
              parameter Modelica.SIunits.MassFlowRate m_flow_nom = 1;
              parameter SI.Area surface_area=1 "Heat transfer area";
              Modelica.SIunits.Temperature t_avg;
              Modelica.SIunits.TemperatureDifference delta_T;
              parameter Real a(unit="(Pa.s2)/m6")
                "Coefficient for quadratic term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
              parameter Real b(unit="(Pa.s)/m3") "Coefficient for linear term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
                      rotation=0)));
            equation
              t_avg = (T_a + T_b)*0.5;
              if noEvent((heatPort.T - T_a)*(heatPort.T - T_b) < 0) then
                // Temperatures at flow ports straddle the heat port temperature
               delta_T = heatPort.T - t_avg;
              else
                // Choose the port with the smallest delta to the heat port
                if noEvent(abs(heatPort.T - T_a) > abs(heatPort.T - T_b)) then
                  // T_b has the smallest delta to the heat port
                  delta_T = heatPort.T - T_b;
                else
                  // T_a has the smallest delta to the heat port
                  delta_T = heatPort.T - T_a;
                end if;
              end if;
              heatPort.Q_flow = (abs(flowPort_a.m_flow) / m_flow_nom) * alpha0*surface_area*delta_T;
              Q_flow = heatPort.Q_flow;
              dp = a*V_flow*abs(V_flow) + b*V_flow;

            annotation (Documentation(info="<HTML>
Pipe with heat exchange.<br>
Thermodynamic equations are defined by Partials.TwoPort.<br>
Q_flow is defined by heatPort.Q_flow.<br>
<b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
<b>Note:</b> Injecting heat into a pipe with zero massflow causes
temperature rise defined by storing heat in medium's mass.
</HTML>"),    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                        100}}), graphics={
                    Polygon(
                      points={{-90,10},{-60,10},{-60,60},{0,0},{60,60},{60,10},{90,10},{90,-10},
                          {60,-10},{60,-60},{0,0},{-60,-60},{-60,-10},{-90,-10},{-90,10}},
                      lineColor={255,0,0},
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Text(extent={{-150,-60},{150,-120}}, textString="%name")}),
                                        Diagram(coordinateSystem(preserveAspectRatio=false,
                               extent={{-100,-100},{100,100}}),
                                                graphics));
            end Volume_Flow_Rate_With_Heat_Addition;

            model Thermal_Bridge_With_Pressure_Drop
              "Links a fluid stream thermally with a solid component via a simplified relationship.  Also includes a pressure vs flow characteristic."

              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort(      m(start=0),
                  final tapT=1, h(start=medium.cp*293.15));

              parameter Real effectiveness_nom = 0.7
                "Nominal effectiveness of the thermal bridge";
              parameter Modelica.SIunits.Power cooling_Q_nom = 1000
                "Nominal heat rejection to the fluid";
              parameter Modelica.SIunits.Temperature T_inlet_nom = 323.15
                "Nominal fluid inlet temperature";
              parameter Modelica.SIunits.VolumeFlowRate V_dot_nom = 0.001
                "Nominal volume flow rate of fluid";
              parameter Modelica.SIunits.MassFlowRate m_dot_nom = V_dot_nom * rho
                "Nominal mass flow rate of fluid";
              parameter Modelica.SIunits.Pressure dp_nom = 2000
                "Nominal pressure drop of fluid";
              parameter Modelica.SIunits.SpecificHeatCapacity cp = medium.cp
                "Specific heat capacity of fluid";
              parameter Modelica.SIunits.Density rho = medium.rho
                "Density of fluid";

              parameter Modelica.SIunits.Temperature T_outlet_nom = T_inlet_nom + cooling_Q_nom / (m_dot_nom * cp);
              parameter Modelica.SIunits.Temperature T_machine_nom = T_inlet_nom + cooling_Q_nom / (m_dot_nom * cp * effectiveness_nom);
              parameter Modelica.SIunits.ThermalConductance H = cooling_Q_nom / (T_machine_nom - T_inlet_nom);

              parameter Modelica.SIunits.SpecificHeatCapacity H_per_m_dot = H / m_dot_nom;
              Modelica.SIunits.ThermalConductance hA(start=0);

              parameter Real a(unit="(Pa.s2)/m6") = dp_nom / V_dot_nom^2
                "Coefficient for quadratic term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
              parameter Real b(unit="(Pa.s)/m3") = 0
                "Coefficient for linear term"
                annotation(Dialog(group="dp = a*V_flow^2 + b*V_flow"));
              Modelica.SIunits.Temperature t_avg;
              Modelica.SIunits.Temperature delta_T;
              Modelica.SIunits.Density d_a
                "Density at port_a when fluid is flowing from port_a to port_b";
              Modelica.SIunits.Density d_b
                "If allowFlowReversal=true then Density at port_b when fluid is flowing from port_b to port_a else d_a";
              Modelica.SIunits.Power dummy_Q;

              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
                      rotation=0)));
            equation

              t_avg = (T_a + T_b)*0.5;
              if noEvent((heatPort.T - T_a)*(heatPort.T - T_b)) < 0 then
                // Temperatures at flow ports straddle the heat port temperature
                delta_T = heatPort.T - t_avg;
              elseif noEvent(abs(heatPort.T - T_a) > abs(heatPort.T - T_b)) then
                delta_T = heatPort.T - T_b;
              else
                delta_T = heatPort.T - T_a;
              end if;

              hA = H_per_m_dot * abs(flowPort_a.m_flow);
              heatPort.Q_flow = hA*(delta_T);
              Q_flow = heatPort.Q_flow;
              dummy_Q = hA*(delta_T);
              // Medium properties
              d_a = medium.rho;
              d_b = medium.rho;
              dp = a*V_flow*abs(V_flow) + b*V_flow;

            annotation (Documentation(info="<HTML>
Pipe with heat exchange.<br>
Thermodynamic equations are defined by Partials.TwoPort.<br>
Q_flow is defined by heatPort.Q_flow.<br>
<b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
leads to neglection of temperature transient cv*m*der(T).<br>
<b>Note:</b> Injecting heat into a pipe with zero massflow causes
temperature rise defined by storing heat in medium's mass.
</HTML>"),    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                        100}}), graphics={
                    Polygon(
                      points={{-90,10},{-60,10},{-60,60},{0,0},{60,60},{60,10},{90,10},{90,-10},
                          {60,-10},{60,-60},{0,0},{-60,-60},{-60,-10},{-90,-10},{-90,10}},
                      lineColor={255,0,0},
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Text(extent={{-150,-60},{150,-120}}, textString="%name")}),
                                        Diagram(coordinateSystem(preserveAspectRatio=false,
                               extent={{-100,-100},{100,100}}),
                                                graphics));
            end Thermal_Bridge_With_Pressure_Drop;
          end Valves_and_pipes;

          package Filter
            extends Modelica.Icons.Package;
            partial model Partial_Filter
              "Base class of filter models.  Extending classes supply block_frac vs mass_deposited function"

              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium = Modelica.Thermal.FluidHeatFlow.Media.Medium();
              parameter SI.Pressure dp_nominal
                "Pressure drop at nominal mass flow rate";
              parameter SI.MassFlowRate m_flow_nominal=0.11
                "Flow@dp_nominal with clean filter";

              parameter Real block_per_init=0.2
                "Initial blockage percentage(0-1)"
               annotation (Dialog(tab="General"));
              parameter SI.Mass block_mass_init;
              SI.Mass mass_deposited(start=block_mass_init, fixed=true)
                "Mass accumulated during operation";

              Real block_frac(min=0, max=1)
                "How blocked the filter is. 0=clean, 1=completely_blocked";
              final parameter Modelica.SIunits.MassFlowRate unit_m_flow = 1;

              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    port_a(medium=medium)
               annotation (Placement(transformation(extent={{-110,30},{-90,50}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    port_b(medium=medium)
               annotation (Placement(transformation(extent={{90,30},{110,50}})));

              Modelica.Blocks.Interfaces.RealInput u
               annotation (Placement(transformation(extent={{-146,-20},{-106,20}})));

              Modelica.Thermal.FluidHeatFlow.Components.Valve valveIncompressible(
                y1=1,
                LinearCharacteristic=true,
                dp0(displayUnit="Pa") = 1000,
                kv0=1e-3,
                rho0=medium.rho,
                medium=medium,
                Kv1=unit_m_flow/medium.rho)
                annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            equation
              der(mass_deposited) = u*port_a.m_flow;

              valveIncompressible.y = max(1.0 - block_frac, 0);

              connect(valveIncompressible.flowPort_b, port_b) annotation (Line(
                  points={{10,40},{100,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(valveIncompressible.flowPort_a, port_a) annotation (Line(
                  points={{-10,40},{-100,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (
                Dialog(tab="General"),
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}),
                        graphics),
                Icon(graphics={
                    Rectangle(extent={{-84,88},{74,-80}}, lineColor={0,0,0}),
                    Line(
                      points={{-84,40},{74,40}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,60},{74,60}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,80},{74,80}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-20},{74,-20}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-40},{74,-40}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-60},{74,-60}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-60,88},{-60,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-20,88},{-20,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,88},{0,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{20,88},{20,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{40,88},{40,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-40,88},{-40,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-20,-20},{-20,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,-20},{0,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{20,-20},{20,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{40,-20},{40,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-40,-20},{-40,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-60,-20},{-60,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,-20},{60,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,88},{60,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,20},{74,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-20},{74,-20}},
                      color={0,0,0},
                      smooth=Smooth.None)}));
            end Partial_Filter;

            model Filter_Linear_Blockage
              "Implements a linear relationship between restriction and mass deposited"
              extends Filter.Partial_Filter(
                                     block_mass_init=block_per_init / slope,
                  valveIncompressible(Kv1=m_flow_nominal/medium.rho, dp0=dp_nominal));

              parameter SI.Mass block_mass_1=0.1 "Blockage mass at point 1"
               annotation (Dialog(tab="General"));
              parameter Real block_per_1=0.05
                "Blockage percentage (0-1) at point 1"
               annotation (Dialog);

              parameter Real slope = block_per_1 / block_mass_1;

            equation
              block_frac = mass_deposited * slope;

              annotation (
                Dialog(tab="General"),
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                        100}}),
                        graphics),
                Icon(graphics={
                    Rectangle(extent={{-84,88},{74,-80}}, lineColor={0,0,0}),
                    Line(
                      points={{-84,40},{74,40}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,60},{74,60}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,80},{74,80}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-20},{74,-20}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-40},{74,-40}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-60},{74,-60}},
                      color={255,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-60,88},{-60,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-20,88},{-20,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,88},{0,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{20,88},{20,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{40,88},{40,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-40,88},{-40,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-20,-20},{-20,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{0,-20},{0,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{20,-20},{20,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{40,-20},{40,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-40,-20},{-40,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-60,-20},{-60,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,-20},{60,-80}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{60,88},{60,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,20},{74,20}},
                      color={0,0,0},
                      smooth=Smooth.None),
                    Line(
                      points={{-84,-20},{74,-20}},
                      color={0,0,0},
                      smooth=Smooth.None)}));
            end Filter_Linear_Blockage;
          end Filter;

          package Thermostats
            extends Modelica.Icons.Package;
            model Thermostat_Simple
              parameter SI.Temperature crack_open_temperature=353
                "Temperature when valve starts to open";
              parameter SI.Temperature full_open_temperature=373
                "Temperature when valve is fully open";
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium = Modelica.Thermal.FluidHeatFlow.Media.Water();

              parameter SI.Pressure dp_nominal=10000 "Nominal pressure drop"
                annotation (Dialog(group="Main flow path"));
              parameter SI.Pressure dp_nominal_bypass=10000
                "Nominal pressure drop"
                annotation (Dialog(group="Bypass"));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                    inlet(medium=medium)
                annotation (Placement(transformation(extent={{-110,30},{-90,50}}),
                    iconTransformation(extent={{-110,30},{-90,50}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    main_outlet(medium=medium)
                annotation (Placement(transformation(extent={{90,30},{110,50}}),
                    iconTransformation(extent={{90,30},{110,50}})));
              parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate m_flow_nominal=
                 1 "Nominal mass flowrate" annotation (Dialog(group="Main flow path"));
              parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate
                m_flow_nominal_bypass=1 "Nominal mass flowrate"
                annotation (Dialog(group="Bypass"));
              parameter SI.Time riseTime=1
                "Time delay in reaching desired value(thermal inertia)";
              Modelica.Blocks.Tables.CombiTable1D temp_vs_opening(smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments, table=[
                    crack_open_temperature - 1,0; crack_open_temperature,0;
                    full_open_temperature,1; full_open_temperature + 1,1])
                annotation (Placement(transformation(extent={{-46,76},{-22,100}})));

              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                    bypass_outlet(medium=medium)
                "Flow path when the main valve is shut"
                annotation (Placement(transformation(extent={{90,-50},{110,-30}}),
                    iconTransformation(extent={{90,-48},{110,-28}})));

              Blocks.Math.One_Minus_U one_Minus_U
                annotation (Placement(transformation(extent={{-2,4},{18,24}})));
              Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor temperatureSensor(medium=
                    medium)
                annotation (Placement(transformation(extent={{-78,78},{-58,98}})));
              Modelica.Thermal.FluidHeatFlow.Components.Valve valveIncompressible(
                medium=medium,
                rho0=medium.rho,
                Kv1=m_flow_nominal/medium.rho,
                dp0(displayUnit="Pa") = dp_nominal,
                m=1e-3,
                kv0=1e-3,
                y1=1)
                annotation (Placement(transformation(extent={{-38,30},{-18,50}})));
              Modelica.Thermal.FluidHeatFlow.Components.Valve valveIncompressible1(
                medium=medium,
                rho0=medium.rho,
                Kv1=m_flow_nominal_bypass/medium.rho,
                dp0(displayUnit="Pa") = dp_nominal_bypass,
                m=1e-3,
                kv0=1e-3,
                y1=1)
                annotation (Placement(transformation(extent={{-14,-50},{6,-30}})));
              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance1(
                h_g=0.001,
                medium=medium,
                m=1e-3,
                T0=293.15) annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=180,
                    origin={-56,40})));
              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance(
                m=1e-3,
                h_g=0,
                medium=medium,
                T0=293.15) annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=180,
                    origin={-80,40})));
              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance2(
                m=1e-3,
                h_g=0,
                medium=medium,
                T0=293.15) annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=180,
                    origin={56,-40})));
            equation
              connect(one_Minus_U.y, valveIncompressible1.y) annotation (Line(
                  points={{19,14},{30,14},{30,-16},{-4,-16},{-4,-31}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(main_outlet, valveIncompressible.flowPort_b) annotation (Line(
                  points={{100,40},{-18,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(one_Minus_U.u, valveIncompressible.y) annotation (Line(
                  points={{-4,14},{-14,14},{-14,58},{-28,58},{-28,49}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(temp_vs_opening.y[1], valveIncompressible.y) annotation (Line(
                  points={{-20.8,88},{-14,88},{-14,58},{-28,58},{-28,49}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(temperatureSensor.y, temp_vs_opening.u[1]) annotation (Line(
                  points={{-57,88},{-48.4,88}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(valveIncompressible.flowPort_a, smallResistance1.flowPort_a)
                annotation (Line(
                  points={{-38,40},{-46,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(temperatureSensor.flowPort, valveIncompressible.flowPort_a)
                annotation (Line(
                  points={{-78,88},{-78,52},{-38,52},{-38,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(smallResistance1.flowPort_b, smallResistance.flowPort_a)
                annotation (Line(
                  points={{-66,40},{-70,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(smallResistance.flowPort_b, inlet) annotation (Line(
                  points={{-90,40},{-100,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(valveIncompressible1.flowPort_a, smallResistance.flowPort_a)
                annotation (Line(
                  points={{-14,-40},{-70,-40},{-70,40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(smallResistance2.flowPort_b, valveIncompressible1.flowPort_b)
                annotation (Line(
                  points={{46,-40},{6,-40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(smallResistance2.flowPort_a, bypass_outlet) annotation (Line(
                  points={{66,-40},{100,-40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}),
                                  graphics), Icon(coordinateSystem(preserveAspectRatio=
                        false, extent={{-100,-100},{100,100}}),
                                                  graphics={
                    Line(
                      points={{-40,60},{-22,88},{-20,90},{20,90},{40,60}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      thickness=0.5),
                    Polygon(
                      points={{-98,60},{100,60},{58,-100},{-60,-100},{-98,60}},
                      lineColor={0,0,255},
                      smooth=Smooth.None,
                      fillPattern=FillPattern.Solid,
                      fillColor={0,128,255}),
                    Rectangle(extent={{-20,60},{26,-98}}, pattern=LinePattern.None),
                    Ellipse(
                      extent={{-26,30},{34,14}},
                      lineColor={0,127,0},
                      lineThickness=0.5,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      extent={{-27,2},{33,-14}},
                      lineColor={0,127,0},
                      lineThickness=0.5,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      extent={{-26,-30},{34,-46}},
                      lineColor={0,127,0},
                      lineThickness=0.5,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      extent={{-26,-64},{34,-80}},
                      lineColor={0,127,0},
                      lineThickness=0.5,
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{34,18},{-28,-4}},
                      pattern=LinePattern.None,
                      thickness=0.5,
                      smooth=Smooth.None),
                    Line(
                      points={{34,-8},{-26,-36}},
                      pattern=LinePattern.None,
                      thickness=0.5,
                      smooth=Smooth.None),
                    Line(
                      points={{34,-40},{-26,-70}},
                      pattern=LinePattern.None,
                      thickness=0.5,
                      smooth=Smooth.None),
                    Ellipse(
                      extent={{104,26},{122,10}},
                      pattern=LinePattern.None,
                      lineThickness=0.5,
                      fillColor={255,0,0},
                      fillPattern=FillPattern.Solid)}));
            end Thermostat_Simple;
          end Thermostats;

          package Pumps_And_Fans
            extends Modelica.Icons.Package;

            partial model Base
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
                "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true);
              parameter Boolean useSupport=false
                "= true, if support flange enabled, otherwise implicitly grounded"
                  annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
              Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
                "Support/housing of component"
                annotation (Placement(transformation(extent={{-10,-170},{10,-150}})));
            protected
              Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
                "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
                annotation (Placement(transformation(extent={{-3,-143},{3,-137}})));
              Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
                "Fixed support/housing, if not useSupport"
                annotation (Placement(transformation(extent={{10,-157},{30,-137}})));
            public
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(final medium=medium)
                annotation (Placement(transformation(extent={{-210,-90},{-190,-70}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b flowPort_b(final medium=medium)
                annotation (Placement(transformation(extent={{190,-90},{210,-70}})));
            equation
              connect(support, internalSupport) annotation (Line(
                  points={{0,-160},{0,-155},{4.4409e-016,-155},{4.4409e-016,-150},{0,-150},
                      {0,-140}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(internalSupport, fixed.flange) annotation (Line(
                  points={{0,-140},{20,-140},{20,-147}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}), graphics));
            end Base;

            model TwoPortFlowDevice
              "Standalone pump used to provide cooling flows independantly (e.g. not reliant on main water pump in a prime-mover) "
              extends
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.Base;
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
                "medium"
                annotation(__Dymola_choicesAllMatching=true);

              parameter Boolean consider_gyroscopic_effects = false
                "if true, take into account gyroscopic reaction forces";
              parameter SI.AngularVelocity N_ref=500
                "Rotational speed at which flow versus pressure data is provided";
              parameter SI.AngularVelocity N_switch=N_ref * 0.01
                "Rotational speed below which flow no longer follows scaling laws";
              parameter SI.Inertia rotating_inertia = 1
                "Moment of inertia of device around its axis of rotation";
              parameter Real efficiency_characteristic[:,:]=fill(
                  0.0,
                  0,
                  2)
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref";
              parameter Real flow_characteristic[:,:]=fill(
                  0.0,
                  0,
                  2)
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref";

              Pump_Base flow_device(
                useSupport=true,
                flow_characteristic=flow_characteristic,
                N_ref=N_ref,
                N_switch=N_switch,
                efficiency_characteristic=efficiency_characteristic,
                medium=medium,
                m=0)
                annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                    rotation=180,
                    origin={0,90})));
              Modelica.Mechanics.Rotational.Components.Inertia inertia(J=rotating_inertia) if
                                         not consider_gyroscopic_effects
                annotation (Placement(transformation(extent={{-28,2},{-8,22}})));

              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe isolatedPipe(medium=
                    medium, h_g=0)
                annotation (Placement(transformation(extent={{-68,80},{-48,100}})));
            equation
              connect(flow_device.flange, inertia.flange_b)
                                                          annotation (Line(
                  points={{0,80},{0,12},{-8,12}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(flow_device.support, internalSupport)
                                                     annotation (Line(
                  points={{1.33227e-015,100},{0,100},{0,122},{28,122},{28,-120},{0,-120},{0,
                      -140}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(isolatedPipe.flowPort_a, flowPort_a) annotation (Line(
                  points={{-68,90},{-136,90},{-136,-80},{-200,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(flow_device.flowPort_b, flowPort_b) annotation (Line(
                  points={{10,90},{108,90},{108,-80},{200,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(flow_device.flowPort_a, isolatedPipe.flowPort_b) annotation (
                  Line(
                  points={{-10,90},{-48,90}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                        -320},{200,280}}), graphics));
            end TwoPortFlowDevice;

            model Fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc
              "Uses a curve of flow rate versus pressure rise provided at a single reference speed and then scales the data to apply at other speeds"
              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort(      h(start=medium.cp*293.15));
              extends
                C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;

              parameter Real flow_characteristic[:,2]=[0,0; 1,1]
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref";
              parameter SI.AngularVelocity N_ref=500
                "Rotational speed at which table data is provided";
              parameter SI.AngularVelocity N_switch=10
                "Rotational speed below which flow no longer follows scaling laws";
              SI.VolumeFlowRate V_flow_ref(start=0);
              SI.VolumeFlowRate V_flow_affinity_laws;
              SI.VolumeFlowRate V_flow_loss_factor;
              SI.Pressure dp_ref;
              SI.Power mechanical_power;
              SI.Power fluid_power_ref;
              SI.Torque torque;
              SI.AngularVelocity speed_in;
              SI.Pressure dp_head=-dp "Present a pressure rise as positive";
              SI.Power fluid_power;
              Real efficiency_ref;
              Real K=1e-6
                "(Volume flow rate/delta P) Loss Coefficient to model the pump/fan as a simple restriction at low speeds"
                annotation (Dialog);
              Real a;
              Modelica.Blocks.Tables.CombiTable1D HeadvsFlow(table=flow_characteristic,
                  smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
               annotation (Placement(transformation(extent={{-18,50},{2,70}})));

              Modelica.Blocks.Tables.CombiTable1D Efficiency_vs_Flow(table=
                    efficiency_characteristic, smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
               annotation (Placement(transformation(extent={{-18,12},{2,32}})));
              parameter Real efficiency_characteristic[:,:]=[0,0; 1,1]
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref";

            equation
              for i in 1:size(flow_characteristic, 1)-1 loop
                if flow_characteristic[i,1] < flow_characteristic[i+1,1] then
                  assert(flow_characteristic[i,2] > flow_characteristic[i+1,2], "Pressure curve must be strictly decreasing with increasing flow");
                else
                  assert(flow_characteristic[i,2] < flow_characteristic[i+1,2], "Pressure curve must be strictly increasing with decreasing flow");
                end if;
              end for;
             // Mechanical calculations
              speed_in = der(flange.phi);
              torque = mechanical_power/max(abs(speed_in), 1e-6);
              torque = flange.tau;

             // Pressure rise versus volume flow rate at reference speed from table

              HeadvsFlow.u[1] = V_flow_ref;
              Efficiency_vs_Flow.u[1] = V_flow_ref;
              dp = dp_ref*((max(speed_in, 0.001))/N_ref)^2;
              -dp_ref = HeadvsFlow.y[1];

              V_flow_affinity_laws = V_flow_ref*(speed_in/N_ref);
              V_flow_loss_factor = K*dp;

              V_flow = (1 - a)*V_flow_loss_factor + a*V_flow_affinity_laws;
              a = (1 + tanh((0.01*(speed_in - N_switch))/2*(N_switch)))/2;

              //Efficiency Calculations

              Efficiency_vs_Flow.y[1] = efficiency_ref;
              //mechanical_power_ref*max(efficiency_ref, 0.00001) = fluid_power_ref;
              //if fluid_power > 0 then
                mechanical_power*max(efficiency_ref, 0.01) = fluid_power;
             // else
             //   mechanical_power = 0;
             // end if;
              // to ensure the efficiency doesn't go negative

              fluid_power_ref = -dp_ref*V_flow_ref;
              //mechanical_power = mechanical_power_ref*(speed_in/N_ref)^3;
              fluid_power = -dp*V_flow;

             // Thermal energy balance
             // In the future should add most of efficiency loss as heat rejected to
             // the fluid here
              flowPort_a.h = flowPort_b.h;

              annotation (Icon(graphics={
                    Rectangle(
                      extent={{-10,100},{10,20}},
                      lineColor={95,95,95},
                      fillPattern=FillPattern.VerticalCylinder,
                      fillColor={175,175,175}),
                    Ellipse(
                      extent={{-60,60},{60,-60}},
                      lineColor={0,0,0},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-20,56},{-40,20},{40,-20},{20,-56}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Line(
                      points={{56,20},{20,40},{-20,-40},{-56,-20}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Line(
                      points={{-90,0},{90,0}},
                      color={0,128,255},
                      smooth=Smooth.None),
                    Line(
                      points={{20,56},{-16,44},{16,-44},{-20,-56}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Ellipse(extent={{-60,60},{60,-60}}, lineColor={0,0,0}),
                    Ellipse(
                      extent={{-30,30},{30,-30}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{21,55},{-15,43},{17,-45},{-19,-57}},
                      color={255,255,255},
                      smooth=Smooth.Bezier,
                      origin={-1,-1},
                      rotation=90)}), Diagram(coordinateSystem(preserveAspectRatio=false,
                      extent={{-100,-100},{100,100}}),
                                              graphics));
            end Fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc;

            model Pump_Base
              "Uses a curve of flow rate versus pressure rise provided at a single reference speed and then scales the data to apply at other speeds"
              extends
                Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort(      h(start=medium.cp*293.15));
              extends
                C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
              import Modelica.Fluid.Utilities.regStep;
              parameter Real flow_characteristic[:,2]=[0,0; 1,1]
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref";
              parameter Real efficiency_characteristic[:,2]=[0,0; 1,1]
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref";
              parameter SI.AngularVelocity N_ref=500
                "Rotational speed at which table data is provided";
              parameter SI.AngularVelocity N_switch=1
                "Rotational speed below which flow no longer follows scaling laws";
              parameter Boolean check_valve = false
                "if true, reverse flow is prevented by a built in check valve";
              SI.VolumeFlowRate V_flow_ref(start=0.0);
              SI.VolumeFlowRate V_flow_raw(start=0.0);
              SI.Pressure dp_ref;
              SI.Power mech_power;
              SI.Power lossPower;
              SI.Torque torque;
              SI.AngularVelocity w(start=0);
              SI.Pressure dp_head=-dp "Present a pressure rise as positive";
              SI.Power fluid_power;
              Real eff_ref "Operating efficiency";
              parameter SI.Torque limit_torque = 1e6 "Torque limit to apply";

            //protected
              SI.Power raw_mech_power;
              SI.Torque raw_torque;
              SI.AngularVelocity w_mod;
              Modelica.Blocks.Tables.CombiTable1D dp_vs_flow(table=flow_characteristic,
                  smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
               annotation (Placement(transformation(extent={{-18,50},{2,70}})));

              Modelica.Blocks.Tables.CombiTable1D eff_vs_flow(table=
                    efficiency_characteristic, smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
               annotation (Placement(transformation(extent={{-18,12},{2,32}})));

            equation
              for i in 1:size(flow_characteristic, 1) - 1 loop
                if flow_characteristic[i, 1] < flow_characteristic[i + 1, 1] then
                  assert(flow_characteristic[i, 2] > flow_characteristic[i + 1, 2], "Pressure curve must be strictly decreasing with increasing flow");
                else
                  assert(flow_characteristic[i, 2] < flow_characteristic[i + 1, 2], "Pressure curve must be strictly increasing with decreasing flow");
                end if;
              end for;

              // Calculate a modified speed that does not go below a minimum threshold
              // to prevent divide by zero errors.  This speed is only used to apply
              // scaling laws so any inaccuracies caused should be negligible.
              w = der(flange.phi);
              w_mod = max(abs(w), N_switch);

              // Calculate reference flow based on affinity law speed scaling from actual flow
              V_flow_ref = V_flow_raw/(w_mod/N_ref);

              if check_valve then
                V_flow = max(0, regStep(abs(w) - N_switch, V_flow_raw, dp*1e-6, N_switch / 2));
              else
                V_flow = regStep(abs(w) - N_switch, V_flow_raw, dp*1e-6, N_switch / 2);
              end if;
              // Get dp_ref = f(V flow_ref) from a table
              dp_vs_flow.u[1] = V_flow_ref;
              -dp_ref = dp_vs_flow.y[1];

              // Get eff_ref = f(V flow_ref) from a table
              eff_vs_flow.u[1] = V_flow_ref;
              eff_vs_flow.y[1] = eff_ref;

              // Calculate actual dp based on affinity law speed scaling back from reference dp
              //dp = dp_ref*regSquare(w_mod/N_ref, 0.001);
              dp = dp_ref * (w_mod/N_ref) * (w_mod/N_ref);

              // Calculate the effective fluid power of the device (+ve means device is doing
              // work on the fluid, -ve the fluid is doing work on the device)
              fluid_power = -dp*V_flow;

              // Calculate the amount of mechanical power that is needed to either drive the device
              // or extracted from the device.  Use a regStep to ensure that when driving the device
              // more mechanical power is needed than fluid power generated and when extracting less
              // mechanical power is produced than fluid power consumed.
              raw_mech_power = regStep(fluid_power, 1/eff_ref, eff_ref, 1e-3)*fluid_power;

                // if noEvent(abs(w) > 1e-10) then
                //   raw_torque = raw_mech_power / w;
                // else
                //   raw_torque = raw_mech_power / (if w >= 0 then 1e-10 else -1e-10);
                // end if;
              // Calculate torque
              if w >= 0 then
                  raw_torque = raw_mech_power / max(w, 1e-10);
              else
                  raw_torque = raw_mech_power / min(w, -1e-10);
              end if;
              torque = min(limit_torque, max(-limit_torque,raw_torque));
              flange.tau = torque;

              // Calculate an actual mechanical power based on torque and the true device speed
              mech_power = torque*w;

              // Anything that was not converted from mechanical to fluid or vice-versa is
              // lumped into a loss term
              lossPower = abs(fluid_power - mech_power);

              // Thermal energy balance - assumes isenthalpic for now
              // Really the lossPower should be added to the flowing fluid but this could be
              // numerically difficult?
              flowPort_a.h = flowPort_b.h;

              annotation (Icon(graphics={
                    Rectangle(
                      extent={{-10,100},{10,20}},
                      lineColor={95,95,95},
                      fillPattern=FillPattern.VerticalCylinder,
                      fillColor={175,175,175}),
                    Ellipse(
                      extent={{-60,60},{60,-60}},
                      lineColor={0,0,0},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-20,56},{-40,20},{40,-20},{20,-56}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Line(
                      points={{56,20},{20,40},{-20,-40},{-56,-20}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Line(
                      points={{-90,0},{90,0}},
                      color={0,128,255},
                      smooth=Smooth.None),
                    Line(
                      points={{20,56},{-16,44},{16,-44},{-20,-56}},
                      color={255,255,255},
                      smooth=Smooth.Bezier),
                    Ellipse(extent={{-60,60},{60,-60}}, lineColor={0,0,0}),
                    Ellipse(
                      extent={{-30,30},{30,-30}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{21,55},{-15,43},{17,-45},{-19,-57}},
                      color={255,255,255},
                      smooth=Smooth.Bezier,
                      origin={-1,-1},
                      rotation=90)}), Diagram(coordinateSystem(preserveAspectRatio=false,
                      extent={{-100,-100},{100,100}}),
                                              graphics));
            end Pump_Base;

            model TwoPortFlowDevice_PumpBase
              "Standalone pump used to provide cooling flows independantly (e.g. not reliant on main water pump in a prime-mover) "
              extends
                C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.Base;
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
                "medium"
                annotation(__Dymola_choicesAllMatching=true);

              parameter Boolean consider_gyroscopic_effects = false
                "if true, take into account gyroscopic reaction forces";
              parameter SI.AngularVelocity N_ref=500
                "Rotational speed at which flow versus pressure data is provided";
              parameter SI.AngularVelocity N_switch=N_ref * 0.01
                "Rotational speed below which flow no longer follows scaling laws";
              parameter SI.Inertia rotating_inertia = 1
                "Moment of inertia of device around its axis of rotation";
              parameter Real efficiency_characteristic[:,:]=fill(
                  0.0,
                  0,
                  2)
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref";
              parameter Real flow_characteristic[:,:]=fill(
                  0.0,
                  0,
                  2)
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref";
              parameter Real loss_coeff=0.1
                "(Volume flow rate/delta P) Loss Coefficient to model the pump as a simple restriction at low fan speeds";
              Pump_Base                                            pump(
                useSupport=true,
                flow_characteristic=flow_characteristic,
                N_ref=N_ref,
                N_switch=N_switch,
                efficiency_characteristic=efficiency_characteristic,
                medium=medium,
                m=0)
                annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                    rotation=180,
                    origin={0,90})));
              Modelica.Mechanics.Rotational.Components.Inertia inertia(J=rotating_inertia) if
                                         not consider_gyroscopic_effects
                annotation (Placement(transformation(extent={{-28,2},{-8,22}})));

              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe isolatedPipe(medium=
                    medium, h_g=0)
                annotation (Placement(transformation(extent={{-68,80},{-48,100}})));
            equation
              connect(pump.flange, inertia.flange_b)      annotation (Line(
                  points={{0,80},{0,12},{-8,12}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(flowPort_b, pump.flowPort_b) annotation (Line(
                  points={{200,-80},{104,-80},{104,90},{10,90}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(pump.support, internalSupport) annotation (Line(
                  points={{1.33227e-015,100},{0,100},{0,122},{28,122},{28,-120},{0,-120},{0,
                      -140}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pump.flowPort_a, isolatedPipe.flowPort_b) annotation (Line(
                  points={{-10,90},{-48,90}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(isolatedPipe.flowPort_a, flowPort_a) annotation (Line(
                  points={{-68,90},{-136,90},{-136,-80},{-200,-80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                        -320},{200,280}}), graphics));
            end TwoPortFlowDevice_PumpBase;
          end Pumps_And_Fans;
        end Components;

        package Adaptors
          extends Modelica.Icons.Package;
          model FluidAdaptor
            "Fluid adaptor between MSL Thermal.FluidHeatFlow and MSL Fluid"
            parameter Modelica.Thermal.FluidHeatFlow.Media.Medium HeatFlowMedium=
              Modelica.Thermal.FluidHeatFlow.Media.Medium()
              "Medium in the component"                                               annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));
            replaceable package Medium =
                Modelica.Media.Interfaces.PartialMedium annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

            Modelica.Fluid.Interfaces.FluidPort_a fluid_port(redeclare package
                Medium =
                  Medium)
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluidHeatflow_port(final
                medium=HeatFlowMedium)
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                    rotation=0)));

            InternalAdaptor internalAdaptor(
              HeatFlowMedium=HeatFlowMedium,
              redeclare package Medium = Medium,
              T=temperature.T)
              annotation (Placement(transformation(extent={{-14,-10},{6,10}})));
            Modelica.Fluid.Sensors.Temperature temperature(redeclare package
                Medium =
                  Medium) annotation (Placement(transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=180,
                  origin={40,30})));
          equation

            connect(internalAdaptor.fluidHeatflow_port, fluidHeatflow_port) annotation (
                Line(
                points={{-14,0},{-100,0}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(internalAdaptor.fluid_port, fluid_port) annotation (Line(
                points={{6,0},{100,0}},
                color={0,127,255},
                smooth=Smooth.None));
            connect(temperature.port, internalAdaptor.fluid_port) annotation (Line(
                points={{40,20},{40,0},{6,0}},
                color={0,127,255},
                smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                      100}}), graphics={
                  Line(
                    points={{-68,20},{-48,30},{-28,36},{-8,40},{12,40},{32,38},{52,34},
                        {72,20},{72,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-64,30},{-68,20},{-58,18},{-58,18}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-70,-10},{-50,0},{-30,6},{-10,10},{10,10},{30,8},{50,4},
                        {70,-10},{70,-10}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    origin={4,-30},
                    rotation=180),
                  Line(
                    points={{-1,6},{-5,-4},{5,-6},{5,-6}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    origin={69,-24},
                    rotation=180)}),  Diagram(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}),
                                              graphics));
          end FluidAdaptor;

          model InternalAdaptor
            "Internal adaptor for use in the FluidAdaptor component"
            parameter Modelica.Thermal.FluidHeatFlow.Media.Medium HeatFlowMedium=
              Modelica.Thermal.FluidHeatFlow.Media.Medium()
              "Medium in the component"                                               annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));
            replaceable package Medium =
                Modelica.Media.Interfaces.PartialMedium annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

            Modelica.SIunits.Temperature T_fluid(start=293.15, fixed=false);
            Modelica.SIunits.Temperature T_fluidHeatFlow(start=293.15, fixed=false);
            input Modelica.SIunits.Temperature T annotation(Dialog);

            Modelica.Fluid.Interfaces.FluidPort_a fluid_port(redeclare package
                Medium =
                  Medium)
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluidHeatflow_port(final
                medium=HeatFlowMedium)
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

            Modelica.SIunits.SpecificEnthalpy h(start = 1e5, fixed = false)=fluid_port.h_outflow;
          equation

            // temperature
            T_fluid = Medium.temperature(Medium.setState_phX(fluid_port.p, fluid_port.h_outflow, fluid_port.Xi_outflow));
            T_fluidHeatFlow = fluidHeatflow_port.h/HeatFlowMedium.cp;

            // set temperature equal
            T_fluid = T_fluidHeatFlow;

            // mass balance
            fluidHeatflow_port.m_flow + fluid_port.m_flow = 0;

            // energy balance
            fluidHeatflow_port.H_flow + fluid_port.m_flow*T*HeatFlowMedium.cp = 0;

            // pressure
            fluidHeatflow_port.p = fluid_port.p;

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={
                  Line(
                    points={{-72,20},{-52,30},{-32,36},{-12,40},{8,40},{28,38},{48,34},
                        {68,20},{68,20}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-68,30},{-72,20},{-62,18},{-62,18}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-70,-10},{-50,0},{-30,6},{-10,10},{10,10},{30,8},{50,4},
                        {70,-10},{70,-10}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    origin={0,-30},
                    rotation=180),
                  Line(
                    points={{-1,6},{-5,-4},{5,-6},{5,-6}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    origin={65,-24},
                    rotation=180)}),  Diagram(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}),
                                              graphics));
          end InternalAdaptor;
        end Adaptors;
      end FluidHeatFlow;

      package HeatTransfer
        "Holds extensions to the MSL package of the same name"
         extends Modelica.Icons.Package;

        package Interfaces
          "Holds extensions to the MSL package of the same name"
            extends Modelica.Icons.InterfacesPackage;

          partial model PartialElementaryConditionalHeatPortWithoutT
            "Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models"
            parameter Boolean useHeatPort = false
              "=true, if heatPort is enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              final Q_flow=-lossPower) if useHeatPort
              "Optional port to which dissipated losses are transported in form of heat"
              annotation (Placement(transformation(extent={{-110,-110},{-90,-90}}),
               iconTransformation(extent={{-110,-110},{-90,-90}})));
            Modelica.SIunits.Power lossPower
              "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)";

          end PartialElementaryConditionalHeatPortWithoutT;

          partial model
            PartialElementaryConditionalHeatPort_Device_With_Thermal_Mass
            "Variation on MSL component that adds annotation 'group='Thermal Behaviour' and includes a thermal mass"
            parameter Boolean use_heat_port = false
              "=true, if external heat port is enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true), Dialog(group="Thermal Behaviour"));

            SI.Temperature T_device(start=293.15, fixed=true, displayUnit="degC")
              "Bulk averaged temperature of device" annotation(Dialog(group="Thermal Behaviour", showStartAttribute=true));
            SI.Power loss_power
              "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)";
            SI.Power heat_generated "heat_generated by component";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              final T=T_device,
              final Q_flow=-loss_power) if use_heat_port
              "Optional port to which dissipated losses are transported in form of heat"
              annotation (Placement(transformation(extent={{-110,-110},{-90,-90}}),
               iconTransformation(extent={{-110,-110},{-90,-90}})));
            parameter SI.HeatCapacity C_device = 1 "Heat capacity of device"   annotation (Dialog(group="Thermal Behaviour"));
          equation
            C_device * der(T_device) = heat_generated - loss_power;

            annotation (Documentation(info="<html>
<p>Extending class must provide equation to calculate <b>heat_generated</b>, this is the heat that the device itself produces.</p>
<p>If the heat_port is enabled (use_heat_port == true) no other equations are required.</p>
<p>If the heat_port is disabled then the extending class must also provide an equation to loss_power.</p>
<p>For a simple isothermal treatment an extending class can simply:</p>
<p><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">if&nbsp;not&nbsp;</font>use_heat_port<font style=\"color: #0000ff; \">&nbsp;then</font></code></p>
<p><code><font style=\"color: #006400; \">//&nbsp;a</font>ssume all heat generated is lost immediately</code></p>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;loss_power&nbsp;=&nbsp;heat_generated;
<p><br/><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">end&nbsp;if</font>;</code></p>
<pre>
Or to reject heat to a surrounding ambeint:
<p><code></p><p>&nbsp;&nbsp;<font style=\"color: #0000ff; \">parameter&nbsp;</font><font style=\"color: #ff0000; \">SI.CoefficientOfHeatTransfer</font>&nbsp;fixed_HTC=100&nbsp;</code></p>
<p><code><font style=\"color: #006400; \">&nbsp;&nbsp;&nbsp;&nbsp;&QUOT;Fixed&nbsp;heat&nbsp;transfer&nbsp;coefficient&nbsp;if&nbsp;use_heat_port=false&QUOT;</font>;</code></p>
<p><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">parameter&nbsp;</font><font style=\"color: #ff0000; \">SI.Area</font>&nbsp;heat_transfer_area=0.01&nbsp;</code></p>
<p><code><font style=\"color: #006400; \">&nbsp;&nbsp;&nbsp;&nbsp;&QUOT;Fixed&nbsp;area&nbsp;for heat transfer&nbsp;if&nbsp;use_heat_port=false&QUOT;</font>;</code></p>
<p><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">parameter&nbsp;</font><font style=\"color: #ff0000; \">SI.Temperature</font>&nbsp;T_ambient=293.15&nbsp;</code></p>
<p><code><font style=\"color: #006400; \">&nbsp;&nbsp;&nbsp;&nbsp;&QUOT;Fixed&nbsp;ambient&nbsp;temperature&nbsp;if&nbsp;use_heat_port=false&QUOT;</font>;</code></p>
<p><code></p><p>&nbsp;&nbsp;<font style=\"color: #0000ff; \">if&nbsp;not&nbsp;</font>use_heat_port<font style=\"color: #0000ff; \">&nbsp;then</font></code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;<font style=\"color: #006400; \">//&nbsp;Reject&nbsp;heat&nbsp;to&nbsp;the&nbsp;specified&nbsp;ambient&nbsp;conditions</font></code></p>
<pre><font style=\"color: #006400; \">    // T_device is available as part of the interface</font>
&nbsp;&nbsp;&nbsp;&nbsp;loss_power&nbsp;=&nbsp;(T_device&nbsp;-&nbsp;T_ambient)&nbsp;*&nbsp;fixed_HTC&nbsp;*&nbsp;heat_transfer_area;
<p><br/><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">end&nbsp;if</font>;</code></p>
<pre>

Any difference between heat_generated and loss_power will cause the device temperature to change.

The rate of change is determined by parameter C_device, the Heat Capacity of the device.  If an extending class 
wants to redefine C_device, say to C.  It should be done when extending:
<p><br/><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">extends&nbsp;</font></code></p>
<pre><font style=\"color: #ff0000; \">&nbsp;&nbsp;&nbsp;&nbsp;C2M2L_OM.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort_Device_With_Thermal_Mass</font>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;(<font style=\"color: #0000ff; \">final&nbsp;</font>C_device=C);</code></p>
<p><br/><code>&nbsp;&nbsp;<font style=\"color: #0000ff; \">parameter&nbsp;</font><font style=\"color: #ff0000; \">SI.HeatCapacity</font>&nbsp;C=spec_heat*mass_thermal*fric_interface_count&nbsp;</code></p>
<p><code><font style=\"color: #006400; \">&nbsp;&nbsp;&nbsp;&nbsp;&QUOT;Heat&nbsp;capacity&nbsp;of&nbsp;clutch&QUOT;</font><font style=\"color: #0000ff; \">annotation&nbsp;</font>(Dialog(group=&QUOT;Thermal&nbsp;Behaviour&QUOT;));</code></p>
</html>"));
          end PartialElementaryConditionalHeatPort_Device_With_Thermal_Mass;

          partial model ConditionalHeatPort
            "Partial model to include a conditional HeatPort in order to describe the power loss via a thermal network"

            parameter Boolean use_heat_port = false
              "=true, if HeatPort is enabled"
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true), Dialog(group="Thermal Behaviour"));
            parameter Modelica.SIunits.Temperature T_fixed=293.15
              "Fixed device temperature if useHeatPort = false" annotation(Dialog(enable=not use_heat_port, group="Thermal Behaviour"));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T=T_heat_port, Q_flow=-loss_power) if use_heat_port
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                  iconTransformation(extent={{-10,-110},{10,-90}})));
            Modelica.SIunits.Power loss_power
              "Loss power leaving component via HeatPort";
            Modelica.SIunits.Temperature T_heat_port "Temperature of HeatPort";
          equation
            if not use_heat_port then
               T_heat_port = T_fixed;
            end if;

            annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                      -100},{100,100}}),                                                                 graphics),
              Documentation(revisions="<html>
<ul>
<li><i> February 17, 2009   </i>
       by Christoph Clauss<br> initially implemented<br>
       </li>
</ul>
</html>",           info="<html>
<p>
This partial model provides a conditional heating port for the connection to a thermal network.
</p>
<ul>
<li> If <b>useHeatPort</b> is set to <b>false</b> (default), no heat port is available, and the thermal
     loss power flows internally to the ground. In this case, the parameter <b>T</b> specifies
     the fixed device temperature (the default for T = 20<sup>o</sup>C).</li>
<li> If <b>useHeatPort</b> is set to <b>true</b>, a heat port is available.</li>
</ul>

<p>
If this model is used, the loss power has to be provided by an equation in the model which inherits from
ConditionalHeatingPort model (<b>lossPower = ...</b>). As device temperature
<b>T_heatPort</b> can be used to describe the influence of the device temperature
on the model behaviour.
</p>
</html>"));
          end ConditionalHeatPort;
        end Interfaces;

        package Components
          "Holds extensions to the MSL package of the same name"
            extends Modelica.Icons.Package;

          model Hollow_Cylinder_Thermal_Conductor
            "Lumped thermal element with the shape of a hollow cylinder that transports heat without storing it"
            extends Modelica.Thermal.HeatTransfer.Interfaces.Element1D;
            parameter SI.Diameter D_o(final min=0)=0.1
              "Outside diameter of tube";
            parameter SI.Diameter D_i(final min=0)=0.09
              "Inside diameter of tube";
            parameter SI.Length l(final min=0)=1.0 "Length of tube";
            parameter SI.ThermalConductivity k(final min=0)=25
              "Conductivity of cylinder material";
          protected
            parameter SI.Area heat_flow_area = pi * (D_o ^ 2 - D_i ^ 2) / 4;
            parameter SI.ThermalConductance G= heat_flow_area * k / l
              "Constant thermal conductance of hollow cylinder";
          equation
            Q_flow = G*dT;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Rectangle(
                    extent={{-90,32},{90,-32}},
                    lineColor={0,0,0},
                    pattern=LinePattern.None,
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward),
                  Line(
                    points={{-90,32},{-90,-32}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{90,32},{90,-32}},
                    color={0,0,0},
                    thickness=0.5),
                  Text(
                    extent={{-150,115},{150,75}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-150,-75},{150,-105}},
                    lineColor={0,0,0},
                    textString="G=%G"),
                  Ellipse(
                    extent={{-74,42},{-36,-38}},
                    lineColor={95,95,95},
                    startAngle=0,
                    endAngle=360),
                  Ellipse(extent={{34,42},{72,-38}}, lineColor={95,95,95}),
                  Line(
                    points={{-54,42},{54,42}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-54,-38},{56,-38}},
                    color={95,95,95},
                    smooth=Smooth.None)}),
              Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                      {100,100}}), graphics={
                  Line(
                    points={{-80,0},{80,0}},
                    color={255,0,0},
                    thickness=0.5,
                    arrow={Arrow.None,Arrow.Filled}),
                  Text(
                    extent={{-26,-10},{27,-39}},
                    lineColor={255,0,0},
                    textString="Q_flow"),
                  Text(
                    extent={{-80,50},{80,20}},
                    lineColor={0,0,0},
                    textString="dT = port_a.T - port_b.T")}),
              Documentation(info="<html>
<p><br/>Implements a conductor where heat flows axially along a hollow tube.  Basically the same as Modelica.Thermal.HeatFlow.ThermalConductor (<code>Q_flow&nbsp;=&nbsp;G*dT) </code>but with the equation to calculate G for a hollow tube built in</p>
<pre>G =&nbsp;heat_flow_area&nbsp;*&nbsp;k&nbsp;/&nbsp;l

where

heat_flow_area&nbsp;=&nbsp;pi&nbsp;*&nbsp;(D_o&nbsp;^&nbsp;2&nbsp;-&nbsp;D_i&nbsp;^&nbsp;2)&nbsp;/&nbsp;4</pre>
</html>"));
          end Hollow_Cylinder_Thermal_Conductor;
        end Components;
      end HeatTransfer;

      model Simple_Conduction_From_Internal_Environment
        "Allows heat to flow from contained environment through a nominal case area and thickness"
        parameter SI.Area case_heat_transfer_area = 1.0
          "Area available for heat to transfer through case";
        parameter SI.Thickness case_heat_transfer_thickness = 0.005
          "Effective case thickness for heat transfer";
        parameter SI.ThermalConductivity case_thermal_conductivity = 50
          "Conductivity of case";

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=case_thermal_conductivity * case_heat_transfer_area / case_heat_transfer_thickness)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-26,62})));
        MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                                            thermal_To_Environment(
            area_for_heat_transfer=case_heat_transfer_area) annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-50,50})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a annotation (
            Placement(transformation(extent={{-40,60},{-20,80}}), iconTransformation(
                extent={{-40,60},{-20,80}})));
      equation
        connect(thermal_To_Environment.solid, thermalConductor.port_a) annotation (
            Line(
            points={{-40,50},{-32,50},{-32,52},{-26,52}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(thermalConductor.port_b, port_a) annotation (Line(
            points={{-26,72},{-26,70},{-30,70}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{
                  -100,-100},{100,100}}),
                            graphics), Icon(graphics={Line(
                points={{76,-90},{78,-86},{66,-50},{54,-26},{30,-12},{2,-12},{-36,-12},
                    {-40,-14},{-56,-18},{-74,-28},{-70,-14},{-60,-32},{-74,-28}},
                color={0,0,255},
                smooth=Smooth.None), Rectangle(
                extent={{-100,60},{100,0}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Backward,
                fillColor={135,135,135})}));
      end Simple_Conduction_From_Internal_Environment;

      model Simple_Conduction_Through_Case
        "Allows heat to flow between 2 heat ports through a nominal case area and thickness"
        parameter SI.Area case_heat_transfer_area = 1.0
          "Area available for heat to transfer through case";
        parameter SI.Thickness case_heat_transfer_thickness = 0.005
          "Effective case thickness for heat transfer";
        parameter SI.ThermalConductivity case_thermal_conductivity = 50
          "Conductivity of case";

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=case_thermal_conductivity * case_heat_transfer_area / case_heat_transfer_thickness)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-14,22})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a annotation (
            Placement(transformation(extent={{-40,60},{-20,80}}), iconTransformation(
                extent={{-40,60},{-20,80}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b annotation (
            Placement(transformation(extent={{-40,-20},{-20,0}}), iconTransformation(
                extent={{-40,-20},{-20,0}})));
      equation
        connect(thermalConductor.port_a, port_b) annotation (Line(
            points={{-14,12},{-14,-10},{-30,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(port_a, thermalConductor.port_b) annotation (Line(
            points={{-30,70},{-14,70},{-14,32}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(graphics), Icon(graphics={
                                     Rectangle(
                extent={{-100,60},{100,0}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Backward,
                fillColor={135,135,135})}));
      end Simple_Conduction_Through_Case;
    end Thermal;

    package Environments
      "Different types of environments that can exist inside a Container"
        extends Modelica.Icons.Package;

      partial model C2M2L_Environment
        "Base class for all environments.  This is the class that contained components should refer to as an outer called 'env'"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heat_port
          "For exchanging thermal energy with the environment"
          annotation (Placement(transformation(extent={{-90,-112},{-70,-92}}),
              iconTransformation(extent={{-90,-112},{-70,-92}})));
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                              fluid_port(medium=medium)
          "For exchanging fluid mass with the environment"
          annotation (Placement(transformation(extent={{70,-110},{90,-90}})));

        SI.CoefficientOfHeatTransfer htc(min=0, start=0)
          "Coefficient of heat transfer calculated by this environment";
        parameter SI.Temperature initial_T = 293.15
          "Start temperature of environment";
        parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()
          "Medium in the component"
          annotation(__Dymola_choicesAllMatching=true);

       annotation(__Dymola_choicesAllMatching=true,
                        defaultComponentName="env",
          defaultComponentPrefixes="inner",
          Icon(graphics={
              Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid),
               Polygon(
                 points={{52,32},{38,42},{20,40},{12,34},{10,32},{2,34},{0,34},{-8,34},
                    {-14,30},{-22,34},{-32,36},{-46,32},{-54,22},{-54,14},{-50,6},{-44,
                    0},{-42,0},{-38,-4},{-38,-8},{-42,-16},{-40,-30},{-30,-40},{-18,-42},
                    {-6,-40},{0,-34},{4,-30},{12,-34},{24,-34},{36,-30},{46,-24},{48,-10},
                    {46,0},{44,2},{42,4},{52,10},{56,20},{54,30},{52,32}},
                 lineColor={0,0,0},
                 smooth=Smooth.Bezier,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
               Line(
                 points={{46,-4},{44,-2},{36,6},{34,8},{22,10},{10,6},{0,0},{-4,-12},{
                    -2,-22},{4,-28},{6,-30}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{-2,-4},{-12,2},{-20,2},{-30,0},{-34,-4},{-38,-8}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{-16,2},{-12,8},{-10,16},{-10,22},{-14,28},{-18,32}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{14,8},{8,14},{6,24},{8,30},{10,32}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
              Text(
                extent={{-56,-26},{54,-92}},
                lineColor={0,0,0},
                textString="env"),
              Line(
                points={{-80,-102},{-80,10},{-28,10}},
                color={255,0,0},
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{80,-102},{80,10},{24,10}},
                color={0,128,255},
                thickness=0.5,
                smooth=Smooth.None)}),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                  {100,100}}),
                  graphics));
      end C2M2L_Environment;

      model Lumped_Thermal_Fixed_HTC
        "Open volume lumped thermal capacitance with a fixed HTC value."
        extends C2M2L_OM.MSL_Extend.Environments.C2M2L_Environment;
        Thermal.FluidHeatFlow.Components.Volumes.Volume
                                            volume(
          medium=medium,
          V=V,
          T0=initial_T)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=180,
              origin={0,10})));
        parameter SI.Volume V = 1
          "Volume of fluid forming the lumped capacitance";
        parameter SI.CoefficientOfHeatTransfer fixed_htc = 100
          "Fixed heat transfer coefficient";
      equation
        htc = fixed_htc;
        connect(volume.heatPort, heat_port) annotation (Line(
            points={{1.77636e-015,20},{-80,20},{-80,-102}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(volume.flowPort_a, fluid_port) annotation (Line(
            points={{10,10},{10,-26},{80,-26},{80,-100}},
            color={255,0,0},
            smooth=Smooth.None));
        annotation (defaultComponentName="env",
          defaultComponentPrefixes="inner",Diagram(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                   graphics));
      end Lumped_Thermal_Fixed_HTC;

      model Lumped_Thermal_Fixed_HTC_Open_Volume
        "Open volume lumped thermal capacitance with a fixed HTC value."
        extends C2M2L_OM.MSL_Extend.Environments.C2M2L_Environment;
        Thermal.FluidHeatFlow.Components.Volumes.OpenTank
                                            volume(
          height=fluid_height * 2,
          crossArea=fluid_area,
          medium=medium,
          T0=initial_T,
          level_start=fluid_height)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=180,
              origin={0,10})));

        parameter SI.Height fluid_height = 0.1
          "Height of fluid forming the lumped capacitance";
        parameter SI.Area fluid_area = 1 "CSA used to define fluid volume.";
        parameter SI.CoefficientOfHeatTransfer fixed_htc = 100
          "Fixed heat transfer coefficient";
      equation
        htc = fixed_htc;
        connect(volume.heatPort, heat_port) annotation (Line(
            points={{1.77636e-015,20},{-80,20},{-80,-102}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(volume.flowPort_a, fluid_port) annotation (Line(
            points={{10,10},{10,-26},{80,-26},{80,-100}},
            color={255,0,0},
            smooth=Smooth.None));
        annotation (defaultComponentName="env",
          defaultComponentPrefixes="inner",Diagram(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                   graphics));
      end Lumped_Thermal_Fixed_HTC_Open_Volume;

      model Lumped_Thermal_Fixed_HTC_Infinite
        "Infinite volume lumped thermal capacitance with a fixed HTC value."
        extends C2M2L_OM.MSL_Extend.Environments.C2M2L_Environment(             initial_T=fixed_T,fluid_port(medium=medium));

        parameter SI.CoefficientOfHeatTransfer fixed_htc = 100
          "Fixed heat transfer coefficient";
        Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=fixed_T)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-30,-50})));
        parameter SI.Temperature fixed_T=300 "Constant environment temperature";
        parameter Modelica.Media.Interfaces.PartialMedium.AbsolutePressure fixed_P=101300
          "Constant pressure of the environment";
        Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                           boundary(
          constantAmbientTemperature=fixed_T,
          constantAmbientPressure=fixed_P,
          medium=medium)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=180,
              origin={30,-50})));
      equation
        htc = fixed_htc;
        connect(fixedTemperature.port, heat_port) annotation (Line(
            points={{-40,-50},{-80,-50},{-80,-102}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(fluid_port, boundary.flowPort) annotation (Line(
            points={{80,-100},{80,-50},{40,-50}},
            color={255,0,0},
            smooth=Smooth.None));
        annotation (defaultComponentName="env",
          defaultComponentPrefixes="inner",Diagram(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                   graphics));
      end Lumped_Thermal_Fixed_HTC_Infinite;

      model Thermal_To_Environment_Thru_Area
        "Calculate heat transfer between component and environment.  Environment calcs HTC but component area must be supplied."

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a solid
                                    annotation (Placement(transformation(extent={{
                  -110,-10},{-90,10}}, rotation=0)));
        outer C2M2L_Environment                               env
          annotation (Placement(transformation(extent={{40,40},{80,80}})));

      parameter SI.Area area_for_heat_transfer(min=0)
          "Area available for convective heat transfer";

        Modelica.Thermal.HeatTransfer.Components.Convection convection
          annotation (Placement(transformation(extent={{-24,-10},{-4,10}})));
        Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
              area_for_heat_transfer)
          annotation (Placement(transformation(extent={{-86,20},{-32,40}})));
      equation
        connect(solid, convection.solid) annotation (Line(
            points={{-100,0},{-24,0}},
            color={191,0,0},
            thickness=0.5,
            smooth=Smooth.None));
        connect(convection.fluid, env.heat_port) annotation (Line(
            points={{-4,0},{44,0},{44,39.6}},
            color={191,0,0},
            thickness=0.5,
            smooth=Smooth.None));
        connect(realExpression.y, convection.Gc) annotation (Line(
            points={{-29.3,30},{-24,30},{-24,10},{-14,10}},
            color={0,0,127},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),     graphics={
              Rectangle(
                extent={{-62,80},{98,-80}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{-150,-90},{150,-130}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0}),
               Polygon(
                 points={{62,42},{48,52},{30,50},{22,44},{20,42},{12,44},{10,44},{2,44},
                    {-4,40},{-12,44},{-22,46},{-36,42},{-44,32},{-44,24},{-40,16},{-34,
                    10},{-32,10},{-28,6},{-28,2},{-32,-6},{-30,-20},{-20,-30},{-8,-32},
                    {4,-30},{10,-24},{14,-20},{22,-24},{34,-24},{46,-20},{56,-14},{58,
                    0},{56,10},{54,12},{52,14},{62,20},{66,30},{64,40},{62,42}},
                 lineColor={0,0,0},
                 smooth=Smooth.Bezier,
                 lineThickness=0.5),
               Line(
                 points={{56,6},{54,8},{46,16},{44,18},{32,20},{20,16},{10,10},{6,-2},
                    {8,-12},{14,-18},{16,-20}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{8,6},{-2,12},{-10,12},{-20,10},{-24,6},{-28,2}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{-6,12},{-2,18},{0,26},{0,32},{-4,38},{-8,42}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{24,18},{18,24},{16,34},{18,40},{20,42}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
              Text(
                extent={{-46,-16},{64,-82}},
                lineColor={0,0,0},
                textString="env"),
              Text(
                extent={{-196,134},{164,90}},
                lineColor={0,0,0},
                textString="area = %area_for_heat_transfer")}),
          Documentation(info="<HTML>
<p>
This is a model of linear heat convection, e.g., the heat transfer
between a plate and the surrounding air. It may be used for complicated
solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive
equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <i>calculated</i> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<b>Machines cooled by air</b> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><b>Laminar</b> flow with constant velocity of a fluid along a
<b>flat plate</b> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re < 5e5 and 0.6 < Pr < 50
</pre>
</HTML>
"),       Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                  {100,100}}), graphics={
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255})}));
      end Thermal_To_Environment_Thru_Area;

      model Thermal_To_Environment_Direct
        "Directly transfer heat to an outer environment"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a solid
                                    annotation (Placement(transformation(extent={{
                  -110,-10},{-90,10}}, rotation=0)));
        outer C2M2L_Environment                               env
          annotation (Placement(transformation(extent={{26,42},{96,110}})));

        Modelica.Thermal.HeatTransfer.Components.Convection convection
          annotation (Placement(transformation(extent={{-26,-10},{-6,10}})));
        Modelica.Blocks.Sources.RealExpression realExpression(y=1e9)
          annotation (Placement(transformation(extent={{-88,20},{-34,40}})));
      equation
        connect(realExpression.y,convection. Gc) annotation (Line(
            points={{-31.3,30},{-26,30},{-26,10},{-16,10}},
            color={0,0,127},
            thickness=0.5,
            smooth=Smooth.None));
        connect(env.heat_port, convection.fluid) annotation (Line(
            points={{33,41.32},{33,0},{-6,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convection.solid, solid) annotation (Line(
            points={{-26,0},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                              graphics={
              Line(points={{100,0},{100,0}}, color={0,127,255}),
               Polygon(
                 points={{62,42},{48,52},{30,50},{22,44},{20,42},{12,44},{10,44},{2,44},
                    {-4,40},{-12,44},{-22,46},{-36,42},{-44,32},{-44,24},{-40,16},{-34,
                    10},{-32,10},{-28,6},{-28,2},{-32,-6},{-30,-20},{-20,-30},{-8,-32},
                    {4,-30},{10,-24},{14,-20},{22,-24},{34,-24},{46,-20},{56,-14},{58,
                    0},{56,10},{54,12},{52,14},{62,20},{66,30},{64,40},{62,42}},
                 lineColor={0,0,0},
                 smooth=Smooth.Bezier,
                 lineThickness=0.5,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
               Line(
                 points={{56,6},{54,8},{46,16},{44,18},{32,20},{20,16},{10,10},{6,-2},
                    {8,-12},{14,-18},{16,-20}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{8,6},{-2,12},{-10,12},{-20,10},{-24,6},{-28,2}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{-6,12},{-2,18},{0,26},{0,32},{-4,38},{-8,42}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
               Line(
                 points={{24,18},{18,24},{16,34},{18,40},{20,42}},
                 color={0,0,0},
                 smooth=Smooth.Bezier),
              Text(
                extent={{-44,-18},{66,-84}},
                lineColor={0,0,0},
                textString="env"),
              Line(
                points={{-88,0},{-30,0},{-60,14}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{-60,-14},{-32,0}},
                color={255,0,0},
                smooth=Smooth.None),
              Text(
                extent={{-140,-80},{160,-120}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<HTML>
<p>
This is a model of linear heat convection, e.g., the heat transfer
between a plate and the surrounding air. It may be used for complicated
solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive
equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <i>calculated</i> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<b>Machines cooled by air</b> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><b>Laminar</b> flow with constant velocity of a fluid along a
<b>flat plate</b> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re < 5e5 and 0.6 < Pr < 50
</pre>
</HTML>
"),       Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}}),      graphics={
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255})}));
      end Thermal_To_Environment_Direct;
    end Environments;

    package Interfaces
      "\"Contains interface definitions that C2M2L components should extend from to implement specific types of connectivity\""
    extends Modelica.Icons.InterfacesPackage;
      partial model Base_C2M2L
        "Provides features that elementary C2M2L components need (e.g. access to an environment)"
       parameter Boolean use_environment_heat_port = false
          "=true, to exchange thermal energy with the environment";

        MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                                            thermal_To_Environment if use_environment_heat_port
          annotation (Placement(transformation(extent={{100,-100},{120,-80}})));

        annotation (Documentation(info="<html>
<p>
This partial model provides a conditional heat port for dissipating losses.
</p>
<ul>
<li>If <b>useHeatPort</b> is set to <b>false</b> (default), no heat port is available, and the thermal loss power is dissipated internally.
In this case, the parameter <b>T</b> specifies the fixed device temperature (the default for T = 20&deg;C) </li>
<li>If <b>useHeatPort</b> is set to <b>true</b>, the heat port is available. </li>
</ul>
<p>
If this model is used, the loss power has to be provided by an equation in the model which inherits from PartialElementaryConditionalHeatPort model
(<b>lossPower = ...</b>). The device temperature <b>TheatPort</b> can be used to describe the influence of the device temperature on the model behaviour.
</p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}),
                         graphics),
                    Icon(graphics));
      end Base_C2M2L;
    end Interfaces;

    package Testing_Blocks
      "Blocks intented to be used to compose test beds for C2M2L_OM library parts and also delivered parts made using the library"
      extends Modelica.Icons.Package;

      package Fluid_Source_Sinks
        "Components that can substitute for a full vehicle fluid system"
      extends Modelica.Icons.Package;
        model Fluid_Source_Sink

          Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                             boundary(
              constantAmbientPressure=p, medium=medium)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-70,60})));
          Thermal.FluidHeatFlow.Sources.MassFlowSource
                                               boundary1(
            constantMassFlow=m_flow,
            constantAmbientTemperature=T,
            medium=medium)
                      annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-70,-60})));

          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                 return_port(medium=medium)
                        annotation (Placement(
                transformation(rotation=0, extent={{50,-110},{70,-90}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                 supply_port(medium=medium)
                        annotation (Placement(
                transformation(rotation=0, extent={{-70,-110},{-50,-90}})));

          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate m_flow=1.5
            "Fixed mass flow rate going out of the fluid port";
          parameter Modelica.Media.Interfaces.PartialMedium.Temperature T=353.15
            "Temperature of fluid leaving";
          parameter Modelica.Media.Interfaces.PartialMedium.AbsolutePressure p=101300
            "pressure of fluid returning";

        equation
          connect(boundary1.flowPort, supply_port) annotation (Line(
              points={{-60,-60},{0,-60},{0,-100},{-60,-100}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(boundary.flowPort, return_port) annotation (Line(
              points={{-60,60},{60,60},{60,-100}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                                        Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                  fillColor={250,250,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid,
                  origin={60,-90},
                  rotation=90),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  origin={-60,-18},
                  rotation=270,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-84,20},{74,-22}},
                  lineColor={0,0,0},
                  textString="Fluid"),
                Text(
                  extent={{-80,100},{100,60}},
                  lineColor={128,128,128},
                  textString="%m_flow kg/s",
                  horizontalAlignment=TextAlignment.Left),
                Text(
                  extent={{-80,60},{100,20}},
                  lineColor={128,128,128},
                  textString="%T K",
                  horizontalAlignment=TextAlignment.Left)}));
        end Fluid_Source_Sink;

        model Air_Path_For_Testing
          "Provides a simplified block for connecting up something that needs access to ambient air"

          Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                             exhaust(
            constantAmbientPressure=p,
            constantAmbientTemperature=T,
            medium=medium)
            annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                rotation=0,
                origin={28,0})));
          Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                             intake(
            constantAmbientPressure=p,
            constantAmbientTemperature=T,
            medium=medium)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-28,0})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                exhaust_out(medium=medium)
                        annotation (Placement(transformation(
                  rotation=0, extent={{50,-110},{70,-90}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                intake_air(medium=medium)
                        annotation (Placement(transformation(
                  rotation=0, extent={{-70,-110},{-50,-90}})));
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Modelica.Media.Interfaces.PartialMedium.AbsolutePressure p=101300
            "Ambient_Pressure";
          parameter Modelica.Media.Interfaces.PartialMedium.Temperature T=293.15
            "Ambient Temperature";
        equation
          connect(exhaust.flowPort, exhaust_out) annotation (Line(
              points={{38,0},{60,0},{60,-100}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(intake.flowPort, intake_air) annotation (Line(
              points={{-38,0},{-60,0},{-60,-100}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                  preserveAspectRatio=false),graphics),                          Icon(
                coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=
                    true), graphics={   Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                  fillColor={250,250,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={0,128,255},
                  smooth=Smooth.None,
                  origin={-60,-18},
                  rotation=270),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={255,85,85},
                  smooth=Smooth.None,
                  origin={60,-90},
                  rotation=90),
                Text(
                  extent={{-100,20},{-20,-20}},
                  lineColor={128,128,128},
                  textString="inl"),
                Text(
                  extent={{20,20},{100,-20}},
                  lineColor={128,128,128},
                  textString="exh"),
                Text(
                  extent={{-100,100},{100,60}},
                  lineColor={128,128,128},
                  horizontalAlignment=TextAlignment.Left,
                  textString="%p Pa"),
                Text(
                  extent={{-80,60},{100,20}},
                  lineColor={128,128,128},
                  textString="%T K",
                  horizontalAlignment=TextAlignment.Left)}));
        end Air_Path_For_Testing;

        model Cooling_Cart_For_Testing
          "Provides a simplified block for connecting up a cooling system"

          Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                             to_rad_source(
            constantAmbientPressure=p,
            constantAmbientTemperature=T,
            medium=medium)
            annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                rotation=180,
                origin={0,60})));
          Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                             from_rad_source(
            constantAmbientPressure=p,
            constantAmbientTemperature=T,
            medium=medium)
            annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                rotation=0,
                origin={0,-60})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                to_rad(medium=medium)
            "heated fluid that needs cooling"
                        annotation (Placement(transformation(
                  rotation=0, extent={{-110,50},{-90,70}}), iconTransformation(extent={
                    {-110,50},{-90,70}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                from_rad(medium=medium)
            "cooled return fluid"
                        annotation (Placement(transformation(
                  rotation=0, extent={{-110,-70},{-90,-50}}), iconTransformation(extent=
                   {{-110,-70},{-90,-50}})));
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Modelica.Media.Interfaces.PartialMedium.AbsolutePressure p=200000
            "System_Pressure";
          parameter Modelica.Media.Interfaces.PartialMedium.Temperature T=363.15
            "Cart Temperature";
          Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance_to(
            h_g=0.001,
            m=1e-3,
            medium=medium,
            T0=293.15) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-50,60})));
          Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance_from(
            h_g=0.001,
            m=1e-3,
            medium=medium,
            T0=293.15) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-50,-60})));
        equation
          connect(from_rad_source.flowPort, smallResistance_from.flowPort_a)
            annotation (Line(
              points={{-10,-60},{-40,-60}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(smallResistance_from.flowPort_b, from_rad) annotation (Line(
              points={{-60,-60},{-100,-60}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(smallResistance_to.flowPort_a, to_rad_source.flowPort) annotation (
              Line(
              points={{-40,60},{-10,60}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(smallResistance_to.flowPort_b, to_rad) annotation (Line(
              points={{-60,60},{-100,60}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                  preserveAspectRatio=false),graphics),                          Icon(
                coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true),
                           graphics={   Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                  fillColor={250,250,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={0,128,255},
                  smooth=Smooth.None,
                  origin={-20,-60},
                  rotation=180),
                Polygon(
                  points={{2,10},{30,10},{30,30},{70,0},{30,-30},{30,-10},{2,-10},{2,10}},
                  lineColor={200,128,255},
                  smooth=Smooth.None,
                  origin={-92,60},
                  rotation=360),
                Text(
                  extent={{-90,6},{90,-34}},
                  lineColor={128,128,128},
                  textString="%T K",
                  horizontalAlignment=TextAlignment.Left),
                Line(
                  points={{-22,60},{82,60},{62,40},{82,20}},
                  color={200,128,255},
                  smooth=Smooth.None),
                Line(
                  points={{82,-20},{62,-40},{82,-60},{-22,-60}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Line(
                  points={{82,20},{62,0},{82,-20}},
                  color={100,128,255},
                  smooth=Smooth.None)}));
        end Cooling_Cart_For_Testing;
      end Fluid_Source_Sinks;

      package Mechanical_Source_Sinks
        "Components that can apply or react an applied torque"
        extends Modelica.Icons.Package;
        model Dyno_Non_Motoring "Dyno using an adjustable damper"

        parameter Real max_damping = 10000;
          Mechanics.Rotational.Components.Damper_Adjustable damper_Adjustable
            annotation (Placement(transformation(extent={{62,18},{82,38}})));
          Modelica.Blocks.Continuous.LimPID PID1(
            yMax=max_damping,
            k=k,
            Ti=Ti,
            Td=Td,
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            initType=Modelica.Blocks.Types.InitPID.SteadyState,
            yMin=0.01)
                  annotation (Placement(transformation(extent={{24,-52},{44,-32}})));
          Modelica.Blocks.Interfaces.RealInput Set_Speed_rpm
            "Dyno set speed in rpm"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-94,206}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={0,240})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor
            annotation (Placement(transformation(extent={{8,44},{28,64}})));
          Modelica.Mechanics.Rotational.Components.Fixed mounting1D
            annotation (Placement(transformation(extent={{-10,-114},{10,-94}})));
          Modelica.Blocks.Math.UnitConversions.To_rpm convert_speed_to_rpm
            annotation (Placement(transformation(
                origin={72,54},
                extent={{-10,-10},{10,10}},
                rotation=0)));
          parameter Real k=10 "Proportional Gain of controller";
          parameter SI.Time Ti=4 "Time constant of Integrator block";
          parameter SI.Time Td=0.5 "Time constant of derivative block";

          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=J, w(start=w_start))
            annotation (Placement(transformation(extent={{18,0},{38,20}})));
          Modelica.Blocks.Math.Feedback feedback
            annotation (Placement(transformation(extent={{86,80},{106,100}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-48,-52},{-28,-32}})));
          parameter SI.Inertia J=1 "Moment of inertia";
          parameter SI.AngularVelocity w_start "initial_speed";

          Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
            annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
        equation
          connect(speedSensor.w, convert_speed_to_rpm.u) annotation (Line(
              points={{29,54},{60,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(feedback.u2, convert_speed_to_rpm.y) annotation (Line(
              points={{96,82},{96,54},{83,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(Set_Speed_rpm, feedback.u1) annotation (Line(
              points={{-94,206},{-94,90},{88,90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(feedback.y, PID1.u_m) annotation (Line(
              points={{105,90},{126,90},{126,-88},{34,-88},{34,-54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PID1.y, damper_Adjustable.u) annotation (Line(
              points={{45,-42},{60,-42},{60,23},{73,23}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(const.y, PID1.u_s) annotation (Line(
              points={{-27,-42},{22,-42}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(inertia.flange_a, brg_01) annotation (Line(
              points={{18,10},{-92,10},{-92,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(damper_Adjustable.flange_a, brg_01) annotation (Line(
              points={{62,28},{0,28},{0,10},{-92,10},{-92,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor.flange, brg_01) annotation (Line(
              points={{8,54},{0,54},{0,10},{-92,10},{-92,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(damper_Adjustable.flange_b, mounting1D.flange) annotation (Line(
              points={{82,28},{100,28},{100,-68},{0,-68},{0,-104}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}), graphics={
                                                        Text(
                  extent={{-102,42},{98,-38}},
                  lineColor={0,0,255},
                  textString="DYNO"),
                Text(
                  extent={{-6,206},{104,166}},
                  visible=  not use_rpm,
                  lineColor={128,128,128},
                  textString="rpm")}));
        end Dyno_Non_Motoring;

        model Simple_Dyno
          "A simple dyno that attempts to achieve a target speed at its input flange by controlling the torque reaction to the flange"

          MSL_Extend.Mechanics.Rotational.Components.Dyno
                                               dyno(
            k=k,
            Ti=Ti,
            max_res_trq=max_res_trq,
            max_mot_trq=max_mot_trq,
            trq_start=trq_start,
            Td=Td,
            controllerType=controllerType,
            use_inertia=use_inertia,
            J=J,
            useSupport=false)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Blocks.Interfaces.RealInput request_speed
            "requested speed in rad/s"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,110})));
          parameter Real k=1 "Gain of dyno controller";
          parameter Modelica.SIunits.Time Ti=0.1
            "Time constant of Dyno integrator";
          parameter Real max_res_trq=1000 "Maximum resisting torque";
          parameter Real max_mot_trq=-max_res_trq "Maximum motoring torque";
          parameter Real trq_start=0 "Initial value of torque output";
          parameter Modelica.Blocks.Types.SimpleController controllerType=Modelica.Blocks.Types.SimpleController.PI
            "Type of controller";
          parameter Modelica.SIunits.Time Td=1
            "Time constant of deriviative block";
          Modelica.Blocks.Interfaces.RealOutput actual_speed annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-80,106})));
          Modelica.Blocks.Interfaces.RealOutput actual_torque annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-40,106})));
          parameter Boolean use_rpm=false
            "= True, input signal is in rpm rather than rad/s" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Boolean use_inertia=false
            "= True, if inertia should be added to flange" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Modelica.SIunits.Inertia J=1 "Moment of inertia"
            annotation (Dialog(enable=use_inertia));
          Modelica.Blocks.Math.UnitConversions.From_rpm from_rpm if use_rpm
            "conditionally compiled when input is in rpm" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={30,50})));
          Modelica.Blocks.Math.Gain dummy_gain(k=1) if not use_rpm
            "conditionally compiled when input is in rad/s" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,60})));
          Modelica.Blocks.Math.UnitConversions.To_rpm to_rpm if  use_rpm annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-74,46})));
          Modelica.Blocks.Math.Gain dummy_gain1(
                                               k=1) if not use_rpm
            "conditionally compiled when input is in rad/s" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-36,48})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          parameter SI.AngularVelocity w=1 "start_speed";
        equation
          connect(dummy_gain.y, dyno.request_speed) annotation (Line(
              points={{-2.22045e-015,49},{-2.22045e-015,40},{0,40},{0,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(from_rpm.y, dyno.request_speed) annotation (Line(
              points={{30,39},{30,20},{0,20},{0,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(request_speed, dummy_gain.u) annotation (Line(
              points={{0,110},{0,72},{2.22045e-015,72}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(request_speed, from_rpm.u) annotation (Line(
              points={{0,110},{0,80},{30,80},{30,62}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(dyno.flange, flange_a) annotation (Line(
              points={{-10,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(dyno.actual_torque, dummy_gain1.u) annotation (Line(
              points={{-5,11},{-5,22},{-36,22},{-36,36}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(dyno.actual_speed, to_rpm.u) annotation (Line(
              points={{-10,11},{-10,14},{-74,14},{-74,34}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_rpm.y, actual_speed) annotation (Line(
              points={{-74,57},{-74,78.5},{-80,78.5},{-80,106}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(dummy_gain1.y, actual_torque) annotation (Line(
              points={{-36,59},{-36,74},{-40,74},{-40,106}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                                              graphics={Text(
                  extent={{-94,38},{106,-42}},
                  lineColor={0,0,255},
                  textString="DYNO"),
                Text(
                  extent={{-240,260},{-180,220}},
                  lineColor={128,128,128},
                  textString="w"),
                Text(
                  extent={{-150,260},{-90,220}},
                  lineColor={128,128,128},
                  textString="tau"),
                Text(
                  extent={{-58,196},{52,156}},
                  visible=  use_rpm,
                  lineColor={255,0,0},
                  textString="rpm"),
                Text(
                  extent={{-50,196},{60,156}},
                  visible=  not use_rpm,
                  lineColor={255,0,0},
                  textString="rad/s")}));
        end Simple_Dyno;

        model Testing_Load
          parameter SI.RotationalDampingConstant d(final min=0, start=0)=1
            "Damping constant";
          parameter SI.Inertia J(min=0, start=1)=1 "Moment of inertia";
          Modelica.Mechanics.Rotational.Components.Damper damper(d=d)
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=J)
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          Modelica.Mechanics.Rotational.Components.Fixed fixed
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        equation
          connect(fixed.flange, damper.flange_b) annotation (Line(
              points={{0,0},{-20,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(damper.flange_a, inertia.flange_b) annotation (Line(
              points={{-40,0},{-60,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_a, flange_a) annotation (Line(
              points={{-80,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                  preserveAspectRatio=true), graphics), Icon(coordinateSystem(extent={{-100,
                    -100},{100,100}}, preserveAspectRatio=false),graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={244,232,255},
                  textString="L"),
                Text(
                  extent={{-140,80},{140,40}},
                  lineColor={128,128,128},
                  textString="J = %J"),
                Text(
                  extent={{-140,40},{140,0}},
                  lineColor={128,128,128},
                  textString="D = %d"),
                Text(
                  extent={{-160,160},{160,120}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name")}));
        end Testing_Load;
      end Mechanical_Source_Sinks;

      package Land "Components for testing on land"
      extends Modelica.Icons.Package;
        model Road_Wheel_Load_Both_Sides
          "Simulates both road wheels connected to a mass simulating a vehicle"

          Modelica.Mechanics.Rotational.Components.IdealRollingWheel idealRollingWheel(
                                radius=radius, useSupportT=false)
            annotation (Placement(transformation(extent={{-32,-10},{-12,10}})));
          SI.Conversions.NonSIunits.Velocity_kmh vehicleSpeed
            "promote velocity to the top level";
          output SI.Time Accel_20kph(start=-1, fixed=true)
            "Acceleration time to 20 kph";
          output SI.Time Accel_40kph(start=-1, fixed=true)
            "Acceleration time to 40 kph";

          parameter Real Crr = 0.01 "Coefficient of rolling resistance";
          parameter SI.Area frontal_area = 16 "Frontal area of vehicle";
          parameter SI.Density air_density = 1.16 "Nominal air density";
          parameter Real Cd = 1.25
            "Vehicle drag factor (Cd) in F = 0.5 * Cd * rho * v^2 * A";
          parameter SI.Distance radius=0.2
            "Wheel radius used to convert rotational to translational motion";
          parameter SI.Mass vehicle_mass=20000 "Mass of the vehicle";
          parameter SI.Force static_resistance=vehicle_mass * 9.81 * Crr
            "Constant force required to move vehicle";
          parameter SI.TranslationalDampingConstant linear_resistance=0
            "Linear resistance coefficient (d) in f = d * vel";
          parameter Real quad_resistance=0.5 * Cd * air_density * frontal_area
            "Quadratic resistance coeff (dq) in f = dq * v * |v|";
          parameter Real grade=0 "% grade (100% = 45degree angle)";
          Modelica.Mechanics.Translational.Components.Mass mass(m=vehicle_mass, L=0,
            v(fixed=true),
            stateSelect=StateSelect.always)
            annotation (Placement(transformation(extent={{62,-10},{82,10}})));
          Modelica.Mechanics.Translational.Components.SupportFriction supportFriction(
            useSupport=true,
            f_pos=[0,static_resistance],
            peak=1,
            locked(fixed=true, start=true))
                       annotation (Placement(transformation(extent={{28,-10},{48,10}})));
          MSL_Extend.Mechanics.Translational.Components.Quadratic_Damper
                                                              quadratic_damper(d=
                linear_resistance, dq=quad_resistance)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={54,-20})));

          Modelica.Mechanics.Rotational.Interfaces.Flange_a         rhs_flange
            annotation (Placement(transformation(extent={{-110,30},{-90,50}})));
          Modelica.Mechanics.Translational.Components.Fixed fixed
            annotation (Placement(transformation(extent={{28,-50},{48,-30}})));
          Modelica.Mechanics.Translational.Sensors.ForceSensor forceSensor
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          Modelica.Mechanics.Translational.Sources.Force force1
            annotation (Placement(transformation(extent={{62,18},{82,38}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=-vehicle_mass*9.81*
                (grade / 100) * sin(pi /4)) annotation (Placement(transformation(extent={{32,18},
                    {52,38}})));
          Modelica.Mechanics.Rotational.Components.Brake brake(fn_max=100000, locked(
                fixed=true, start=true))
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

          Modelica.Mechanics.Rotational.Interfaces.Flange_a         lhs_flange
            annotation (Placement(transformation(extent={{-110,-50},{-90,-30}})));

          Modelica.Mechanics.Rotational.Components.Inertia rotational_inertia(J=1)
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
          Modelica.Mechanics.Translational.Sensors.SpeedSensor speedSensor
            annotation (Placement(transformation(extent={{4,50},{24,70}})));
          Modelica.Blocks.Sources.Constant const2(k=0)
            annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Blocks.Interfaces.RealOutput vehicle_speed annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={30,106})));
          Modelica.Mechanics.Rotational.Components.IdealGear idealPlanetary(ratio=-1)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-100,-18})));
        equation
          vehicleSpeed = SI.Conversions.to_kmh(mass.v);

          when vehicleSpeed > 20 then
             Accel_20kph = time;
          end when;
          when vehicleSpeed > 40 then
             Accel_40kph = time;
          end when;

          connect(idealRollingWheel.flangeT, forceSensor.flange_a) annotation (Line(
              points={{-12,0},{0,0}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(forceSensor.flange_b, supportFriction.flange_a) annotation (Line(
              points={{20,0},{28,0}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(supportFriction.flange_b, quadratic_damper.flange_a) annotation (Line(
              points={{48,0},{54,0},{54,-10}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(supportFriction.flange_b, mass.flange_a) annotation (Line(
              points={{48,0},{62,0}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(supportFriction.support, fixed.flange) annotation (Line(
              points={{38,-10},{38,-40}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(fixed.flange, quadratic_damper.flange_b) annotation (Line(
              points={{38,-40},{54,-40},{54,-30}},
              color={0,127,0},
              smooth=Smooth.None));

          connect(force1.flange, mass.flange_b) annotation (Line(
              points={{82,28},{92,28},{92,0},{82,0}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(realExpression.y, force1.f) annotation (Line(
              points={{53,28},{60,28}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(brake.flange_b, idealRollingWheel.flangeR) annotation (Line(
              points={{-40,0},{-32,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(rotational_inertia.flange_b, brake.flange_a) annotation (Line(
              points={{-70,0},{-60,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealRollingWheel.flangeT, speedSensor.flange) annotation (Line(
              points={{-12,0},{-8,0},{-8,60},{4,60}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(const2.y, brake.f_normalized) annotation (Line(
              points={{-59,50},{-50,50},{-50,11}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(rotational_inertia.flange_a, rhs_flange) annotation (Line(
              points={{-90,0},{-100,0},{-100,40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor.v, vehicle_speed) annotation (Line(
              points={{25,60},{30,60},{30,106}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(idealPlanetary.flange_b, rhs_flange) annotation (Line(
              points={{-100,-8},{-100,40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealPlanetary.flange_a, lhs_flange) annotation (Line(
              points={{-100,-28},{-100,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Ellipse(
                  extent={{-40,-40},{-20,-60}},
                  lineColor={0,0,255},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-40},{60,-60}},
                  lineColor={0,0,255},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{64,-38},{-12,-4}},
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Ellipse(
                  extent={{-16,-40},{4,-60}},
                  lineColor={0,0,255},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-38},{-44,-38},{-44,-20},{-34,-4},{-20,-4},{-20,-38}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Polygon(
                  points={{-36,-22},{-32,-8},{-26,-8},{-26,-22},{-36,-22}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-64,88},{68,8}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  textString="Road
Load"),         Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0})}));
        end Road_Wheel_Load_Both_Sides;
      end Land;
    end Testing_Blocks;

    package Hydraulics_Simple "Light weight hydraulics package"
    import SI = Modelica.SIunits;

      extends Modelica.Icons.Package;

      package Components "Simple hydraulic components"
      extends Modelica.Icons.Package;

        package Cylinders
          extends Modelica.Icons.Package;
          model Hydraulic_Mechanical_Conversion_Translational
            "Ideal conversion between translational flange and hydraulic flow"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Hydraulic_Mechanical_Conversion_Translational;
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Icons.Hydraulic_Mechanical_Device_Translational;
          equation
              V = piston_area * der(flange.s);
              dP = -flange.f / piston_area;
            annotation (Diagram(graphics), Icon(graphics));
          end Hydraulic_Mechanical_Conversion_Translational;
        end Cylinders;

        package Orifices
          extends Modelica.Icons.Package;
          model Loss_Linear
            "Simple linear loss model V = k * dP, where k is a user entered parameter"
            extends Templates.Partial_Two_Port_Transport;
            parameter Real k=1 "Loss factor";
            SI.Power loss_power "Power dissipated in component";
          equation
            V = k * dP;
            loss_power = abs(V * dP);
            annotation (Diagram(graphics), Icon(graphics={
                  Line(
                    points={{-100,0},{100,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{-60,30},{-40,10},{40,10},{60,30}},
                    color={95,95,95},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{-60,-30},{-40,-10},{40,-10},{60,-30}},
                    color={95,95,95},
                    smooth=Smooth.Bezier),
                  Text(
                    extent={{-140,-40},{140,-100}},
                    lineColor={128,128,128},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    textString="k = %k"),
                  Text(
                    extent={{20,80},{60,40}},
                    lineColor={0,0,0},
                    textString="L")}));
          end Loss_Linear;

          model Loss_Quadratic
            "Simple quadratic loss model V = k * sqrt(dP), where k is a user entered parameter"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;
            import Modelica.Fluid.Utilities.regRoot;
            parameter SI.Pressure dP_regularize = 1000
              "dP below which to use regularaization";

            parameter Real k=1 "Loss factor";
            SI.Power loss_power "Power dissipated in component";
          equation
            //V =  k * regRoot(dP);
            V = k*regRoot(dP, dP_regularize);
            loss_power = abs(V * dP);
            annotation (Diagram(graphics), Icon(graphics={
                  Line(
                    points={{-100,0},{100,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{-60,30},{-40,10},{40,10},{60,30}},
                    color={95,95,95},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{-60,-30},{-40,-10},{40,-10},{60,-30}},
                    color={95,95,95},
                    smooth=Smooth.Bezier),
                  Text(
                    extent={{-140,-40},{140,-100}},
                    lineColor={0,0,0},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    textString="k = %k")}));
          end Loss_Quadratic;

          model Short_Circuit
            "Lossless connection primarily used to help build model with selectable components"
            extends Interfaces.Partial_Two_Port;
          equation
            connect(hyd_a, hyd_b) annotation (Line(
                points={{-100,0},{100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Line(
                    points={{-100,0},{100,0}},
                    color={255,0,128},
                    smooth=Smooth.None)}));
          end Short_Circuit;
        end Orifices;

        package Pumps
          extends Modelica.Icons.Package;

          model Hydraulic_Mechanical_Conversion
            "Ideal conversion between rotary shaft and hydraulic flow in a fixed displacement device"
            extends
              MSL_Extend.Hydraulics_Simple.Interfaces.Partial_Hydraulic_Mechanical_Conversion_Rotary;
            extends Icons.Hydraulic_Mechanical_Device;
          equation
              V = vol_per_radian * der(flange.phi);
              dP = -flange.tau / Nm_per_pascal;
            annotation (Diagram(graphics), Icon(graphics));
          end Hydraulic_Mechanical_Conversion;

          model Hydraulic_Mechanical_Conversion_Lossy
            "Converts between rotary shaft and hydraulic flow with mechanical and hydrauic losses"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Hydraulic_Mechanical_Conversion_Lossy;

            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion
              hydraulic_Mechanical_Conversion(vol_per_radian=vol_per_radian,
                Nm_per_pascal=Nm_per_pascal,
              useSupport=false)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          equation

            connect(hydraulic_Mechanical_Conversion.hyd_a, hyd_a) annotation (Line(
                points={{-10,0},{-100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion.hyd_b, hyd_b) annotation (Line(
                points={{10,0},{100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(inertia_small.flange_b, hydraulic_Mechanical_Conversion.flange)
              annotation (Line(
                points={{20,40},{0,40},{0,10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(disc.flange_b, hydraulic_Mechanical_Conversion.flange) annotation (
                Line(
                points={{-18,40},{0,40},{0,10}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={
                  Polygon(
                    points={{-75,50},{-46,50},{-46,90},{-56,90},{-36,110},{-16,90},{-26,
                        90},{-26,30},{-75,30},{-75,50}},
                    lineColor={0,0,0},
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid)}));
          end Hydraulic_Mechanical_Conversion_Lossy;

          model Hydraulic_Mechanical_Conversion_Variable_Lossy
            "Converts between rotary shaft and hydraulic flow with mechanical and hydrauic losses and a variable displacement device"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Hydraulic_Mechanical_Conversion_Lossy;

            Pumps.Hydraulic_Mechanical_Conversion_Variable
              hydraulic_Mechanical_Conversion(vol_per_radian=vol_per_radian,
              useSupport=false,
              min_multiplier=min_multiplier)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            parameter Real min_multiplier=0.1
              "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u";
            Modelica.Blocks.Interfaces.RealInput u
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          equation

            connect(hydraulic_Mechanical_Conversion.hyd_a, hyd_a) annotation (Line(
                points={{-10,0},{-100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion.hyd_b, hyd_b) annotation (Line(
                points={{10,0},{100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(u, hydraulic_Mechanical_Conversion.u) annotation (Line(
                points={{-120,80},{-66,80},{-66,8},{-12,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia_small.flange_b, hydraulic_Mechanical_Conversion.flange)
              annotation (Line(
                points={{20,40},{20,25},{0,25},{0,10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(disc.flange_b, hydraulic_Mechanical_Conversion.flange) annotation (
                Line(
                points={{-18,40},{0,40},{0,10}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={
                  Polygon(
                    points={{-75,50},{-46,50},{-46,90},{-56,90},{-36,110},{-16,90},{-26,
                        90},{-26,30},{-75,30},{-75,50}},
                    lineColor={0,0,0},
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{40,56},{60,60},{56,40}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{60,60},{-60,-60}},
                    color={0,0,255},
                    smooth=Smooth.None)}));
          end Hydraulic_Mechanical_Conversion_Variable_Lossy;

          model Hydraulic_Mechanical_Conversion_Variable_One_Way
            "Ideal conversion between rotary shaft and hydraulic flow in a variable displacement device"
            extends Interfaces.Partial_Hydraulic_Mechanical_Conversion_Rotary;
            extends Icons.Hydraulic_Mechanical_Device;

            parameter Real min_multiplier(min=0)=0.1
              "if |u_d| < |min_mult| then u_limited = sign(u_d) * min_mult else u_limit=u_d";
            Modelica.Blocks.Interfaces.RealInput u_d
              "displacement multiplier [-1 to +1]"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          equation
            V = max(abs(u_d), min_multiplier) *vol_per_radian*der(flange.phi);

            dP = -flange.tau*max(abs(u_d), min_multiplier)/Nm_per_pascal;

            annotation (Diagram(graphics), Icon(graphics={Line(
                    points={{60,60},{-60,-60}},
                    color={0,0,255},
                    smooth=Smooth.None), Line(
                    points={{40,56},{60,60},{56,40}},
                    color={0,0,255},
                    smooth=Smooth.None)}));
          end Hydraulic_Mechanical_Conversion_Variable_One_Way;

          model Hydraulic_Mechanical_Conversion_Variable
            "Ideal conversion between rotary shaft and hydraulic flow in a variable displacement device"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Partial_Two_Port;
            extends
              C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
            extends Icons.Hydraulic_Mechanical_Device;
            parameter SI.Volume vol_per_radian = 1
              "Nominal volume of hydraulic fluid moved for 1 radian of shaft rotation";
            constant SI.Length unit_length = 1;
            parameter Real min_multiplier=0.1
              "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u";
            Modelica.Blocks.Interfaces.RealInput u
              "displacement multiplier [-1 to +1]"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

            Blocks.Math.Positive_Negative_Split real_To_Signed_Integer(flip_neg=true)
              annotation (Placement(transformation(extent={{-40,64},{-20,84}})));
            parameter SI.Torque locked_max_torque=1000
              "Max torque transmitted when locked";
            Pumps.Hydraulic_Mechanical_Conversion_Variable_One_Way
              hydraulic_Mechanical_Conversion_Variable_One_Way(
              vol_per_radian=vol_per_radian,
              Nm_per_pascal=vol_per_radian,
              min_multiplier=min_multiplier)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia(J=0.01) annotation (
                Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={0,30})));
            Modelica.Mechanics.Rotational.Components.IdealGear idealGear(ratio=-1,
                useSupport=false) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={30,40})));
            Modelica.Mechanics.Rotational.Components.Clutch clutch_rev(fn_max=
                  locked_max_torque/unit_length) annotation (Placement(transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=270,
                  origin={60,68})));
            Modelica.Mechanics.Rotational.Components.Clutch clutch_fwd(fn_max=
                  locked_max_torque/unit_length) annotation (Placement(transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=270,
                  origin={0,80})));
            Blocks.Math.Reg_Step reg_Step(u_small=min_multiplier)
              annotation (Placement(transformation(extent={{-70,58},{-50,78}})));
            C2M2L_OM.MSL_Extend.Blocks.Sources.Constants.Fix_Plus_1
                                      fix_Plus_1_1
              annotation (Placement(transformation(extent={{-88,72},{-80,80}})));
            C2M2L_OM.MSL_Extend.Blocks.Sources.Constants.Fix_Minus_1
                                       fix_Minus_1_1
              annotation (Placement(transformation(extent={{-88,56},{-80,64}})));
          equation
            connect(hyd_a, hydraulic_Mechanical_Conversion_Variable_One_Way.hyd_a)
              annotation (Line(
                points={{-100,0},{-10,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Variable_One_Way.hyd_b, hyd_b)
              annotation (Line(
                points={{10,0},{100,0}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(u, hydraulic_Mechanical_Conversion_Variable_One_Way.u_d)
              annotation (Line(
                points={{-120,80},{-96,80},{-96,8},{-12,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia.flange_a, hydraulic_Mechanical_Conversion_Variable_One_Way.flange)
              annotation (Line(
                points={{-6.12323e-016,20},{0,20},{0,10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(real_To_Signed_Integer.y_neg, clutch_rev.f_normalized) annotation (
                Line(
                points={{-19,68},{49,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(real_To_Signed_Integer.y_pos, clutch_fwd.f_normalized) annotation (
                Line(
                points={{-19,80},{-11,80}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(idealGear.flange_a, inertia.flange_b) annotation (Line(
                points={{20,40},{6.12323e-016,40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(clutch_fwd.flange_b, flange) annotation (Line(
                points={{1.83697e-015,90},{1.83697e-015,100},{0,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(clutch_rev.flange_b, flange) annotation (Line(
                points={{60,78},{60,90},{0,90},{0,100}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(clutch_rev.flange_a, idealGear.flange_b) annotation (Line(
                points={{60,58},{60,40},{40,40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(clutch_fwd.flange_a, inertia.flange_b) annotation (Line(
                points={{-1.83697e-015,70},{-1.83697e-015,40},{6.12323e-016,40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fix_Plus_1_1.y, reg_Step.a) annotation (Line(
                points={{-79,76},{-72,76}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(fix_Minus_1_1.y, reg_Step.b) annotation (Line(
                points={{-79,60},{-72,60}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(u, reg_Step.u) annotation (Line(
                points={{-120,80},{-96,80},{-96,34},{-60,34},{-60,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(reg_Step.y, real_To_Signed_Integer.u) annotation (Line(
                points={{-49,74},{-42,74}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={Line(
                    points={{60,60},{-60,-60}},
                    color={0,0,255},
                    smooth=Smooth.None), Line(
                    points={{40,56},{60,60},{56,40}},
                    color={0,0,255},
                    smooth=Smooth.None)}));
          end Hydraulic_Mechanical_Conversion_Variable;
        end Pumps;

        package Switches
          extends Modelica.Icons.Package;
          model Hydraulic_On_Off_Switch
            "switches a circuit on-off based on a signal input"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;

            import Modelica.Fluid.Utilities.regRoot;

            parameter SI.Pressure dP_regularize = 1000
              "dP below which to use regularaization";

            parameter Real k_on(min=0.0)=0.0001 "loss factor (>0) when on";
            parameter Real k_off(min=0.0)=0.0 "loss factor (>=0) when off";
            parameter Boolean exact=false
              "true/false exact treatment/filtering the input signal";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal"
              annotation (Dialog(enable=not exact));
            Modelica.Blocks.Interfaces.BooleanInput u   annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,120}),  iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,120})));
          //protected
            Real k;
            Real y;
            Modelica.Blocks.Continuous.CriticalDamping crit_damp(
              final n=1,
              f=f_crit,
              normalized=false,
              initType=Modelica.Blocks.Types.Init.SteadyState)
              annotation (Placement(transformation(extent={{60,60},{80,80}})));
          public
            Modelica.Blocks.Math.BooleanToReal booleanToReal
              annotation (Placement(transformation(extent={{20,60},{40,80}})));
          equation
            if exact then
              y = booleanToReal.y;
            else
              y = max(min(1.0, crit_damp.y), 0.0);
            end if;

            k = y * k_on + (1 - y) * k_off;
            V = k * regRoot(dP, dP_regularize);

            connect(booleanToReal.u, u) annotation (Line(
                points={{18,70},{0,70},{0,120}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(booleanToReal.y, crit_damp.u)              annotation (Line(
                points={{41,70},{58,70}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Icon(graphics={
                  Line(
                    points={{-100,0},{-20,0},{20,40}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{20,0},{102,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{0,100},{0,20}},
                    color={255,0,255},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Text(
                    extent={{-140,-60},{140,-100}},
                    lineColor={0,0,255},
                    textString="%name")}), Diagram(graphics));
          end Hydraulic_On_Off_Switch;

          model Hydraulic_One_Way
            "Allows flow to easily pass in the forward direction but provides a large resistance to reverse flow"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;

            import Modelica.Fluid.Utilities.regRoot;
            import Modelica.Fluid.Utilities.regStep;

            parameter SI.Pressure dP_regularize = 1000
              "dP below which to use regularaization";

            parameter Real k_forward(min=0.0) = 0.0001
              "loss factor (>0) when on";
            parameter Real k_reverse(min=0.0) = 1e-10
              "loss factor (>=0) when off";
          //protected
            Real k;

          equation
            k = regStep(dP, k_forward, k_reverse, dP_regularize / 100);
            V = k*regRoot(dP, dP_regularize);
            annotation (Icon(graphics={
                  Line(
                    points={{-100,0},{-40,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{50,0},{102,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Text(
                    extent={{-140,-60},{140,-100}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Ellipse(extent={{-30,30},{30,-30}},lineColor={0,0,0},
                    origin={20,0},
                    rotation=90),
                  Line(
                    points={{-40,-30},{0,10},{40,-30}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={-30,0},
                    rotation=90)}),        Diagram(graphics));
          end Hydraulic_One_Way;

          model Hydraulic_On_Off_Switch_Continuous
            "switches a circuit continuously between on-off based on 0-1 real signal"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;
            import Modelica.Fluid.Utilities.regRoot;

            parameter SI.Pressure dP_regularize = 1000
              "dP below which to use regularaization";

            parameter Real k_on(min=0.0) = 0.0001 "loss factor (>0) when on";
            parameter Real k_off(min=0.0) = 0.0 "loss factor (>=0) when off";
            parameter Boolean exact=false
              "true/false exact treatment/filtering the input signal";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal"
              annotation (Dialog(enable=not exact));
            Modelica.Blocks.Interfaces.RealInput u annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
          //protected
            Real k;
            Real y;
            Modelica.Blocks.Continuous.CriticalDamping crit_damp(
              final n=1,
              f=f_crit,
              normalized=false,
              initType=Modelica.Blocks.Types.Init.SteadyState)
              annotation (Placement(transformation(extent={{20,60},{40,80}})));

          equation
            if exact then
              y = u;
            else
              y = max(min(1.0, crit_damp.y), 0.0);
            end if;
            k = y*k_on + (1 - y)*k_off;
            //dP = V*abs(V)/k^2;
            V = k*regRoot(dP, dP_regularize);
            connect(crit_damp.u, u) annotation (Line(
                points={{18,70},{0,70},{0,100}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Icon(graphics={
                  Line(
                    points={{-100,0},{-20,0},{20,40}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{20,0},{102,0}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{0,100},{0,20}},
                    color={255,0,255},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Text(
                    extent={{-140,-60},{140,-100}},
                    lineColor={0,0,255},
                    textString="%name")}), Diagram(graphics));
          end Hydraulic_On_Off_Switch_Continuous;
        end Switches;

        package Templates "Classes used to build other classes"
        extends Modelica.Icons.Package;

          partial model Partial_Two_Port_Transport
            "Base class with two hydraulic connectors and no storage of mass or energy"
            extends Interfaces.Partial_Two_Port;
            SI.VolumeFlowRate V(start=0)
              "Flow rate through component, +ve from a to b";
            SI.Pressure dP(start=0)
              "Pressure drop across component, +ve if a.P > b.P";
          equation
            V = hyd_a.V;
            dP = hyd_a.P - hyd_b.P;
            0 = hyd_a.V + hyd_b.V;
            annotation (Icon(graphics), Diagram(graphics));
          end Partial_Two_Port_Transport;

          partial model Partial_Hydraulic_Mechanical_Conversion_Translational
            "Base class for converting  between translational flange and hydraulic flow"
            extends
              C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;
            extends
              C2M2L_OM.MSL_Extend.Mechanics.Translational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
            parameter SI.Area piston_area = 1
              "Relates hydraulic volume flow to linear flange movement";

            annotation (Diagram(graphics));
          end Partial_Hydraulic_Mechanical_Conversion_Translational;

          partial model Partial_Hydraulic_Mechanical_Conversion_Lossy
            "Partial wrapper that provides efficiency losses, inertia and leakage flow"
           extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(
                thermal_To_Environment(area_for_heat_transfer=0.1));
           extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
           extends
              C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.PartialOneFlangeAndSupport_Top;
           extends Icons.Hydraulic_Mechanical_Device;
           extends Interfaces.Partial_Two_Port;
           parameter SI.Volume vol_per_radian = 1
              "Volume of hydraulic fluid moved for 1 radian of shaft rotation"
                                                                             annotation(Dialog(group="Hydraulic"));
           parameter SI.Volume Nm_per_pascal = 1
              "Pressure rise for 1 Nm of torque input"
                                                     annotation(Dialog(group="Hydraulic"));
           parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
              "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical"));
           parameter Boolean useInertia=false
              "= true if inertia enabled, otherwise not used in model"                              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(group="Inertia"));

            parameter SI.Inertia J(
              min=0,
              start=1)=0.001 "Moment of inertia"                          annotation(Dialog(group="Inertia",
                  enable=useInertia));
           parameter Boolean useLeakage=true
              "= true if leakage enabled, otherwise not used in model"
                                                                     annotation(Dialog(group="Hydraulic"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            parameter Real leakage=0.001 "Leakage loss factor"
                                                              annotation(Dialog(group="Hydraulic",
                  enable=useLeakage));

           Modelica.Mechanics.Rotational.Components.IdealGear lossyGear(ratio=1,
             useSupport=false)
             annotation (Placement(transformation(
                 extent={{-10,-10},{10,10}},
                 rotation=270,
                 origin={0,78})));
           Modelica.Mechanics.Rotational.Components.Inertia inertia_small(J=J) if    useInertia
             annotation (Placement(transformation(
                 extent={{-10,-10},{10,10}},
                 rotation=270,
                 origin={20,50})));
           Orifices.Loss_Quadratic                 leakage_loss(k=leakage) if    useLeakage
             annotation (Placement(transformation(extent={{-10,-44},{10,-24}})));
            Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow fixedHeatFlow(Q_flow=0) if useHeatPort
              annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));
           Modelica.Mechanics.Rotational.Components.Disc disc if not useInertia
             annotation (Placement(transformation(
                 extent={{-10,-10},{10,10}},
                 rotation=270,
                 origin={-18,50})));
          equation
            if not useHeatPort then
                //lossPower = lossyGear.lossPower;
                lossPower = 0.0;
            end if;

           connect(inertia_small.flange_a, lossyGear.flange_b) annotation (Line(
               points={{20,60},{-1.83697e-015,60},{-1.83697e-015,68}},
               color={0,0,0},
               smooth=Smooth.None));
           connect(lossyGear.flange_a, flange) annotation (Line(
               points={{1.83697e-015,88},{0,88},{0,100}},
               color={0,0,0},
               smooth=Smooth.None));
           connect(leakage_loss.hyd_a, hyd_a) annotation (Line(
               points={{-10,-34},{-54,-34},{-54,0},{-100,0}},
               color={255,0,128},
               smooth=Smooth.None));
           connect(leakage_loss.hyd_b, hyd_b) annotation (Line(
               points={{10,-34},{54,-34},{54,0},{100,0}},
               color={255,0,128},
               smooth=Smooth.None));
            connect(fixedHeatFlow.port, thermal_To_Environment.solid) annotation (Line(
                points={{-80,-70},{32,-70},{32,-90},{100,-90}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(fixedHeatFlow.port, heatPort) annotation (Line(
                points={{-80,-70},{-74,-70},{-74,-100},{-100,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(lossyGear.flange_b, disc.flange_a) annotation (Line(
                points={{0,68},{0,60},{-18,60}},
                color={0,0,0},
                smooth=Smooth.None));
           annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                               graphics={Text(
                    extent={{-118,-40},{-68,-62}},
                    lineColor={255,0,0},
                    textString="Temporarily removed the lossy gear 
and therefore heat rejection.  
fixedHeatFlow required to make model compile")}),
                                          Icon(graphics={
                 Polygon(
                   points={{-75,50},{-46,50},{-46,90},{-56,90},{-36,110},{-16,90},{-26,
                       90},{-26,30},{-75,30},{-75,50}},
                   lineColor={0,0,0},
                   fillColor={255,0,0},
                   fillPattern=FillPattern.Solid)}));
          end Partial_Hydraulic_Mechanical_Conversion_Lossy;
        end Templates;

        package Valves
          extends Modelica.Icons.Package;
          model Crossover
            "Fluid from inlet P (pressure) can be sent to A and returned via B to T (tank) or vice versa.  Also has a closed position."

            Switches.Hydraulic_On_Off_Switch                                           v_1(
              k_on=k_on,
              k_off=k_off,
              f_crit=f_crit)
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Switches.Hydraulic_On_Off_Switch  v_4(
              k_on=k_on,
              k_off=k_off,
              f_crit=f_crit)
              annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
            Switches.Hydraulic_On_Off_Switch  v_2(
              k_on=k_on,
              k_off=k_off,
              f_crit=f_crit)
              annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
            Interfaces.Hydraulic_Port P
              annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
            Switches.Hydraulic_On_Off_Switch  v_3(
              k_on=k_on,
              k_off=k_off,
              f_crit=f_crit)
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Interfaces.Hydraulic_Port T
              annotation (Placement(transformation(extent={{-110,-69},{-90,-49}}),
                  iconTransformation(extent={{-110,-71},{-90,-51}})));
            Interfaces.Hydraulic_Port A
              annotation (Placement(transformation(extent={{90,50},{110,70}})));
            Interfaces.Hydraulic_Port B
              annotation (Placement(transformation(extent={{90,-71},{110,-51}})));
            Blocks.Logical.Integer_Equality_Parameter plus1(p=1)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=-90,
                  origin={-10,80})));
            Blocks.Logical.Integer_Equality_Parameter minus1(p=-1)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=-90,
                  origin={-70,80})));
            Modelica.Blocks.Interfaces.IntegerInput u annotation (Placement(
                  transformation(
                  extent={{-12,-12},{12,12}},
                  rotation=-90,
                  origin={0,112})));
            parameter Real k_on=0.0001 "loss factor (>0) when on";
            parameter Real k_off=0.000001 "loss factor (>=0) when off";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal";
          equation
            connect(plus1.y, v_1.u)                      annotation (Line(
                points={{-10.05,68.85},{-10.05,66.425},{10,66.425},{10,62}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(plus1.y, v_2.u)                      annotation (Line(
                points={{-10.05,68.85},{-10.05,-50},{10,-50},{10,-58}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(P, v_1.hyd_a) annotation (Line(
                points={{-100,60},{-98,60},{-98,50},{0,50}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(v_1.hyd_b, A) annotation (Line(
                points={{20,50},{98,50},{98,60},{100,60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(T, v_2.hyd_a) annotation (Line(
                points={{-100,-59},{-100,-70},{0,-70}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(v_2.hyd_b, B) annotation (Line(
                points={{20,-70},{100,-70},{100,-61}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(plus1.u, u)                      annotation (Line(
                points={{-10,92},{-10,98},{0,98},{0,112}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(u, minus1.u)                      annotation (Line(
                points={{0,112},{0,98},{-70,98},{-70,92}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(P, v_3.hyd_a) annotation (Line(
                points={{-100,60},{-100,0},{-60,0}},
                color={255,128,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(v_3.hyd_b, B) annotation (Line(
                points={{-40,0},{100,0},{100,-61}},
                color={255,128,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(minus1.y, v_4.u)                      annotation (Line(
                points={{-70.05,68.85},{-70.05,-12},{-50,-12},{-50,-18}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(T, v_4.hyd_a) annotation (Line(
                points={{-100,-59},{-100,-30},{-60,-30}},
                color={255,128,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(v_4.hyd_b, A) annotation (Line(
                points={{-40,-30},{0,-30},{0,30},{100,30},{100,60}},
                color={255,128,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(v_3.u, minus1.y) annotation (Line(
                points={{-50,12},{-50,40},{-70.05,40},{-70.05,68.85}},
                color={255,0,255},
                smooth=Smooth.None));

            annotation (Diagram(graphics), Icon(graphics={
                  Rectangle(
                    extent={{-88,30},{92,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-28,30},{32,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-44,-20},{-44,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-74,-20},{-74,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-84,10},{-74,20},{-64,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-30},{-12,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-22,-10},{-2,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,-26},{86,24}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,24},{86,-26}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-10,-1.66874e-015},{0,10},{10,1.66874e-015}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={-44,-10},
                    rotation=180),
                  Line(
                    points={{72,-26},{86,-26},{86,-12}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Text(
                    extent={{-172,74},{178,24}},
                    lineColor={128,128,128},
                    textString="1   0  -1"),
                  Line(
                    points={{0,100},{0,70}},
                    color={255,128,0},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Line(
                    points={{60,72},{60,92},{-60,92},{-60,70}},
                    color={255,128,0},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Line(
                    points={{-12,10},{-12,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,10},{18,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,-30},{18,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{8,-10},{28,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-22,10},{-2,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{8,10},{28,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-7,-7},{7,-7},{7,7}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={79,17},
                    rotation=90),
                  Text(
                    extent={{-120,110},{-80,70}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="P"),
                  Text(
                    extent={{80,110},{120,70}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="A"),
                  Text(
                    extent={{80,-70},{120,-110}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="B"),
                  Text(
                    extent={{-120,-70},{-80,-110}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="T")}));
          end Crossover;

          model Pressure_Relief_Valve
            "Allows bypass from P to T to prevent pressure at A exceeding a set value."

            Interfaces.Hydraulic_Port P
              annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
            Interfaces.Hydraulic_Port T
              annotation (Placement(transformation(extent={{-10,-109},{10,-89}}),
                  iconTransformation(extent={{-10,-109},{10,-89}})));
            Interfaces.Hydraulic_Port A
              annotation (Placement(transformation(extent={{90,50},{110,70}})));
            Sensors.Pressure_Sensor pressure_Sensor annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-50,30})));
            parameter SI.Pressure p_max=1e5 "Maximum pressure allowed at A";
            parameter Real p_error_frac(min=0.0)=0.01
              "Fraction of p_max over p_max that fully opens relief valve";
            Switches.Hydraulic_On_Off_Switch_Continuous                        hydraulic_Valve(
              k_on=k_on,
              k_off=k_off,
              exact=exact,
              f_crit=f_crit)                     annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-80,-40})));
            Modelica.Blocks.Math.Add add(k1=1, k2=-1)
              annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
            Modelica.Blocks.Sources.Constant const1(k=p_max)
              annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Math.Gain gain(k=1/(p_max*p_error_frac))
              annotation (Placement(transformation(extent={{10,-20},{30,0}})));
            Blocks.Math.Min_Max.Max_Against_Parameter max_Against_Parameter(p=min_opening)
              annotation (Placement(transformation(extent={{40,-20},{60,0}})));
            parameter Real k_on=0.0001 "loss factor (>0) when on";
            parameter Real k_off=0.0 "loss factor (>0) when off";
            parameter Boolean exact=false
              "true/false exact treatment/filtering the input signal";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal";
            parameter Real min_opening=0.001
              "Minimum fractional opening of the valve (improves performance if > 0)";
          equation
            connect(P, A) annotation (Line(
                points={{-100,60},{100,60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Sensor.hydraulic_port, A) annotation (Line(
                points={{-60,30},{-80,30},{-80,60},{100,60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_Valve.hyd_a, P) annotation (Line(
                points={{-80,-30},{-80,60},{-100,60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_Valve.hyd_b, T) annotation (Line(
                points={{-80,-50},{-80,-80},{0,-80},{0,-99}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Sensor.y, add.u1) annotation (Line(
                points={{-39,30},{-30.5,30},{-30.5,-4},{-22,-4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.u2, const1.y) annotation (Line(
                points={{-22,-16},{-30,-16},{-30,-10},{-39,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, gain.u) annotation (Line(
                points={{1,-10},{8,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(gain.y, max_Against_Parameter.u) annotation (Line(
                points={{31,-10},{38,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(max_Against_Parameter.y, hydraulic_Valve.u) annotation (Line(
                points={{61,-10},{78,-10},{78,-40},{-70,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Line(
                    points={{0,60},{0,42}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{-20,22},{0,42},{20,22}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Ellipse(extent={{-16,26},{14,-4}}, lineColor={0,0,0}),
                  Line(
                    points={{0,-4},{0,-8},{-20,-18},{20,-28},{-20,-38},{20,-48},{0,-54},{
                        0,-68}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-90,60},{90,60}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-68},{0,-88}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Text(
                    extent={{-160,-40},{140,-80}},
                    lineColor={0,0,0},
                    textString="p_max=%p_max"),
                  Text(
                    extent={{-118,156},{104,100}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end Pressure_Relief_Valve;
        end Valves;

        package Volumes
          extends Modelica.Icons.Package;
          model Hydraulic_Reservoir

          parameter SI.Volume total_volume = 10 "total volume of the reservoir";

          parameter SI.Pressure atmospheric_pressure = 1.0e5
              "constant pressure of the air acting on the fluid";

          SI.Volume hydraulic_fluid_accumulated(start = 0);

            Interfaces.Hydraulic_Port hydraulic_Port
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                  iconTransformation(extent={{-10,-112},{10,-92}})));
          equation

          der(hydraulic_fluid_accumulated) = hydraulic_Port.V;

          hydraulic_Port.P = atmospheric_pressure;

          assert(hydraulic_fluid_accumulated > 0, "Hydraulic_Reservoir: hydraulic fluid accumulated should always be greater than zero");
          assert(hydraulic_fluid_accumulated < total_volume, "Hydraulic_Reservoir: hydraulic fluid accumulated should always be lesser than total volume");

            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{
                      -100,-100},{100,100}}),
                                graphics), Icon(graphics={
                  Rectangle(
                    extent={{-100,-20},{100,-60}},
                    lineColor={0,0,0},
                    fillColor={255,0,128},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,20},{-100,-60},{100,-60},{100,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-60},{0,-98}},
                    color={255,0,128},
                    smooth=Smooth.None),
                  Text(
                    extent={{-100,80},{100,50}},
                    lineColor={128,128,128},
                    textString="P_atm=%atmospheric_pressure"),
                  Line(
                    points={{-60,0},{-60,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-66,-10},{-60,-20},{-54,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-20,0},{-20,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-26,-10},{-20,-20},{-14,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{20,0},{20,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{14,-10},{20,-20},{26,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{60,0},{60,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{54,-10},{60,-20},{66,-10}},
                    color={95,95,95},
                    smooth=Smooth.None)}));
          end Hydraulic_Reservoir;

          model Hydraulic_Accumulator "Models Hydraulic Accumulator"

          parameter SI.Volume total_volume = 10
              "total volume of the accumulator";

          parameter SI.Pressure empty_pressure = 20e5
              " pressure of the air in the accumulator when no fluid is trapped ";
          parameter SI.Volume hydraulic_fluid_accumulated_start = total_volume / 2
              "Initial of hydraulic fluid in accumulator";
          SI.Pressure fluid_pressure "pressure of the fluid in the accumulator";

          SI.Volume hydraulic_fluid_accumulated(start = hydraulic_fluid_accumulated_start, fixed=true);

            Interfaces.Hydraulic_Port hydraulic_Port
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                  iconTransformation(extent={{-10,-110},{10,-90}})));
          protected
          parameter Real gas_mass = empty_pressure * total_volume;

          equation
          if noEvent(hydraulic_fluid_accumulated >= total_volume * 0.01) then
            der(hydraulic_fluid_accumulated) = hydraulic_Port.V;
            fluid_pressure = hydraulic_Port.P;
          else
            der(hydraulic_fluid_accumulated) = max(0.0, hydraulic_Port.V);
            hydraulic_Port.P = empty_pressure;
          end if;
          gas_mass  = fluid_pressure * max(1e-10, (total_volume - max(0.0, hydraulic_fluid_accumulated)));

          // assert(hydraulic_fluid_accumulated >= 0, "hydraulic fluid accumulated should always be greater than zero");
          // assert(hydraulic_fluid_accumulated < total_volume*1.01, "hydraulic fluid accumulated should always be less than total volume");

            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-60,40},{60,-80}},
                    lineColor={0,0,0},
                    radius=20,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-60,-20},{60,-80}},
                    fillColor={255,0,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    radius=20),
                  Rectangle(
                    extent={{-60,-20},{60,-60}},
                    fillColor={255,0,128},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    radius=0),
                  Line(
                    points={{0,-100},{0,-70}},
                    smooth=Smooth.None,
                    color={255,0,128}),
                  Rectangle(
                    extent={{-60,40},{60,-80}},
                    lineColor={0,0,0},
                    radius=20),
                  Text(
                    extent={{-142,-120},{140,-160}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="%name"),
                  Text(
                    extent={{-100,100},{100,80}},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="Vol=%total_volume"),
                  Text(
                    extent={{-100,70},{100,50}},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="P_init=%empty_pressure"),
                  Line(
                    points={{40,0},{40,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{34,-10},{40,-20},{46,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-40,0},{-40,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-46,-10},{-40,-20},{-34,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,0},{0,-20}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-6,-10},{0,-20},{6,-10}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{-60,-20},{60,-20}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    thickness=0.5)}), Diagram(graphics));
          end Hydraulic_Accumulator;
        end Volumes;

        package Control_Elements "Valves etc. used to control hydraulic flow"
          extends Modelica.Icons.Package;

          model Crossover_Continuous_Pass_Through
            "Fluid from inlet P (pressure) can be sent to A and returned via B to T (tank) or vice versa.  Also has a closed position with an optional bypass."

            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         straight_P_A(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={-62,20})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         cross_T_A(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={40,-30})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         straight_T_B(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={62,20})));
            Interfaces.Hydraulic_Port P
              annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                  iconTransformation(extent={{-70,-110},{-50,-90}})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         cross_P_B(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-40,-30})));
            Interfaces.Hydraulic_Port T
              annotation (Placement(transformation(extent={{50,-109},{70,-89}}),
                  iconTransformation(extent={{50,-109},{70,-89}})));
            Interfaces.Hydraulic_Port A
              annotation (Placement(transformation(extent={{-70,90},{-50,110}}),
                  iconTransformation(extent={{-70,90},{-50,110}})));
            Interfaces.Hydraulic_Port B
              annotation (Placement(transformation(extent={{50,89},{70,109}}),
                  iconTransformation(extent={{50,91},{70,111}})));
            Modelica.Blocks.Interfaces.RealInput    u annotation (Placement(
                  transformation(
                  extent={{-12,-12},{12,12}},
                  rotation=180,
                  origin={112,0}), iconTransformation(
                  extent={{-12,-12},{12,12}},
                  rotation=180,
                  origin={112,0})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Positive_Negative_Split positive_Negative_Split(flip_neg=true)
              annotation (Placement(transformation(
                  extent={{-5,-5},{5,5}},
                  rotation=0,
                  origin={75,-23})));
            Modelica.Blocks.Nonlinear.Limiter limiter(uMax=1)
              annotation (Placement(transformation(extent={{90,-4},{80,6}})));
            Modelica.Blocks.Continuous.CriticalDamping         filter(
              final n=1,
              f=f_crit,
              normalized=false,
              initType=Modelica.Blocks.Types.Init.SteadyState)
              annotation (Placement(transformation(extent={{76,-4},{66,6}})));
            parameter Boolean exact=false
              "true/false exact treatment/filtering the input signal";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal";
            parameter Real k_on=0.0001 "loss factor (>0) when on";
            parameter Real k_off=k_on/10000 "loss factor (>0) when off";
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         bypass_P_P1(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={0,-80})));
            C2M2L_OM.MSL_Extend.Blocks.Math.One_Minus_U bypass_command(use_abs_u=true)
              "closes the bypass when the directional valves are opened"
              annotation (Placement(transformation(extent={{44,-86},{34,-76}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Squash squash_straight
              annotation (Placement(transformation(extent={{90,60},{80,70}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Squash squash_bypass(u_low=bypass_open, u_high=
                  bypass_closed)
              annotation (Placement(transformation(extent={{26,-86},{16,-76}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Squash squash_cross(u_low=open_AB, u_high=close_AB)
              annotation (Placement(transformation(
                  extent={{-5,5},{5,-5}},
                  rotation=180,
                  origin={85,-65})));
            parameter Real bypass_open=0
              "|u| value that gives fully open bypass";
            parameter Real bypass_closed=1
              "|u| value that gives fully closed bypass";
            parameter Real open_AB=0 "|u| value that gives A or B zero opening";
            parameter Real close_AB=1
              "|u| value that gives A or B full opening";
            Interfaces.Hydraulic_Port P1
              annotation (Placement(transformation(extent={{-10,89},{10,109}})));
          equation
            connect(P, straight_P_A.hyd_a)
                                  annotation (Line(
                points={{-60,-100},{-63,-100},{-63,10},{-62,10}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(straight_P_A.hyd_b, A)
                                  annotation (Line(
                points={{-62,30},{-62,100},{-60,100}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(T, straight_T_B.hyd_a)
                                  annotation (Line(
                points={{60,-99},{60,10},{62,10}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(straight_T_B.hyd_b, B)
                                  annotation (Line(
                points={{62,30},{62,98},{60,98},{60,99}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(P, cross_P_B.hyd_a)
                                  annotation (Line(
                points={{-60,-100},{-60,-60},{-40,-60},{-40,-40},{-40,-40}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(cross_P_B.hyd_b, B)
                                  annotation (Line(
                points={{-40,-20},{-40,38},{60,38},{60,99}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(T, cross_T_A.hyd_a)
                                  annotation (Line(
                points={{60,-99},{60,-60},{40,-60},{40,-40}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(cross_T_A.hyd_b, A)
                                  annotation (Line(
                points={{40,-20},{40,-20},{40,48},{-60,48},{-60,100}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));

            connect(limiter.u, u) annotation (Line(
                points={{91,1},{94,1},{94,0},{112,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(positive_Negative_Split.y_pos, squash_straight.u) annotation (Line(
                points={{80.5,-20},{98,-20},{98,65},{91,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(straight_T_B.u, squash_straight.y) annotation (Line(
                points={{72,20},{78,20},{78,65},{79.5,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(straight_P_A.u, squash_straight.y) annotation (Line(
                points={{-52,20},{-42,20},{-42,65},{79.5,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.u, positive_Negative_Split.y_neg) annotation (Line(
                points={{91,-65},{98,-65},{98,-26},{80.5,-26}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.y, cross_P_B.u) annotation (Line(
                points={{79.5,-65},{-86,-65},{-86,-30},{-50,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(limiter.y, filter.u) annotation (Line(
                points={{79.5,1},{77,1}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(filter.y, positive_Negative_Split.u) annotation (Line(
                points={{65.5,1},{63.25,1},{63.25,-23},{69,-23}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_bypass.y, bypass_P_P1.u)
                                                   annotation (Line(
                points={{15.5,-81},{10,-81},{10,-80}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(bypass_command.u, filter.y) annotation (Line(
                points={{45,-81},{64,-81},{64,1},{65.5,1}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.y, cross_T_A.u) annotation (Line(
                points={{79.5,-65},{16,-65},{16,-30},{30,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(P, bypass_P_P1.hyd_b) annotation (Line(
                points={{-60,-100},{-1.83697e-015,-100},{-1.83697e-015,-90}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(bypass_command.y, squash_bypass.u) annotation (Line(
                points={{33.5,-81},{30.75,-81},{30.75,-81},{27,-81}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(bypass_P_P1.hyd_a, P1) annotation (Line(
                points={{1.83697e-015,-70},{0,-70},{0,99}},
                color={255,0,128},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Text(
                    extent={{-110,-80},{-70,-120}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="P"),
                  Text(
                    extent={{-110,120},{-70,80}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="A"),
                  Text(
                    extent={{70,-80},{110,-120}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="T"),
                  Text(
                    extent={{70,120},{110,80}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="B"),
                  Rectangle(
                    extent={{-88,30},{92,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-28,30},{32,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-44,-20},{-44,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-74,-20},{-74,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-84,10},{-74,20},{-64,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-30},{-12,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,-26},{86,24}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,24},{86,-26}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-10,-1.66874e-015},{0,10},{10,1.66874e-015}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={-44,-10},
                    rotation=180),
                  Line(
                    points={{72,-26},{86,-26},{86,-12}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Text(
                    extent={{-172,74},{178,24}},
                    lineColor={128,128,128},
                    textString="1   0  -1"),
                  Line(
                    points={{60,72},{60,80},{-60,80},{-60,70}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{-12,10},{-12,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,10},{18,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,-30},{18,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-22,10},{-2,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{8,10},{28,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-7,-7},{7,-7},{7,7}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={79,17},
                    rotation=90),
                  Line(
                    points={{18,-10},{-12,-10}},
                    color={0,0,0},
                    smooth=Smooth.None)}));
          end Crossover_Continuous_Pass_Through;

          model Crossover_Continuous_No_Bypass
            "Fluid from inlet P (pressure) can be sent to A and returned via B to T (tank) or vice versa.  Also has a closed position with an optional bypass."

            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         straight_P_A(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={-62,20})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         cross_T_A(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={40,-30})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         straight_T_B(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={62,20})));
            Interfaces.Hydraulic_Port P
              annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                  iconTransformation(extent={{-70,-110},{-50,-90}})));
            C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch_Continuous
                                                                                                         cross_P_B(
              exact=true,
              k_on=k_on,
              k_off=k_off)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-40,-30})));
            Interfaces.Hydraulic_Port T
              annotation (Placement(transformation(extent={{50,-109},{70,-89}}),
                  iconTransformation(extent={{50,-109},{70,-89}})));
            Interfaces.Hydraulic_Port A
              annotation (Placement(transformation(extent={{-70,90},{-50,110}}),
                  iconTransformation(extent={{-70,90},{-50,110}})));
            Interfaces.Hydraulic_Port B
              annotation (Placement(transformation(extent={{50,89},{70,109}}),
                  iconTransformation(extent={{50,91},{70,111}})));
            Modelica.Blocks.Interfaces.RealInput    u annotation (Placement(
                  transformation(
                  extent={{-12,-12},{12,12}},
                  rotation=180,
                  origin={112,0}), iconTransformation(
                  extent={{-12,-12},{12,12}},
                  rotation=180,
                  origin={112,0})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Positive_Negative_Split positive_Negative_Split(flip_neg=true)
              annotation (Placement(transformation(
                  extent={{-5,-5},{5,5}},
                  rotation=0,
                  origin={75,-23})));
            Modelica.Blocks.Nonlinear.Limiter limiter(uMax=1)
              annotation (Placement(transformation(extent={{90,-4},{80,6}})));
            Modelica.Blocks.Continuous.CriticalDamping         filter(
              final n=1,
              f=f_crit,
              normalized=false,
              initType=Modelica.Blocks.Types.Init.SteadyState)
              annotation (Placement(transformation(extent={{76,-4},{66,6}})));
            parameter Boolean exact=false
              "true/false exact treatment/filtering the input signal";
            parameter SI.Frequency f_crit=50
              "if exact=false, critical frequency of filter to filter input signal";
            parameter Real k_on=0.0001 "loss factor (>0) when on";
            parameter Real k_off=k_on/10000 "loss factor (>0) when off";
            C2M2L_OM.MSL_Extend.Blocks.Math.Squash squash_straight
              annotation (Placement(transformation(extent={{90,60},{80,70}})));
            C2M2L_OM.MSL_Extend.Blocks.Math.Squash squash_cross(u_low=open_AB, u_high=close_AB)
              annotation (Placement(transformation(
                  extent={{-5,5},{5,-5}},
                  rotation=180,
                  origin={85,-65})));
            parameter Real bypass_open=0
              "|u| value that gives fully open bypass";
            parameter Real bypass_closed=1
              "|u| value that gives fully closed bypass";
            parameter Real open_AB=0 "|u| value that gives A or B zero opening";
            parameter Real close_AB=1
              "|u| value that gives A or B full opening";
          equation
            connect(P, straight_P_A.hyd_a)
                                  annotation (Line(
                points={{-60,-100},{-63,-100},{-63,10},{-62,10}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(straight_P_A.hyd_b, A)
                                  annotation (Line(
                points={{-62,30},{-62,100},{-60,100}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(T, straight_T_B.hyd_a)
                                  annotation (Line(
                points={{60,-99},{60,10},{62,10}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(straight_T_B.hyd_b, B)
                                  annotation (Line(
                points={{62,30},{62,98},{60,98},{60,99}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(P, cross_P_B.hyd_a)
                                  annotation (Line(
                points={{-60,-100},{-60,-60},{-40,-60},{-40,-40},{-40,-40}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(cross_P_B.hyd_b, B)
                                  annotation (Line(
                points={{-40,-20},{-40,38},{60,38},{60,99}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(T, cross_T_A.hyd_a)
                                  annotation (Line(
                points={{60,-99},{60,-60},{40,-60},{40,-40}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));
            connect(cross_T_A.hyd_b, A)
                                  annotation (Line(
                points={{40,-20},{40,-20},{40,48},{-60,48},{-60,100}},
                color={255,0,128},
                smooth=Smooth.None,
                pattern=LinePattern.Dash,
                thickness=0.5));

            connect(limiter.u, u) annotation (Line(
                points={{91,1},{94,1},{94,0},{112,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(positive_Negative_Split.y_pos, squash_straight.u) annotation (Line(
                points={{80.5,-20},{98,-20},{98,65},{91,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(straight_T_B.u, squash_straight.y) annotation (Line(
                points={{72,20},{78,20},{78,65},{79.5,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(straight_P_A.u, squash_straight.y) annotation (Line(
                points={{-52,20},{-42,20},{-42,65},{79.5,65}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.u, positive_Negative_Split.y_neg) annotation (Line(
                points={{91,-65},{98,-65},{98,-26},{80.5,-26}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.y, cross_P_B.u) annotation (Line(
                points={{79.5,-65},{-86,-65},{-86,-30},{-50,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(limiter.y, filter.u) annotation (Line(
                points={{79.5,1},{77,1}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(filter.y, positive_Negative_Split.u) annotation (Line(
                points={{65.5,1},{63.25,1},{63.25,-23},{69,-23}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(squash_cross.y, cross_T_A.u) annotation (Line(
                points={{79.5,-65},{16,-65},{16,-30},{30,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Text(
                    extent={{-110,-80},{-70,-120}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="P"),
                  Text(
                    extent={{-110,120},{-70,80}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="A"),
                  Text(
                    extent={{70,-80},{110,-120}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="T"),
                  Text(
                    extent={{70,120},{110,80}},
                    lineColor={255,0,0},
                    pattern=LinePattern.Dash,
                    lineThickness=0.5,
                    textString="B"),
                  Rectangle(
                    extent={{-88,30},{92,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-28,30},{32,-30}},
                    lineColor={0,0,0},
                    fillColor={255,240,250},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-44,-20},{-44,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-74,-20},{-74,20}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-84,10},{-74,20},{-64,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-12,-30},{-12,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,-26},{86,24}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{36,24},{86,-26}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-10,-1.66874e-015},{0,10},{10,1.66874e-015}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={-44,-10},
                    rotation=180),
                  Line(
                    points={{72,-26},{86,-26},{86,-12}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Text(
                    extent={{-172,74},{178,24}},
                    lineColor={128,128,128},
                    textString="1   0  -1"),
                  Line(
                    points={{60,72},{60,80},{-60,80},{-60,70}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{-12,10},{-12,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,10},{18,30}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{18,-30},{18,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-22,10},{-2,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{8,10},{28,10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{-7,-7},{7,-7},{7,7}},
                    color={0,0,0},
                    smooth=Smooth.None,
                    origin={79,17},
                    rotation=90),
                  Line(
                    points={{-22,-10},{-2,-10}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{8,-10},{28,-10}},
                    color={0,0,0},
                    smooth=Smooth.None)}));
          end Crossover_Continuous_No_Bypass;
        end Control_Elements;
      end Components;

      package Sensors "Sensors for simple hydraulic components"
      extends Modelica.Icons.SensorsPackage;
        model Pressure_Sensor
          "Outputs as a signal the pressure at a hydraulic port"
          extends Modelica.Icons.RotationalSensor;
          Interfaces.Hydraulic_Port hydraulic_port
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          Modelica.Blocks.Interfaces.RealOutput y annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,110}),              iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,110})));
        equation
          y = hydraulic_port.P;
          hydraulic_port.V = 0;
          annotation (Icon(graphics={
                Line(
                  points={{0,-96},{0,-70}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{0,72},{0,100}},
                  color={95,95,95},
                  smooth=Smooth.None),
                Text(
                  extent={{-26,-14},{36,-70}},
                  lineColor={95,95,95},
                  textString="P")}), Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                             graphics));
        end Pressure_Sensor;
      end Sensors;

      package Interfaces
      extends Modelica.Icons.InterfacesPackage;

        connector Hydraulic_Port
          flow SI.VolumeFlowRate V;
          SI.AbsolutePressure P;
          annotation (Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid)}), Diagram(graphics={
                                     Rectangle(
                  extent={{-40,40},{40,-40}},
                  lineColor={255,0,128},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-140,100},{140,60}},
                  lineColor={0,0,0},
                  textString="%name")}));
        end Hydraulic_Port;

        partial model Partial_Hydraulic_Mechanical_Conversion_Rotary
          "Base class for converting  between rotary shaft and hydraulic flow"
          extends Components.Templates.Partial_Two_Port_Transport;
          extends
            C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport_Top;
          parameter SI.Volume vol_per_radian = 1
            "Nominal volume of hydraulic fluid moved for 1 radian of shaft rotation";
          parameter SI.Volume Nm_per_pascal = vol_per_radian
            "Nominal pressure rise for 1 Nm of torque input";

          annotation (Diagram(graphics));
        end Partial_Hydraulic_Mechanical_Conversion_Rotary;

        partial model Partial_Two_Port
          "Base class with two hydraulic connectors"

          Hydraulic_Port hyd_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Hydraulic_Port hyd_b annotation (Placement(transformation(extent={{90,-10},{110,
                    10}}),iconTransformation(extent={{90,-10},{110,10}})));

          annotation (Icon(graphics), Diagram(graphics));
        end Partial_Two_Port;
      end Interfaces;

      package Sources "Simple hydraulic sources"
      extends Modelica.Icons.SourcesPackage;

        model Pressure_Source
          "Provides a constant pressure.  ALWAYS need one of these in every circuit."
          parameter SI.AbsolutePressure P_constant=1;
          Interfaces.Hydraulic_Port hydraulic_port
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        equation
          hydraulic_port.P = P_constant;
          //hydraulic_port.V = 0.0;
          annotation (Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                                     Text(
                  extent={{-100,118},{100,-82}},
                  lineColor={255,0,128},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="P"), Text(
                  extent={{-100,-60},{100,-100}},
                  lineColor={128,128,128},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid,
                  textString="P=%P_constant")}));
        end Pressure_Source;

        model Pressure_Source_Actuated "Provides a signal controlled pressure"
         parameter SI.AbsolutePressure P_constant=1;
          parameter Boolean use_p_in = false
            "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

          Interfaces.Hydraulic_Port hydraulic_port
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput p_in if              use_p_in
            "Prescribed boundary pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                  rotation=0)));

        protected
          Modelica.Blocks.Interfaces.RealInput p_in_internal
            "Needed to connect to conditional connector";

        equation
          connect(p_in, p_in_internal);
          hydraulic_port.P = p_in_internal;
          if not use_p_in then
            p_in_internal = P_constant;
          end if;
          //hydraulic_port.V = 0.0;
          annotation (Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                                     Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="P")}),             Diagram(graphics));
        end Pressure_Source_Actuated;

        model Flow_Source "Provides a volume flow source"
          parameter SI.VolumeFlowRate V_constant=1;
          Interfaces.Hydraulic_Port hydraulic_port
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        equation
          hydraulic_port.V = V_constant;
          annotation (Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                                     Text(
                  extent={{-100,120},{100,-80}},
                  lineColor={255,0,128},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="V"), Text(
                  extent={{-100,-60},{100,-100}},
                  lineColor={128,128,128},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid,
                  textString="V=%V_constant")}));
        end Flow_Source;

        model Flow_Source_Actuated "Provides a volume flow source"

          Interfaces.Hydraulic_Port hydraulic_port
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput V_in
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        equation
          hydraulic_port.V = V_in;
          annotation (Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                                     Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,0,128},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="V")}),             Diagram(graphics));
        end Flow_Source_Actuated;
      end Sources;

      package Icons "Icons specific to hydraulic components"
      extends Modelica.Icons.Package;

        model Hydraulic_Mechanical_Device "Icon for a hydraulic pump or motor"

          annotation (Icon(graphics={
                Rectangle(
                  extent={{-10,100},{10,44}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.VerticalCylinder),
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-66,20},{-66,-20},{-26,0},{-66,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,20},{-20,-20},{20,0},{-20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={46,0},
                  rotation=180),
                Line(
                  points={{-100,0},{-66,0}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{66,0},{100,0}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{0,-60},{0,-100}},
                  color={95,95,95},
                  smooth=Smooth.None)}));
        end Hydraulic_Mechanical_Device;

        model Hydraulic_Mechanical_Device_Translational
          "Icon for a hydraulic cylinder"

          annotation (Icon(graphics={
                Rectangle(
                  extent={{-40,44},{40,-60}},
                  lineColor={0,0,0},
                  fillColor={255,0,128},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-10,100},{10,10}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.VerticalCylinder),
                Line(
                  points={{-100,0},{-70,0},{-70,-30},{-40,-30}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{40,30},{70,30},{70,0},{100,0}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{0,-60},{0,-100}},
                  color={95,95,95},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,10},{40,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={95,95,95})}));
        end Hydraulic_Mechanical_Device_Translational;
      end Icons;
      annotation ();
    end Hydraulics_Simple;

    package Icons "Provide extensions to the MSL package of the same name"
        extends Modelica.Icons.Package;

      partial model Test_Bench "Icon for a test bench"

        annotation (Icon(graphics={            Rectangle(
                extent={{-32,94},{28,34}},
                lineColor={0,0,0},
                fillColor={215,230,240},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,20},{80,20},{80,0},{60,0},{60,-80},{40,-80},{40,0},{-40,
                    0},{-40,-80},{-60,-80},{-60,0},{-80,0},{-80,20}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillPattern=FillPattern.Backward),
                                                Rectangle(
                extent={{-40,86},{20,26}},
                lineColor={0,0,0},
                fillColor={240,240,240},
                fillPattern=FillPattern.Solid)}));
      end Test_Bench;

      partial record Record_Template "Base icon for all C2M2L records"
      parameter String part_name="Name here" "Name of component";

        annotation (Icon(graphics={
              Text(
                extent={{-128,-54},{130,-92}},
                lineColor={255,0,0},
                textString="%part_name%",
                lineThickness=0.5),
              Line(
                points={{32,80},{90,80}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{32,60},{90,60}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{32,40},{90,40}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{30,20},{90,20}},
                color={255,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{20,0},{20,100},{88,100},{100,88},{100,0},{20,0}},
                lineColor={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{88,100},{88,88},{100,88}},
                color={255,0,0},
                smooth=Smooth.None)}));
      end Record_Template;

      model Simple_Test_Case
        "Icon for a simple test case (not a full Test_Bench)"

        annotation (Icon(graphics={Bitmap(extent={{-100,100},{100,-100}}, fileName=
                    "modelica://C2M2L_OM/Resources/Interfaces/tick.png")}));
      end Simple_Test_Case;

      partial class Broken_Model
        "A broken model that should not be used.  Kept around until it's organs can be harvested."
        String error_message = "Trying to use a model that is marked as a Broken_Model";
      equation
        assert(false, error_message);
        annotation (Icon(graphics={Rectangle(
                extent={{-102,98},{16,4}},
                lineColor={255,255,255},
                lineThickness=0.5,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                                   Text(
                extent={{-86,76},{86,-76}},
                lineColor={255,0,0},
                lineThickness=0.5,
                fillPattern=FillPattern.Solid,
                origin={-44,52},
                rotation=180,
                textStyle={TextStyle.Bold},
                fontName="Times New Roman",
                textString="!!!")}), Documentation(info="<html>
<p>Use this icon to make sure a particular model is not used.  E.g. when in the middle of extensive refactoring it might be necessary to keep an old model around to use parts of it&apos;s code or for reference.</p>
<p>The included assert will stop anything from running by accident using any model that extends from this icon.</p>
<p>No parts should be officially released if they are broken or contain or reference anything that is broken.</p>
</html>"));
      end Broken_Model;

      package Signal_Sub_Buses_Colored
        "Different colored sub bus icons to make identification a little easier"
      extends Modelica.Icons.Package;

        connector Red "Icon for signal sub-bus with red background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name"),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Red;

        connector Blue "Icon for signal sub-bus with blue background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Blue;

        connector Green "Icon for signal sub-bus with green background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={85,255,85},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={85,255,85},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Green;

        connector Light_Gray
          "Icon for signal sub-bus with light gray background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Light_Gray;

        connector Dark_Gray "Icon for signal sub-bus with dark gray background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={95,95,95},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={95,95,95},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={50,50,50},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Dark_Gray;

        connector Magenta "Icon for signal sub-bus with magenta background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={255,0,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={255,0,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Magenta;

        connector Light_Blue
          "Icon for signal sub-bus with light blue background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name"),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Light_Blue;

        connector Dark_Blue "Icon for signal sub-bus with dark blue background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={64,64,160},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={64,64,160},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name"),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Dark_Blue;

        connector Dark_Green
          "Icon for signal sub-bus with dark green background"

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Line(
                  points={{-16,2},{16,2}},
                  color={255,204,51},
                  thickness=0.5),
                Rectangle(
                  extent={{-10,8},{8,0}},
                  lineColor={255,204,51},
                  lineThickness=0.5),
                Polygon(
                  points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                      -40},{-100,30},{-80,50}},
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2},
                initialScale=0.1), graphics={
                Polygon(
                  points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                      -20},{-50,15},{-40,25}},
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-22.5,7.5},{-17.5,12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{17.5,12.5},{22.5,7.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2.5,-7.5},{2.5,-12.5}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,70},{150,40}},
                  lineColor={0,0,0},
                  textString=
                       "%name")}),
            Documentation(info="<html>
<p>
This icon is designed for a <b>sub-bus</b> in a signal connector.
</p>
</html>"));

        end Dark_Green;
      end Signal_Sub_Buses_Colored;

      partial package Package_For_Simple_Test_Cases
        "Stores Simple_Test_Case models"

        annotation (Icon(graphics={            Rectangle(
                extent={{-80,100},{100,-80}},
                lineColor={0,0,0},
                fillColor={215,230,240},
                fillPattern=FillPattern.Solid), Rectangle(
                extent={{-100,80},{80,-100}},
                lineColor={0,0,0},
                fillColor={240,240,240},
                fillPattern=FillPattern.Solid),
                                   Bitmap(extent={{-90,70},{70,-90}}, fileName=
                  "modelica://C2M2L_OM/Resources/Interfaces/tick.png")}));
      end Package_For_Simple_Test_Cases;

      partial package Sandbox_Package
        "Stores sand box models that should not be released"

        annotation (Icon(graphics={            Rectangle(
                extent={{-80,100},{100,-80}},
                lineColor={0,0,0},
                fillColor={215,230,240},
                fillPattern=FillPattern.Solid), Rectangle(
                extent={{-100,80},{80,-100}},
                lineColor={0,0,0},
                fillColor={240,240,240},
                fillPattern=FillPattern.Solid),
            Bitmap(extent={{-100,80},{80,-100}}, fileName=
                  "modelica://C2M2L_OM/Resources/Interfaces/Sandbox.png"),
            Rectangle(extent={{-110,110},{110,-112}}, lineColor={255,0,0})}));
      end Sandbox_Package;

      model Enumeration_Icon "Icon for enumerations"

        annotation (Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={215,230,240},
                fillPattern=FillPattern.Solid), Text(
                extent={{-94,94},{94,-94}},
                lineColor={0,0,0},
                fillColor={181,181,181},
                fillPattern=FillPattern.Solid,
              textString="E")}));
      end Enumeration_Icon;

      model Test_Driver
        "Base icon for a component that feeds test signals into a control bus.  Avoids having floating buses."

        annotation (Icon(graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-94,-80},{90,-80}},
                                            color={192,192,192}),
              Polygon(
                points={{0,8},{-6,-8},{6,-8},{0,8}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                origin={86,-80},
                rotation=270),
              Line(
                points={{-82,-4},{-82,-4},{-70,30},{-66,36},{-42,50},{-32,46},{-16,28},
                    {-10,6},{-2,-2},{8,-18},{18,-26},{30,-40},{46,-38},{52,-38},{70,-44},
                    {82,-6}},
                color={170,85,255},
                smooth=Smooth.None),
              Line(
                points={{-82,-52},{-56,-52},{-56,-2},{-22,-2},{-22,-52},{26,-52},{26,-2},
                    {82,-2}},
                color={255,170,255},
                smooth=Smooth.None),
              Line(
                points={{-84,44},{-64,74},{-44,76},{-10,60},{-8,52},{-4,34},{-2,28},{8,
                    12},{10,10},{14,40},{22,70},{30,74},{36,30},{40,26},{58,12},{72,16},
                    {82,16}},
                color={255,0,255},
                smooth=Smooth.None),
              Rectangle(
                extent={{52,36},{122,-36}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dot),
              Text(
                extent={{42,-46},{82,-86}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="t"),
              Text(
                extent={{-140,140},{140,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="%name"),
              Text(
                extent={{30,74},{110,32}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="bus"),
              Line(points={{-92,0},{92,0}}, color={192,192,192},
                origin={-80,-2},
                rotation=90),
              Polygon(
                points={{0,8},{-6,-8},{6,-8},{0,8}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                origin={-80,82},
                rotation=360)}));
      end Test_Driver;

      model Test_Driver_Multi_Bus
        "Base icon for a component that feeds test signals into multiple buses.  Avoids having floating buses."

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),
                         graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-184,-160},{138,-160}},
                                            color={192,192,192}),
              Polygon(
                points={{0,8},{-6,-8},{6,-8},{0,8}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                origin={132,-160},
                rotation=270),
              Line(
                points={{-170,-60},{-162,-28},{-70,30},{-66,36},{-42,50},{-32,46},{
                    -16,28},{-10,6},{-2,-2},{8,-18},{18,-26},{30,-40},{46,-38},{52,
                    -38},{70,-44},{148,24}},
                color={170,85,255},
                smooth=Smooth.None),
              Line(
                points={{-172,-118},{-146,-118},{-146,-60},{-58,-60},{-58,-118},{60,
                    -118},{60,-30},{152,-30}},
                color={255,170,255},
                smooth=Smooth.None),
              Line(
                points={{-172,0},{-150,50},{-124,108},{-68,126},{-36,104},{-12,66},{
                    -2,28},{8,12},{10,10},{14,40},{22,70},{30,74},{36,30},{40,26},{58,
                    12},{72,16},{142,-2}},
                color={255,0,255},
                smooth=Smooth.None),
              Rectangle(
                extent={{154,180},{220,-180}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dot),
              Text(
                extent={{102,-160},{142,-200}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="t"),
              Text(
                extent={{-232,250},{282,204}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="%name"),
              Line(points={{-92,0},{246,2.83858e-014}},
                                            color={192,192,192},
                origin={-170,-80},
                rotation=90),
              Polygon(
                points={{0,8},{-6,-8},{6,-8},{0,8}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                origin={-170,158},
                rotation=360)}), Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-200},{200,200}})));
      end Test_Driver_Multi_Bus;
    end Icons;

    package Types
        extends Modelica.Icons.Package;

      type NormalizedReal = Modelica.Icons.TypeReal (
          final quantity="",
          final unit="1",
          final displayUnit="1",
          final min=0,
          final max=1) "Normalized real number" annotation (Icon(graphics={Text(
              extent={{-102,0},{110,-120}},
              lineColor={0,0,0},
              textString="0    1")}));
      type Direction = enumeration(
          Positive,
          Negative,
          Both) "Enumeration of directions (positive, negative, both)"
        annotation (Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={215,230,240},
                fillPattern=FillPattern.Solid), Text(
                extent={{-94,94},{94,-94}},
                lineColor={0,0,0},
                fillColor={181,181,181},
                fillPattern=FillPattern.Solid,
              textString="E")}));
    end Types;

    package Math "Holds extensions to the MSL package of the same name"
    extends Modelica.Icons.Package;
      package Random "Implementation of Random package from Modelica book"
        extends Modelica.Icons.Package;
        import Modelica.Math;
        constant Real NV_MAGICCONST = 4 * exp(-0.5)/sqrt(2.0);

        type Seed = Real[3];
        function random "generate random numbers"
          input Seed si;
          output Real x;
          output Seed so;
        algorithm
          so[1] := abs(rem((171 * si[1]), 30269));
          so[2] := abs(rem((172 * si[2]), 30307));
          so[3] := abs(rem((170 * si[3]), 30323));
          if so[1] == 0 then
            so[1] := 1;
          end if;
          if so[2] == 0 then
            so[2] := 1;
          end if;
          if so[3] == 0 then
            so[3] := 1;
          end if;
          x := rem((so[1]/30269.0 + so[2]/30307.0 + so[3]/30323.0), 1.0);
        end random;

        function normalvariate "normally distributed random variable"
          input Real mu;
          input Real sigma;
          input Seed si;
          output Real x;
          output Seed so;
        protected
          Seed s1;
          Seed s2;
          Real z;
          Real zz;
          Real u1;
          Real u2;
          Boolean brk=false;
        algorithm
          s1 := si;
          u2 := 1;
          while not brk loop
            (u1, s2) := random(s1);
            (u2, s1) := random(s2);
            z := NV_MAGICCONST*(u1 - 0.5)/u2;
            zz := z*z/4.0;
            brk := zz <= (-Math.log(u2));
          end while;
          x := mu + z * sigma;
          so := s1;
        end normalvariate;
      end Random;

      function Logistic "y = 1 / (1 + e^u)"
        extends Modelica.Icons.Function;
        input Real u;
        output Real y;
      algorithm
        y := 1 / (1 + exp(-u));
      end Logistic;

      function Reg_Double_Step
        "Uses 2 calls to Modelica.Fluid.Utilities.regStep to provide a smooth step up and down between two values based on a third"
        extends Modelica.Icons.Function;
        import Modelica.Fluid.Utilities.regStep;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > x_low && x < x_high";
        input Real y2 "Ordinate value for x < x_low || x > x_high";
        input Real x_low "Defines start of step";
        input Real x_high "Defines end of step";
        input Real x_small_low(min=0) = 1e-5
          "Approximation of step for -x_small <= (x - x_low) <= x_small; x_small >= 0 required";
        input Real x_small_high(min=0) = 1e-5
          "Approximation of step for -x_small <= (x - x_low) <= x_small; x_small >= 0 required";
        output Real y
          "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := regStep(x - x_low, y1, y2, x_small_low);
        y := regStep(x - x_high, y2, y, x_small_high);
        annotation(smoothOrder=1);
      end Reg_Double_Step;
    end Math;
  end MSL_Extend;

  package C2M2L_Component_Building_Blocks
    "Components organized by vehicle sub-system that can be used to build delivered components"
    extends Modelica.Icons.Package;

    package Drive_Line "Building blocks related to the vehicle drive line"
      extends Modelica.Icons.Package;

      package Range_Pack "Gearboxes with a range of selectable gears"
        extends Modelica.Icons.Package;
        package Simplified_Range_Pack
          "Model of a simplified range pack with arbitrarily selectable gear ratios"
          extends Modelica.Icons.Package;

          model Range_Pack_Internals
            "1-D internals of range pack using selectable gears.  Needs to be put in a case."
            extends
              Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;
            extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(                      thermal_To_Environment(
                  area_for_heat_transfer=0.1));
          extends
              C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
            parameter Integer num_gears(min=1)=1
              "The number of gear ratios in this range pack (including reverse if applicable)";
            parameter Integer gear_nums[num_gears] = {1}
              "Identifiers for the gears.  E.g {-1,1,2,3,4} for a pack with 1 reverse and 4 forward gears";
            Modelica.Blocks.Interfaces.IntegerInput gear_selected annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={-6,100})));

            MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.Selectable_Gear
                            selectable_Gear[num_gears](
              each useSupport=useSupport,
              ratio=ratios,
              lossTable=lossTables,
              gear_num=gear_nums,
              each locked_max_torque=locked_max_torque,
              each synchronizer_max_torque=synchronizer_max_torque,
              each useHeatPort=useHeatPort or use_environment_heat_port)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            parameter Real ratios[num_gears] = {1}
              "Transmission ratio (flange_a.phi/flange_b.phi) of gears";
            parameter Real lossTables[num_gears,:,5] = {[0,1,1,0,0]}
              "Array of arrays of mesh efficiencies and bearing friction depending on speed for each gear";
            parameter SI.Torque locked_max_torque
              "Max torque transmitted when gear clutches are locked";
            parameter SI.Torque synchronizer_max_torque
              "Max torque transmitted while synchronizing each gear";

          public
            MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.GearEfficiency
                           gearEfficiency(
              useSupport=useSupport,
              eta=lossTables[1, 1, 2],
              useHeatPort=useHeatPort or use_environment_heat_port)
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation

            if not useHeatPort then
              lossPower = sum(selectable_Gear[i].lossPower for i in 1:num_gears) + gearEfficiency.lossPower;
            end if;
            for i in 1:num_gears loop
            connect(selectable_Gear[i].flange_a, gearEfficiency.flange_b) annotation (
                Line(
                points={{-10,0},{-40,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(flange_b, selectable_Gear[i].flange_b) annotation (Line(
                points={{100,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(gear_selected, selectable_Gear[i].gear_selected) annotation (Line(
                points={{-6,100},{-6,10}},
                color={255,127,0},
                smooth=Smooth.None));
            end for;
            if useHeatPort then
              for i in 1:num_gears loop
            connect(heatPort, selectable_Gear[i].heatPort) annotation (Line(
                points={{-100,-100},{-60,-100},{-60,-22},{-10,-22},{-10,-10}},
                color={191,0,0},
                smooth=Smooth.None));
              end for;
            connect(heatPort, gearEfficiency.heatPort) annotation (Line(
                points={{-100,-100},{-60,-100},{-60,-10}},
                color={191,0,0},
                smooth=Smooth.None));
            end if;
            if use_environment_heat_port then
              for i in 1:num_gears loop
            connect(selectable_Gear[i].heatPort, thermal_To_Environment.solid)
              annotation (Line(
                points={{-10,-10},{-10,-22},{40,-22},{40,-90}},
                color={191,0,0},
                smooth=Smooth.None));
              end for;
            connect(gearEfficiency.heatPort, thermal_To_Environment.solid) annotation (
                Line(
                points={{-60,-10},{-60,-22},{40,-22},{40,-90}},
                color={191,0,0},
                smooth=Smooth.None));
            end if;
            if useSupport then
              for i in 1:num_gears loop
                connect(selectable_Gear[i].support, internalSupport) annotation (Line(
                points={{0,-10},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
              end for;
            connect(gearEfficiency.support, internalSupport) annotation (Line(
                points={{-50,-10},{-50,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            end if
            annotation (Diagram(graphics), Icon(graphics={
                  Rectangle(
                    extent={{-90,8},{-36,-12}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-50,16},{-30,-20}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-50,40},{-30,22}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-50,-26},{-30,-44}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-50,54},{-20,46}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-50,-50},{-20,-58}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-24,54},{-16,-58}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-60,34},{-40,28}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-60,-32},{-40,-38}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-60,-32},{-56,-68}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-60,-64},{-6,-68}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-60,62},{-6,58}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-60,62},{-56,28}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-8,62},{-4,28}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-22,8},{28,-12}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-8,-32},{-4,-68}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{26,32},{-6,28}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{14,54},{44,46}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{14,40},{34,22}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{14,16},{34,-20}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{40,54},{48,-58}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{14,-26},{34,-44}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{14,-50},{44,-58}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{24,-32},{-8,-36}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{40,8},{90,-12}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0})}));

            connect(gearEfficiency.flange_a, flange_a) annotation (Line(
                points={{-60,0},{-100,0}},
                color={0,0,0},
                smooth=Smooth.None));

            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics));
          end Range_Pack_Internals;

        end Simplified_Range_Pack;
      end Range_Pack;

      package Drive_Shafts "Reusable drive shaft physics models"
          extends Modelica.Icons.Package;

        package Components "Drive shaft physics models"
            extends Modelica.Icons.Package;

          package Base_Models
            "Contains partial models used to implement drive shafts"
              extends Modelica.Icons.BasesPackage;

            partial model Partial_Mechanical
              "Base class for all mechanical implementations of drive shafts"

              parameter SI.Length length(final min=0) = 1
                "Length of shaft, slip joint collapsed";
              parameter SI.Length length_flange_to_joint_center(final min=0) = 0.1
                "Length of from connection flanges to the center of the articulating joints";
              parameter SI.Length max_slip(final min=0) = 0.1
                "Maximum length slip joint can extend";
              parameter SI.Diameter outer_dia(final min=0) = 0.05
                "Outer diameter of shaft";
              parameter SI.Diameter wall_thick(final min=0) = 0.005
                "Wall thickness of shaft";
              parameter SI.Density rho(final min=0) = 8000
                "Material density of shaft";
              parameter SI.ShearModulus G(final min=0) = 79.3e9
                "Shear modulus of shaft material";
              Modelica.Mechanics.Rotational.Interfaces.Flange_a
                                                              frame_a
                annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
              Modelica.Mechanics.Rotational.Interfaces.Flange_b
                                                              frame_b
                annotation (Placement(transformation(extent={{84,-16},{116,16}})));
            equation

              annotation (Icon(graphics={
                    Rectangle(
                      extent={{-82,78},{-60,50}},
                      lineColor={0,0,0},
                      fillColor={175,175,175},
                      fillPattern=FillPattern.HorizontalCylinder),
                    Rectangle(
                      extent={{62,24},{84,-4}},
                      lineColor={0,0,0},
                      fillColor={175,175,175},
                      fillPattern=FillPattern.HorizontalCylinder),
                    Polygon(
                      points={{-46,74},{58,24},{48,2},{-56,54},{-46,74}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.HorizontalCylinder,
                      smooth=Smooth.None,
                      fillColor={175,175,175}),
                    Line(
                      points={{-98,2},{-88,2},{-88,66},{-54,66},{58,8},{100,8}},
                      color={0,0,0},
                      smooth=Smooth.None,
                      pattern=LinePattern.DashDot)}), Documentation(info="<html>
<p>Partial model that specifies the connection ports that a drive shaft mechanical model implements.</p>
<p>Specifies an <b>outer</b> record that will obtain the drive shaft data from a containing drive shaft component. All the data required from the record is copied into local parameters so extending models can use them directly.</p>
</html>"),      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                        {100,100}}),
                        graphics));
            end Partial_Mechanical;
          end Base_Models;

          package Mechanical_Models "Implementation of Mechanical models"
            extends Modelica.Icons.Package;

            model Mechanical_Simple_1D_Bevel "Bevels 1D"
              import C2M2L_OM;
              extends
                C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Drive_Shafts.Components.Base_Models.Partial_Mechanical;

              parameter Real k=10
                "Torque (Nm) lost in each joint per radian of deflection";

            equation
              connect(frame_b, frame_a) annotation (Line(
                  points={{100,0},{-100,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}),
                                  graphics), Documentation(info="<html>
<p>Mechanical model that includes:</p>
<p><ul>
<li>The mass and inertia effects of the main shaft</li>
<li>Losses in the universal joints at both ends of the shaft</li>
</ul></p>
<p>Note that the UJs are rotated 90degrees apart so that the axis of their revolute joints match across the main shaft. This is essential to reduce speed and torque fluctuations observed caused by the joints, only when they are 90deg apart will they not cause a speed variation. Regardless of their orientation the center shaft will always experience speed fluctuations.</p>
</html>"));
            end Mechanical_Simple_1D_Bevel;
          end Mechanical_Models;
        end Components;
      end Drive_Shafts;

      package Torque_Converters
        "Basic component descriptions of torque converters"
        extends Modelica.Icons.Package;

        model Torque_Converter_Lockup_with_2PTO
          "Wraps Torque_Converter_Simple with a lockup clutch and front/rear PTO"
          extends
            Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;
          extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(
              thermal_To_Environment(area_for_heat_transfer=0.1));
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

        //inertia
          parameter SI.Inertia moi_rotational=0.2
            "rotational moment of inertia";

        //Torque Converter Inputs
            parameter Real powerCoeffTable_TC[:, 2]=
            [-10, 0.2; 0, 0.2; 0.00001, 0.2; 0.1, 0.2488; 0.2, 0.2712; 0.3, 0.2872; 0.4, 0.2968; 0.5, 0.3; 0.6, 0.2968; 0.7, 0.2872; 0.8, 0.2712; 0.9, 0.2488; 1, 0.2]
            "Table for power coefficientas a function of speed ratio"                                                                                                     annotation (Dialog(group="Torque Converter"));
            parameter Real torqueConverTable_TC[:, 2]=
            [-10, 2;  0, 2; 0.00001, 2; 0.1, 1.9; 0.2, 1.8; 0.3, 1.7; 0.4, 1.6; 0.5, 1.5; 0.6, 1.4; 0.7, 1.3; 0.8, 1.0; 0.9, 0.90; 0.95, 0.85; 0.985, 0.8; 1, 0.8; 10, 0.0]
            "Torque Ratio as a function of speed ratio"                                                                                                     annotation (Dialog(group="Torque Converter"));
            parameter SI.Length Diameter_TC = 0.2 "Torque Converter Diameter"
                                                   annotation (Dialog(group="Torque Converter"));
            parameter SI.Density fluidDensity_TC = 850
            "Density of transmission fluid"                                            annotation (Dialog(group="Torque Converter"));

              // TC Lockup clutch gubbins
              parameter SI.Torque locked_max_torque_TC= 550
            "Max torque transmitted when TC clutch is locked"    annotation (Dialog(group="Torque Converter"));
              parameter SI.Torque synchronizer_max_torque_TC=400
            "Max torque transmitted while synchronizing impeller & turbine"     annotation (Dialog(group="Torque Converter"));

        //front_PTO
          parameter Real ratio_frontPTO(start=1) = 1
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Front PTO"));
          parameter Real lossTable_frontPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Front PTO"));

        //rear_PTO
          parameter Real ratio_rearPTO(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Rear PTO"));
          parameter Real lossTable_rearPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Rear PTO"));

        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_in(J=moi_rotational/2)
            annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_out(J=moi_rotational/
                2)
            annotation (Placement(transformation(extent={{50,-10},{70,10}})));
          MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.Lossy_Gear_With_Environment
                                                                      rear_PTO(
                                              useSupport=true,
            ratio=ratio_rearPTO,
            lossTable=lossTable_rearPTO,
            use_environment_heat_port=false,
            useHeatPort=useHeatPort)
            annotation (Placement(transformation(extent={{32,60},{52,80}})));
          MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.Lossy_Gear_With_Environment
                                                                      front_PTO(
                                              useSupport=true,
            ratio=ratio_frontPTO,
            lossTable=lossTable_frontPTO,
            use_environment_heat_port=false,
            useHeatPort=useHeatPort)
            annotation (Placement(transformation(extent={{-30,60},{-50,80}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_front_PTO
            annotation (Placement(transformation(extent={{-110,60},{-90,80}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_rear_PTO
            annotation (Placement(transformation(extent={{90,60},{110,80}})));
          Torque_Converter_Lockup
            torque_Converter_Internals(
            powerCoeffTable=powerCoeffTable_TC,
            torqueConverTable=torqueConverTable_TC,
            Diameter=Diameter_TC,
            fluidDensity=fluidDensity_TC,
            locked_max_torque=locked_max_torque_TC,
            synchronizer_max_torque=synchronizer_max_torque_TC,
            use_environment_heat_port=false,
            useHeatPort=true)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Blocks.Interfaces.RealInput lockup_torque_converter annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,106})));
        equation
          if not useHeatPort then
            lossPower = front_PTO.lossPower + rear_PTO.lossPower + torque_Converter_Internals.lossPower;
          end if;

          connect(front_PTO.support, internalSupport) annotation (Line(
              points={{-40,60},{-40,40},{14,40},{14,-80},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(rear_PTO.support, internalSupport) annotation (Line(
              points={{42,60},{42,40},{14,40},{14,-80},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(flange_a, inertia_in.flange_a) annotation (Line(
              points={{-100,0},{-70,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_in.flange_b, front_PTO.flange_a) annotation (Line(
              points={{-50,0},{-20,0},{-20,70},{-30,70}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_in.flange_b, rear_PTO.flange_a) annotation (Line(
              points={{-50,0},{-20,0},{-20,70},{32,70}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(rear_PTO.flange_b, flange_rear_PTO) annotation (Line(
              points={{52,70},{100,70}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(flange_front_PTO, front_PTO.flange_b) annotation (Line(
              points={{-100,70},{-50,70}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_out.flange_b, flange_b) annotation (Line(
              points={{70,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(front_PTO.heatPort, heatPort) annotation (Line(
              points={{-30,60},{-30,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(front_PTO.heatPort, thermal_To_Environment.solid) annotation (Line(
              points={{-30,60},{-30,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(rear_PTO.heatPort, heatPort) annotation (Line(
              points={{32,60},{32,-48},{-30,-48},{-30,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(rear_PTO.heatPort, thermal_To_Environment.solid) annotation (Line(
              points={{32,60},{32,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.TC_Input, inertia_in.flange_b) annotation (
             Line(
              points={{-10,0},{-50,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.TC_Output, inertia_out.flange_a)
            annotation (Line(
              points={{10,0},{50,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.TC_Stator, internalSupport) annotation (
              Line(
              points={{10,3.4},{14,3.4},{14,-80},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.heatPort, heatPort) annotation (Line(
              points={{-10,-10},{-30,-10},{-30,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.heatPort, thermal_To_Environment.solid)
            annotation (Line(
              points={{-10,-10},{-30,-10},{-30,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Internals.lockup_torque_converter,
            lockup_torque_converter) annotation (Line(
              points={{0,10.8},{0,106}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Polygon(
                  points={{-70,10},{-70,70},{-50,90},{2,90},{20,88},{40,84},{60,68},{60,
                      48},{40,30},{22,24},{8,46},{14,52},{14,60},{2,64},{2,86},{-48,86},
                      {-66,68},{-66,-66},{-44,-90},{2,-90},{2,-66},{14,-60},{14,-52},{8,
                      -46},{22,-26},{40,-34},{60,-48},{60,-72},{40,-86},{20,-92},{2,-94},
                      {-48,-94},{-70,-70},{-70,10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-4,64},{-4,80},{-20,80},{-40,78},{-50,60},{-50,40},{-34,20},{
                      -34,-20},{-50,-40},{-50,-60},{-40,-78},{-20,-84},{-4,-84},{-4,-66},
                      {-16,-60},{-16,-52},{-6,-46},{-18,-26},{-18,-10},{98,-10},{98,10},
                      {-18,10},{-18,26},{-6,46},{-16,50},{-16,60},{-4,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{106,-24},{106,-22},{82,-22},{82,-14},{-14,-14},{-14,-24},{-2,
                      -44},{4,-44},{16,-26},{16,-18},{78,-18},{78,-22},{70,-22},{70,-24},
                      {106,-24}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{2,44},{-2,44},{-14,24},{-14,14},{82,14},{82,22},{106,22},{106,
                      24},{70,24},{70,22},{78,22},{78,18},{14,18},{14,24},{2,44}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-66,10},{-56,6}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,22},{-52,6}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-62,32},{-58,16}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-50,46},{-46,16}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-62,32},{-48,28}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-50,-16},{-46,-46}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-62,-28},{-48,-32}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-62,-16},{-58,-32}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,-6},{-52,-22}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-66,-6},{-56,-10}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-102,10},{-70,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None)}));
        end Torque_Converter_Lockup_with_2PTO;

        model Torque_Converter_Simple
          "Revised torque convertor with explicit treatment of stator freewheeling"

          parameter Real powerCoeffTable[:,2]=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488;
              0.2,0.2712; 0.3,0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712;
              0.9,0.2488; 1,0.2]
            "Table for power coefficientas a function of speed ratio";

          parameter Real torqueConverTable[:,2]=[-10,2; 0,2; 0.00001,2; 0.1,1.9; 0.2,1.8;
              0.3,1.7; 0.4,1.6; 0.5,1.5; 0.6,1.4; 0.7,1.3; 0.8,1.0; 0.9,0.90; 0.95,0.85;
              0.985,0.8; 1,0.8; 10,0.0]
            "Torque Ratio as a function of speed ratio";
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
          extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(     thermal_To_Environment(
                area_for_heat_transfer=0.5));
          Real speedRatio(stateSelect=StateSelect.never)
            "Ratio of input to output speed, dimensionless";
          Real torqueConverRatio(stateSelect=StateSelect.never)
            "Ratio of input to output torque, dimensionless";
          Modelica.SIunits.AngularVelocity impellerSpeed
            "Speed of impeller in rad/s";
          Modelica.SIunits.AngularVelocity turbineSpeed
            "Speed of turbine in rad/s";
          Modelica.SIunits.Torque impellerTorque "Torque of impeller in Nm";
          Modelica.SIunits.Torque turbineTorque "Torque of turbine in Nm";
          Modelica.SIunits.Torque statorTorque "Torque of stator in Nm";
          Modelica.SIunits.Power impellerPower "Impeller power in W";
          Modelica.SIunits.Power turbinePower "turbine power in W";
          Modelica.SIunits.Efficiency Efficiency
            "Torque Converter Efficiency in %";
          Modelica.SIunits.Power watt_loss
            "Power lost to heat in the torque converter";
        // new paramters for reworked TC

          parameter Modelica.SIunits.Length Diameter=0.2
            "Torque Converter Diameter";
          parameter Modelica.SIunits.Density fluidDensity=850
            "Density of transmission fluid";

        public
          Modelica.Mechanics.Rotational.Interfaces.Flange_a TC_Input  annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b TC_Output annotation (Placement(transformation(extent={{90,-10},
                    {110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b TC_Stator annotation (Placement(transformation(extent={{90,24},
                    {110,44}}),
                iconTransformation(extent={{90,24},{110,44}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prescribedHeatFlow
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-16,-40})));
        protected
          Modelica.Blocks.Interfaces.RealOutput y annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-16,-8})));

        equation
            // Connections
          der(TC_Input.phi) = impellerSpeed;
          der(TC_Output.phi) = turbineSpeed;
          TC_Input.tau = -impellerTorque;
          TC_Output.tau = -turbineTorque;
          TC_Stator.tau = -statorTorque;

          // Basics
          if noEvent(impellerSpeed >= 1) then
            speedRatio = turbineSpeed/impellerSpeed;

            torqueConverRatio = Modelica.Math.tempInterpol1(
              speedRatio,
              torqueConverTable,
              2);

            -impellerTorque = Modelica.Math.tempInterpol1(
              speedRatio,
              powerCoeffTable,
              2)*(impellerSpeed*abs(impellerSpeed))*fluidDensity*(Diameter^5);
          else
            impellerTorque = 0;
            torqueConverRatio = 0;
            speedRatio = 0;
          end if;
            //Efficiency Loss
          impellerPower = -impellerSpeed*impellerTorque;
          turbinePower = -turbineSpeed*turbineTorque;
          watt_loss = abs(impellerPower + turbinePower);

          if noEvent(impellerPower > 0 and turbinePower < 0) then
            Efficiency = 1 - watt_loss/impellerPower;
          else
            Efficiency = 0.0;
          end if;
            // Calculate Stator
          statorTorque + turbineTorque + impellerTorque = 0;

          // stator would freewheel if trq_ratio < 1
          turbineTorque = (-1)*max(torqueConverRatio, 1)*impellerTorque;

            // Kludge to make heat rejection model work with conditional heat port and environment
          y = watt_loss;
          if not useHeatPort then
            lossPower = watt_loss;
          end if;

          connect(y, prescribedHeatFlow.Q_flow) annotation (Line(
              points={{-16,-8},{-16,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(thermal_To_Environment.solid, prescribedHeatFlow.port) annotation (
              Line(
              points={{40,-90},{-16,-90},{-16,-50}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(prescribedHeatFlow.port, heatPort) annotation (Line(
              points={{-16,-50},{-16,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
            Icon(graphics={
                Polygon(
                  points={{-68,10},{-68,70},{-48,90},{4,90},{22,88},{42,84},{62,68},{62,
                      48},{42,30},{24,24},{10,46},{16,52},{16,60},{4,64},{4,86},{-46,86},
                      {-64,68},{-64,-66},{-42,-90},{4,-90},{4,-66},{16,-60},{16,-52},{10,
                      -46},{24,-26},{42,-34},{62,-48},{62,-72},{42,-86},{22,-92},{4,-94},
                      {-46,-94},{-68,-70},{-68,10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{4,44},{0,44},{-12,24},{-12,14},{84,14},{84,22},{108,22},{108,
                      24},{72,24},{72,22},{80,22},{80,18},{16,18},{16,24},{4,44}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{108,-24},{108,-22},{84,-22},{84,-14},{-12,-14},{-12,-24},{0,-44},
                      {6,-44},{18,-26},{18,-18},{80,-18},{80,-22},{72,-22},{72,-24},{108,
                      -24}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-2,64},{-2,80},{-18,80},{-38,78},{-48,60},{-48,40},{-32,20},{
                      -32,-20},{-48,-40},{-48,-60},{-38,-78},{-18,-84},{-2,-84},{-2,-66},
                      {-14,-60},{-14,-52},{-4,-46},{-16,-26},{-16,-10},{100,-10},{100,10},
                      {-16,10},{-16,26},{-4,46},{-14,50},{-14,60},{-2,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}),
                Rectangle(
                  extent={{-100,10},{-68,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None)}),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}),
                    graphics),
            Documentation(info="<html>
<p><u><b>How to use Torque Converter</b></u></p>
<p><ul>
<li>Must fill in tables for torque ratio and power coefficient also supply corresponding TC diameter and transmission fluid density (Supplier Data)</li>
<li>Torque converter characteristics can quickly be changed by adjusting the TC diameter </li>
<li><pre><font style=\"color: #006400; \">Operaing&nbsp;mode&nbsp;of&nbsp;TC&nbsp;::&nbsp;TC&nbsp;mode&nbsp;state::&nbsp;1=&nbsp;Slipping,&nbsp;2&nbsp;=&nbsp;speed&nbsp;unity,&nbsp;3&nbsp;=&nbsp;turbine&nbsp;overspeed&nbsp;</pre></font></li>
</ul></p>
</html>"));
        end Torque_Converter_Simple;

        model Torque_Converter_Lockup
          "Wraps Torque_Converter_Simple with a lockup clutch"

        //Torque Converter Inputs

            parameter Real powerCoeffTable[:, 2]=
            [-10, 0.2; 0, 0.2; 0.00001, 0.2; 0.1, 0.2488; 0.2, 0.2712; 0.3, 0.2872; 0.4, 0.2968; 0.5, 0.3; 0.6, 0.2968; 0.7, 0.2872; 0.8, 0.2712; 0.9, 0.2488; 1, 0.2]
            "Table for power coefficientas a function of speed ratio"                                                                                                     annotation ();
            parameter Real torqueConverTable[:, 2]=
            [-10, 2;  0, 2; 0.00001, 2; 0.1, 1.9; 0.2, 1.8; 0.3, 1.7; 0.4, 1.6; 0.5, 1.5; 0.6, 1.4; 0.7, 1.3; 0.8, 1.0; 0.9, 0.90; 0.95, 0.85; 0.985, 0.8; 1, 0.8; 10, 0.0]
            "Torque Ratio as a function of speed ratio"                                                                                                     annotation ();
            parameter SI.Length Diameter = 0.2 "Torque Converter Diameter"
                                                   annotation ();
            parameter SI.Density fluidDensity = 850
            "Density of transmission fluid"                                         annotation ();
          extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
          extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(
              thermal_To_Environment(area_for_heat_transfer=0.5));
        // Lockup clutch gubbins
          parameter Modelica.SIunits.Torque locked_max_torque= 550
            "Max torque transmitted when TC clutch is locked"
                                                             annotation ();
          parameter Modelica.SIunits.Torque synchronizer_max_torque=400
            "Max torque transmitted while synchronizing impeller & turbine" annotation ();
          Modelica.SIunits.AngularVelocity inputOmega;
          Modelica.SIunits.AngularVelocity outputOmega;
        //
              Integer mode_lockup(start=1)
            "Operaing mode of lockup TC :: TC mode state:: 1= Slipping, 2 = lockup, 3 = turbine overspeed ";
        protected
            constant Modelica.SIunits.Length unit_length = 1;
            parameter Real mue_pos[:,2]=[0,synchronizer_max_torque/locked_max_torque]
            "[w,mue] positive sliding friction coefficient (w_rel>=0)";
            parameter Real peak=1
            "peak*mue_pos[1,2] = maximum value of mue for w_rel==0" annotation ();
            parameter Real cgeo=1
            "Geometry constant containing friction distribution assumption" annotation ();

        public
          Modelica.Mechanics.Rotational.Interfaces.Flange_a TC_Input  annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b TC_Output annotation (Placement(transformation(extent={{90,-10},
                    {110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=0.05)
            annotation (Placement(transformation(extent={{10,-10},{30,10}})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor input_speedSensor
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-60,20})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor output_speedSensor
            annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                rotation=270,
                origin={60,20})));
          Modelica.Blocks.Interfaces.RealOutput input_speed_torque_converter
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-60,106})));
          Modelica.Blocks.Interfaces.RealOutput output_speed_torque_converter
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,106})));
          Modelica.Blocks.Interfaces.RealInput lockup_torque_converter annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,108})));
          Torque_Converter_Simple         torque_Converter_Revised(
            powerCoeffTable=powerCoeffTable,
            torqueConverTable=torqueConverTable,
            Diameter=Diameter,
            fluidDensity=fluidDensity,
            useHeatPort=true)
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          MSL_Extend.Mechanics.Rotational.Components.Clutches.Clutch_Simple_Friction
                                                          clutch_lockup(
            mue_pos=mue_pos,
            peak=peak,
            cgeo=cgeo,
            fn_max=locked_max_torque/unit_length,
            useHeatPort=false)
                       annotation (Placement(transformation(extent={{-20,20},{0,40}})));
          MSL_Extend.Mechanics.Rotational.Components.Clutches.Free_Wheel_Clutch_Based
            free_Wheel_Clutch_Based
            annotation (Placement(transformation(extent={{34,-10},{54,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b TC_Stator annotation (Placement(transformation(extent={{90,30},
                    {110,50}}),
                iconTransformation(extent={{90,24},{110,44}})));
        equation
            if not useHeatPort then
              lossPower = torque_Converter_Revised.watt_loss;// + clutch_lockup.lossPower;
            end if;
        inputOmega = der(TC_Input.phi);
        outputOmega = der(TC_Output.phi);
        //Show operating mode
             if inputOmega > outputOmega+1e-7 then
               mode_lockup = 1;
             elseif abs(abs(inputOmega)-abs(outputOmega))<1e-7 then
               mode_lockup = 2;
             elseif inputOmega+1e-7 < outputOmega then
               mode_lockup = 3;
             else mode_lockup = 0;
             end if;

          connect(TC_Input, input_speedSensor.flange) annotation (Line(
              points={{-100,0},{-60,0},{-60,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(output_speedSensor.flange, TC_Output) annotation (Line(
              points={{60,10},{60,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(output_speedSensor.w, output_speed_torque_converter) annotation (
              Line(
              points={{60,31},{60,106}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(input_speedSensor.w, input_speed_torque_converter) annotation (
              Line(
              points={{-60,31},{-60,106}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(torque_Converter_Revised.TC_Input, TC_Input)
                                                              annotation (Line(
              points={{-20,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_a, clutch_lockup.flange_b)
                                                     annotation (Line(
              points={{10,0},{10,30},{0,30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(clutch_lockup.flange_a, TC_Input)
                                             annotation (Line(
              points={{-20,30},{-40,30},{-40,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(free_Wheel_Clutch_Based.flange_a, inertia.flange_b) annotation (Line(
              points={{34,0},{30,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Revised.TC_Stator, TC_Stator) annotation (Line(
              points={{0,3.4},{4,3.4},{4,40},{100,40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(free_Wheel_Clutch_Based.flange_b, TC_Output) annotation (Line(
              points={{54,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(clutch_lockup.f_normalized, lockup_torque_converter) annotation (
              Line(
              points={{-10,41},{-10,60},{0,60},{0,108}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(torque_Converter_Revised.heatPort, thermal_To_Environment.solid)
            annotation (Line(
              points={{-20,-10},{-20,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Revised.heatPort, heatPort) annotation (Line(
              points={{-20,-10},{-20,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Revised.TC_Output, inertia.flange_a) annotation (
              Line(
              points={{0,0},{10,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-100,10},{-68,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{-68,10},{-68,70},{-48,90},{4,90},{22,88},{42,84},{62,68},{62,
                      48},{42,30},{24,24},{10,46},{16,52},{16,60},{4,64},{4,86},{-46,86},
                      {-64,68},{-64,-66},{-42,-90},{4,-90},{4,-66},{16,-60},{16,-52},{10,
                      -46},{24,-26},{42,-34},{62,-48},{62,-72},{42,-86},{22,-92},{4,-94},
                      {-46,-94},{-68,-70},{-68,10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-2,64},{-2,80},{-18,80},{-38,78},{-48,60},{-48,40},{-32,20},{
                      -32,-20},{-48,-40},{-48,-60},{-38,-78},{-18,-84},{-2,-84},{-2,-66},
                      {-14,-60},{-14,-52},{-4,-46},{-16,-26},{-16,-10},{100,-10},{100,10},
                      {-16,10},{-16,26},{-4,46},{-14,50},{-14,60},{-2,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{108,-24},{108,-22},{84,-22},{84,-14},{-12,-14},{-12,-24},{0,-44},
                      {6,-44},{18,-26},{18,-18},{80,-18},{80,-22},{72,-22},{72,-24},{108,
                      -24}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{4,44},{0,44},{-12,24},{-12,14},{84,14},{84,22},{108,22},{108,
                      24},{72,24},{72,22},{80,22},{80,18},{16,18},{16,24},{4,44}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-64,10},{-54,6}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,22},{-50,6}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,32},{-56,16}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-48,46},{-44,16}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,32},{-46,28}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-48,-16},{-44,-46}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,-28},{-46,-32}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,-16},{-56,-32}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,-6},{-50,-22}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-64,-6},{-54,-10}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p><u><b>How to use Torque Converter</b></u></p>
<p><br/>see torque converter internal model for more information</p>
<p><ul>
<li>Lock-up clutch is controlled by external controller</li>
<li><code><font style=\"color: #006400; \">Operaing&nbsp;mode&nbsp;of&nbsp;</font>lockup <font style=\"color: #006400; \">TC&nbsp;::&nbsp;TC&nbsp;mode&nbsp;state::&nbsp;1=&nbsp;Slipping,&nbsp;2&nbsp;=&nbsp;lockup,&nbsp;3&nbsp;=&nbsp;turbine&nbsp;overspeed&nbsp;</font></code></li>
</ul></p>
</html>"));
        end Torque_Converter_Lockup;
      end Torque_Converters;

      package Brakes_Clutch
        "Needs to include some of the control aspects but otherwise is basically a sub-assembly consisting of a wet-clutch"
        extends Modelica.Icons.Package;

        model Clutch_Brake "Wet clutch brake. transmission internal"

        extends Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;
          parameter SI.Force maxApply_force=10000 "Maximum clutch apply force";
          parameter Integer frictionPlate_count(min=1)=3
            "Number of clutch friction plates";
          parameter SI.Length meanRadius=0.1 "Friction plate mean radius";
          parameter Real mue[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0). ";

          Modelica.Mechanics.Rotational.Components.Clutch clutch(
            fn_max=maxApply_force,
            mue_pos=mue,
            cgeo=2*frictionPlate_count*meanRadius,
            useHeatPort=false)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Blocks.Interfaces.RealInput brake_clutch_command
            "signal input for clutch or brake. 0 = off. 1 = fully engaged" annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,114})));
        equation

          connect(clutch.flange_b, flange_b) annotation (Line(
              points={{10,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(clutch.flange_a, flange_a) annotation (Line(
              points={{-10,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(brake_clutch_command, clutch.f_normalized) annotation (Line(
              points={{-80,114},{-80,60},{0,60},{0,11}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Icon(graphics={
                Rectangle(
                  extent={{-100,10},{40,-10}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-4,40},{4,-40}},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,40},{40,34}},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,-34},{40,-40}},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-80,86},{80,80}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{74,86},{80,-80}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-80,-80},{80,-86}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-80,86},{-74,20}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-80,-14},{-74,-80}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{80,20},{100,-20}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{32,80},{40,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{24,76},{32,40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{16,80},{24,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{8,76},{16,40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{0,80},{8,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-8,76},{0,40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-16,80},{-8,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-24,76},{-16,40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-32,80},{-24,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-40,76},{-32,40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-40,-76},{-32,-40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-32,-80},{-24,-44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-24,-76},{-16,-40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-16,-80},{-8,-44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{-8,-76},{0,-40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{0,-80},{8,-44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{8,-76},{16,-40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{16,-80},{24,-44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{24,-76},{32,-40}},
                  pattern=LinePattern.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{32,-80},{40,-44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{54,80},{74,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Rectangle(
                  extent={{54,-44},{76,-80}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={135,135,135}),
                Polygon(
                  points={{40,48},{46,48},{54,80},{48,80},{40,48}},
                  lineColor={135,135,135},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-48},{46,-48},{54,-80},{48,-80},{40,-48}},
                  lineColor={135,135,135},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,58},{-52,72},{-52,64},{-72,64},{-72,52},{-52,52},{-52,44},
                      {-42,58}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,204,51},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,-58},{-52,-44},{-52,-52},{-72,-52},{-72,-64},{-52,-64},{
                      -52,-72},{-42,-58}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,204,51},
                  fillPattern=FillPattern.Solid)}),
                                      Diagram(graphics),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Parameters needed to run, Maximum apply force, number of friction plates, Friction coeffficient, friction plate mean radius</li>
<li>Clutch performance will change as input parameters change</li>
<li>Clutch apply signal must be a value from 0(not applied) to 1(max apply)</li>
</ul></p>
</html>"));
        end Clutch_Brake;
      end Brakes_Clutch;

      package Steering_Cross_Drive
        "Cross Drive Steering system using hydrostatic pump & motor"
        extends Modelica.Icons.Package;

        model Hydrostatic_Pump_Motor
          "hydrostatic pump and motor combination. Uses one variable displacement and one fixed "
        extends C2M2L_OM.MSL_Extend.Interfaces.Base_C2M2L(
              thermal_To_Environment(area_for_heat_transfer=0.1));
        extends
            C2M2L_OM.MSL_Extend.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
        extends
            Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

          parameter SI.AbsolutePressure P_constant=10000000;

        //pump parameters
          parameter Real min_multiplier_pump=0.00001
            "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u"
                                                                                    annotation(Dialog(tab="Pump"));
         parameter SI.Volume vol_per_radian_pump = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Pump"));
         parameter SI.Volume Nm_per_pascal_pump = 1
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(group="Hydraulic",tab="Pump"));
         parameter Real lossTable_pump[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Pump"));
         parameter Boolean useInertia_pump=true
            "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(group="Inertia",tab="Pump"));

          parameter SI.Inertia J_pump(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Pump",
                enable=useInertia_pump));
         parameter Boolean useLeakage_pump=true
            "= true if leakage enabled, otherwise not used in model"
                  annotation(Dialog(group="Hydraulic",tab="Pump"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_pump=0.001 "Leakage loss factor"
                                                                 annotation(Dialog(group="Hydraulic",tab="Pump",
                enable=useLeakage_pump));

        //motor parameters
         parameter SI.Volume vol_per_radian_motor = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Motor"));
         parameter Boolean useInertia_motor=true
            "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(group="Inertia",tab="Motor"));

          parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Motor",
                enable=useInertia_motor));
         parameter Boolean useLeakage_motor=true
            "= true if leakage enabled, otherwise not used in model"
                  annotation(Dialog(group="Hydraulic",tab="Motor"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                  annotation(Dialog(group="Hydraulic",tab="Motor",
                enable=useLeakage_motor));

          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source pressure_Source(P_constant=
                P_constant)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={50,-20})));
          Modelica.Blocks.Interfaces.RealInput u annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,108})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Lossy
            hydraulic_Mechanical_Conversion_Lossy(useHeatPort=useHeatPort, useSupport=true,
            vol_per_radian=vol_per_radian_motor,
            Nm_per_pascal=Nm_per_pascal_motor,
            lossTable=lossTable_motor,
            useInertia=useInertia_motor,
            J=J_motor,
            useLeakage=useLeakage_motor,
            leakage=leakage_motor)
            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=270,
                origin={20,0})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Variable_Lossy
            hydraulic_Mechanical_Conversion_Variable_Lossy(
            useHeatPort=useHeatPort,
            useSupport=true,
            vol_per_radian=vol_per_radian_pump,
            lossTable=lossTable_pump,
            useInertia=useInertia_pump,
            J=J_pump,
            useLeakage=useLeakage_pump,
            leakage=leakage_pump,
            min_multiplier=min_multiplier_pump,
            Nm_per_pascal=Nm_per_pascal_pump)   annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={-72,0})));
        equation

          if not useHeatPort then
              lossPower = hydraulic_Mechanical_Conversion_Lossy.lossPower + hydraulic_Mechanical_Conversion_Variable_Lossy.lossPower;
          end if;

          connect(pressure_Source.hydraulic_port,
            hydraulic_Mechanical_Conversion_Variable_Lossy.hyd_b)  annotation (Line(
              points={{40,-20},{-72,-20},{-72,-10}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Variable_Lossy.support,
            internalSupport) annotation (Line(
              points={{-62,-6.12323e-016},{-20,-6.12323e-016},{-20,0},{0,0},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.support, internalSupport)
            annotation (Line(
              points={{10,1.77636e-015},{16,1.77636e-015},{16,0},{0,0},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Variable_Lossy.hyd_b,
            hydraulic_Mechanical_Conversion_Lossy.hyd_a) annotation (Line(
              points={{-72,-10},{-72,-20},{20,-20},{20,-10}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Variable_Lossy.hyd_a,
            hydraulic_Mechanical_Conversion_Lossy.hyd_b) annotation (Line(
              points={{-72,10},{-72,20},{20,20},{20,10}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(u, hydraulic_Mechanical_Conversion_Variable_Lossy.u)  annotation (
              Line(
              points={{-80,108},{-80,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Variable_Lossy.heatPort, heatPort)
            annotation (Line(
              points={{-62,10},{-20,10},{-20,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Variable_Lossy.heatPort,
            thermal_To_Environment.solid) annotation (Line(
              points={{-62,10},{-20,10},{-20,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.heatPort, heatPort) annotation (
             Line(
              points={{10,-10},{-20,-10},{-20,-100},{-100,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.heatPort,
            thermal_To_Environment.solid) annotation (Line(
              points={{10,-10},{-20,-10},{-20,-90},{40,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(flange_a, hydraulic_Mechanical_Conversion_Variable_Lossy.flange)
            annotation (Line(
              points={{-100,0},{-82,0},{-82,6.12323e-016}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.flange, flange_b) annotation (
              Line(
              points={{30,-1.77636e-015},{30,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics), Icon(graphics={
                Rectangle(
                  extent={{-102,10},{-54,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-78,32},{-18,-28}},
                  lineColor={135,135,135},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{52,10},{100,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{14,32},{74,-28}},
                  lineColor={135,135,135},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Polygon(
                  points={{-58,16},{-38,16},{-48,32},{-58,16}},
                  pattern=LinePattern.None,
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-10,-8},{10,-8},{0,8},{-10,-8}},
                  pattern=LinePattern.None,
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  origin={-48,-20},
                  rotation=180),
                Polygon(
                  points={{-10,-8},{10,-8},{0,8},{-10,-8}},
                  pattern=LinePattern.None,
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  origin={44,-20},
                  rotation=360),
                Polygon(
                  points={{-10,-8},{10,-8},{0,8},{-10,-8}},
                  pattern=LinePattern.None,
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  origin={44,24},
                  rotation=180),
                Line(
                  points={{-78,-32},{-12,42},{-28,36}},
                  thickness=0.5,
                  smooth=Smooth.None,
                  color={0,0,255}),
                Line(
                  points={{-12,42},{-14,28}},
                  color={0,0,255},
                  thickness=0.5,
                  smooth=Smooth.None),
                Line(
                  points={{-48,32},{-48,60},{44,60},{44,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-46,-14},{-46,14},{46,14},{46,-14}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  origin={-2,-42},
                  rotation=180),
                Line(
                  points={{-78,-42},{82,-42},{82,104}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Polygon(
                  points={{72,100},{82,120},{92,100},{72,100}},
                  lineColor={255,0,0},
                  smooth=Smooth.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid)}));
        end Hydrostatic_Pump_Motor;

        model Steering_Cross_Drive
          "Steering system block for X-Drive transmission"
          import C2M2L_OM;

        // Pump_variableDisp parameters
          parameter SI.AbsolutePressure P_constant=10000000;

        ////pump parameters
          parameter Real min_multiplier_pump=0.00001
            "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u"
                                                                                    annotation(Dialog(tab="Pump"));
         parameter SI.Volume vol_per_radian_pump = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Pump"));
         parameter SI.Volume Nm_per_pascal_pump = 1
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(group="Hydraulic",tab="Pump"));
         parameter Real lossTable_pump[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Pump"));
         parameter Boolean useInertia_pump=true
            "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(group="Inertia",tab="Pump"));

          parameter SI.Inertia J_pump(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Pump",
                enable=useInertia_pump));
         parameter Boolean useLeakage_pump=true
            "= true if leakage enabled, otherwise not used in model"
                  annotation(Dialog(group="Hydraulic",tab="Pump"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_pump=0.001 "Leakage loss factor"
                                                                 annotation(Dialog(group="Hydraulic",tab="Pump",
                enable=useLeakage_pump));

        ////motor parameters
         parameter SI.Volume vol_per_radian_motor = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Motor"));
         parameter Boolean useInertia_motor=true
            "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(group="Inertia",tab="Motor"));

          parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Motor",
                enable=useInertia_motor));
         parameter Boolean useLeakage_motor=true
            "= true if leakage enabled, otherwise not used in model"
                  annotation(Dialog(group="Hydraulic",tab="Motor"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                  annotation(Dialog(group="Hydraulic",tab="Motor",
                enable=useLeakage_motor));
        //Motor output planetary
          parameter Integer N_sun = 50 "Number of teeth on Sun gear" annotation(Dialog(group="Teeth Count",tab="Motor Ouput Planet"));
          parameter Integer N_ring = 100 "Number of teeth on Ring gear" annotation(Dialog(group="Teeth Count",tab="Motor Ouput Planet"));
          parameter Integer N_planet = 25 "Number of teeth on Planet gear" annotation(Dialog(group="Teeth Count",tab="Motor Ouput Planet"));

          parameter SI.Conversions.NonSIunits.AngularVelocity_rpm sunSpeed_max = 10000
            "Sun speed, maximum limit [rpm]" annotation(Dialog(tab="Motor Ouput Planet",group="Speed Limits"));
          parameter SI.Conversions.NonSIunits.AngularVelocity_rpm carrierSpeed_max = 10000
            "Carrier speed, maximum limit [rpm]" annotation(Dialog(tab="Motor Ouput Planet",group="Speed Limits"));
          parameter SI.Conversions.NonSIunits.AngularVelocity_rpm ringSpeed_max = 10000
            "Ring speed, maximum limit [rpm]" annotation(Dialog(tab="Motor Ouput Planet",group="Speed Limits"));
          parameter SI.Conversions.NonSIunits.AngularVelocity_rpm planetSpeed_max = 10000
            "Planet speed, maximum limit [rpm]" annotation(Dialog(tab="Motor Ouput Planet",group="Speed Limits"));
          parameter SI.Torque Torque_max = 1000
            "Maximum transmited torque limit [Nm]" annotation(Dialog(tab="Motor Ouput Planet",group="Torque Limit"));

          parameter Real lossTable_sun[:, 5]=[0, 0.995, 0.995, 0, 0]
            "losses for sun planet mesh"
            annotation(Dialog(group="Efficiency",tab="Motor Ouput Planet"));
          parameter Real lossTable_ring[:, 5]=[0, 0.995, 0.995, 0, 0]
            "losses for ring planet mesh"
            annotation(Dialog(group="Efficiency",tab="Motor Ouput Planet"));

          Modelica.Mechanics.Rotational.Components.IdealGear steering_sign_flip(ratio=-1)
            annotation (Placement(transformation(extent={{-60,-10},{-80,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Support support
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a pumpIn
            annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b leftOut
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b rightOut
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Steering_Cross_Drive.Hydrostatic_Pump_Motor
                                         hydrostatic_Pump_Motor(
            use_environment_heat_port=true,
            useSupport=true,
            P_constant=P_constant,
            min_multiplier_pump=min_multiplier_pump,
            vol_per_radian_pump=vol_per_radian_pump,
            Nm_per_pascal_pump=Nm_per_pascal_pump,
            lossTable_pump=lossTable_pump,
            useInertia_pump=useInertia_pump,
            J_pump=J_pump,
            useLeakage_pump=useLeakage_pump,
            leakage_pump=leakage_pump,
            vol_per_radian_motor=vol_per_radian_motor,
            Nm_per_pascal_motor=Nm_per_pascal_motor,
            lossTable_motor=lossTable_motor,
            useInertia_motor=useInertia_motor,
            J_motor=J_motor,
            useLeakage_motor=useLeakage_motor,
            leakage_motor=leakage_motor)
            annotation (Placement(transformation(extent={{-10,-34},{10,-14}})));
          Modelica.Blocks.Math.Gain gain(k=1)   annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-80,70})));
          Modelica.Mechanics.Rotational.Components.IdealPlanetary idealPlanetary(ratio=
                N_ring/N_sun)
            annotation (Placement(transformation(extent={{60,-34},{80,-14}})));
          Modelica.Blocks.Interfaces.RealInput steer_command annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,108})));
        equation
          connect(leftOut, steering_sign_flip.flange_b) annotation (Line(
              points={{-100,0},{-80,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydrostatic_Pump_Motor.flange_a, pumpIn) annotation (Line(
              points={{-10,-24},{-20,-24},{-20,60},{0,60},{0,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydrostatic_Pump_Motor.support, support) annotation (Line(
              points={{0,-34},{0,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(gain.y, hydrostatic_Pump_Motor.u) annotation (Line(
              points={{-80,59},{-80,40},{-8,40},{-8,-13.2}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(idealPlanetary.sun, hydrostatic_Pump_Motor.flange_b) annotation (Line(
              points={{60,-24},{10,-24}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealPlanetary.ring, support) annotation (Line(
              points={{80,-24},{80,-100},{0,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealPlanetary.carrier, steering_sign_flip.flange_a) annotation (Line(
              points={{60,-20},{52,-20},{52,0},{-60,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealPlanetary.carrier, rightOut) annotation (Line(
              points={{60,-20},{52,-20},{52,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(gain.u, steer_command) annotation (Line(
              points={{-80,82},{-80,108}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics),
            Icon(graphics={
                Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}),
                Text(
                  extent={{-100,40},{0,-60}},
                  lineColor={128,128,128},
                  textString="L"),
                Text(
                  extent={{0,40},{100,-60}},
                  lineColor={128,128,128},
                  textString="R"),
                Text(
                  extent={{-148,90},{152,30}},
                  lineColor={0,0,0},
                  textString="steer"),
                Text(
                  extent={{-140,166},{140,106}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Inputs needed for pump &AMP; motor; pump and motor displacement, pump and motor volumetric efficiency, pressure limit</li>
<li>Inputs needed for Motor output planetary; sun/ring/planet teeth count, sun-planet/ring-planet mesh efficiency, sun/ring/planet/carrier speed limits, torque limit</li>
<li>Model contains small inertias, but user cannot change parameter. only used for proper model operation</li>
<li>Motor displacement will vary from 0 to max depending on steering signal input</li>
<li>Steering signal input will vary from -1 to 1. An input of 0(zero) will not allow motor to rotate</li>
</ul></p>
</html>"));
        end Steering_Cross_Drive;
      end Steering_Cross_Drive;
    end Drive_Line;

    package Prime_Movers
      "Devices that convert chemical energy to mechanical energy (e.g. engines)"
      extends Modelica.Icons.Package;
      package Reciprocating
        "Engines that use a linear piston motion to extract mechanical power from heated gases "
        extends Modelica.Icons.Package;
        package Compression_Ignition
          "Internal combustion engines that use a compression process to ignite the fuel-air mixture"
          extends Modelica.Icons.Package;
          package Table_Based_Engine
            "Engine model that uses lookup tables to calculate torque generation, heat rejection and fuel consumption"
            extends Modelica.Icons.Package;
            package Sub_Models "Sub models used by Table_Based_Engine"
              extends Modelica.Icons.Package;

              model Torque_And_Fueling_1 "Torque and Fuel Maps"
               parameter SI.Torque friction_map[:,2] = [0,0;1,1]
                  "Table of speed (rpm) vs engine friction torque";
               parameter SI.Torque torque_map[:,2] =  [0,0;1,1]
                  " Table of speed(rpm) vs engine torque at WOT";
               parameter SI.MassFlowRate fuel_map[:,:] =  [0,0;1,1]
                  "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
               parameter SI.AngularVelocity crank_speed=62.831853071796
                  "crank speed";

                Modelica.Mechanics.Rotational.Sources.Torque torque_produced(useSupport=true)
                  annotation (Placement(transformation(extent={{52,-8},{68,8}})));
                Modelica.Blocks.Math.UnitConversions.To_rpm convert_speed_to_rpm
                  annotation (Placement(transformation(
                      origin={58,60},
                      extent={{10,-10},{-10,10}},
                      rotation=0)));
                Modelica.Blocks.Math.Gain fuel_energy_density(k=45800000)
                  annotation (Placement(transformation(extent={{-8,-8},{8,8}},
                      rotation=0,
                      origin={136,84})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow engine_heat_generation(T_ref=
                      673.15)
                  annotation (Placement(transformation(extent={{176,72},{192,88}})));
                Modelica.Blocks.Math.Add fuel_energy_less_generated_power(k2=-1)
                  annotation (Placement(transformation(extent={{156,72},{172,88}})));
                Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                   Placement(transformation(
                      extent={{-8,-8},{8,8}},
                      rotation=90,
                      origin={80,8})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a engine_heat_out
                  annotation (Placement(transformation(extent={{192,72},{208,88}})));
                Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
                  annotation (Placement(transformation(extent={{90,8},{106,-8}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
                  annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b
                  annotation (Placement(transformation(extent={{190,-10},{210,10}})));
                Modelica.Mechanics.Rotational.Interfaces.Support support
                  annotation (Placement(transformation(extent={{40,-108},{60,-88}})));

              public
                Modelica.Blocks.Tables.CombiTable1D friction_table(
                  smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
                  columns={2},
                  table=friction_map)
                  annotation (Placement(transformation(extent={{-6,-6},{6,6}},
                      rotation=270,
                      origin={-68,38})));
              protected
                parameter Real friction_map_rads[:,2] = [(friction_map[:,1]*pi/30),(friction_map[:,2])];
              public
                Modelica.Mechanics.Rotational.Sensors.PowerSensor powerSensor
                  annotation (Placement(transformation(extent={{146,8},{162,-8}})));
                Fuel_Map_From_Torque_And_Speed fuel_Map(fuel_table=fuel_map)
                  annotation (Placement(transformation(extent={{110,-10},{130,10}})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Proportional_Combining proportional_Combining
                  annotation (Placement(transformation(extent={{-10,-16},{10,4}})));
                Modelica.Blocks.Math.Gain gain(k=-1)
                  annotation (Placement(transformation(extent={{-60,-22},{-40,-2}})));
                C2M2L_OM.MSL_Extend.Blocks.Tables.Limited_Map
                            limited_Map(table=torque_map, alt_table=friction_map)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-40,28})));
                Modelica.Mechanics.Rotational.Components.Clutch clutch(fn_max=
                      max_resistive_torque)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={80,-66})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Positive_Negative_Split positive_Negative_Split
                  annotation (Placement(transformation(extent={{20,-16},{40,4}})));
                parameter SI.Force max_resistive_torque = 100000
                  "Maximum torque the engine can resist";
                Modelica.Blocks.Math.Gain gain1(k=-1/max_resistive_torque)
                  annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                      rotation=90,
                      origin={46,-50})));
                Modelica.Blocks.Interfaces.RealOutput speed annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-40,166})));
              public
                Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out annotation (
                    Placement(transformation(
                      extent={{-20,-20},{20,20}},
                      rotation=270,
                      origin={20,170})));
                Modelica.Blocks.Interfaces.RealOutput net_torque annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={132,166})));
                Modelica.Blocks.Interfaces.RealOutput fuel_flow annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={74,166})));
              equation

                connect(fuel_energy_less_generated_power.y, engine_heat_generation.Q_flow)
                                                          annotation (Line(
                    points={{172.8,80},{176,80}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(convert_speed_to_rpm.u, speedSensor.w)
                                                  annotation (Line(
                    points={{70,60},{80,60},{80,16.8}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(engine_heat_generation.port, engine_heat_out)
                                                         annotation (Line(
                    points={{192,80},{200,80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(torque_produced.support, support)
                                                 annotation (Line(
                    points={{60,-8},{60,-98},{50,-98}},
                    color={0,0,0},
                    smooth=Smooth.None));

                connect(convert_speed_to_rpm.y, friction_table.u[1])
                                                       annotation (Line(
                    points={{47,60},{-68,60},{-68,45.2}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(flange_a, flange_b) annotation (Line(
                    points={{-100,0},{-100,-112},{200,-112},{200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_energy_density.y, fuel_energy_less_generated_power.u1)
                  annotation (Line(
                    points={{144.8,84},{154.4,84},{154.4,84.8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(powerSensor.flange_b, flange_b) annotation (Line(
                    points={{162,0},{200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.flange, torqueSensor.flange_a) annotation (Line(
                    points={{80,0},{90,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_Map.fuel_rate, fuel_energy_density.u) annotation (Line(
                    points={{120,11},{120,84},{126.4,84}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torqueSensor.flange_b, fuel_Map.flange_a) annotation (Line(
                    points={{106,0},{110,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_Map.flange_b, powerSensor.flange_a) annotation (Line(
                    points={{130,0},{146,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(powerSensor.power, fuel_energy_less_generated_power.u2) annotation (
                    Line(
                    points={{147.6,8.8},{147.6,52},{148,52},{148,75.2},{154.4,75.2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torque_produced.flange, speedSensor.flange) annotation (Line(
                    points={{68,0},{80,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(friction_table.y[1], gain.u) annotation (Line(
                    points={{-68,31.4},{-68,-12},{-62,-12}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(gain.y, proportional_Combining.u2) annotation (Line(
                    points={{-39,-12},{-12,-12}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(limited_Map.u, convert_speed_to_rpm.y) annotation (Line(
                    points={{-40,40},{-40,60},{47,60}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(limited_Map.y, proportional_Combining.u1) annotation (Line(
                    points={{-40,17},{-40,0},{-12,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(clutch.flange_a, support) annotation (Line(
                    points={{80,-76},{80,-98},{50,-98}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(clutch.flange_b, speedSensor.flange) annotation (Line(
                    points={{80,-56},{80,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(proportional_Combining.y, positive_Negative_Split.u) annotation (Line(
                    points={{11,-6},{18,-6}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(positive_Negative_Split.y_pos, torque_produced.tau) annotation (Line(
                    points={{41,0},{50.4,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(positive_Negative_Split.y_neg, gain1.u) annotation (Line(
                    points={{41,-12},{46,-12},{46,-38}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(gain1.y, clutch.f_normalized) annotation (Line(
                    points={{46,-61},{46,-66},{69,-66}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(convert_speed_to_rpm.y, speed) annotation (Line(
                    points={{47,60},{-40,60},{-40,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torqueSensor.tau, net_torque) annotation (Line(
                    points={{91.6,8.8},{91.6,98},{92,98},{92,148},{132,148},{132,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(fuel_Map.fuel_rate, fuel_flow) annotation (Line(
                    points={{120,11},{120,84},{74,84},{74,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(ECU_Throttle_Out, proportional_Combining.p) annotation (
                    Line(
                    points={{20,170},{20,20},{-20,20},{-20,-30},{0,-30},{0,-18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                          -100},{200,160}}),      graphics), Icon(coordinateSystem(
                        preserveAspectRatio=true, extent={{-100,-100},{200,160}}),
                      graphics={
                      Rectangle(
                        extent={{-100,160},{200,-100}},
                        lineColor={0,0,255},
                        fillPattern=FillPattern.Solid,
                        fillColor={255,255,255}),
                      Rectangle(
                        extent={{-44,76},{-4,56}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-26,56},{-22,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,36},{28,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{6,56},{46,36}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{74,56},{78,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{56,76},{96,56}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{106,56},{146,36}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{124,36},{128,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-46,16},{-2,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{0,-4},{50,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{104,-4},{148,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{48,16},{52,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{52,16},{100,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{100,16},{104,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{144,16},{148,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-50,16},{-46,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,4},{-46,-2}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{148,4},{192,-2}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-26,66},{-22,62}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{24,46},{28,42}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{74,66},{78,62}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{124,44},{128,40}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-2,16},{2,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-102,-28},{198,-68}},
                        textString="%name",
                        lineColor={0,0,255})}));
              end Torque_And_Fueling_1;

              model Inertia
              extends
                  Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;
               parameter Modelica.SIunits.Inertia Jengine;

                Modelica.Mechanics.Rotational.Components.Inertia inertia(J=Jengine)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

              equation
                connect(inertia.flange_b, flange_b) annotation (Line(
                    points={{10,0},{100,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(inertia.flange_a, flange_a) annotation (Line(
                    points={{-10,0},{-100,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                annotation (Icon(graphics), Diagram(graphics={Text(
                        extent={{-70,78},{86,24}},
                        lineColor={0,0,255},
                        fontSize=12,
                        textString="Make sure this includes ALL rotating inertia, not just crank
")}));
              end Inertia;

              model dummy_starter_motor
                "Dummy starter, doesn't conserve energy"

                Modelica.Mechanics.Rotational.Sources.Torque
                                                     torque(useSupport=true)
                                                            annotation (Placement(
                      transformation(extent={{53,0},{73,20}},   rotation=0)));
                Modelica.Blocks.Logical.Switch torqueFromMotor
                  annotation (Placement(transformation(extent={{-4,-10},{36,30}},rotation=0)));
                Modelica.Blocks.Sources.Constant motorOn(k=600)             annotation (Placement(
                      transformation(extent={{-74,50},{-54,70}}, rotation=0)));
                Modelica.Blocks.Sources.Constant motorOff(k=0)                annotation (Placement(
                      transformation(extent={{-74,-50},{-54,-30}}, rotation=0)));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b
                  annotation (Placement(transformation(extent={{90,-10},{110,12}})));
                Modelica.Mechanics.Rotational.Interfaces.Support support
                  annotation (Placement(transformation(extent={{-12,-110},{10,-90}})));
                Modelica.Blocks.Interfaces.BooleanInput crank
                  annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              equation
                connect(torqueFromMotor.y,torque.tau)           annotation (Line(points={{38,10},
                        {51,10}}));
                connect(motorOn.y,torqueFromMotor.u1)             annotation (Line(points={{-53,60},
                        {-33,60},{-33,26},{-8,26}},         color={0,0,255}));
                connect(motorOff.y,torqueFromMotor.u3)             annotation (Line(points={{-53,-40},
                        {-34,-40},{-34,-6},{-8,-6}},            color={0,0,255}));
                connect(torque.flange, flange_b) annotation (Line(
                    points={{73,10},{88,10},{88,1},{100,1}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(support, torque.support) annotation (Line(
                    points={{-1,-100},{-1,-51},{63,-51},{63,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(crank, torqueFromMotor.u2) annotation (Line(
                    points={{-120,0},{-66,0},{-66,10},{-8,10}},
                    color={255,0,255},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                          -100},{100,100}}),
                                    graphics), Icon(coordinateSystem(extent={{-100,-100},{100,
                          100}}),                   graphics={
                      Rectangle(
                        extent={{-46,80},{60,-60}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{60,20},{94,0}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-148,-60},{152,-100}},
                        textString="%name",
                        lineColor={0,0,255})}));
              end dummy_starter_motor;

              model Engine_Operation_Sensor
                "Uses engine inputs to determine if the engine is running."
               parameter SI.AngularVelocity crank_speed=62.831853071796
                  "crank speed";

                Modelica.Blocks.Logical.OnOffController onOffController(bandwidth=0)
                  annotation (extent=[-30,-30; -10,-10], Placement(transformation(extent={{-42,8},
                          {-18,32}})));
                Modelica.Blocks.Sources.RealExpression realExpression(y=crank_speed)
                  annotation (extent=[-70,-24; -50,-4], Placement(transformation(extent={{-90,18},
                          {-70,38}})));
                Modelica.Blocks.Interfaces.RealInput EngineSpeed
                  annotation (Placement(transformation(extent={{-114,0},{-90,24}})));
                Modelica.Blocks.Interfaces.BooleanOutput y
                  annotation (Placement(transformation(extent={{96,10},{116,30}})));
                Modelica.Blocks.Logical.Not not1
                  annotation (Placement(transformation(extent={{14,10},{34,30}})));
              equation
                connect(realExpression.y,onOffController. reference) annotation (Line(
                    points={{-69,28},{-48,28},{-48,27.2},{-44.4,27.2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(onOffController.y, not1.u) annotation (Line(
                    points={{-16.8,20},{12,20}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(not1.y, y) annotation (Line(
                    points={{35,20},{106,20}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(onOffController.u, EngineSpeed) annotation (Line(
                    points={{-44.4,12.8},{-72.2,12.8},{-72.2,12},{-102,12}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                          -100},{100,100}}),
                                    graphics));
              end Engine_Operation_Sensor;

              model Fuel_Map_From_Torque_And_Speed
                "Fuel map component that uses mechanical connections.  Will not allow negative fuel rates to occur."
                extends
                  Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;
                parameter Boolean table_speed_in_rpm = true
                  "=true if speed in table is provided in rpm, =false, speed is in rad/s"
                                                                                                                      annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
                Modelica.Blocks.Tables.CombiTable2D combiTable2D(       smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments, table=
                      fuel_table)
                  annotation (Placement(transformation(extent={{26,46},{46,66}})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                                  prevent_negative_fuel_rate
                  annotation (Placement(transformation(extent={{64,46},{84,66}})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Min_Max.Max_Against_Parameter
                                                  prevent_negative_speed
                  annotation (Placement(transformation(extent={{-12,30},{8,50}})));
                Modelica.Blocks.Interfaces.RealOutput fuel_rate(unit="kg/s")
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={0,110})));
                Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-60,10})));
                Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
                  annotation (Placement(transformation(extent={{-88,10},{-68,-10}})));
                Modelica.Blocks.Math.Gain unit_conversion(k=if table_speed_in_rpm then SI.Conversions.to_rpm(1)
                       else 1)
                  annotation (Placement(transformation(extent={{-44,30},{-24,50}})));
                parameter Real fuel_table[:,:] = [0,1;1,1]
                  "table matrix of fuel flow vs torque=first column and speed=first row";
              equation
                connect(combiTable2D.y, prevent_negative_fuel_rate.u)
                                                                 annotation (Line(
                    points={{47,56},{62,56}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(unit_conversion.y,prevent_negative_speed. u) annotation (Line(
                    points={{-23,40},{-14,40}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(prevent_negative_fuel_rate.y, fuel_rate)
                                                            annotation (Line(
                    points={{85,56},{96,56},{96,84},{0,84},{0,110}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(prevent_negative_speed.y, combiTable2D.u2) annotation (Line(
                    points={{9,40},{14,40},{14,50},{24,50}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torqueSensor.tau, combiTable2D.u1) annotation (Line(
                    points={{-86,11},{-86,62},{24,62}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(flange_a, torqueSensor.flange_a) annotation (Line(
                    points={{-100,0},{-88,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(torqueSensor.flange_b, speedSensor.flange) annotation (Line(
                    points={{-68,0},{-60,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.flange, flange_b) annotation (Line(
                    points={{-60,0},{100,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.w, unit_conversion.u) annotation (Line(
                    points={{-60,21},{-60,40},{-46,40}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(graphics));
              end Fuel_Map_From_Torque_And_Speed;

              model Engine_Heating_Model_2
                "Basic Engine heat rejection model - Not conduction based"
                parameter SI.Mass engine_mass "mass of engine";
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a engine_heat_in
                  annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b heat_to_ambient
                  annotation (Placement(transformation(extent={{90,70},{110,90}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b heat_to_coolant
                  annotation (Placement(transformation(extent={{90,16},{110,36}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b heat_to_oil
                  annotation (Placement(transformation(extent={{90,-36},{110,-16}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b exhaust_heat_out
                  annotation (Placement(transformation(extent={{90,-90},{110,-70}})));
                Modelica.Thermal.HeatTransfer.Sources.FixedTemperature
                                                    thermal_To_Environment1(T=293.15)
                                                annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={-72,-30})));
                Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heatFlowSensor
                  annotation (Placement(transformation(extent={{-82,10},{-62,-10}})));
                Modelica.Blocks.Math.Gain ambient_heat_split(k=0.015)
                  "percentage of engine waste heat to ambient"
                  annotation (Placement(transformation(extent={{0,74},{12,86}})));
                Modelica.Blocks.Math.Gain coolant_heat_split(k=0.2113)
                  "percentage of engine waste heat to coolant"
                  annotation (Placement(transformation(extent={{0,20},{12,32}})));
                Modelica.Blocks.Math.Gain oil_heat_split(k=0.084859)
                  "percentage of engine waste heat to oil"
                  annotation (Placement(transformation(extent={{0,-32},{12,-20}})));
                Modelica.Blocks.Math.Gain exhaust_heat_split(k=0.68882)
                  "percentage of engine waste heat to exhaust"
                  annotation (Placement(transformation(extent={{0,-86},{12,-74}})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
                  ambient_heat_generation
                  annotation (Placement(transformation(extent={{42,70},{62,90}})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
                  coolant_heat_generation
                  annotation (Placement(transformation(extent={{42,16},{62,36}})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow oil_heat_generation
                  annotation (Placement(transformation(extent={{42,-36},{62,-16}})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
                  exhaust_heat_generation
                  annotation (Placement(transformation(extent={{42,-90},{62,-70}})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor exhaust_heat_capacitance(C=450*
                      engine_mass*0.1)
                  annotation (Placement(transformation(extent={{52,-86},{72,-106}})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor oil_conduction_path_capacitance(C=450*
                      engine_mass*0.3)
                  annotation (Placement(transformation(extent={{52,-34},{72,-54}})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor coolant_conduction_path_capacitance(C=450*
                      engine_mass*0.4)
                  annotation (Placement(transformation(extent={{52,18},{72,-2}})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor ambient_conduction_path_capacitance(C=450*
                      engine_mass*0.1)
                  annotation (Placement(transformation(extent={{52,72},{72,52}})));
              equation
                connect(engine_heat_in, heatFlowSensor.port_a) annotation (Line(
                    points={{-100,0},{-82,0}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(ambient_heat_split.y, ambient_heat_generation.Q_flow) annotation (
                    Line(
                    points={{12.6,80},{42,80}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(ambient_heat_generation.port, heat_to_ambient) annotation (Line(
                    points={{62,80},{100,80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(coolant_heat_generation.port, heat_to_coolant) annotation (Line(
                    points={{62,26},{100,26}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(coolant_heat_split.y, coolant_heat_generation.Q_flow) annotation (
                    Line(
                    points={{12.6,26},{42,26}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(ambient_heat_split.u, heatFlowSensor.Q_flow) annotation (Line(
                    points={{-1.2,80},{-36,80},{-36,26},{-72,26},{-72,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(coolant_heat_split.u, heatFlowSensor.Q_flow) annotation (Line(
                    points={{-1.2,26},{-72,26},{-72,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(oil_heat_split.u, heatFlowSensor.Q_flow) annotation (Line(
                    points={{-1.2,-26},{-36,-26},{-36,26},{-72,26},{-72,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(exhaust_heat_split.u, heatFlowSensor.Q_flow) annotation (Line(
                    points={{-1.2,-80},{-36,-80},{-36,26},{-72,26},{-72,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(exhaust_heat_generation.port, exhaust_heat_out) annotation (Line(
                    points={{62,-80},{100,-80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(oil_heat_generation.port, heat_to_oil) annotation (Line(
                    points={{62,-26},{100,-26}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(oil_heat_split.y, oil_heat_generation.Q_flow) annotation (Line(
                    points={{12.6,-26},{42,-26}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(exhaust_heat_split.y, exhaust_heat_generation.Q_flow) annotation (
                    Line(
                    points={{12.6,-80},{42,-80}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(exhaust_heat_capacitance.port, exhaust_heat_generation.port)
                                                                           annotation (Line(
                    points={{62,-86},{62,-80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(oil_conduction_path_capacitance.port, oil_heat_generation.port)
                  annotation (Line(
                    points={{62,-34},{62,-26}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(coolant_conduction_path_capacitance.port, coolant_heat_generation.port)
                  annotation (Line(
                    points={{62,18},{62,26}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(ambient_conduction_path_capacitance.port, ambient_heat_generation.port)
                  annotation (Line(
                    points={{62,72},{62,80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(thermal_To_Environment1.port, heatFlowSensor.port_b) annotation (Line(
                    points={{-62,-30},{-52,-30},{-52,0},{-62,0}},
                    color={191,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(graphics), Icon(graphics={Polygon(
                        points={{-34,-38},{-42,-18},{-44,-2},{-38,16},{-34,32},{-32,56},{
                            -24,42},{-16,26},{-12,12},{-6,40},{0,58},{10,78},{8,52},{14,
                            26},{26,42},{40,56},{52,62},{42,50},{34,38},{32,26},{42,-8},{
                            42,-22},{36,-38},{24,-46},{8,-54},{-12,-46},{-26,-44},{-30,
                            -42},{-34,-38}},
                        lineColor={0,0,255},
                        smooth=Smooth.None,
                        fillColor={255,0,0},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-150,-52},{150,-92}},
                        textString="%name",
                        lineColor={0,0,255})}),
                  Documentation(info="<html>
<p>Model Limitations: Current heat capacitance values are arbitrarily assigned, unlikely to be accurate.</p>
<p>Todo: Add more realistic values for heat capacitances</p>
</html>"));
              end Engine_Heating_Model_2;

              model Airflow_Submodel
                "Uses a volumetric efficiency map to calculate airflow as a function of speed and torque"
               parameter Real engine_displacement
                  "engine displacement in liters";
               parameter Real voleff[:,:] = [0,  600,  1200,  1500,  1800;0,  0.867641652,  0.867641652,  0.867641652,  0.867641652;300,  0.867641652,  1,  1.05,  1.1;400,  0.867641652,  1.027886075,  1.074580184,  1.122243498;500,  0.867641652,  1.027886075,  1.169487592,  1.318243069;600,  0.867641652,  1.098542293,  1.264395,  1.514242641;700,  0.867641652,  1.169198511,  1.359303369,  1.514242641;800,  0.867641652,  1.239854728,  1.454211738,  1.514242641;900,  0.867641652,  1.310510946,  1.454211738,  1.706250056;1000,  0.867641652,  1.391266152,  1.693757702,  1.898257471;1200,  0.867641652,  1.552776565,  1.933303667,  2.059404565;1300,  0.867641652,  1.633531772,  1.933303667,  2.220551658;1400,  0.867641652,  1.712133134,  2.11370574,  2.220551658;1600,  0.867641652,  1.790734496,  2.294107813,  2.220551658;1700,  0.867641652,  1.869335858,  2.294107813,  2.220551658;1800,  0.867641652,  1.94793722,  2.3,  2.220551658]
                  "Table of volumetric efficiency";

                Modelica.Blocks.Tables.CombiTable2D voleff_table(
                  y(quantity="MassFlowRate", unit="kg/s"),
                  smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
                  table=voleff)
                  annotation (Placement(transformation(extent={{-82,60},{-66,44}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a
                                                      intake_port(medium=Medium)
                  annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b
                                                      exhaust_port(medium=Medium)
                  annotation (Placement(transformation(extent={{90,-10},{110,10}})));
                Modelica.Blocks.Sources.Constant displacement(k=engine_displacement)
                  annotation (Placement(transformation(extent={{-78,28},{-70,36}})));
                Modelica.Blocks.Math.UnitConversions.From_litre convert_displacement_to_m3
                  annotation (Placement(transformation(extent={{-64,28},{-56,36}})));
                Modelica.Blocks.Math.Gain rpm_to_half_rps(k=1/120)
                  annotation (Placement(transformation(extent={{-22,68},{-30,76}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a exhaust_heat_in
                  annotation (Placement(transformation(extent={{30,88},{50,108}})));
                MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                        air_intake_boundary(                       medium=
                      Medium,
                  useMassFlowInput=true,
                  constantAmbientTemperature=293.15)
                  annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                      rotation=180,
                      origin={-30,0})));
                MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                        exhaust_gas_boundary(useMassFlowInput=
                     true, useTemperatureInput=true,
                  medium=Medium)
                  annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                      rotation=180,
                      origin={50,0})));
                MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Fluid_Transport
                                                   fluid_Transport(
                  diameter=0.05,
                  length=0.1,
                  medium=Medium,
                  h_g=0)
                  annotation (Placement(transformation(extent={{64,10},{84,-10}})));
                Modelica.Blocks.Math.MultiProduct
                                          density_correction_proportional_gain(nu=2)
                  annotation (Placement(transformation(extent={{-5,-5},{5,5}},
                      rotation=0,
                      origin={1,21})));
                Modelica.Blocks.Math.Gain gain2(k=-1)
                  "corrects direction of flow"
                  annotation (Placement(transformation(extent={{8,-12},{0,-4}})));
                Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                          temperature(medium=Medium)
                  annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                      rotation=0,
                      origin={-30,-30})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
                  annotation (Placement(transformation(extent={{-110,-90},{-90,-70}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b
                  annotation (Placement(transformation(extent={{90,-90},{110,-70}})));
                Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
                  annotation (Placement(transformation(extent={{-90,-70},{-70,-90}})));
                Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                   Placement(transformation(
                      extent={{10,-10},{-10,10}},
                      rotation=270,
                      origin={30,-70})));
                Modelica.Blocks.Math.UnitConversions.To_rpm to_rpm annotation (Placement(
                      transformation(
                      extent={{10,-10},{-10,10}},
                      rotation=270,
                      origin={30,50})));
                Modelica.Blocks.Math.MultiProduct multiProduct(nu=3)
                  annotation (Placement(transformation(extent={{-40,46},{-28,58}})));
                parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Medium = Modelica.Thermal.FluidHeatFlow.Media.Medium();
                MSL_Extend.Thermal.FluidHeatFlow.Sensors.DensitySensor
                                                      density(medium=Medium)
                  annotation (Placement(transformation(extent={{-40,10},{-20,30}})));
                Modelica.Thermal.HeatTransfer.Components.ThermalConductor
                  thermalConductor(G=1e9) annotation (Placement(transformation(
                        extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={74,50})));
              equation
                connect(displacement.y, convert_displacement_to_m3.u)
                                                      annotation (Line(
                    points={{-69.6,32},{-64.8,32}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(flange_a, torqueSensor.flange_a) annotation (Line(
                    points={{-100,-80},{-90,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(torqueSensor.flange_b, speedSensor.flange) annotation (Line(
                    points={{-70,-80},{30,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.flange, flange_b) annotation (Line(
                    points={{30,-80},{100,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.w, to_rpm.u) annotation (Line(
                    points={{30,-59},{30,38}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(to_rpm.y, voleff_table.u2) annotation (Line(
                    points={{30,61},{30,80},{-88,80},{-88,56.8},{-83.6,56.8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(to_rpm.y, rpm_to_half_rps.u) annotation (Line(
                    points={{30,61},{30,72},{-21.2,72}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(rpm_to_half_rps.y, multiProduct.u[1]) annotation (Line(
                    points={{-30.4,72},{-54,72},{-54,54.8},{-40,54.8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(voleff_table.y, multiProduct.u[2]) annotation (Line(
                    points={{-65.2,52},{-40,52}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(convert_displacement_to_m3.y, multiProduct.u[3]) annotation (Line(
                    points={{-55.6,32},{-54,32},{-54,49.2},{-40,49.2}},
                    color={0,0,127},
                    smooth=Smooth.None));

                connect(torqueSensor.tau, voleff_table.u1) annotation (Line(
                    points={{-88,-69},{-88,47.2},{-83.6,47.2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(density_correction_proportional_gain.y, gain2.u) annotation (Line(
                    points={{6.85,21},{20,21},{20,-8},{8.8,-8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(gain2.y, air_intake_boundary.massflow) annotation (Line(
                    points={{-0.4,-8},{-20,-8},{-20,-7}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(exhaust_gas_boundary.flowPort, fluid_Transport.flowPort_a)
                  annotation (Line(
                    points={{60,-1.33227e-015},{60,0},{64,0}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(density_correction_proportional_gain.y, exhaust_gas_boundary.massflow)
                  annotation (Line(
                    points={{6.85,21},{40,21},{40,7}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(temperature.y, exhaust_gas_boundary.ambientTemperature) annotation (
                    Line(
                    points={{-19,-30},{40,-30},{40,-7}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(fluid_Transport.flowPort_b, exhaust_port) annotation (Line(
                    points={{84,0},{100,0}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(air_intake_boundary.flowPort, intake_port) annotation (
                    Line(
                    points={{-40,1.33227e-015},{-100,1.33227e-015},{-100,0}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(multiProduct.y, density_correction_proportional_gain.u[
                  1]) annotation (Line(
                    points={{-26.98,52},{-4,52},{-4,22.75}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(density.y, density_correction_proportional_gain.u[2])
                  annotation (Line(
                    points={{-19,20},{-4,20},{-4,19.25}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(fluid_Transport.heatPort, thermalConductor.port_b)
                  annotation (Line(
                    points={{74,10},{74,40}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(thermalConductor.port_a, exhaust_heat_in) annotation (
                    Line(
                    points={{74,60},{74,98},{40,98}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(air_intake_boundary.flowPort, density.flowPort) annotation (Line(
                    points={{-40,1.33227e-015},{-40,20}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(air_intake_boundary.flowPort, temperature.flowPort) annotation (Line(
                    points={{-40,1.33227e-015},{-40,-30}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                          -100},{100,100}}),
                                    graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                        extent={{-100,-100},{100,100}}), graphics={
                      Rectangle(
                        extent={{-100,100},{200,-100}},
                        lineColor={0,0,255},
                        fillPattern=FillPattern.Solid,
                        fillColor={255,255,255}),
                      Polygon(
                        points={{110,16},{150,1},{110,-14},{110,16}},
                        lineColor={0,128,255},
                        smooth=Smooth.None,
                        fillColor={0,128,255},
                        fillPattern=FillPattern.Solid,
                        visible=showDesignFlowDirection),
                      Polygon(
                        points={{110,11},{140,1},{110,-9},{110,11}},
                        lineColor={255,255,255},
                        smooth=Smooth.None,
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        visible=allowFlowReversal),
                      Line(
                        points={{145,1},{-64,2}},
                        color={0,128,255},
                        smooth=Smooth.None,
                        visible=showDesignFlowDirection),
                      Line(
                        points={{40,88},{40,8}},
                        color={200,0,0},
                        smooth=Smooth.None),
                      Line(
                        points={{60,28},{40,8},{20,28}},
                        color={200,0,0},
                        smooth=Smooth.None),
                      Text(
                        extent={{-160,-10},{260,-70}},
                        lineColor={85,170,255},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        textString="air path")}),
                  Documentation(info="<html>
<p>Operation:</p>
<p>When used as part of an engine model, this model draws air through an intake path and pushes it out through an exhaust pathway, after adding heat to it. The amount of is calculated using the engine displacement, volumetric efficiency, and rotational speed. The mass of the fuel consumed by the engine is added into the exhaust stream. There is also a path for heat generated by the engine to be added to the exhaust stream.</p>
<p><br/>Model Limitations: </p>
<p>The model currently models the exhaust gas stream as air, rather than exhaust gases.</p>
<p>Intake and exhaust systems need to be modeled separately from this model.</p>
<p><br/>Physical Limits:</p>
</html>"));
              end Airflow_Submodel;

              model Dummy_Turbo
                "Do nothing turbo component to make transition between table and MVEM model easier"

                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a from_filter(medium=medium) annotation (Placement(transformation(extent={{-90,90},{-70,110}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b to_cac(medium=medium) annotation (Placement(transformation(extent={{-30,90},{-10,110}}),
                      iconTransformation(extent={{-30,90},{-10,110}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a exh_from_engine(medium=medium) annotation (Placement(transformation(extent={{10,-110},{30,
                          -90}}), iconTransformation(extent={{10,-110},{30,-90}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b exh_to_downpipe(medium=medium) annotation (Placement(transformation(extent={{70,90},{90,
                          110}}), iconTransformation(extent={{70,90},{90,110}})));
                parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium = Modelica.Thermal.FluidHeatFlow.Media.Air_30degC();
              equation
                connect(from_filter, to_cac) annotation (Line(
                    points={{-80,100},{-80,80},{-20,80},{-20,100},{-20,100}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(exh_to_downpipe, exh_from_engine) annotation (Line(
                    points={{80,100},{80,0},{20,0},{20,-100}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                          -100},{100,100}}),
                                    graphics), Icon(graphics={
                      Polygon(
                        points={{-80,60},{-58,60},{-20,20},{-20,-20},{-60,-60},{-80,-60},{-80,
                            60}},
                        lineColor={0,0,255},
                        smooth=Smooth.None,
                        fillColor={135,135,135},
                        fillPattern=FillPattern.Solid),
                      Polygon(
                        points={{-30,60},{-8,60},{30,20},{30,-20},{-10,-60},{-30,-60},{-30,60}},
                        lineColor={0,0,255},
                        smooth=Smooth.None,
                        origin={50,0},
                        rotation=180,
                        fillPattern=FillPattern.Solid,
                        fillColor={135,135,135}),
                      Line(
                        points={{-80,90},{-80,62},{-80,60}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-20,20},{-20,100}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{20,-100},{20,-20}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{80,60},{80,100}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-80,60},{-70,70}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-30,80},{-20,90}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{10,-30},{20,-20}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Line(
                        points={{70,80},{80,90}},
                        color={0,0,255},
                        smooth=Smooth.None),
                      Rectangle(
                        extent={{-20,8},{20,-8}},
                        lineColor={0,0,255},
                        fillColor={135,135,135},
                        fillPattern=FillPattern.Solid)}));
              end Dummy_Turbo;

              model Engine_To_Starter_Motor_Bridge

                Modelica.Blocks.Math.BooleanToReal booleanToReal
                  annotation (Placement(transformation(extent={{4,-10},{24,10}})));
                Modelica.Blocks.Logical.And and1
                  annotation (Placement(transformation(extent={{-32,-10},{-12,10}})));
                Modelica.Blocks.Logical.Not not1
                  annotation (Placement(transformation(extent={{-66,-30},{-46,-10}})));
                Modelica.Blocks.Interfaces.BooleanInput starter_engage
                  annotation (Placement(transformation(extent={{-120,0},{-80,40}})));
                Modelica.Blocks.Interfaces.BooleanInput engine_running
                  annotation (Placement(transformation(extent={{-120,-40},{-80,0}})));
                Modelica.Blocks.Interfaces.RealOutput demand
                  annotation (Placement(transformation(extent={{90,-10},{110,10}})));
              public
                Modelica.Blocks.Continuous.Filter filter(f_cut=1)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={60,0})));
              equation
                connect(and1.y, booleanToReal.u) annotation (Line(
                    points={{-11,0},{2,0}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(not1.y, and1.u2) annotation (Line(
                    points={{-45,-20},{-40,-20},{-40,-8},{-34,-8}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(and1.u1, starter_engage) annotation (Line(
                    points={{-34,0},{-60,0},{-60,20},{-100,20}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(not1.u, engine_running) annotation (Line(
                    points={{-68,-20},{-100,-20}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(demand, filter.y) annotation (Line(
                    points={{100,0},{71,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(filter.u, booleanToReal.y) annotation (Line(
                    points={{48,0},{25,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                          -100},{100,100}}),
                                    graphics), Icon(graphics));
              end Engine_To_Starter_Motor_Bridge;

              model Torque_And_Fueling_1_Advanced "Torque and Fuel Maps"
               parameter SI.Torque friction_map[:,2] = [0,0;1,1]
                  "Table of speed (rpm) vs engine friction torque";
               parameter SI.Torque torque_map[:,2] =  [0,0;1,1]
                  " Table of speed(rpm) vs engine torque at WOT";
               parameter SI.MassFlowRate fuel_map[:,:] =  [0,0;1,1]
                  "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
               parameter SI.AngularVelocity crank_speed=62.831853071796
                  "crank speed";
               parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Fuel_Medium = C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8();
                Modelica.Mechanics.Rotational.Sources.Torque torque_produced(useSupport=true)
                  annotation (Placement(transformation(extent={{52,-8},{68,8}})));
                Modelica.Blocks.Math.UnitConversions.To_rpm convert_speed_to_rpm
                  annotation (Placement(transformation(
                      origin={58,60},
                      extent={{10,-10},{-10,10}},
                      rotation=0)));
                Modelica.Blocks.Math.Gain fuel_energy_density(k=45800000)
                  annotation (Placement(transformation(extent={{-8,-8},{8,8}},
                      rotation=0,
                      origin={136,84})));
                Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow engine_heat_generation(T_ref=
                      673.15)
                  annotation (Placement(transformation(extent={{176,72},{192,88}})));
                Modelica.Blocks.Math.Add fuel_energy_less_generated_power(k2=-1)
                  annotation (Placement(transformation(extent={{156,72},{172,88}})));
                Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
                   Placement(transformation(
                      extent={{-8,-8},{8,8}},
                      rotation=90,
                      origin={80,8})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a engine_heat_out
                  annotation (Placement(transformation(extent={{192,72},{208,88}})));
                Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
                  annotation (Placement(transformation(extent={{90,8},{106,-8}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
                  annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b
                  annotation (Placement(transformation(extent={{190,-10},{210,10}})));
                Modelica.Mechanics.Rotational.Interfaces.Support support
                  annotation (Placement(transformation(extent={{40,-108},{60,-88}})));

              public
                Modelica.Blocks.Tables.CombiTable1D friction_table(
                  smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
                  columns={2},
                  table=friction_map)
                  annotation (Placement(transformation(extent={{-6,-6},{6,6}},
                      rotation=270,
                      origin={-68,38})));
              protected
                parameter Real friction_map_rads[:,2] = [(friction_map[:,1]*pi/30),(friction_map[:,2])];
              public
                Modelica.Mechanics.Rotational.Sensors.PowerSensor powerSensor
                  annotation (Placement(transformation(extent={{146,8},{162,-8}})));
                Fuel_Map_From_Torque_And_Speed fuel_Map(fuel_table=fuel_map)
                  annotation (Placement(transformation(extent={{110,-10},{130,10}})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Proportional_Combining proportional_Combining
                  annotation (Placement(transformation(extent={{-10,-16},{10,4}})));
                Modelica.Blocks.Math.Gain gain(k=-1)
                  annotation (Placement(transformation(extent={{-60,-22},{-40,-2}})));
                C2M2L_OM.MSL_Extend.Blocks.Tables.Limited_Map
                            limited_Map(table=torque_map, alt_table=friction_map)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-40,28})));
                Modelica.Mechanics.Rotational.Components.Clutch clutch(fn_max=
                      max_resistive_torque)
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={80,-66})));
                C2M2L_OM.MSL_Extend.Blocks.Math.Positive_Negative_Split positive_Negative_Split
                  annotation (Placement(transformation(extent={{20,-16},{40,4}})));
                parameter SI.Force max_resistive_torque = 100000
                  "Maximum torque the engine can resist";
                Modelica.Blocks.Math.Gain gain1(k=-1/max_resistive_torque)
                  annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                      rotation=90,
                      origin={46,-50})));
                Modelica.Blocks.Interfaces.RealOutput speed annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-60,166})));
              public
                Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out annotation (
                    Placement(transformation(
                      extent={{-20,-20},{20,20}},
                      rotation=270,
                      origin={20,170})));
                Modelica.Blocks.Interfaces.RealOutput net_torque annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={100,166})));
                Modelica.Blocks.Interfaces.RealOutput fuel_flow annotation (
                    Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={60,166})));
                Modelica.Blocks.Math.Gain flip_fuel_dir(k=-1)
                  annotation (Placement(transformation(extent={{-4,-4},{4,4}},
                      rotation=90,
                      origin={120,98})));
                MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                                massFlowSource(medium=
                      Fuel_Medium, useMassFlowInput=true) annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={140,126})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a port_a(medium=
                      Fuel_Medium)
                  annotation (Placement(transformation(extent={{130,150},{150,170}})));
                Engine_Operation_Sensor engine_Operation_Sensor(crank_speed=crank_speed)
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={44,84})));
                Modelica.Blocks.Interfaces.BooleanOutput engine_running annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-20,166})));
              equation

                connect(fuel_energy_less_generated_power.y, engine_heat_generation.Q_flow)
                                                          annotation (Line(
                    points={{172.8,80},{176,80}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(convert_speed_to_rpm.u, speedSensor.w)
                                                  annotation (Line(
                    points={{70,60},{80,60},{80,16.8}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(engine_heat_generation.port, engine_heat_out)
                                                         annotation (Line(
                    points={{192,80},{200,80}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(torque_produced.support, support)
                                                 annotation (Line(
                    points={{60,-8},{60,-98},{50,-98}},
                    color={0,0,0},
                    smooth=Smooth.None));

                connect(convert_speed_to_rpm.y, friction_table.u[1])
                                                       annotation (Line(
                    points={{47,60},{-68,60},{-68,45.2}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(flange_a, flange_b) annotation (Line(
                    points={{-100,0},{-100,-112},{200,-112},{200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_energy_density.y, fuel_energy_less_generated_power.u1)
                  annotation (Line(
                    points={{144.8,84},{154.4,84},{154.4,84.8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(powerSensor.flange_b, flange_b) annotation (Line(
                    points={{162,0},{200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(speedSensor.flange, torqueSensor.flange_a) annotation (Line(
                    points={{80,0},{90,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_Map.fuel_rate, fuel_energy_density.u) annotation (Line(
                    points={{120,11},{120,84},{126.4,84}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torqueSensor.flange_b, fuel_Map.flange_a) annotation (Line(
                    points={{106,0},{110,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(fuel_Map.flange_b, powerSensor.flange_a) annotation (Line(
                    points={{130,0},{146,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(powerSensor.power, fuel_energy_less_generated_power.u2) annotation (
                    Line(
                    points={{147.6,8.8},{147.6,52},{148,52},{148,75.2},{154.4,75.2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torque_produced.flange, speedSensor.flange) annotation (Line(
                    points={{68,0},{80,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(friction_table.y[1], gain.u) annotation (Line(
                    points={{-68,31.4},{-68,-12},{-62,-12}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(gain.y, proportional_Combining.u2) annotation (Line(
                    points={{-39,-12},{-12,-12}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(limited_Map.u, convert_speed_to_rpm.y) annotation (Line(
                    points={{-40,40},{-40,60},{47,60}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(limited_Map.y, proportional_Combining.u1) annotation (Line(
                    points={{-40,17},{-40,0},{-12,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(clutch.flange_a, support) annotation (Line(
                    points={{80,-76},{80,-98},{50,-98}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(clutch.flange_b, speedSensor.flange) annotation (Line(
                    points={{80,-56},{80,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(proportional_Combining.y, positive_Negative_Split.u) annotation (Line(
                    points={{11,-6},{18,-6}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(positive_Negative_Split.y_pos, torque_produced.tau) annotation (Line(
                    points={{41,0},{50.4,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(positive_Negative_Split.y_neg, gain1.u) annotation (Line(
                    points={{41,-12},{46,-12},{46,-38}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(gain1.y, clutch.f_normalized) annotation (Line(
                    points={{46,-61},{46,-66},{69,-66}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(torqueSensor.tau, net_torque) annotation (Line(
                    points={{91.6,8.8},{91.6,98},{92,98},{92,148},{100,148},{100,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(fuel_Map.fuel_rate, fuel_flow) annotation (Line(
                    points={{120,11},{120,84},{60,84},{60,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(ECU_Throttle_Out, proportional_Combining.p) annotation (
                    Line(
                    points={{20,170},{20,20},{-20,20},{-20,-30},{0,-30},{0,-18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(flip_fuel_dir.u, fuel_Map.fuel_rate) annotation (Line(
                    points={{120,93.2},{120,11}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(massFlowSource.flowPort, port_a) annotation (Line(
                    points={{140,136},{140,160}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(massFlowSource.massflow, flip_fuel_dir.y) annotation (Line(
                    points={{147,116},{147,108},{120,108},{120,102.4}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(speedSensor.w, engine_Operation_Sensor.EngineSpeed) annotation (Line(
                    points={{80,16.8},{80,82},{54.2,82},{54.2,82.8}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(engine_Operation_Sensor.y, engine_running) annotation (Line(
                    points={{33.4,82},{-20,82},{-20,166}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(convert_speed_to_rpm.y, speed) annotation (Line(
                    points={{47,60},{-60,60},{-60,166}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                          -100},{200,160}}),      graphics), Icon(coordinateSystem(
                        preserveAspectRatio=true, extent={{-100,-100},{200,160}}),
                      graphics={
                      Rectangle(
                        extent={{-100,160},{200,-100}},
                        lineColor={0,0,255},
                        fillPattern=FillPattern.Solid,
                        fillColor={255,255,255}),
                      Rectangle(
                        extent={{-44,76},{-4,56}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-26,56},{-22,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,36},{28,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{6,56},{46,36}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{74,56},{78,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{56,76},{96,56}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{106,56},{146,36}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{124,36},{128,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-46,16},{-2,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{0,-4},{50,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{104,-4},{148,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{48,16},{52,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{52,16},{100,10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{100,16},{104,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{144,16},{148,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-50,16},{-46,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,4},{-46,-2}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{148,4},{192,-2}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-26,66},{-22,62}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{24,46},{28,42}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{74,66},{78,62}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{124,44},{128,40}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-2,16},{2,-10}},
                        lineColor={0,0,255},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-102,-28},{198,-68}},
                        textString="%name",
                        lineColor={0,0,255})}));
              end Torque_And_Fueling_1_Advanced;
            end Sub_Models;
          end Table_Based_Engine;
        end Compression_Ignition;
      end Reciprocating;
    end Prime_Movers;

    package Suspension "Components of the suspension system"
      extends Modelica.Icons.Package;

      package Submodels
        extends Modelica.Icons.Package;

        block Interpolate "Interpolates a value from two inputs and a scalar"
          extends Modelica.Blocks.Interfaces.SI2SO;
          parameter Real scale(min=0,max=1)
            "Ratio of desired output between the inputs (=0, lower input; =1, upper input)";

        equation
              y = smooth(1, u2 + (scale*(u1-u2)));
          annotation (Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1),
                           graphics={
            Line(points={{-94,0},{90,0}}, color={192,192,192}),
            Line(points={{0,-94},{0,90}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{90,0},{68,8},{68,-8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-40},{-60,-40}}, color={192,192,192}),
                Line(
                  points={{-70,-30},{-50,-10},{-10,-2},{0,0},{10,2},{50,10},{70,30}},
                  color={0,0,255},
                  smooth=Smooth.Bezier),
            Line(points={{-80,20},{-60,20}}, color={192,192,192}),
                Text(
                  extent={{-10,8},{10,-8}},
                  lineColor={0,0,0},
                  origin={-90,20},
                  rotation=180,
                  textString="y1"),
                Text(
                  extent={{-10,8},{10,-8}},
                  lineColor={0,0,0},
                  origin={-90,-40},
                  rotation=180,
                  textString="y0"),
                Line(
                  points={{-70,-60},{-40,-56},{-10,-40},{0,0},{10,40},{40,56},{70,60}},
                  color={255,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,-44},{-40,-34},{-10,-20},{0,0},{10,20},{40,34},{70,44}},
                  color={255,0,255},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dash)}),     Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1), graphics));
        end Interpolate;

        block Interpolate_damping
          "Interpolates a value from two inputs and a scalar.  Has additional input port to determine if compression or rebound damping is happening"
          extends Modelica.Blocks.Interfaces.SI2SO;

          parameter Real compression_scale(min=0, max=1) = 0.0
            "Scale factor between min and max force curves - Compression damping";
          parameter Real rebound_scale(min=0, max=1) = 0.0
            "Scale factor between min and max force curves - Rebound damping";

        public
          Modelica.Blocks.Interfaces.RealInput
                    u3 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-110}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120})));
        equation
         if noEvent(u3>=0) then
           y = u2 + (rebound_scale*(u1-u2));
         else
           y = u2 + (compression_scale*(u1-u2));
         end if;

          annotation (Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1),
                           graphics={
            Line(points={{-94,0},{90,0}}, color={192,192,192}),
            Line(points={{0,-94},{0,90}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{90,0},{68,8},{68,-8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-40},{-60,-40}}, color={192,192,192}),
                Line(
                  points={{-70,-30},{-50,-10},{-10,-2},{0,0},{10,2},{50,10},{70,30}},
                  color={0,0,255},
                  smooth=Smooth.Bezier),
            Line(points={{-80,20},{-60,20}}, color={192,192,192}),
                Text(
                  extent={{-10,8},{10,-8}},
                  lineColor={0,0,0},
                  origin={-90,20},
                  rotation=180,
                  textString="y1"),
                Text(
                  extent={{-10,8},{10,-8}},
                  lineColor={0,0,0},
                  origin={-90,-40},
                  rotation=180,
                  textString="y0"),
                Line(
                  points={{-70,-60},{-40,-56},{-10,-40},{0,0},{10,40},{40,56},{70,60}},
                  color={255,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,-44},{-40,-34},{-10,-20},{0,0},{10,20},{40,34},{70,44}},
                  color={255,0,255},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dash)}),     Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.1), graphics));
        end Interpolate_damping;

        model Elasto_Gap_Belt_Tension
          "1D translational spring damper combination with gap working in tension and comparing 3D distance with 1D free length"
          extends
            Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates;
          parameter Real c(
            final unit="N/m",
            final min=0,
            start=1) "Spring constant";
          parameter Real d(
            final unit="N/ (m/s)",
            final min=0,
            start=1) "Damping constant";
          Modelica.SIunits.Position s_rel0 "Unstretched spring length";
          parameter Real n(final min=1) = 1
            "Exponent of spring force ( f_c = -c*|s_rel-s_rel0|^n )";
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

        /*
Please note that initialization might fail due to the nonlinear spring characteristic
(spring force is zero for s_rel > s_rel0)
if a positive force is acting on the element and no other force balances this force
(e.g., when setting both initial velocity and acceleration to 0)
*/
          Boolean contact "=true, if contact, otherwise no contact";
        //protected
          Modelica.SIunits.Force f_c "Spring force";
          Modelica.SIunits.Force f_d2 "Linear damping force";
          Modelica.SIunits.Force f_d
            "Linear damping force which is limited by spring force (|f_d| <= |f_c|)";
          Modelica.Mechanics.Translational.Interfaces.Flange_a flange_3D_a
            "Left flange of compliant 1-dim. translational component"
            annotation (Placement(transformation(extent={{-90,90},{-70,110}},
                  rotation=0)));
          Modelica.Mechanics.Translational.Interfaces.Flange_b flange_3D_b
            "Right flange of compliant 1-dim. transational component"
            annotation (Placement(transformation(extent={{70,90},{90,110}},
                  rotation=0)));
        equation
          s_rel0 = flange_3D_b.s - flange_3D_a.s;
          flange_3D_a.f = 0;
          flange_3D_b.f = 0;
          // Modify contact force, so that it is only "pushing" and not
          // "pulling/sticking" and that it is continous

          contact = s_rel < s_rel0;
          f_c = smooth(1, noEvent(if contact then -c*abs(s_rel - s_rel0)^n else 0));
          f_d2 = if contact then d*v_rel else 0;
          f_d = smooth(0, noEvent(if contact then (if f_d2 < f_c then f_c else if f_d2 >
            -f_c then -f_c else f_d2) else 0));
            if initial() then
              f = 0;
          //  f = f_c + f_d;
             else
            f = f_c + f_d;
          end if;
        //   when {not initial()} then
        //     reinit(s_rel, s_rel0);
        //   end when;

          lossPower = f_d*v_rel;
          annotation (
            Window(
              x=0.23,
              y=0.04,
              width=0.62,
              height=0.69),
            Documentation(info="<html>
<p>
This component models a spring damper combination that can lift off.
It can be connected between a sliding mass and the housing (model
<a href=\"modelica://Modelica.Mechanics.Translational.Components.Fixed\">Fixed</a>),
to describe the contact of a sliding mass with the housing.
</p>

<p>
As long as s_rel &gt; s_rel0, no force is exerted (s_rel = flange_b.s - flange_a.s).
If s_rel &le; s_rel0, the contact force is basically computed with a linear
spring/damper characteristic. With parameter n&ge;1 (exponent of spring force),
a nonlinear spring force can be modeled:
</p>

<pre>
   desiredContactForce = c*|s_rel - s_rel0|^n + d*<b>der</b>(s_rel)
</pre>

<p>
Note, Hertzian contact is described by:
</p>
<ul>
<li> Contact between two metallic spheres: n=1.5</li>
<li> Contact between two metallic plates: n=1</li>
</ul>

<p>
The above force law leads to the following difficulties:
</p>

<ol>
<li> If the damper force becomes larger as the spring force and with opposite sign,
     the contact force would be \"pulling/sticking\" which is unphysical, since during
     contact only pushing forces can occur.</li>

<li> When contact occurs with a non-zero relative speed (which is the usual
     situation), the damping force has a non-zero value and therefore the contact
     force changes discontinuously at s_rel = s_rel0. Again, this is not physical
     because the force can only change continuously. (Note, this component is not an
     idealized model where a steep characteristic is approximated by a discontinuity,
     but it shall model the steep characteristic.)</li>
</ol>

<p>
In the literature there are several proposals to fix problem (2). Especially, often
the following model is used (see, e.g.,
Lankarani, Nikravesh: Continuous Contact Force Models for Impact
Analysis in Multibody Systems, Nonlinear Dynamics 5, pp. 193-207, 1994,
<a href=\"http://www.springerlink.com/content/h50x61270q06p65n/fulltext.pdf\">pdf-download</a>):
</p>

<pre>
   f = c*s_rel^n + (d*s_rel^n)*<b>der</b>(s_rel)
</pre>

<p>
However, this and other models proposed in literature violate
issue (1), i.e., unphysical pulling forces can occur (if d*<b>der</b>(s_rel)
becomes large enough). Note, if the force law is of the form \"f = f_c + f_d\", then a
necessary condition is that |f_d| &le; |f_c|, otherwise (1) and (2) are violated.
For this reason, the most simplest approach is used in the ElastoGap model
to fix both problems by using this necessary condition in the force law directly.
If s_rel0 = 0, the equations are:
</p>

<pre>
    <b>if</b> s_rel &ge; 0 <b>then</b>
       f = 0;    // contact force
    <b>else</b>
       f_c  = -c*|s_rel|^n;          // contact spring force (Hertzian contact force)
       f_d2 = d*<b>der</b>(s_rel);         // linear contact damper force
       f_d  = <b>if</b> f_d2 &lt;  f_c <b>then</b>  f_c <b>else</b>
              <b>if</b> f_d2 &gt; -f_c <b>then</b> -f_c <b>else</b> f_d2;  // bounded damper force
       f    = f_c + f_d;            // contact force
    <b>end if</b>;
</pre>

<p>
Note, since |f_d| &le; |f_c|, pulling forces cannot occur and the contact force
is always continuous, especially around the start of the penetration at s_rel = s_rel0.
</p>

<p>
In the next figure, a typical simulation with the ElastoGap model is shown
(<a href=\"modelica://Modelica.Mechanics.Translational.Examples.ElastoGap\">Examples.ElastoGap</a>)
where the different effects are visualized:
</p>

<ol>
<li> Curve 1 (elastoGap1.f) is the unmodified contact force, i.e., the linear spring/damper
     characteristic. A pulling/sticking force is present at the end of the contact.</li>
<li> Curve 2 (elastoGap2.f) is the contact force, where the force is explicitly set to
     zero when pulling/sticking occurs. The contact force is discontinuous when contact starts.</li>
<li> Curve 3 (elastoGap3.f) is the ElastoGap model of this library. No discontinuity and no
     pulling/sticking occurs.</li>
</ol>

<img src=\"modelica://Modelica/Resources/Images/Translational/ElastoGap1.png\">
</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(points={{-100,0},{-50,0}}, color={0,127,0}),
                Line(
                  points={{-48,34},{-48,-46}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{8,40},{8,2}}, color={0,0,0}),
                Line(points={{-2,0},{38,0},{38,44},{-2,44}}, color={0,0,0}),
                Line(points={{38,22},{72,22}}, color={0,0,0}),
                Line(
                  points={{-12,-38},{-12,20}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{-12,22},{8,22}}, color={0,0,0}),
                Line(points={{-12,-38},{-2,-38}}, color={0,0,0}),
                Line(points={{72,0},{100,0}}, color={0,127,0}),
                Line(points={{72,22},{72,-42}}, color={0,0,0}),
                Line(points={{-2,-38},{10,-28},{22,-48},{38,-28},{50,-48},{64,-28},{72,-40}},
                    color={0,0,0}),
                Rectangle(
                  extent={{8,44},{38,0}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-64,-80},{64,-64}},
                  lineColor={0,0,255},
                  textString="s_rel"),
                Line(points={{-100,-29},{-100,-61}}, color={0,0,0}),
                Line(points={{100,-61},{100,-28}}, color={0,0,0}),
                Line(points={{-98,-60},{98,-60}}, color={0,0,0}),
                Polygon(
                  points={{-101,-60},{-96,-59},{-96,-61},{-101,-60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{100,-60},{95,-61},{95,-59},{100,-60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(points={{-98,0},{-48,0}}, color={0,127,0}),
                Line(
                  points={{-48,38},{-48,-38}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{8,-10},{8,-48}}, color={0,0,0}),
                Line(points={{-2,-50},{38,-50},{38,-6},{-2,-6}}, color={0,0,0}),
                Line(points={{38,-28},{72,-28}}, color={0,0,0}),
                Line(
                  points={{-12,-38},{-12,36}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{-12,-28},{8,-28}}, color={0,0,0}),
                Line(points={{-12,24},{-6,24}}, color={0,0,0}),
                Line(points={{72,0},{98,0}}, color={0,127,0}),
                Line(points={{72,22},{72,-42}}, color={0,0,0}),
                Line(points={{-6,24},{6,34},{18,14},{34,34},{46,14},{60,34},{68,22}},
                    color={0,0,0}),
                Rectangle(
                  extent={{8,-6},{38,-50}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-52,-70},{28,-70}}, color={0,0,0}),
                Polygon(
                  points={{58,-70},{28,-60},{28,-80},{58,-70}},
                  lineColor={128,128,128},
                  fillColor={128,128,128},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  extent={{-150,-125},{150,-95}},
                  lineColor={0,0,0},
                  textString="c=%c"),
                Text(
                  extent={{-150,-160},{150,-130}},
                  lineColor={0,0,0},
                  textString="d=%d"),
                Line(points={{68,22},{72,22}}, color={0,0,0}),
                Line(
                  visible=useHeatPort,
                  points={{-100,-100},{-100,-44},{22,-44},{22,-28}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None)}));
        end Elasto_Gap_Belt_Tension;

        model NonLinearSpring2
          "Non-linear 1D translational spring - for bumpstop"

          extends Modelica.Mechanics.Translational.Interfaces.PartialCompliant;
        Modelica.SIunits.TranslationalSpringConstant c(final min=0, start=1)
            "Spring constant ";
            parameter Real a "First Coefficient of quadratic equation";
            parameter Real b "Second Coefficient of quadratic equation";
            parameter Real k "Spring constant";
          parameter Modelica.SIunits.Distance s_rel0=0
            "Unstretched spring length";
        public
            Integer trigger(start=0);
           parameter Real TargetInput;
          Modelica.Blocks.Interfaces.RealInput TestInput
            annotation (Placement(transformation(extent={{-116,56},{-76,96}})));
        equation
          c=a*((TestInput - TargetInput)^2)+b*(TestInput - TargetInput)+k;
          f = trigger*c*(TestInput - TargetInput);

          if (TestInput>TargetInput) then   trigger=0; else trigger=1;
          end if;
          annotation (
            Documentation(info="<html>
<p>
A <i>linear 1D translational spring</i>. The component can be connected either
between two sliding masses, or between
a sliding mass and the housing (model Fixed), to describe
a coupling of the sliding mass with the housing via a spring.
</p>

</HTML>
"),         Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(points={{-60,-90},{20,-90}}, color={0,0,0}),
                Polygon(
                  points={{50,-90},{20,-80},{20,-100},{50,-90}},
                  lineColor={128,128,128},
                  fillColor={128,128,128},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,90},{150,50}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{-98,0},{-60,0},{-44,-30},{-16,30},{14,-30},{44,30},{
                      60,0},{100,0}},color={0,0,0}),
                Text(
                  extent={{-150,-45},{150,-75}},
                  lineColor={0,0,0},
                  textString="c=%c")}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(points={{-100,0},{-100,65}}, color={128,128,128}),
                Line(points={{100,0},{100,65}}, color={128,128,128}),
                Line(points={{-100,60},{100,60}}, color={128,128,128}),
                Polygon(
                  points={{90,63},{100,60},{90,57},{90,63}},
                  lineColor={128,128,128},
                  fillColor={128,128,128},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-56,66},{36,81}},
                  lineColor={0,0,255},
                  textString="s_rel"),
                Line(points={{-86,0},{-60,0},{-44,-30},{-16,30},{14,-30},{44,30},{
                      60,0},{84,0}}, color={0,0,0})}));
        end NonLinearSpring2;
      end Submodels;

      package Suspension_Components
        extends Modelica.Icons.Package;

        model Damper_From_Table_With_Range
          "Damper with force determined from a force vs velocity table"
          import Modelica.Mechanics.MultiBody.Types;
          parameter Boolean animation=true
            "= true, if animation shall be enabled";
          parameter Modelica.SIunits.Distance length_a=world.defaultForceLength
            " Length of cylinder at frame_a side"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input SI.Diameter diameter_a=world.defaultForceWidth
            " Diameter of cylinder at frame_a side"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input SI.Diameter diameter_b=0.6*diameter_a
            " Diameter of cylinder at frame_b side"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input Types.Color color_a={100,100,100} " Color at frame_a"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
          input Types.Color color_b={155,155,155} " Color at frame_b"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
          input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
            "Reflection of ambient light (= 0: light is completely absorbed)"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));

        //  extends Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce;
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
             final T=293.15);
            parameter Modelica.SIunits.Mass m_damper(min=0) "Mass of damper";
            parameter Modelica.SIunits.Length L_max
            "Maximum extended length of damper";
            parameter Modelica.SIunits.Length L_min
            "Minimum compressed length of damper";
        protected
          Real e_a[3] = cat(1, Modelica.Math.Vectors.normalize(r_rel_a), {0});
          SI.Position r0_b[3]=e_a*noEvent(min(length_a, s));
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_a(
            shapeType="cylinder",
            color=color_a,
            specularCoefficient=specularCoefficient,
            length=noEvent(min(length_a, s)),
            width=diameter_a,
            height=diameter_a,
            lengthDirection=e_a,
            widthDirection={0,1,0},
            r=cat(1, frame_a.s, {0}),
            R=C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_b(
            shapeType="cylinder",
            color=color_b,
            specularCoefficient=specularCoefficient,
            length=noEvent(max(s - length_a, 0)),
            width=diameter_b,
            height=diameter_b,
            lengthDirection=e_a,
            widthDirection={0,1,0},
            r_shape=r0_b,
            r=cat(1, frame_a.s, {0}),
            R=C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.rotation(frame_a.phi)) if world.enableAnimation and animation;
        protected
          outer C2M2L_OM.MSL_Extend.Mechanics.Planar.World world;

        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MAX_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=max_table)
            annotation (Placement(transformation(extent={{-30,-65},{-10,-45}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=der(s))
            annotation (Placement(transformation(extent={{-100,-65},{-80,-45}})));
          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="force vs velocity table data definition"));
          parameter Real max_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
            annotation (Dialog(group="force vs velocity table data definition", enable = not tableOnFile));
          parameter Real min_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
            annotation (Dialog(group="force vs velocity table data definition", enable = not tableOnFile));
          parameter String tableName="NoName" "name of damper table in file"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Real compression_scale(min=0, max=1) = 0.0
            "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Real rebound_scale(min=0, max=1) = 0.0
            "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)";
          Real r_rel_a[2];
          Modelica.SIunits.Force f;
          Modelica.SIunits.Position s
            "(Guarded) distance between the origin of frame_a and the origin of frame_b (>= s_small))";
          parameter Modelica.SIunits.Position s_small=1.E-6
            " Prevent zero-division if relative distance s=0"
            annotation (Dialog(tab="Advanced"));
        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MIN_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=min_table)
            annotation (Placement(transformation(extent={{-30,-95},{-10,-75}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.Interpolate_damping
            interpolate_damping(compression_scale=compression_scale, rebound_scale=
                rebound_scale)
            annotation (Placement(transformation(extent={{10,-80},{30,-60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        equation
          f = interpolate_damping.y;
          lossPower = f*der(s);
          r_rel_a = C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, frame_b.s - frame_a.s);
          s = noEvent(max(Modelica.Math.Vectors.length(
                                        r_rel_a), s_small));
          frame_a.f = -f*{cos(frame_a.phi), sin(frame_a.phi)};
          frame_b.f + frame_a.f = zeros(2);
          frame_a.tau = 0;
          frame_b.tau = 0;
          connect(realExpression.y, lookup_force_MAX_damping.u)   annotation (Line(
              points={{-79,-55},{-32,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, lookup_force_MIN_damping.u) annotation (Line(
              points={{-79,-55},{-40,-55},{-40,-85},{-32,-85}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MAX_damping.y[1], interpolate_damping.u1) annotation (
              Line(
              points={{-9,-55},{0,-55},{0,-64},{8,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MIN_damping.y[1], interpolate_damping.u2) annotation (
              Line(
              points={{-9,-85},{0,-85},{0,-76},{8,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, interpolate_damping.u3) annotation (Line(
              points={{-79,-55},{-45,-55},{-45,-100},{14,-100},{14,-82}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<HTML>
<p>
<b>Linear damper</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = d*<b>der</b>(s);
</pre>
<p>
where \"d\" is a parameter, \"s\" is the
distance between the origin of frame_a and the origin of frame_b
and der(s) is the time derivative of \"s\".
</p>
<p>
In the following figure a typical animation is shown
where a mass is hanging on a damper.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/MultiBody/Forces/Damper.png\">

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-101,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(visible=useHeatPort,
                  points={{-100,-99},{-100,-25},{-10,-25}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-100,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="der(s)"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{36,-70},{55,-70},{55,-46},{51,-52},{59,-52},{55,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{53,-24},{100,-52}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the force 'f'
in the text layer")}));
        end Damper_From_Table_With_Range;

        model Rotation_Spring_From_Table_With_Range
          "Rotational spring with force determined from a torque vs displacement table (N-m vs deg)"
          extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliant;

          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="torque vs displacement table data definition"));
          parameter Real max_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Angular displacement [deg] versus torque [N.m] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N-m)"
            annotation (Dialog(group="torque vs displacement table data definition",enable = not tableOnFile));
          parameter Real min_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Angular displacement [deg] versus torque [N.m] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N-m)"
            annotation (Dialog(group="torque vs displacement table data definition",enable = not tableOnFile));
          parameter String tableName="NoName" "name of table in file"
            annotation (Dialog(group="torque vs displacement table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="torque vs displacement table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Real spring_scale(min=0, max=1) = 0.0
            "Spring scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Modelica.SIunits.Angle phi_rel0=0
            "Unstretched spring angle";

        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MAX(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=max_table)
            annotation (Placement(transformation(extent={{-30,-65},{-10,-45}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=phi_rel - phi_rel0)
            annotation (Placement(transformation(extent={{-100,-65},{-80,-45}})));
          Modelica.Blocks.Math.UnitConversions.To_deg to_deg
            annotation (Placement(transformation(extent={{-70,-65},{-50,-45}})));
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MIN(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=min_table)
            annotation (Placement(transformation(extent={{-30,-95},{-10,-75}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.Interpolate
                                                                                    interpolate(scale=
                spring_scale)
            annotation (Placement(transformation(extent={{10,-80},{30,-60}})));
        equation
          tau = interpolate.y;

          connect(to_deg.y, lookup_force_MAX.u)               annotation (Line(
              points={{-49,-55},{-32,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, to_deg.u) annotation (Line(
              points={{-79,-55},{-72,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y, lookup_force_MIN.u) annotation (Line(
              points={{-49,-55},{-40,-55},{-40,-85},{-32,-85}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MAX.y[1], interpolate.u1) annotation (Line(
              points={{-9,-55},{0,-55},{0,-64},{8,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MIN.y[1], interpolate.u2) annotation (Line(
              points={{-9,-85},{0,-85},{0,-76},{8,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
A <b>linear 1D rotational spring</b>. The component can be connected either
between two inertias/gears to describe the shaft elasticity, or between
a inertia/gear and the housing (component Fixed), to describe
a coupling of the element with the housing via a spring.
</p>

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(
                  points={{-100,0},{-55,0},{-50,30},{-40,-30},{-30,30},{-20,-30},{-10,
                      30},{0,-30},{10,30},{20,-30},{30,30},{40,-30},{50,30},{55,0},{100,
                      0}},
                  color={0,0,0},
                  thickness=0),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="phi_rel"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{36,-70},{55,-70},{55,-46},{51,-52},{59,-52},{55,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{53,-24},{100,-52}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the torque 't'
in the text layer"),
                Line(
                  points={{-100,0},{-55,0},{-50,30},{-40,-30},{-30,30},{-20,-30},{-10,30},
                      {0,-30},{10,30},{20,-30},{30,30},{40,-30},{50,30},{55,0},{100,0}},
                  color={0,0,0},
                  thickness=0)}));
        end Rotation_Spring_From_Table_With_Range;

        model Rotation_Damper_From_Table_With_Range
          "Damper with force determined from a force vs rotational velocity table"
          extends
            Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="torque vs velocity table data definition"));
          parameter Real max_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Angular velocity [deg/s] versus torque [N.m] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m)"
            annotation (Dialog(group="torque vs velocity table data definition", enable = not tableOnFile));
          parameter Real min_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Angular velocity [deg/s] versus torque [N.m] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m)"
            annotation (Dialog(group="torque vs velocity table data definition", enable = not tableOnFile));
          parameter String tableName="NoName" "name of damper table in file"
            annotation (Dialog(group="torque vs velocity table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="torque vs velocity table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Real compression_scale(min=0, max=1) = 0.0
            "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Real rebound_scale(min=0, max=1) = 0.0
            "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)";

          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MAX_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=max_table)
            annotation (Placement(transformation(extent={{-30,-65},{-10,-45}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=w_rel)
            annotation (Placement(transformation(extent={{-100,-65},{-80,-45}})));
          Modelica.Blocks.Math.Gain                   to_deg(k=180/pi)
            annotation (Placement(transformation(extent={{-70,-65},{-50,-45}})));
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MIN_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=min_table)
            annotation (Placement(transformation(extent={{-30,-95},{-10,-75}})));

          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.Interpolate_damping
            interpolate_damping(compression_scale=compression_scale, rebound_scale=
                rebound_scale)
            annotation (Placement(transformation(extent={{10,-80},{30,-60}})));
        equation
          tau = interpolate_damping.y;
          lossPower = tau*w_rel;
          connect(to_deg.y, lookup_force_MAX_damping.u)   annotation (Line(
              points={{-49,-55},{-32,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, to_deg.u) annotation (Line(
              points={{-79,-55},{-72,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y,lookup_force_MIN_damping. u) annotation (Line(
              points={{-49,-55},{-40,-55},{-40,-85},{-32,-85}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y, interpolate_damping.u3) annotation (Line(
              points={{-49,-55},{-45,-55},{-45,-100},{14,-100},{14,-82}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MAX_damping.y[1], interpolate_damping.u1) annotation (
              Line(
              points={{-9,-55},{0,-55},{0,-64},{8,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MIN_damping.y[1], interpolate_damping.u2) annotation (
              Line(
              points={{-9,-85},{0,-85},{0,-76},{8,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
A <b>linear 1D rotational spring</b>. The component can be connected either
between two inertias/gears to describe the shaft elasticity, or between
a inertia/gear and the housing (component Fixed), to describe
a coupling of the element with the housing via a spring.
</p>

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-101,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(visible=useHeatPort,
                  points={{-100,-99},{-100,-25},{-10,-25}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-100,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="w_rel"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{36,-70},{55,-70},{55,-46},{51,-52},{59,-52},{55,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{53,-24},{100,-52}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the torque 't'
in the text layer")}));
        end Rotation_Damper_From_Table_With_Range;

        model Road_Arm_With_Torsion_Bar_Trans_Damper
          "Road arm with separate transforms for each direction - parameterized - includes torsion bar and attachment for translational damper.  Outputs arm angle and torsion bar torque."
            parameter Modelica.SIunits.Length lever_arm_wheel
            "Distance from center of hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_wheel
            "Lateral offset of wheel center from hull bearing";

            parameter Modelica.SIunits.Length lever_arm_damper
            "Distance from center of hull bearing to damper attachment (projected in side view)";
            parameter Modelica.SIunits.Length bracket_height_damper
            "Distance of damper attachment above or below the line from hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_damper
            "Lateral offset of damper attachment from hull bearing";

            parameter Modelica.SIunits.Length lever_arm_CG
            "Distance from center of hull bearing to arm CG location (projected in side view)";
            parameter Modelica.SIunits.Length bracket_height_CG
            "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_CG
            "Lateral offset of arm CG location from hull bearing";
            parameter Modelica.SIunits.Mass m_arm(min=0) "Mass of arm";
            parameter Modelica.SIunits.Inertia I_xx_arm(min=0)
            "(1,1) element of inertia tensor";
            parameter Modelica.SIunits.Inertia I_yy_arm(min=0)
            "(2,2) element of inertia tensor";
            parameter Modelica.SIunits.Inertia I_zz_arm(min=0)
            "(3,3) element of inertia tensor";

            parameter Modelica.SIunits.Mass m_bar(min=0) "Mass of torsion bar";
            parameter Real c_bar(unit="N.m/deg") "Torsion bar spring constant";
            parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg torsion_bar_install_angle
            "Unstretched spring angle (aka installation angle of torsion bar)";

        protected
          parameter Modelica.SIunits.Length length_damper_x=(sqrt(abs((lever_arm_damper^2)-(bracket_height_damper^2))))*sign(lever_arm_damper)
            "X-component of lever arm length - damper";
          parameter Modelica.SIunits.Length length_CG_x=(sqrt(abs((lever_arm_CG^2)-(bracket_height_CG^2))))*sign(lever_arm_CG)
            "X-component of lever arm length - CG";
          parameter Modelica.SIunits.RotationalSpringConstant c=c_bar*180/pi
            "Torsion bar spring constant";
          parameter Modelica.SIunits.Angle torsion_bar_install_angle_rad = torsion_bar_install_angle*pi/180;

        public
          MSL_Extend.Mechanics.Planar.Joints.Revolute  hull_pivot(useAxisFlange=true, phi(
                start=pi + torsion_bar_install_angle_rad, fixed=true))
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       trans_damp_x(r={length_damper_x,
                0})
            "Road arm length from chassis attachment to damper attachment"
                       annotation (Placement(transformation(extent={{0,-20},{20,0}})));
          MSL_Extend.Mechanics.Planar.Parts.Body  CG(
            m=m_arm, J=I_zz_arm)
            annotation (Placement(transformation(extent={{80,-180},{100,-160}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  wheel_x(r={
                lever_arm_wheel,0})
            "Road arm length from chassis attachment to road wheel attachment"
                       annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  arm_cm_x(r={length_CG_x,0})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{0,-140},{20,-120}})));
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  hull     annotation (
              Placement(transformation(rotation=0, extent={{-176,-16},{-148,16}}),
                iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,244})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                          wheel(includeBearingConnector=
               true)                                               annotation (
              Placement(transformation(rotation=0, extent={{-14,-16},{14,16}},
                origin={90,-80}),
                iconTransformation(extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,-244})));
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_b  damper   annotation (
              Placement(transformation(
                rotation=90,
                extent={{-14,-16},{14,16}},
                origin={80,30}), iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=180,
                origin={244,-40})));
          Modelica.Mechanics.Rotational.Components.Spring torsion_bar(
            c=c, phi_rel0=pi + torsion_bar_install_angle_rad)
            annotation (Placement(transformation(extent={{-18,-18},{18,18}},
                rotation=0,
                origin={-80,120})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  arm_cm_y(r={0,
                bracket_height_CG})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={30,-150})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  trans_damp_y(r={0,
                bracket_height_damper})
            "Road arm length from chassis attachment to damper attachment"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={30,10})));

          MSL_Extend.Mechanics.Planar.Parts.Body       bar_mass(m=m_bar, J=0)
            annotation (Placement(transformation(extent={{-130,40},{-110,60}})));
          Modelica.Mechanics.Rotational.Sensors.RelAngleSensor relAngleSensor
            annotation (Placement(transformation(extent={{-80,40},{-60,20}})));
          Modelica.Blocks.Math.UnitConversions.To_deg to_deg
            annotation (Placement(transformation(extent={{120,40},{140,60}})));
          Modelica.Blocks.Sources.Constant const(k=180)
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          Modelica.Blocks.Math.Add subtract_180(k2=-1)
            annotation (Placement(transformation(extent={{170,20},{190,40}})));
          Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
              tau_constant=0)
            annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
          Modelica.Blocks.Interfaces.RealOutput angle annotation (Placement(
                transformation(extent={{240,20},{260,40}}), iconTransformation(extent={
                    {240,-130},{260,-110}})));
        equation
          connect(trans_damp_x.frame_a, hull_pivot.frame_b)    annotation (Line(
              points={{0,-10},{-40,-10},{-40,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull, hull_pivot.frame_a)         annotation (Line(
              points={{-162,0},{-80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull_pivot.frame_b, wheel_x.frame_a) annotation (Line(
              points={{-60,0},{-40,0},{-40,-40},{0,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torsion_bar.flange_b,hull_pivot. axis) annotation (Line(
              points={{-62,120},{-20,120},{-20,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hull_pivot.support,torsion_bar. flange_a) annotation (Line(
              points={{-76,10},{-140,10},{-140,120},{-98,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_cm_x.frame_b, arm_cm_y.frame_a)
                                                   annotation (Line(
              points={{20,-130},{30,-130},{30,-140}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(trans_damp_x.frame_b, trans_damp_y.frame_a)
                                                     annotation (Line(
              points={{20,-10},{30,-10},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_a, hull_pivot.frame_b) annotation (Line(
              points={{0,-130},{-40,-130},{-40,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(bar_mass.frame_a, hull_pivot.frame_a) annotation (Line(
              points={{-130,50},{-130,20},{-100,20},{-100,0},{-80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(relAngleSensor.phi_rel, to_deg.u) annotation (Line(
              points={{-70,41},{-70,50},{118,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_a, hull_pivot.support) annotation (Line(
              points={{-80,30},{-80,10},{-76,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_b, hull_pivot.axis) annotation (Line(
              points={{-60,30},{-60,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(const.y, subtract_180.u2) annotation (Line(
              points={{141,10},{160,10},{160,24},{168,24}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y, subtract_180.u1) annotation (Line(
              points={{141,50},{160,50},{160,36},{168,36}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(constantTorque.flange, wheel.flange) annotation (Line(
              points={{120,-50},{120,-80},{90,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(subtract_180.y, angle) annotation (Line(
              points={{191,30},{250,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(wheel_x.frame_b, wheel.bearingFrame) annotation (Line(
              points={{20,-40},{38,-40},{38,-80},{90,-80}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(trans_damp_y.frame_b, damper) annotation (Line(
              points={{30,20},{30,30},{80,30}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_y.frame_b, CG.frame_a) annotation (Line(
              points={{30,-160},{30,-170},{80,-170}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,
                    -240},{240,240}}),
                              graphics),
            experiment(StopTime=5),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}}),     graphics={
                Rectangle(
                  extent={{-240,240},{240,-240}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{13,43},{45,-27},{9,-43},{-43,-3},{13,43}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.Solid,
                  fillColor={135,135,135},
                  origin={69,-23},
                  rotation=360),
                Polygon(
                  points={{26,-26},{-100,-180},{-140,-180},{-180,-140},{-180,-100},{-32,
                      30},{26,-26}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{26,-26},{180,100},{180,140},{140,180},{100,180},{-32,30},{26,
                      -26}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{76,-78},{116,-38}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={-140,-140},
                  rotation=360),
                Ellipse(
                  extent={{-160,-160},{-120,-120}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-10,-10},{10,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={96,-58},
                  rotation=360),
                Ellipse(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={140,140},
                  rotation=360),
                Ellipse(
                  extent={{120,120},{160,160}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-260,-192},{-140,-220}},
                  lineColor={0,0,0},
                  textString="w"),
                Text(
                  extent={{140,-26},{260,-54}},
                  lineColor={0,0,0},
                  textString="d"),
                Text(
                  extent={{-24,216},{96,188}},
                  lineColor={0,0,0},
                  textString="h"),
                Text(
                  extent={{-260,250},{20,290}},
                  textString="%name",
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={255,255,255}),
                Line(
                  points={{174,-42},{118,-52}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-32,30},{26,-26}},
                  color={135,135,135},
                  smooth=Smooth.None),
                Text(
                  extent={{174,-106},{254,-134}},
                  lineColor={0,0,0},
                  fontName="Symbol",
                  textString="q")}));
        end Road_Arm_With_Torsion_Bar_Trans_Damper;

        model Hydropneumatic_Road_Arm
          "Road arm with hydropneumatics represented by rotational spring and rotational damper.  Outputs arm angle and torque from hydropneumatic."
          parameter Modelica.SIunits.Length lever_arm_wheel
            "Distance from center of hull bearing to wheel bearing (projected in side view)";
          parameter Modelica.SIunits.Length offset_wheel
            "Lateral offset of wheel center from hull bearing";
          parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg arm_install_angle
            "Installation angle of arm";
          parameter Modelica.SIunits.Length lever_arm_CG
            "Distance from center of hull bearing to arm CG location (projected in side view)";
          parameter Modelica.SIunits.Length bracket_height_CG
            "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)";
          parameter Modelica.SIunits.Length offset_CG
            "Lateral offset of arm CG location from hull bearing";
          parameter Modelica.SIunits.Mass m_arm(min=0) "Mass of arm";
          parameter Modelica.SIunits.Inertia I_xx_arm(min=0)
            "(1,1) element of inertia tensor";
          parameter Modelica.SIunits.Inertia I_yy_arm(min=0)
            "(2,2) element of inertia tensor";
          parameter Modelica.SIunits.Inertia I_zz_arm(min=0)
            "(3,3) element of inertia tensor";
          parameter Real t_phi_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "N.m/deg - Torque versus rotational displacement ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N.m)";
          parameter Real t_phi_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "N.m/deg - Torque versus rotational displacement ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N.m)";
          parameter Real spring_scale(min=0, max=1) = 0.0
            "Spring scale factor between min and max force curves (=0, lower input; =1, upper input)";

          parameter Real t_w_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "N.m.s/deg - Torque versus rotational velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m)";
          parameter Real t_w_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "N.m.s/deg - Torque versus rotational velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m)";
          parameter Real compression_scale(min=0, max=1) = 0.0
            "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Real rebound_scale(min=0, max=1) = 0.0
            "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)";

        protected
          parameter Modelica.SIunits.Length length_CG_x=(sqrt(abs((lever_arm_CG^2)-(bracket_height_CG^2))))*sign(lever_arm_CG)
            "X-component of lever arm length - CG";
          parameter Modelica.SIunits.Angle  arm_install_angle_rad =  arm_install_angle*pi/180;

        public
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  hull     annotation (
              Placement(transformation(rotation=0, extent={{-120,-16},{-92,16}}),
                iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,244})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                          wheel(includeBearingConnector=
               true)                                               annotation (
              Placement(transformation(
                rotation=0,
                extent={{-14,-16},{14,16}},
                origin={90,-80}), iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,-244})));
          MSL_Extend.Mechanics.Planar.Joints.Revolute  hull_pivot(useAxisFlange=true, phi(
                start=pi + arm_install_angle_rad))
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          MSL_Extend.Mechanics.Planar.Parts.Body  CG(
            m=m_arm, J=I_zz_arm)
            annotation (Placement(transformation(extent={{80,-180},{100,-160}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  wheel_x(r={
                lever_arm_wheel,0})
            "Road arm length from chassis attachment to road wheel attachment"
                       annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       arm_cm_x(r={length_CG_x,0})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{0,-140},{20,-120}})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       arm_cm_y(r={0,bracket_height_CG})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={30,-150})));

          Rotation_Damper_From_Table_With_Range hydro_damper(
            max_table=t_w_table_max,
            min_table=t_w_table_min,
            compression_scale=compression_scale,
            rebound_scale=rebound_scale)
            annotation (Placement(transformation(extent={{-98,142},{-62,178}})));
          Rotation_Spring_From_Table_With_Range hydro_spring(
            spring_scale=spring_scale,
            max_table=t_phi_table_max,
            min_table=t_phi_table_min,
            phi_rel0=pi + arm_install_angle_rad)
            annotation (Placement(transformation(extent={{-98,102},{-62,138}})));
          Modelica.Mechanics.Rotational.Sensors.RelAngleSensor relAngleSensor
            annotation (Placement(transformation(extent={{-80,40},{-60,20}})));
          Modelica.Blocks.Math.UnitConversions.To_deg to_deg
            annotation (Placement(transformation(extent={{120,40},{140,60}})));
          Modelica.Blocks.Interfaces.RealOutput angle
                                                  annotation (Placement(transformation(
                  extent={{240,20},{260,40}}), iconTransformation(extent={{240,-130},{
                    260,-110}})));
          Modelica.Blocks.Sources.Constant const(k=180)
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          Modelica.Blocks.Math.Add subtract_180(k2=-1)
            annotation (Placement(transformation(extent={{170,20},{190,40}})));
          Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
              tau_constant=0)
            annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
        equation
          connect(hull, hull_pivot.frame_a)         annotation (Line(
              points={{-106,0},{-80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull_pivot.frame_b, wheel_x.frame_a) annotation (Line(
              points={{-60,0},{-40,0},{-40,-40},{0,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_b, arm_cm_y.frame_a)
                                                   annotation (Line(
              points={{20,-130},{30,-130},{30,-140}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_a, hull_pivot.frame_b) annotation (Line(
              points={{0,-130},{-40,-130},{-40,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hydro_damper.flange_b, hull_pivot.axis) annotation (Line(
              points={{-62,160},{-20,160},{-20,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydro_damper.flange_a, hull_pivot.support) annotation (Line(
              points={{-98,160},{-140,160},{-140,10},{-76,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydro_spring.flange_b, hull_pivot.axis) annotation (Line(
              points={{-62,120},{-20,120},{-20,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydro_spring.flange_a, hull_pivot.support) annotation (Line(
              points={{-98,120},{-140,120},{-140,10},{-76,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(relAngleSensor.phi_rel, to_deg.u) annotation (Line(
              points={{-70,41},{-70,50},{118,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_a, hull_pivot.support) annotation (Line(
              points={{-80,30},{-80,10},{-76,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_b, hull_pivot.axis) annotation (Line(
              points={{-60,30},{-60,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(const.y, subtract_180.u2) annotation (Line(
              points={{141,10},{160,10},{160,24},{168,24}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y, subtract_180.u1) annotation (Line(
              points={{141,50},{160,50},{160,36},{168,36}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(subtract_180.y, angle) annotation (Line(
              points={{191,30},{250,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(constantTorque.flange, wheel.flange) annotation (Line(
              points={{120,-50},{120,-80},{90,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_cm_y.frame_b, CG.frame_a) annotation (Line(
              points={{30,-160},{30,-170},{80,-170}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(wheel_x.frame_b, wheel.bearingFrame) annotation (Line(
              points={{20,-40},{52,-40},{52,-80},{90,-80}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,
                    -240},{240,240}}),
                              graphics),
            experiment(StopTime=5),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}}),     graphics={
                Rectangle(
                  extent={{-240,240},{240,-240}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-90,-90},{90,90}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={120,120},
                  rotation=360),
                Rectangle(
                  extent={{-150,80},{170,-80}},
                  lineColor={0,0,255},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  origin={-20,-20},
                  rotation=45),
                Ellipse(
                  extent={{-80,-80},{80,80}},
                  lineColor={0,0,255},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  origin={120,120},
                  rotation=0),
                Ellipse(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={-90,-90},
                  rotation=360),
                Ellipse(
                  extent={{-110,-110},{-70,-70}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-250,-182},{-130,-210}},
                  lineColor={0,0,0},
                  textString="w"),
                Text(
                  extent={{-26,226},{94,198}},
                  lineColor={0,0,0},
                  textString="h"),
                Text(
                  extent={{-260,250},{20,290}},
                  textString="%name",
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={255,255,255}),
                Text(
                  extent={{174,-106},{254,-134}},
                  lineColor={0,0,0},
                  fontName="Symbol",
                  textString="q")}));
        end Hydropneumatic_Road_Arm;

        model Road_Arm_With_Torsion_Bar_Trans_Damper_ZERO_FIDELITY
          "Road arm with separate transforms for each direction - parameterized - includes torsion bar and attachment for translational damper.  Outputs arm angle and torsion bar torque."
            parameter Modelica.SIunits.Length lever_arm_wheel
            "Distance from center of hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_wheel
            "Lateral offset of wheel center from hull bearing";

            parameter Modelica.SIunits.Length lever_arm_damper
            "Distance from center of hull bearing to damper attachment (projected in side view)";
            parameter Modelica.SIunits.Length bracket_height_damper
            "Distance of damper attachment above or below the line from hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_damper
            "Lateral offset of damper attachment from hull bearing";

            parameter Modelica.SIunits.Length lever_arm_CG
            "Distance from center of hull bearing to arm CG location (projected in side view)";
            parameter Modelica.SIunits.Length bracket_height_CG
            "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)";
            parameter Modelica.SIunits.Length offset_CG
            "Lateral offset of arm CG location from hull bearing";
            parameter Modelica.SIunits.Mass m_arm(min=0) "Mass of arm";
            parameter Modelica.SIunits.Inertia I_xx_arm(min=0)
            "(1,1) element of inertia tensor";
            parameter Modelica.SIunits.Inertia I_yy_arm(min=0)
            "(2,2) element of inertia tensor";
            parameter Modelica.SIunits.Inertia I_zz_arm(min=0)
            "(3,3) element of inertia tensor";

            parameter Modelica.SIunits.Mass m_bar(min=0) "Mass of torsion bar";
            parameter Real c_bar(unit="N.m/deg") "Torsion bar spring constant";
            parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg torsion_bar_install_angle
            "Unstretched spring angle (aka installation angle of torsion bar)";

        protected
          parameter Modelica.SIunits.Length length_damper_x=(sqrt(abs((lever_arm_damper^2)-(bracket_height_damper^2))))*sign(lever_arm_damper)
            "X-component of lever arm length - damper";
          parameter Modelica.SIunits.Length length_CG_x=(sqrt(abs((lever_arm_CG^2)-(bracket_height_CG^2))))*sign(lever_arm_CG)
            "X-component of lever arm length - CG";
          parameter Modelica.SIunits.RotationalSpringConstant c=c_bar*180/pi
            "Torsion bar spring constant";
          parameter Modelica.SIunits.Angle torsion_bar_install_angle_rad = torsion_bar_install_angle*pi/180;

        public
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Joints.Revolute
                                                        hull_pivot(useAxisFlange=true, phi(
                start=pi + torsion_bar_install_angle_rad))
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                                trans_damp_x(r={
                length_damper_x,0})
            "Road arm length from chassis attachment to damper attachment"
                       annotation (Placement(transformation(extent={{0,-20},{20,0}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Body
                                                    CG(
            m=m_arm, J=I_zz_arm)
            annotation (Placement(transformation(extent={{80,-180},{100,-160}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                                wheel_x(r={
                lever_arm_wheel,0})
            "Road arm length from chassis attachment to road wheel attachment"
                       annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                                arm_cm_x(r={length_CG_x,
                0})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{0,-140},{20,-120}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a
                                                          hull     annotation (
              Placement(transformation(rotation=0, extent={{-176,-16},{-148,16}}),
                iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,244})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                          wheel(includeBearingConnector=
               true)                                               annotation (
              Placement(transformation(rotation=0, extent={{-14,-16},{14,16}},
                origin={90,-80}),
                iconTransformation(extent={{-14,-16},{14,16}},
                rotation=90,
                origin={0,-244})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b damper   annotation (
              Placement(transformation(
                rotation=90,
                extent={{-14,-16},{14,16}},
                origin={80,30}), iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=180,
                origin={244,-40})));
          Modelica.Mechanics.Rotational.Components.Disc   torsion_bar(deltaPhi=pi +
                torsion_bar_install_angle_rad)
            annotation (Placement(transformation(extent={{-18,-18},{18,18}},
                rotation=0,
                origin={-80,120})));

          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                                arm_cm_y(r={0,
                bracket_height_CG})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={30,-150})));

          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                                trans_damp_y(r={0,
                bracket_height_damper})
            "Road arm length from chassis attachment to damper attachment"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={30,10})));

          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Body
                                                    bar_mass(m=m_bar, J=0)
            annotation (Placement(transformation(extent={{-130,40},{-110,60}})));
          Modelica.Mechanics.Rotational.Sensors.RelAngleSensor relAngleSensor
            annotation (Placement(transformation(extent={{-80,40},{-60,20}})));
          Modelica.Blocks.Math.UnitConversions.To_deg to_deg
            annotation (Placement(transformation(extent={{120,40},{140,60}})));
          Modelica.Blocks.Interfaces.RealOutput angle
                                                  annotation (Placement(transformation(
                  extent={{240,20},{260,40}}), iconTransformation(extent={{240,-130},{
                    260,-110}})));
          Modelica.Blocks.Sources.Constant const(k=180)
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          Modelica.Blocks.Math.Add subtract_180(k2=-1)
            annotation (Placement(transformation(extent={{170,20},{190,40}})));
          Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
              tau_constant=0)
            annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
        equation
          connect(trans_damp_x.frame_a, hull_pivot.frame_b)    annotation (Line(
              points={{0,-10},{-40,-10},{-40,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull, hull_pivot.frame_a)         annotation (Line(
              points={{-162,0},{-80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull_pivot.frame_b, wheel_x.frame_a) annotation (Line(
              points={{-60,0},{-40,0},{-40,-40},{0,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torsion_bar.flange_b,hull_pivot. axis) annotation (Line(
              points={{-62,120},{-20,120},{-20,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hull_pivot.support,torsion_bar. flange_a) annotation (Line(
              points={{-76,10},{-140,10},{-140,120},{-98,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_cm_x.frame_b, arm_cm_y.frame_a)
                                                   annotation (Line(
              points={{20,-130},{30,-130},{30,-140}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(trans_damp_x.frame_b, trans_damp_y.frame_a)
                                                     annotation (Line(
              points={{20,-10},{30,-10},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_a, hull_pivot.frame_b) annotation (Line(
              points={{0,-130},{-40,-130},{-40,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(bar_mass.frame_a, hull_pivot.frame_a) annotation (Line(
              points={{-130,50},{-130,20},{-100,20},{-100,0},{-80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(relAngleSensor.phi_rel, to_deg.u) annotation (Line(
              points={{-70,41},{-70,50},{118,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_a, hull_pivot.support) annotation (Line(
              points={{-80,30},{-80,10},{-76,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(relAngleSensor.flange_b, hull_pivot.axis) annotation (Line(
              points={{-60,30},{-60,10},{-70,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(const.y, subtract_180.u2) annotation (Line(
              points={{141,10},{160,10},{160,24},{168,24}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(to_deg.y, subtract_180.u1) annotation (Line(
              points={{141,50},{160,50},{160,36},{168,36}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(subtract_180.y, angle) annotation (Line(
              points={{191,30},{250,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(constantTorque.flange, wheel.flange) annotation (Line(
              points={{120,-50},{120,-80},{90,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(wheel_x.frame_b, wheel.bearingFrame) annotation (Line(
              points={{20,-40},{54,-40},{54,-80},{90,-80}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_y.frame_b, CG.frame_a) annotation (Line(
              points={{30,-160},{30,-170},{80,-170}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(trans_damp_y.frame_b, damper) annotation (Line(
              points={{30,20},{30,30},{80,30}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,
                    -240},{240,240}}),
                              graphics),
            experiment(StopTime=5),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}}),     graphics={
                Rectangle(
                  extent={{-240,240},{240,-240}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{13,43},{45,-27},{9,-43},{-43,-3},{13,43}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.Solid,
                  fillColor={135,135,135},
                  origin={69,-23},
                  rotation=360),
                Polygon(
                  points={{26,-26},{-100,-180},{-140,-180},{-180,-140},{-180,-100},{-32,
                      30},{26,-26}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{26,-26},{180,100},{180,140},{140,180},{100,180},{-32,30},{26,
                      -26}},
                  lineColor={0,0,255},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{76,-78},{116,-38}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={-140,-140},
                  rotation=360),
                Ellipse(
                  extent={{-160,-160},{-120,-120}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-10,-10},{10,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={96,-58},
                  rotation=360),
                Ellipse(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  origin={140,140},
                  rotation=360),
                Ellipse(
                  extent={{120,120},{160,160}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-260,-192},{-140,-220}},
                  lineColor={0,0,0},
                  textString="w"),
                Text(
                  extent={{140,-26},{260,-54}},
                  lineColor={0,0,0},
                  textString="d"),
                Text(
                  extent={{-24,216},{96,188}},
                  lineColor={0,0,0},
                  textString="h"),
                Text(
                  extent={{-260,250},{20,290}},
                  textString="%name",
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={255,255,255}),
                Line(
                  points={{174,-42},{118,-52}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-32,30},{26,-26}},
                  color={135,135,135},
                  smooth=Smooth.None),
                Text(
                  extent={{174,-106},{254,-134}},
                  lineColor={0,0,0},
                  fontName="Symbol",
                  textString="q"),
                Text(
                  extent={{-240,240},{240,-242}},
                  lineColor={255,0,255},
                  fontName="Comic Sans MS",
                  textStyle={TextStyle.Bold},
                  textString="ZF")}));
        end Road_Arm_With_Torsion_Bar_Trans_Damper_ZERO_FIDELITY;

        model Translational_Spring_From_Table_With_Range
          "Translational spring with force determined from a force vs displacement table (N vs m)"
          import SI = Modelica.SIunits;
          import Modelica.Mechanics.MultiBody.Types;
        //  extends Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce;
          parameter Boolean animation=true
            "= true, if animation shall be enabled";

          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="torque vs displacement table data definition"));
          parameter Real max_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Displacement [m] versus force [N] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4m give a force of 16N)"
            annotation (Dialog(group="torque vs displacement table data definition",enable = not tableOnFile));
          parameter Real min_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "Displacement [m] versus force [N] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4m give a force of 16N)"
            annotation (Dialog(group="torque vs displacement table data definition",enable = not tableOnFile));
          parameter String tableName="NoName" "name of table in file"
            annotation (Dialog(group="torque vs displacement table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="torque vs displacement table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Real spring_scale(min=0, max=1) = 0.0
            "Spring scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Modelica.SIunits.Length s_rel0=0
            "Unstretched spring length";

          Real r_rel_a[2];
          Modelica.SIunits.Force f;
          Modelica.SIunits.Position s
            "(Guarded) distance between the origin of frame_a and the origin of frame_b (>= s_small))";
          parameter Modelica.SIunits.Position s_small=1.E-6
            " Prevent zero-division if relative distance s=0"
            annotation (Dialog(tab="Advanced"));
        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MAX(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=max_table)
            annotation (Placement(transformation(extent={{-30,-65},{-10,-45}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=s - s_rel0)
            annotation (Placement(transformation(extent={{-100,-65},{-80,-45}})));
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MIN(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=min_table)
            annotation (Placement(transformation(extent={{-30,-95},{-10,-75}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.Interpolate
                                                                                    interpolate(scale=
                spring_scale)
            annotation (Placement(transformation(extent={{10,-80},{30,-60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

        equation
          f = interpolate.y;
          r_rel_a = [cos(frame_a.phi), -sin(frame_a.phi); sin(frame_a.phi), cos(frame_a.phi)]*(frame_a.s-frame_a.s);
          s = noEvent(max(Modelica.Math.Vectors.length(
                                        r_rel_a), s_small));
          frame_a.f = -f*{cos(frame_a.phi), sin(frame_a.phi)};
          frame_b.f + frame_a.f = zeros(2);
          frame_a.tau = 0;
          frame_b.tau = 0;
          connect(lookup_force_MAX.y[1], interpolate.u1) annotation (Line(
              points={{-9,-55},{0,-55},{0,-64},{8,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MIN.y[1], interpolate.u2) annotation (Line(
              points={{-9,-85},{0,-85},{0,-76},{8,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, lookup_force_MAX.u) annotation (Line(
              points={{-79,-55},{-32,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, lookup_force_MIN.u) annotation (Line(
              points={{-79,-55},{-40,-55},{-40,-85},{-32,-85}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
A <b>linear 1D rotational spring</b>. The component can be connected either
between two inertias/gears to describe the shaft elasticity, or between
a inertia/gear and the housing (component Fixed), to describe
a coupling of the element with the housing via a spring.
</p>

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(
                  points={{-100,0},{-55,0},{-50,30},{-40,-30},{-30,30},{-20,-30},{-10,
                      30},{0,-30},{10,30},{20,-30},{30,30},{40,-30},{50,30},{55,0},{100,
                      0}},
                  color={0,0,0},
                  thickness=0),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="s_rel"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{36,-70},{55,-70},{55,-46},{51,-52},{59,-52},{55,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{53,-24},{100,-52}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the force 'f'
in the text layer"),
                Line(
                  points={{-100,0},{-55,0},{-50,30},{-40,-30},{-30,30},{-20,-30},{-10,30},
                      {0,-30},{10,30},{20,-30},{30,30},{40,-30},{50,30},{55,0},{100,0}},
                  color={0,0,0},
                  thickness=0)}));
        end Translational_Spring_From_Table_With_Range;

        model Translational_Damper_From_Table_With_Range
          "Damper with force determined from a force vs velocity table"
          import Modelica.Mechanics.MultiBody.Types;
        //   parameter Boolean animation=true "= true, if animation shall be enabled";
        //   parameter Modelica.SIunits.Distance length_a=world.defaultForceLength
        //     " Length of cylinder at frame_a side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input SI.Diameter diameter_a=world.defaultForceWidth
        //     " Diameter of cylinder at frame_a side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input SI.Diameter diameter_b=0.6*diameter_a
        //     " Diameter of cylinder at frame_b side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input Types.Color color_a={100,100,100} " Color at frame_a"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
        //   input Types.Color color_b={155,155,155} " Color at frame_b"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
        //   input Types.SpecularCoefficient specularCoefficient = 0.1
        //     "Reflection of ambient light (= 0: light is completely absorbed)"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //  extends Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce;
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
             final T=293.15);
            parameter Modelica.SIunits.Mass m_damper(min=0) "Mass of damper";
            parameter Modelica.SIunits.Length L_max
            "Maximum extended length of damper";
            parameter Modelica.SIunits.Length L_min
            "Minimum compressed length of damper";
          Real r_rel_a[2];
          Modelica.SIunits.Force f;
          Modelica.SIunits.Position s
            "(Guarded) distance between the origin of frame_a and the origin of frame_b (>= s_small))";
          parameter Modelica.SIunits.Position s_small=1.E-6
            " Prevent zero-division if relative distance s=0"
            annotation (Dialog(tab="Advanced"));

        //   SI.Position r0_b[3]=e_a*noEvent(min(length_a, s));
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_a(
        //     shapeType="cylinder",
        //     color=color_a,
        //     specularCoefficient=specularCoefficient,
        //     length=noEvent(min(length_a, s)),
        //     width=diameter_a,
        //     height=diameter_a,
        //     lengthDirection=e_a,
        //     widthDirection={0,1,0},
        //     r=frame_a.r_0,
        //     R=frame_a.R) if world.enableAnimation and animation;
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_b(
        //     shapeType="cylinder",
        //     color=color_b,
        //     specularCoefficient=specularCoefficient,
        //     length=noEvent(max(s - length_a, 0)),
        //     width=diameter_b,
        //     height=diameter_b,
        //     lengthDirection=e_a,
        //     widthDirection={0,1,0},
        //     r_shape=r0_b,
        //     r=frame_a.r_0,
        //     R=frame_a.R) if world.enableAnimation and animation;
        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MAX_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=max_table)
            annotation (Placement(transformation(extent={{-30,-65},{-10,-45}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=der(s))
            annotation (Placement(transformation(extent={{-100,-65},{-80,-45}})));
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_MIN_damping(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            tableName=tableName,
            fileName=fileName,
            table=min_table)
            annotation (Placement(transformation(extent={{-30,-95},{-10,-75}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.Interpolate_damping
            interpolate_damping(compression_scale=compression_scale, rebound_scale=
                rebound_scale)
            annotation (Placement(transformation(extent={{10,-80},{30,-60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="force vs velocity table data definition"));
          parameter Real max_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
            annotation (Dialog(group="force vs velocity table data definition", enable = not tableOnFile));
          parameter Real min_table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
            annotation (Dialog(group="force vs velocity table data definition", enable = not tableOnFile));
          parameter String tableName="NoName" "name of damper table in file"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Real compression_scale(min=0, max=1) = 0.0
            "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)";
          parameter Real rebound_scale(min=0, max=1) = 0.0
            "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)";

        equation
          f = interpolate_damping.y;
          lossPower = f*der(s);
          r_rel_a = [cos(frame_a.phi), -sin(frame_a.phi); sin(frame_a.phi), cos(frame_a.phi)]*(frame_a.s-frame_a.s);
          s = noEvent(max(Modelica.Math.Vectors.length(
                                        r_rel_a), s_small));
          frame_a.f = -f*{cos(frame_a.phi), sin(frame_a.phi)};
          frame_b.f + frame_a.f = zeros(2);
          frame_a.tau = 0;
          frame_b.tau = 0;
          connect(realExpression.y, lookup_force_MAX_damping.u)   annotation (Line(
              points={{-79,-55},{-32,-55}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, lookup_force_MIN_damping.u) annotation (Line(
              points={{-79,-55},{-40,-55},{-40,-85},{-32,-85}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MAX_damping.y[1], interpolate_damping.u1) annotation (
              Line(
              points={{-9,-55},{0,-55},{0,-64},{8,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(lookup_force_MIN_damping.y[1], interpolate_damping.u2) annotation (
              Line(
              points={{-9,-85},{0,-85},{0,-76},{8,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(realExpression.y, interpolate_damping.u3) annotation (Line(
              points={{-79,-55},{-45,-55},{-45,-100},{14,-100},{14,-82}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<HTML>
<p>
<b>Linear damper</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = d*<b>der</b>(s);
</pre>
<p>
where \"d\" is a parameter, \"s\" is the
distance between the origin of frame_a and the origin of frame_b
and der(s) is the time derivative of \"s\".
</p>
<p>
In the following figure a typical animation is shown
where a mass is hanging on a damper.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/MultiBody/Forces/Damper.png\">

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-101,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(visible=useHeatPort,
                  points={{-100,-99},{-100,-25},{-10,-25}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-100,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="der(s)"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{36,-70},{55,-70},{55,-46},{51,-52},{59,-52},{55,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{53,-24},{100,-52}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the force 'f'
in the text layer")}));
        end Translational_Damper_From_Table_With_Range;

        model Bumpstop "Linear translational spring with optional mass"
          import Modelica.Mechanics.MultiBody.Types;
          extends MSL_Extend.Mechanics.Planar.Interfaces.PartialTwoFrames;
          parameter Boolean animation=true
            "= true, if animation shall be enabled";
          parameter Boolean showMass=true
            "= true, if point mass shall be visualized as sphere if animation=true and m>0";

          parameter Modelica.SIunits.TranslationalSpringConstant c(final min=0)
            "Spring constant";
          parameter Modelica.SIunits.Length s_unstretched=0
            "Unstretched spring length";
          parameter Modelica.SIunits.Mass m(min=0)=0
            "Spring mass located on the connetion line between the origin of frame_a and the origin of frame_b";
          parameter Real lengthFraction(
            min=0,
            max=1) = 0.5
            "Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)";
          input Modelica.SIunits.Distance width=world.defaultForceWidth
            " Width of spring"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input Modelica.SIunits.Distance coilWidth=width/10
            " Width of spring coil"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          parameter Integer numberOfWindings=5 " Number of spring windings"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.SpringColor
            " Color of spring"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
            "Reflection of ambient light (= 0: light is completely absorbed)"
            annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
          input Modelica.SIunits.Diameter massDiameter=max(0, (width - 2*coilWidth)*0.9)
            " Diameter of mass point sphere" annotation (Dialog(tab="Animation", group=
                  "if animation = true and showMass = true", enable=animation and showMass));
          input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor
            " Color of mass point" annotation (Dialog(tab="Animation", group=
                  "if animation = true and showMass = true", enable=animation and showMass));
          parameter Boolean fixedRotationAtFrame_a=false
            "=true, if rotation frame_a.R is fixed (to directly connect line forces)"
             annotation (Evaluate=true, choices(__Dymola_checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
          parameter Boolean fixedRotationAtFrame_b=false
            "=true, if rotation frame_b.R is fixed (to directly connect line forces)"
             annotation (Evaluate=true, choices(__Dymola_checkBox=true),Dialog(tab="Advanced", group="If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces"));
          parameter Real a "First Coefficient of quadratic equation";
          parameter Real b "Second Coefficient of quadratic equation";
          parameter Real TargetInput
            "The travel value that the spring becomes active";
          MSL_Extend.Mechanics.Planar.Forces.LineForceWithMass  lineForce(
            animateLine=animation,
            animateMass=showMass,
            m=m,
            lengthFraction=lengthFraction,
            lineShapeType="spring",
            lineShapeHeight=coilWidth*2,
            lineShapeWidth=width,
            lineShapeExtra=numberOfWindings,
            lineShapeColor=color,
            specularCoefficient=specularCoefficient,
            massDiameter=massDiameter,
            massColor=massColor,
            fixedRotationAtFrame_a=fixedRotationAtFrame_a,
            fixedRotationAtFrame_b=fixedRotationAtFrame_b) annotation (Placement(transformation(extent={{-20,
                    -20},{20,20}}, rotation=0)));

          Modelica.Blocks.Interfaces.RealInput TestInput
            annotation (Placement(transformation(extent={{-122,60},{-82,100}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Submodels.NonLinearSpring2
            nonLinearSpring2_2(
            a=a,
            b=b,
            k=c,
            TargetInput=TargetInput)
            annotation (Placement(transformation(extent={{-10,42},{10,62}})));
        equation
          connect(lineForce.frame_a, frame_a)
            annotation (Line(
              points={{-20,0},{-100,0}},
              color={95,95,95},
              thickness=0.5));
          connect(lineForce.frame_b, frame_b)
            annotation (Line(
              points={{20,0},{100,0}},
              color={95,95,95},
              thickness=0.5));

          connect(nonLinearSpring2_2.flange_a, lineForce.flange_a) annotation (Line(
              points={{-10,52},{-12,52},{-12,20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(nonLinearSpring2_2.flange_b, lineForce.flange_b) annotation (Line(
              points={{10,52},{12,52},{12,20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(TestInput, nonLinearSpring2_2.TestInput) annotation (Line(
              points={{-102,80},{-60,80},{-60,59.6},{-9.6,59.6}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                            graphics={
                Line(
                  points={{-100,0},{-58,0},{-43,-30},{-13,30},{17,-30},{47,30},{62,0},
                      {100,0}},
                  color={0,0,0},
                  pattern=LinePattern.Solid,
                  thickness=0.25,
                  arrow={Arrow.None,Arrow.None}),
                Text(
                  extent={{-150,56},{150,96}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-80},{150,-50}},
                  lineColor={0,0,0},
                  textString="c=%c"),
                Ellipse(
                  extent={{-8,8},{8,-8}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(visible=fixedRotationAtFrame_a, extent={{-70,30},{-130,-30}}, lineColor={255,0,0}),
                Text(visible=fixedRotationAtFrame_a,
                  extent={{-62,50},{-140,30}},
                  lineColor={255,0,0},
                  textString="R=0"),
                Ellipse(visible=fixedRotationAtFrame_b, extent={{70,30},{130,-30}}, lineColor={255,0,0}),
                Text(visible=fixedRotationAtFrame_b,
                  extent={{62,50},{140,30}},
                  lineColor={255,0,0},
                  textString="R=0")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}),
                    graphics),
            Documentation(info="<HTML>
<p>
<b>Linear spring</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = c*(s - s_unstretched);
</pre>
<p>
where \"c\" and \"s_unstretched\" are parameters and \"s\" is the
distance between the origin of frame_a and the origin of frame_b.
</p>
<p>
Optionally, the mass of the spring is taken into account by a
point mass located on the line between frame_a and frame_b
(default: middle of the line). If the spring mass is zero, the
additional equations to handle the mass are removed.
</p>
<p>
In the following figure a typical animation of the
spring is shown. The blue sphere in the middle of the
spring characterizes the location of the point mass.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/MultiBody/Examples/Elementary/SpringWithMass.png\"
ALT=\"model Examples.Elementary.SpringWithMass\">

</HTML>"));
        end Bumpstop;

        model Damper_From_Table
          "Damper with force determined from a force vs velocity table"
          import Modelica.Mechanics.MultiBody.Types;
        //   parameter Boolean animation=true "= true, if animation shall be enabled";
        //   parameter Modelica.SIunits.Distance length_a=world.defaultForceLength
        //     " Length of cylinder at frame_a side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input SI.Diameter diameter_a=world.defaultForceWidth
        //     " Diameter of cylinder at frame_a side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input SI.Diameter diameter_b=0.6*diameter_a
        //     " Diameter of cylinder at frame_b side"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //   input Types.Color color_a={100,100,100} " Color at frame_a"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
        //   input Types.Color color_b={155,155,155} " Color at frame_b"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation, colorSelector));
        //   input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient
        //     "Reflection of ambient light (= 0: light is completely absorbed)"
        //     annotation (Dialog(tab="Animation", group="if animation = true", enable=animation));
        //  extends Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce;
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort(
             final T=293.15);
            parameter Modelica.SIunits.Mass m_damper(min=0) "Mass of damper";
            parameter Modelica.SIunits.Length L_max
            "Maximum extended length of damper";
            parameter Modelica.SIunits.Length L_min
            "Minimum compressed length of damper";

        //   SI.Position r0_b[3]=e_a*noEvent(min(length_a, s));
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_a(
        //     shapeType="cylinder",
        //     color=color_a,
        //     specularCoefficient=specularCoefficient,
        //     length=noEvent(min(length_a, s)),
        //     width=diameter_a,
        //     height=diameter_a,
        //     lengthDirection=e_a,
        //     widthDirection={0,1,0},
        //     r=frame_a.r_0,
        //     R=frame_a.R) if world.enableAnimation and animation;
        //   Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape_b(
        //     shapeType="cylinder",
        //     color=color_b,
        //     specularCoefficient=specularCoefficient,
        //     length=noEvent(max(s - length_a, 0)),
        //     width=diameter_b,
        //     height=diameter_b,
        //     lengthDirection=e_a,
        //     widthDirection={0,1,0},
        //     r_shape=r0_b,
        //     r=frame_a.r_0,
        //     R=frame_a.R) if world.enableAnimation and animation;
        public
          Modelica.Blocks.Tables.CombiTable1Ds lookup_force_from_velocity(
            smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
            tableOnFile=tableOnFile,
            table=table,
            tableName=tableName,
            fileName=fileName)
            annotation (Placement(transformation(extent={{-20,-74},{0,-54}})));

          Modelica.Blocks.Sources.RealExpression realExpression(y=der(s))
            annotation (Placement(transformation(extent={{-72,-74},{-52,-54}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a frame_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_b frame_b
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          parameter Boolean tableOnFile=false
            "true, if table is defined on file or in function usertab"
            annotation (Dialog(group="force vs velocity table data definition"));
          parameter Real table[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
            "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
            annotation (Dialog(group="force vs velocity table data definition", enable = not tableOnFile));
          parameter String tableName="NoName" "name of damper table in file"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile));
          parameter String fileName="NoName"
            "file where matrix is stored (full path or local from where model is ran)"
            annotation (Dialog(group="force vs velocity table data definition", enable = tableOnFile,
                                 __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                                 caption="Open file in which table is present")));
          parameter Modelica.SIunits.Force max_force(min=0) = Modelica.Constants.inf
            "Maximum force damper can produce";
          parameter Real force_multiplier(min=0) = 1.0
            "Multiply damper force by this parameter";
          Real r_rel_a[2];
          Modelica.SIunits.Force f;
          Modelica.SIunits.Position s
            "(Guarded) distance between the origin of frame_a and the origin of frame_b (>= s_small))";
          parameter Modelica.SIunits.Position s_small=1.E-6
            " Prevent zero-division if relative distance s=0"
            annotation (Dialog(tab="Advanced"));
        equation
        //   if initial() then
        //     f = 0;
        //   else
            if abs( (lookup_force_from_velocity.y[1]) * force_multiplier) < max_force then
              f = lookup_force_from_velocity.y[1] * force_multiplier;
            else
              f = max_force * sign(lookup_force_from_velocity.y[1]);
            end if;
          //end if;
          lossPower = f*der(s);
          r_rel_a = C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, frame_b.s - frame_a.s);
          s = noEvent(max(Modelica.Math.Vectors.length(
                                        r_rel_a), s_small));
          frame_a.f = -f*{cos(frame_a.phi), sin(frame_a.phi)};
          frame_b.f + frame_a.f = zeros(2);
          frame_a.tau = 0;
          frame_b.tau = 0;
          connect(realExpression.y, lookup_force_from_velocity.u) annotation (Line(
              points={{-51,-64},{-22,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<HTML>
<p>
<b>Linear damper</b> acting as line force between frame_a and frame_b.
A <b>force f</b> is exerted on the origin of frame_b and with opposite sign
on the origin of frame_a along the line from the origin of frame_a to the origin
of frame_b according to the equation:
</p>
<pre>
   f = d*<b>der</b>(s);
</pre>
<p>
where \"d\" is a parameter, \"s\" is the
distance between the origin of frame_a and the origin of frame_b
and der(s) is the time derivative of \"s\".
</p>
<p>
In the following figure a typical animation is shown
where a mass is hanging on a damper.
</p>

<IMG src=\"modelica://Modelica/Resources/Images/MultiBody/Forces/Damper.png\">

</HTML>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-101,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-15},{84,-95}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Text(
                  extent={{-150,50},{150,90}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(visible=useHeatPort,
                  points={{-100,-99},{-100,-25},{-10,-25}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(points={{-36,-15},{-36,-95},{84,-95},{84,-15},{54,-15},{54,-95},{-6,
                      -95},{-6,-15},{-36,-15},{-36,-35},{84,-35},{84,-55},{-36,-55},{-36,
                      -75},{84,-75},{84,-95},{-36,-95},{-36,-15},{84,-15},{84,-95}},
                                                                              color={
                      0,0,0}),
                Line(points={{24,-15},{24,-95}},
                                              color={0,0,0}),
                Rectangle(
                  extent={{-36,-15},{-6,-35}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-35},{-6,-55}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-55},{-6,-75}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-36,-75},{-6,-95}},
                  lineColor={0,0,0},
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-100,0},{-60,0}}, color={0,0,0}),
                Line(points={{-60,-30},{-60,30}}, color={0,0,0}),
                Line(points={{-60,-30},{60,-30}}, color={0,0,0}),
                Line(points={{-60,30},{60,30}}, color={0,0,0}),
                Rectangle(
                  extent={{-60,30},{30,-30}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{30,0},{100,0}}, color={0,0,0}),
                Line(points={{-50,60},{50,60}}, color={128,128,128}),
                Text(
                  extent={{-40,64},{23,77}},
                  lineColor={128,128,128},
                  textString="der(s)"),
                Polygon(
                  points={{64,60},{42,68},{42,52},{62,60},{64,60}},
                  lineColor={128,128,128},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{8,-64},{27,-64},{27,-40},{24,-46},{31,-46},{28,-41}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{25,-29},{72,-57}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Supplies the force 'f'
in the text layer")}));
        end Damper_From_Table;
      end Suspension_Components;

      package Running_Gear_Components
        extends Modelica.Icons.Package;

        model Idler_Arm "Attachment arm for idler wheel and tensioner"
          parameter Modelica.SIunits.Length lever_arm_wheel
            "Distance from center of hull bearing to wheel bearing (projected in side view)"
            annotation (Dialog(group="Lever Arm - Wheel"));
            parameter Modelica.SIunits.Length offset_wheel
            "Lateral offset of wheel center from hull bearing"
            annotation (Dialog(group="Lever Arm - Wheel"));
            parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg initial_angle
            "Estimated initial angle of idler arm"
            annotation (Dialog(group="Lever Arm - Wheel"));

           parameter Modelica.SIunits.Length lever_arm_tensioner
            "Distance from center of hull bearing to tensioner attachment (projected in side view)"
            annotation (Dialog(group="Lever Arm - Tensioner"));
            parameter Modelica.SIunits.Length bracket_height_tensioner
            "Distance of tensioner attachment above or below the line from hull bearing to wheel bearing (projected in side view)"
            annotation (Dialog(group="Lever Arm - Tensioner"));
            parameter Modelica.SIunits.Length offset_tensioner
            "Lateral offset of tensioner attachment from hull bearing"
            annotation (Dialog(group="Lever Arm - Tensioner"));

            parameter Modelica.SIunits.Length lever_arm_CG_idler
            "Distance from center of hull bearing to arm CG location (projected in side view)"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));
            parameter Modelica.SIunits.Length bracket_height_CG_idler
            "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));
            parameter Modelica.SIunits.Length offset_CG_idler
            "Lateral offset of arm CG location from hull bearing"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));

            parameter Modelica.SIunits.Mass m_arm(min=0) "Mass of arm"
            annotation (Dialog(group="Mass Properties"));
            parameter Modelica.SIunits.Inertia I_xx_arm(min=0)
            "(1,1) element of inertia tensor"
            annotation (Dialog(group="Mass Properties"));
            parameter Modelica.SIunits.Inertia I_yy_arm(min=0)
            "(2,2) element of inertia tensor"
            annotation (Dialog(group="Mass Properties"));
            parameter Modelica.SIunits.Inertia I_zz_arm(min=0)
            "(3,3) element of inertia tensor"
            annotation (Dialog(group="Mass Properties"));
        protected
          parameter Modelica.SIunits.Length length_tensioner_x=sqrt((lever_arm_tensioner^2)-(bracket_height_tensioner^2))
            "X-component of lever arm length - tensioner";
          parameter Modelica.SIunits.Length length_CG_x=sqrt((lever_arm_CG_idler^2)-(bracket_height_CG_idler^2))
            "X-component of lever arm length - CG";
          parameter Modelica.SIunits.Angle initial_angle_rad = initial_angle*pi/180;

        public
          MSL_Extend.Mechanics.Planar.Joints.Revolute
                                               hull_pivot(
            a(fixed=true),
            useAxisFlange=false,
            phi(start=initial_angle_rad))
            annotation (Placement(transformation(extent={{-74,-10},{-54,10}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       tensioner_x(r={
                length_tensioner_x,0})
            "Road arm length from chassis attachment to tensioner attachment"
                       annotation (Placement(transformation(extent={{0,-10},{20,10}})));
          MSL_Extend.Mechanics.Planar.Parts.Body
                                           CG(
            m=m_arm, J=I_zz_arm)
            annotation (Placement(transformation(extent={{80,-180},{100,-160}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       wheel_x(r={lever_arm_wheel,0})
            "Road arm length from chassis attachment to road wheel attachment"
                       annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       arm_cm_x(r={length_CG_x,0})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{0,-140},{20,-120}})));
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  hull     annotation (
              Placement(transformation(rotation=0, extent={{-120,-16},{-92,16}}),
                iconTransformation(
                extent={{-14,-16},{14,16}},
                rotation=180,
                origin={-204,-60})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                          wheel(includeBearingConnector=
               true)                                               annotation (
              Placement(transformation(rotation=0, extent={{-14,-16},{14,16}},
                origin={90,-80}),
                iconTransformation(extent={{-14,-16},{14,16}},
                rotation=180,
                origin={204,0})));
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_b tensioner annotation (
              Placement(transformation(rotation=90,extent={{-14,-16},{14,16}},
                origin={80,40}),
                iconTransformation(extent={{-14,-16},{14,16}},
                rotation=180,
                origin={204,180})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       arm_cm_y(r={0,
                bracket_height_CG_idler})
            "Road Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={30,-150})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                       tensioner_y(r={0,
                bracket_height_tensioner})
            "Road arm length from chassis attachment to tensioner attachment"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={30,20})));

          Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
              tau_constant=0)
            annotation (Placement(transformation(extent={{100,-60},{120,-40}})));

        equation
          connect(tensioner_x.frame_a, hull_pivot.frame_b)     annotation (Line(
              points={{0,0},{-54,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull, hull_pivot.frame_a)         annotation (Line(
              points={{-106,0},{-74,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull_pivot.frame_b, wheel_x.frame_a) annotation (Line(
              points={{-54,0},{-40,0},{-40,-40},{0,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_b, arm_cm_y.frame_a)
                                                   annotation (Line(
              points={{20,-130},{30,-130},{30,-140}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tensioner_x.frame_b, tensioner_y.frame_a)
                                                     annotation (Line(
              points={{20,0},{30,0},{30,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));

          connect(arm_cm_x.frame_a, hull_pivot.frame_b) annotation (Line(
              points={{0,-130},{-40,-130},{-40,0},{-54,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(constantTorque.flange, wheel.flange) annotation (Line(
              points={{120,-50},{120,-80},{90,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_cm_y.frame_b, CG.frame_a) annotation (Line(
              points={{30,-160},{30,-170},{80,-170}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(wheel_x.frame_b, wheel.bearingFrame) annotation (Line(
              points={{20,-40},{42,-40},{42,-80},{90,-80}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tensioner_y.frame_b, tensioner) annotation (Line(
              points={{30,30},{30,40},{80,40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -200},{200,200}}),
                              graphics),
            experiment(StopTime=5),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}}),
                                graphics={
                Rectangle(
                  extent={{-200,200},{200,-200}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-120,50},{120,-50}},
                  lineColor={86,86,68},
                  origin={-10,-10},
                  rotation=225,
                  fillColor={217,217,172},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-65,-65},{65,65}},
                  lineColor={0,0,255},
                  origin={76,76},
                  rotation=360,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-70,-70},{70,70}},
                  lineColor={0,0,255},
                  origin={-80,-80},
                  rotation=360,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{134,14},{194,-14}},
                  lineColor={0,0,0},
                  textString="w"),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={76,126},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={32,101},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={32,51},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={76,26},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={120,51},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-8,-8},{8,8}},
                  lineColor={0,0,255},
                  origin={120,101},
                  rotation=360,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-200,-6},{-140,-34}},
                  lineColor={0,0,0},
                  textString="h"),
                Text(
                  extent={{130,184},{190,156}},
                  lineColor={0,0,0},
                  textString="t")}));
        end Idler_Arm;

        model Rigid_Tensioner "Track tensioner that has a fixed length"

          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  hull    annotation (
              Placement(transformation(
                extent={{-16,-16},{16,16}},
                rotation=0,
                origin={-162,0}), iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=180,
                origin={204,-74})));
          parameter Modelica.SIunits.Length ideal_length
            "Ideal distance from hull attachment to idler arm attachment (projected in side view)"
            annotation (Dialog(group="Dimensions"));

          parameter Modelica.SIunits.Length lever_arm_CG_tensioner
            "Distance from center of hull attachment to arm CG location (projected in side view)"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));
          parameter Modelica.SIunits.Length bracket_height_CG_tensioner
            "Distance of CG above or below the line from hull attachment to wheel bearing (projected in side view)"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));
          parameter Modelica.SIunits.Length offset_CG_tensioner
            "Lateral offset of arm CG location from hull attachment"
            annotation (Dialog(group="Lever Arm - Center of Gravity"));

          parameter Modelica.SIunits.Mass m_tensioner "Mass of tensioner" annotation (Dialog(group="Mass Properties"));
          parameter Modelica.SIunits.Inertia I_xx_tensioner
            "(1,1) element of inertia tensor"                                                 annotation (Dialog(group="Mass Properties"));
          parameter Modelica.SIunits.Inertia I_yy_tensioner
            "(2,2) element of inertia tensor"                                                 annotation (Dialog(group="Mass Properties"));
          parameter Modelica.SIunits.Inertia I_zz_tensioner
            "(3,3) element of inertia tensor"                                                 annotation (Dialog(group="Mass Properties"));

        protected
          parameter Modelica.SIunits.Length length_CG_x=sqrt((lever_arm_CG_tensioner^2)-(bracket_height_CG_tensioner^2))
            "X-component of lever arm length - CG";

        public
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_b idler_arm
                                                                  annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=180,
                origin={142,0}),   iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=0,
                origin={-204,-20})));

          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation tensioner_x(
            animation=true,
            r={ideal_length,0},
            color={0,0,200},
            width=0.1,
            height=0.1,
            specularCoefficient=0.1)
            "Arm length from chassis attachment to idler arml attachment"
                       annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation arm_cm_x(
            width=0.06,
            height=0.06,
            r={length_CG_x,0},
            specularCoefficient=0.2,
            color={0,0,200},
            animation=false)
            "Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation arm_cm_y(
            width=0.06,
            height=0.06,
            r={0,bracket_height_CG_tensioner},
            specularCoefficient=0.2,
            color={0,0,200},
            animation=false)
            "Arm length from chassis attachment to arm center of mass"
                       annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-70})));

          MSL_Extend.Mechanics.Planar.Parts.Body body(
            m=m_tensioner,
            J=I_zz_tensioner,
            cylinderColor={0,128,255},
            sphereDiameter=0.0005*m_tensioner)
            "Represents mass and inertia of the tensioner assembly"
            annotation (Placement(transformation(extent={{0,-100},{20,-80}})));
          MSL_Extend.Mechanics.Planar.Joints.Revolute
                                               revolute
            annotation (Placement(transformation(extent={{-140,-10},{-120,10}})));
          MSL_Extend.Mechanics.Planar.Joints.Revolute  revolute1
            annotation (Placement(transformation(extent={{80,-10},{100,10}})));
        equation
          connect(arm_cm_x.frame_b, arm_cm_y.frame_a) annotation (Line(
              points={{-80,-50},{-60,-50},{-60,-60}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(revolute.frame_b, tensioner_x.frame_a)
                                                     annotation (Line(
              points={{-120,0},{-60,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_x.frame_a, revolute.frame_b) annotation (Line(
              points={{-100,-50},{-110,-50},{-110,0},{-120,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hull, revolute.frame_a) annotation (Line(
              points={{-162,0},{-140,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(revolute1.frame_b, idler_arm) annotation (Line(
              points={{100,0},{142,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tensioner_x.frame_b, revolute1.frame_a) annotation (Line(
              points={{-40,0},{80,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_cm_y.frame_b, body.frame_a) annotation (Line(
              points={{-60,-80},{-60,-90},{0,-90}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -200},{200,200}}),
                              graphics),
            experiment(StopTime=10, Interval=0.001),
            __Dymola_experimentSetupOutput,
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics={
                Rectangle(
                  extent={{-200,200},{200,-200}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-160,30},{140,-30}},
                  lineColor={86,86,68},
                  origin={0,-35},
                  rotation=166,
                  fillColor={217,217,172},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-45,-45},{45,45}},
                  lineColor={0,0,255},
                  origin={-130,0},
                  rotation=360,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,-36},{36,36}},
                  lineColor={0,0,255},
                  origin={156,-74},
                  rotation=360,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{140,-2},{200,-30}},
                  lineColor={0,0,0},
                  textString="h"),
                Text(
                  extent={{-220,-40},{-160,-68}},
                  lineColor={0,0,0},
                  textString="i")}));
        end Rigid_Tensioner;
      end Running_Gear_Components;

      package Component_Test_Cases
        extends Modelica.Icons.Package;

        model Hydropneumatic_Arm_Test

        extends MSL_Extend.Icons.Simple_Test_Case;

          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.TrackSusp_SubAssembly_Hydropneumatic
                                                                                                                suspension(
            spring_scale=0.5,
            t_phi_table_max=[-20,-2000; -10,-1000; 0,0; 10,1000; 20,2000],
            t_phi_table_min=[-20,-1000; -10,-500; 0,0; 10,500; 20,1000],
            lever_arm_wheel=0.5,
            offset_wheel=0.2,
            lever_arm_CG=0.25,
            bracket_height_CG=0,
            offset_CG=0.1,
            t_w_table_max=[-1.5,-405.49; -1.375,-393.34; -1.25,-385.69; -1.125,-376.48;
                -1,-361.57; -0.875,
                                  -339.52; -0.75,
                                                -311.69; -0.625,
                                                               -281.54; -0.5,
                                                                            -253.28; -0.375,
                -229.75; -0.25,
                              -209.6; -0.125,
                                            -183.74; -0.1,
                                                         -176.29; -0.05,
                                                                       -157.34; -0.01,
                                                                                     -137.03;
                0,0;0.01,66.7;0.05,129.04;0.1,142.09;0.125,147.44;0.25,168.06;0.375,186.51;0.5,
                   208.15;0.625,233.49;0.75,260.57;0.875,286.68; 1,309.62; 1.125,328.35;
                1.25,343.1; 1.375,354.94; 1.5,364.79],
            t_w_table_min=[-1.5,-155.4; -1.375,-137.02; -1.25,-119.12; -1.125,-100.36; -1,
                -81.15; -0.875,
                              -62.82; -0.75,
                                           -46.93; -0.625,
                                                         -34.72; -0.5,
                                                                     -26.6; -0.375,
                                                                                  -21.85;
                -0.25,
                     -18.29; -0.125,
                                   -12.21; -0.1,
                                               -10.24; -0.05,
                                                            -5.18; -0.01,
                                                                        0.19;0,0;0.01,6.18;0.05,
                    7.38;0.1,9.23;0.125,10.36;0.25,18.6;0.375,32.01;0.5,50.73;0.625,73.99;0.75,
                    100.46;0.875,128.6; 1,156.98; 1.125,184.68; 1.25,211.56; 1.375,238.67;
                1.5,268.55],
            compression_scale=0.9,
            rebound_scale=0.1,
            arm_install_angle=-0.5235987755983,
            m_arm=50,
            I_xx_arm=1,
            I_yy_arm=1,
            I_zz_arm=1)
            annotation (Placement(transformation(extent={{-60,40},{-20,80}})));
          Modelica.Blocks.Sources.Sine sine(
            startTime=1,
            amplitude=10000,
            freqHz=1)
            annotation (Placement(transformation(extent={{-148,-30},{-128,-10}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-148,-76},{-128,-56}})));
          MSL_Extend.Mechanics.Planar.Forces.Force       force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-30,-10})));
          Modelica.Mechanics.Rotational.Components.Fixed fixed1
            annotation (Placement(transformation(extent={{14,14},{34,34}})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearingAdaptor adaptor(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-40,14},{-20,34}})));
          MSL_Extend.Mechanics.Planar.Parts.Fixed
                                            fixed
            annotation (Placement(transformation(extent={{-156,96},{-136,116}})));
        equation
          connect(suspension.wheel, adaptor.flangeAndFrame) annotation (Line(
              points={{-40,39.6},{-40,24}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(force.frame_b, adaptor.frame) annotation (Line(
              points={{-30,0},{-30,14}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(sine.y, force.f[2]) annotation (Line(
              points={{-127,-20},{-88,-20},{-88,-66},{-31,-66},{-31,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(const.y, force.f[1]) annotation (Line(
              points={{-127,-66},{-29,-66},{-29,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(fixed1.flange, adaptor.flange) annotation (Line(
              points={{24,24},{-30,24}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(fixed.frame, suspension.hull) annotation (Line(
              points={{-146,106},{-40,106},{-40,80.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Hydropneumatic_Arm_Test;

        model Torsion_Bar_Translational_Damper_Arm_Test
          "Using damper with max-min ranges"

        extends MSL_Extend.Icons.Simple_Test_Case;

          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.TrackSusp_SubAssembly_Torsion_Trans_Damper_Range
            suspension(
            lever_arm_wheel=0.5,
            offset_wheel=0.2,
            lever_arm_CG=0.25,
            bracket_height_CG=0,
            offset_CG=0.1,
            lever_arm_damper=0.15,
            bracket_height_damper=-0.2,
            f_v_table_max=[-1.5,-405.49; -1.375,-393.34; -1.25,-385.69; -1.125,-376.48;
                -1,-361.57; -0.875,
                                  -339.52; -0.75,
                                                -311.69; -0.625,
                                                               -281.54; -0.5,
                                                                            -253.28; -0.375,
                -229.75; -0.25,
                              -209.6; -0.125,
                                            -183.74; -0.1,
                                                         -176.29; -0.05,
                                                                       -157.34; -0.01,
                                                                                     -137.03;
                0,0;0.01,66.7;0.05,129.04;0.1,142.09;0.125,147.44;0.25,168.06;0.375,186.51;0.5,
                   208.15;0.625,233.49;0.75,260.57;0.875,286.68; 1,309.62; 1.125,328.35;
                1.25,343.1; 1.375,354.94; 1.5,364.79],
            f_v_table_min=[-1.5,-155.4; -1.375,-137.02; -1.25,-119.12; -1.125,-100.36; -1,
                -81.15; -0.875,
                              -62.82; -0.75,
                                           -46.93; -0.625,
                                                         -34.72; -0.5,
                                                                     -26.6; -0.375,
                                                                                  -21.85;
                -0.25,
                     -18.29; -0.125,
                                   -12.21; -0.1,
                                               -10.24; -0.05,
                                                            -5.18; -0.01,
                                                                        0.19;0,0;0.01,6.18;0.05,
                    7.38;0.1,9.23;0.125,10.36;0.25,18.6;0.375,32.01;0.5,50.73;0.625,73.99;0.75,
                    100.46;0.875,128.6; 1,156.98; 1.125,184.68; 1.25,211.56; 1.375,238.67;
                1.5,268.55],
            L_max=1,
            L_min=0.5,
            offset_damper=-0.1,
            damper_top_mount_x=0.5,
            damper_top_mount_y=0.3,
            damper_top_mount_z=-0.1,
            m_bar=0,
            rebound_scale=0.9,
            m_damper=0,
            compression_scale=0.2,
            m_arm=50,
            I_xx_arm=1,
            I_yy_arm=1,
            I_zz_arm=1,
            c_bar=600,
            torsion_bar_install_angle=-0.5235987755983)
            annotation (Placement(transformation(extent={{-60,40},{-20,80}})));
          Modelica.Blocks.Sources.Sine sine(
            startTime=1,
            amplitude=10000,
            freqHz=1)
            annotation (Placement(transformation(extent={{-148,-30},{-128,-10}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-148,-76},{-128,-56}})));
          MSL_Extend.Mechanics.Planar.Forces.Force       force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-40,-10})));
          MSL_Extend.Mechanics.Planar.Parts.Fixed
                                            fixed
            annotation (Placement(transformation(extent={{-134,90},{-114,110}})));
        equation
          connect(force.frame_b, suspension.wheel) annotation (Line(
              points={{-40,0},{-40,39.6}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(force.f[1], const.y) annotation (Line(
              points={{-39,-22},{-40,-22},{-40,-66},{-127,-66}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sine.y, force.f[2]) annotation (Line(
              points={{-127,-20},{-90,-20},{-90,-66},{-41,-66},{-41,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(fixed.frame, suspension.hull) annotation (Line(
              points={{-124,100},{-40,100},{-40,80.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Torsion_Bar_Translational_Damper_Arm_Test;
      end Component_Test_Cases;

      package Contact_Models

        function point_to_line
          "calculate the vector distance from point to line"
          input Real p1[2];
          input Real p2[2];
          input Real p3[2];
          output Real d[2];
          output Integer d_t;
        protected
          Real x;
          Real y;
          Real u;
          Real l_sq;
        algorithm
          l_sq := (p2[1] - p1[1])^2 + (p2[2] - p1[2])^2;
          u := ((p3[1] - p1[1]) * (p2[1] - p1[1]) + (p3[2] - p1[2]) * (p2[2] - p1[2])) / l_sq;
          if u <= 0 then
            d := {p3[1] - p1[1], p3[2] - p1[2]};
            d_t := 0;
          elseif u >= 1 then
            d := {p3[1] - p2[1], p3[2] - p2[2]};
            d_t := 1;
          else
            x := p1[1] + u * (p2[1] - p1[1]);
            y := p1[2] + u * (p2[2] - p1[2]);
            d := {p3[1] - x, p3[2] - y};
            d_t := -1;
          end if;
        end point_to_line;

        function closest_line_search "returns vector distance to closest line"
          import
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.point_to_line;
          input Real p[:,2];
          input Real pt[2];
          input Real radius;
          output Real d[2];
          output Integer d_t;
        protected
          Integer i;
          Integer upper_bound;
          Integer lower_bound;
          Integer upper_max;
          Integer lower_min;
          Integer mid_point;
          Real d_sq_temp;
          Real d_sq = 1e30;
          Real d_temp[2];
          Integer d_tt = -1;
          Boolean found_contact = false;
        algorithm
          lower_bound := 1;
          upper_bound := size(p, 1);
          lower_min := 1;
          upper_max := size(p, 1);
          while (upper_bound - lower_bound > 1) loop
            mid_point := div((upper_bound + lower_bound), 2);
            if pt[1] >= p[mid_point, 1] then
              lower_bound := mid_point;
              if (pt[1] - radius) > p[mid_point, 1] then
                lower_min := mid_point;
              end if;
            else
              upper_bound := mid_point;
              if (pt[1] + radius) < p[mid_point, 1] then
                upper_max := mid_point;
              end if;
            end if;
          end while;

          for i in lower_min:(upper_max - 1) loop
            (d_temp, d_tt) := point_to_line(p[i,:], p[i+1,:], pt);
            d_sq_temp := d_temp[1] * d_temp[1] + d_temp[2] * d_temp[2];
            if d_sq_temp < d_sq then
              found_contact := true;
              d_sq := d_sq_temp;
              d := d_temp;
              if d_tt < 0 then
                // closest to a segment
                d_t := -i;
              else
                d_t := i + d_tt;
              end if;
            end if;
          end for;
          if d_t == 1 then
            d_t := -1;
          elseif d_t == size(p,1) then
            d_t := -(d_t - 1);
          end if;
          assert(found_contact, "No match found within sqrt(1e30) m");
        end closest_line_search;

        model Tire_Contact_Force_Physical_Normal_And_Friction
          "Generates contact force directly to attached frame"
          extends
            Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

          import
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.closest_line;
          import Modelica.Fluid.Utilities.regStep;
        //  import Modelica.Mechanics.MultiBody.Frames.resolve2;

          parameter StateSelect stateSelect=StateSelect.prefer
            "Priority to use phi_rel and w_rel as states"
          annotation(HideResult=true, Dialog(tab="Advanced"));
          parameter Modelica.SIunits.Distance s_nominal=1e-3
            "Nominal value of s_rel (used for scaling)"   annotation(Dialog(tab="Advanced"));
          parameter Modelica.SIunits.Radius radius=1.0
            "Radius to contact patch"                                             annotation(Dialog(group="Wheel Properties"));
          parameter Real c(final unit="N/m", final min=0, start=1) = 1e7
            "Spring constant"                                                              annotation(Dialog(group="Wheel Properties"));
          parameter Real d(final unit="N/(m/s)", final min=0, start=1)= 1e5
            "Damping constant" annotation(Dialog(group="Wheel Properties"));
          parameter Real n(final min=1) = 1.0
            "Exponent of spring force ( f_c = -c*|s_rel-s_rel0|^n )" annotation(Dialog(group="Wheel Properties"));

          // Don't really need s_rel0 but kept around for easier comparison with original
          // ElastoGap code
          constant Modelica.SIunits.Position s_rel0=0
            "Unstretched spring length";

          parameter Modelica.SIunits.CoefficientOfFriction mue_sliding=0.35
            "[w,mue] positive sliding friction coefficient (w_rel>=0)" annotation (Dialog(group="Friction"));
          parameter Modelica.SIunits.CoefficientOfFriction mue_locked=0.7
            "[w,mue] positive sliding friction coefficient (w_rel>=0)" annotation (Dialog(group="Friction"));
          parameter Real peak=mue_locked/mue_sliding annotation (Dialog(group="Friction"));
          parameter Modelica.SIunits.Velocity v_small=1e-3
            "Small velocity used in regularization of friction forces"    annotation(Dialog(tab="Advanced"));

          SI.Position s_rel(start=0, stateSelect=stateSelect, nominal=s_nominal);
          SI.Velocity v_rel(start=0, stateSelect=stateSelect)
            "Relative velocity (= der(s_rel))";

          Boolean contact "=true, if contact, otherwise no contact";
          Modelica.SIunits.Force f_c "Spring force";
          Modelica.SIunits.Force f_d
            "Linear damping force which is limited by spring force (|f_d| <= |f_c|)";

          SI.Force f_norm;
          SI.Force f_fric;
          SI.Power lossPower;

          SI.Velocity v_rel_fric;

          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  frame_a
            "Center of wheel"                                                       annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={0,100})));

          Modelica.Mechanics.Translational.Interfaces.Flange_b flange_b
            "Surface of wheel(right) flange fixed in housing"
                                              annotation (Placement(transformation(
                  extent={{110,56},{90,36}},  rotation=0)));
        protected
          outer
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground;
          parameter Integer size_p=size(p, 1);
          Real dl[2];
        //   Real line[3];
          Real line[2];
          Integer d_t;
          SI.Force f_sl;
          Modelica.SIunits.Force f_d2 "Uncorrected linear damping force";
          parameter Modelica.SIunits.Velocity v_small_half = v_small * 0.5;
          parameter Modelica.SIunits.Velocity v_small_x15 = v_small * 1.5;
          parameter Real p[:,2]=ground.p;
          parameter Real p_length[size_p - 1]=ground.p_length;
          outer C2M2L_OM.MSL_Extend.Mechanics.Planar.World world;

          encapsulated model Housing
            import Modelica;
            import C2M2L_OM;
            input Modelica.SIunits.Force f[2];
            C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a
                                                            frame_a
                                       annotation (Placement(transformation(extent={{
                      -116,-16},{-84,16}}, rotation=0)));
          equation
            frame_a.f = f;
            frame_a.tau = 0;
            annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                      {100,100}}), graphics={Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-150,110},{150,150}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end Housing;
          Housing housing(f=f_local) if                                     world.driveTrainMechanics2D
                        annotation (Placement(transformation(extent={{20,-60},{40,-40}},
                rotation=0)));
          SI.Force f_local[2];
        equation
          // Find the closest line (or point) from the center line profile
          // dl is the vector distance {x,y} from the wheel center to the profile
          // If d_t is +ve, wheel center is closest to point p[d_t] else to line p[-dt] to p[1-dt]
          (dl,d_t) =
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.closest_line_search(
            p,
            frame_a.s,
            radius);

          // Calculate a signed distance from the ground based on the sign of y (dl[2])
          // ensures to get a force that reacts against the ground
          s_rel = sqrt(dl[1] * dl[1] + dl[2] * dl[2]) * sign(dl[2]);

          // Calculate the slope of the ground.  If closest to a point, the 'slope' is
          // perpendicular to the line from the ground to the wheel center.
          // Also calculate the relative normal velocity between the wheel and the ground
          if d_t < 0 then
            // closest to a line
            line = {p[1 - d_t, 1] - p[-d_t, 1],p[1 - d_t, 2] - p[-d_t, 2]} / p_length[-d_t];
            // v_rel = -(cross(line, {0,0,1})) * {der(frame_a.s[1]), der(frame_a.s[2]), 0};
            //v_rel = -{-line[2], line[1]} * {der(frame_a.s[1]), der(frame_a.s[2])};
            v_rel = -{line[2], -line[1]} * {der(frame_a.s[1]), der(frame_a.s[2])};
          else
            // closest to a point
            if noEvent(abs(s_rel) > 1e-6) then
              // use distance vector directly
              // line = (cross({0,0,1}, {dl[1],dl[2],0}))/abs(s_rel);
              line = ({-dl[2],dl[1]})/abs(s_rel);
            else
              // too close, dl is likely degenerate, so use average of adjacent lines instead
              if d_t == 1 then
                line = {p[d_t + 1, 1] - p[d_t, 1], p[d_t + 1, 2] - p[d_t, 2]}/p_length[d_t];
              elseif d_t == size_p then
                line = {p[d_t, 1] - p[d_t - 1, 1], p[d_t, 2] - p[d_t - 1, 2]}/p_length[d_t - 1];
              else
                line = ({p[d_t + 1, 1] - p[d_t, 1], p[d_t + 1, 2] - p[d_t, 2]}/p_length[d_t] +
                        {p[d_t, 1] - p[d_t - 1, 1], p[d_t, 2] - p[d_t - 1, 2]}/p_length[d_t - 1])/2;
              end if;
            end if;
            v_rel = -der(sqrt((p[d_t, 1] - frame_a.s[1]) * (p[d_t, 1] - frame_a.s[1]) +
                              (p[d_t, 2] - frame_a.s[2]) * (p[d_t, 2] - frame_a.s[2])));
          end if;

          // Calculate normal force fn based on c, d, s_rel, v_rel and contact
          contact = s_rel < s_rel0;
          f_c = smooth(1, noEvent(if contact then c*abs(s_rel - s_rel0)^n else 0));
          f_d2 = (if contact then -d*v_rel else 0);
          f_d = smooth(0, noEvent(if contact then (if f_d2 > f_c then f_c else
                                  if f_d2 < -f_c then -f_c else f_d2) else 0));
          f_norm = f_c + f_d;

          // Calculate relative slip velocity between wheel movement -> line*der(frame_a.r_0)
          // and wheel periphery translational speed der(flange_b.s)
          v_rel_fric = der(flange_b.s) + line*der(frame_a.s);

          // Use a regularized step function to smooth sliding friction force thru zero
          // within -v_small < v_rel < v_small
          f_sl = regStep(v_rel_fric, 1, -1, v_small) * mue_sliding * f_norm;

          // Use another step to increase torque to account for static friction when locked
          // Step will give maximum static torque at w_rel = w_small, not until w_rel > (2*w_small)
          // will the torque have all static influence removed.
          f_fric = regStep(abs(v_rel_fric) - v_small_x15, f_sl, f_sl*peak, v_small_half);

          // Sum resultant forces together (except during initialization when the net force is
          // set to {0,0,0})
          if initial() then
            f_local = zeros(2);
          else
        //     f_local = -C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, -line * f_fric - cross(line, {0,0,1}) * f_norm);
            //f_local = -C2M2L_OM.MSL_Extend.Mechanics.Planar.Frames.resolve2(frame_a.phi, -line * f_fric - {line[2], -line[1]} * f_norm);
            //f_local = -(-line * f_fric - {line[2], -line[1]} * f_norm);
            f_local = (line * f_fric + {line[2], -line[1]} * f_norm);
          end if;
          // Apply reaction force to outside of wheel
          flange_b.f = f_fric;

          // Loss power includes both damping and friction losses
          lossPower = f_fric*v_rel_fric + f_d*v_rel;

          connect(housing.frame_a, frame_a) annotation (Line(
              points={{20,-50},{0,-50},{0,100}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));

          annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})),
            Window(
              x=0.23,
              y=0.04,
              width=0.62,
              height=0.69),
            Documentation(info="<html>
<p>
This component models a spring damper combination that can lift off.
It can be connected between a sliding mass and the housing (model
<a href=\"modelica://Modelica.Mechanics.Translational.Components.Fixed\">Fixed</a>),
to describe the contact of a sliding mass with the housing.
</p>

<p>
As long as s_rel &gt; s_rel0, no force is exerted (s_rel = flange_b.s - flange_a.s).
If s_rel &le; s_rel0, the contact force is basically computed with a linear
spring/damper characteristic. With parameter n&ge;1 (exponent of spring force),
a nonlinear spring force can be modeled:
</p>

<pre>
   desiredContactForce = c*|s_rel - s_rel0|^n + d*<b>der</b>(s_rel)
</pre>

<p>
Note, Hertzian contact is described by:
</p>
<ul>
<li> Contact between two metallic spheres: n=1.5</li>
<li> Contact between two metallic plates: n=1</li>
</ul>

<p>
The above force law leads to the following difficulties:
</p>

<ol>
<li> If the damper force becomes larger as the spring force and with opposite sign,
     the contact force would be \"pulling/sticking\" which is unphysical, since during
     contact only pushing forces can occur.</li>

<li> When contact occurs with a non-zero relative speed (which is the usual
     situation), the damping force has a non-zero value and therefore the contact
     force changes discontinuously at s_rel = s_rel0. Again, this is not physical
     because the force can only change continuously. (Note, this component is not an
     idealized model where a steep characteristic is approximated by a discontinuity,
     but it shall model the steep characteristic.)</li>
</ol>

<p>
In the literature there are several proposals to fix problem (2). Especially, often
the following model is used (see, e.g.,
Lankarani, Nikravesh: Continuous Contact Force Models for Impact
Analysis in Multibody Systems, Nonlinear Dynamics 5, pp. 193-207, 1994,
<a href=\"http://www.springerlink.com/content/h50x61270q06p65n/fulltext.pdf\">pdf-download</a>):
</p>

<pre>
   f = c*s_rel^n + (d*s_rel^n)*<b>der</b>(s_rel)
</pre>

<p>
However, this and other models proposed in literature violate
issue (1), i.e., unphysical pulling forces can occur (if d*<b>der</b>(s_rel)
becomes large enough). Note, if the force law is of the form \"f = f_c + f_d\", then a
necessary condition is that |f_d| &le; |f_c|, otherwise (1) and (2) are violated.
For this reason, the most simplest approach is used in the ElastoGap model
to fix both problems by using this necessary condition in the force law directly.
If s_rel0 = 0, the equations are:
</p>

<pre>
    <b>if</b> s_rel &ge; 0 <b>then</b>
       f = 0;    // contact force
    <b>else</b>
       f_c  = -c*|s_rel|^n;          // contact spring force (Hertzian contact force)
       f_d2 = d*<b>der</b>(s_rel);         // linear contact damper force
       f_d  = <b>if</b> f_d2 &lt;  f_c <b>then</b>  f_c <b>else</b>
              <b>if</b> f_d2 &gt; -f_c <b>then</b> -f_c <b>else</b> f_d2;  // bounded damper force
       f    = f_c + f_d;            // contact force
    <b>end if</b>;
</pre>

<p>
Note, since |f_d| &le; |f_c|, pulling forces cannot occur and the contact force
is always continuous, especially around the start of the penetration at s_rel = s_rel0.
</p>

<p>
In the next figure, a typical simulation with the ElastoGap model is shown
(<a href=\"modelica://Modelica.Mechanics.Translational.Examples.ElastoGap\">Examples.ElastoGap</a>)
where the different effects are visualized:
</p>

<ol>
<li> Curve 1 (elastoGap1.f) is the unmodified contact force, i.e., the linear spring/damper
     characteristic. A pulling/sticking force is present at the end of the contact.</li>
<li> Curve 2 (elastoGap2.f) is the contact force, where the force is explicitly set to
     zero when pulling/sticking occurs. The contact force is discontinuous when contact starts.</li>
<li> Curve 3 (elastoGap3.f) is the ElastoGap model of this library. No discontinuity and no
     pulling/sticking occurs.</li>
</ol>

<img src=\"modelica://Modelica/Resources/Images/Translational/ElastoGap1.png\">
</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(
                  points={{-50,34},{-50,-46}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{8,40},{8,2}}, color={0,0,0}),
                Line(points={{-2,0},{38,0},{38,44},{-2,44}}, color={0,0,0}),
                Line(points={{38,22},{72,22}}, color={0,0,0}),
                Line(
                  points={{-12,-38},{-12,20}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{-12,22},{8,22}}, color={0,0,0}),
                Line(points={{-12,-38},{-2,-38}}, color={0,0,0}),
                Line(points={{72,22},{72,-42}}, color={0,0,0}),
                Line(points={{-2,-38},{10,-28},{22,-48},{38,-28},{50,-48},{64,-28},{72,-40}},
                    color={0,0,0}),
                Rectangle(
                  extent={{8,44},{38,0}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-64,-80},{64,-64}},
                  lineColor={0,0,255},
                  textString="s_rel"),
                Line(points={{-100,-29},{-100,-61}}, color={0,0,0}),
                Line(points={{100,-61},{100,-28}}, color={0,0,0}),
                Line(points={{-98,-60},{98,-60}}, color={0,0,0}),
                Polygon(
                  points={{-101,-60},{-96,-59},{-96,-61},{-101,-60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{100,-60},{95,-61},{95,-59},{100,-60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Line(
                  points={{0,38},{0,-38}},
                  color={0,0,0},
                  thickness=1,
                  origin={2,-38},
                  rotation=90),
                Line(
                  points={{-20,-22},{20,-22},{20,22},{-20,22}},
                  color={0,0,0},
                  origin={-14,-7},
                  rotation=90),
                Line(
                  points={{-17,0},{17,0}},
                  color={0,0,0},
                  origin={-15,30},
                  rotation=90),
                Line(
                  points={{0,-37},{0,37}},
                  color={0,0,0},
                  thickness=1,
                  origin={2,-59},
                  rotation=90),
                Line(
                  points={{-10,0},{10,0}},
                  color={0,0,0},
                  origin={-14,-28},
                  rotation=90),
                Line(
                  points={{-3,0},{3,0}},
                  color={0,0,0},
                  origin={27,44},
                  rotation=90),
                Line(
                  points={{0,32},{0,-32}},
                  color={0,0,0},
                  origin={0,48},
                  rotation=90),
                Line(
                  points={{-37,0},{-25,10},{-13,-10},{3,10},{15,-10},{29,10},{37,-2}},
                  color={0,0,0},
                  origin={25,4},
                  rotation=90),
                Rectangle(
                  extent={{-15,22},{15,-22}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  origin={-14,-2},
                  rotation=90),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  extent={{-150,-129},{150,-99}},
                  lineColor={0,0,0},
                  textString="c=%c"),
                Text(
                  extent={{-150,-158},{150,-128}},
                  lineColor={0,0,0},
                  textString="d=%d"),
                Line(
                  points={{-2,0},{2,0}},
                  color={0,0,0},
                  origin={26,-36},
                  rotation=90),
                Line(
                  visible=useHeatPort,
                  points={{-100,-100},{-100,-44},{22,-44},{22,-28}},
                  color={191,0,0},
                  pattern=LinePattern.Dot,
                  smooth=Smooth.None),
                Line(
                  points={{-100,-4},{-100,-76},{2,-76},{2,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{2,48},{2,60},{100,60},{100,10}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-100,34},{-78,14},{-58,4},{-34,-6},{-12,-10},{10,-10},{38,-4},
                      {64,6},{86,24},{100,38}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash,
                  thickness=0.5)}));
        end Tire_Contact_Force_Physical_Normal_And_Friction;

        model Flat_Road "Smooth flat ground"
          extends Ground_Definition_2D(
             p_act=[10.0,0.5; 20.0,0.5], road=[10.0,0.0; 20.0,0.0]);

        end Flat_Road;

        model Ground_Definition_2D

          // Put the generated wheel center profile in here
          parameter Real p_act[:,2]=[-10,0.0; 10,0.0];

          //  Adding the actual road here enables it to be used for visualisation
          parameter Real road[:,2]=[-10,0.0; 10.0,0.0];

          // extend p a large amount behind and infront of p_act
          parameter Real p[size(p_act, 1) + 2,2]=cat(
              1,
              [-1000000,p_act[1, 2]],
              p_act,
              [1000000,p_act[size(p_act, 1), 2]]);

          // pre calculate the length of all segments
          parameter Real p_length[size(p, 1) - 1]={sqrt((p[i, 1] - p[i + 1, 1])^2 + (p[
              i, 2] - p[i + 1, 2])^2) for i in 1:(size(p, 1) - 1)};
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation actual_road[size(road, 1)
             - 1](r={{road[i + 1, 1] - road[i, 1],road[i + 1, 2] - road[i, 2]} for i in
                    1:(size(road, 1) - 1)},
            each width=0.02,
            color={if rem(i, 2) == 0 then {0,0,0} else {128,128,0} for i in 1:(size(road, 1))},
            each specularCoefficient=0,
            each animation=world.enableAnimation) if world.enableAnimation
            annotation (Placement(transformation(extent={{-34,32},{-14,52}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Fixed fixed1(s0={road[1, 1],
                road[1, 2]})
            annotation (Placement(transformation(extent={{-72,14},{-52,34}})));
          outer C2M2L_OM.MSL_Extend.Mechanics.Planar.World world
            annotation (Placement(transformation(extent={{50,71},{70,91}})));
        equation
            for i in 1:(size(road, 1) - 2) loop
            connect(actual_road[i].frame_b, actual_road[i + 1].frame_a);
          end for;
          connect(actual_road[1].frame_a,fixed1.frame) annotation (Line(
              points={{-34,42},{-44,42},{-44,24},{-62,24}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            defaultComponentName="ground",
            defaultComponentPrefixes="inner",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}),
                 graphics={            Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-90,-69},{90,-69},{90,-19},{80,-23},{70,-29},{60,-21},{50,
                      -22},{40,-28},{30,-23},{20,-21},{10,-18},{0,-22},{-10,-24},{-20,
                      -31},{-30,-29},{-40,-28},{-50,-18},{-60,-20},{-70,-26},{-81,-32},
                      {-90,-27},{-90,-69}},
                  smooth=Smooth.Bezier,
                  fillColor={255,170,85},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-90,-39},{90,-90}},
                  fillColor={255,170,85},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  origin={-50,1},
                  rotation=360),
                Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  origin={-30,-9},
                  rotation=360),
                Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  origin={-10,-4},
                  rotation=360),
                Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  origin={10,1},
                  rotation=360)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1})));
        end Ground_Definition_2D;
      end Contact_Models;

      model Base_Pulley
        "Partial model of pulley, used for the idler, guide wheel, and inside of the road wheel"

        parameter Modelica.SIunits.Length D_wheel(min=0)=0.6 "Wheel diameter"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Length W_wheel(min=0)=0.2 "Wheel width"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Length Z_offset(min=0)=0
          "Thickness of single road wheel flange (=0 if not a road wheel)"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Angle phi=0 "guess_angle"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Mass m_wheel(min=0)=50 "Mass of wheel"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_xx_wheel(min=0)=10
          "I_xx inertia of wheel"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_yy_wheel(min=0)=10
          "I_yy inertia of wheel"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_zz_wheel(min=0)=10
          "I_zz inertia of wheel"
          annotation (Dialog(enable=use_mass_and_viz,group="Pulley Details"));

        parameter Boolean fix_wheel_brg_phi = false
          "=true if angular position of pulley should be zero"
          annotation (Dialog(enable=use_mass_and_viz));
        parameter Boolean fix_wheel_brg_w = false
          "=true if angular velocity of pulley should be zero"
          annotation (Dialog(enable=use_mass_and_viz));
        parameter Boolean fix_wheel_brg_a = false
          "=true if angular accel of pulley should be zero"
          annotation (Dialog(enable=use_mass_and_viz));
        parameter StateSelect stateSelect=StateSelect.prefer
          "Priority to use joint angle phi and w=der(phi) as states"
          annotation (Dialog(enable=use_mass_and_viz));
        parameter Boolean use_mass_and_viz = true
          "if true, include the mass and visualizer for this pulley";

        MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  fixedTranslation4(
          specularCoefficient=0.5,
          color={50,32,64},
          r={0,D_wheel/2})
                         annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,70})));
        MSL_Extend.Mechanics.Planar.Joints.Revolute                      revolute3
          annotation (Placement(transformation(extent={{-30,30},{-10,50}})));
        MSL_Extend.Mechanics.Planar.Joints.Revolute  revolute(phi(start=phi))
          annotation (Placement(transformation(extent={{-30,-50},{-10,-30}})));
        MSL_Extend.Mechanics.Planar.Parts.FixedRotation     fixedTranslation1(
          angle=180,
          color={200,128,255},
          specularCoefficient=0.7,
          r={0,D_wheel/2})
                         annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-70})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                 frame_b(
            includeBearingConnector=true)                       annotation (Placement(
              transformation(rotation=0, extent={{111,-218},{149,-182}}),
              iconTransformation(extent={{121,-218},{159,-182}})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                 frame_a(
            includeBearingConnector=true)                       annotation (Placement(
              transformation(rotation=0, extent={{111,182},{149,218}}),
              iconTransformation(extent={{121,182},{159,218}})));
        MSL_Extend.Mechanics.Planar.Visualizers.VoluminousWheel
                                                       wheel(
          specularCoefficient=0.1,
          color={64,64,64},
          rCurvature=100,
          rTire=D_wheel/2,
          rRim=D_wheel*0.4,
          width=W_wheel) if use_mass_and_viz
          annotation (Placement(transformation(extent={{180,-10},{200,10}})));
        MSL_Extend.Mechanics.Planar.Visualizers.FixedShape  wheel_hub(
          shapeType="gearwheel",
          specularCoefficient=0.3,
          extra=6,
          width=D_wheel/2,
          height=D_wheel/2,
          length=W_wheel,
          r_shape={-W_wheel/2,0,0}) if use_mass_and_viz
                   annotation (Placement(transformation(extent={{180,-50},{200,-30}})));
        MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Translational mounting_1D_Translational(n={-1,0})
          annotation (Placement(transformation(extent={{-10,180},{10,200}})));
        MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Translational mounting_1D_Translational1(n={-1,0})
          annotation (Placement(transformation(extent={{-10,-180},{10,-200}})));
        MSL_Extend.Mechanics.Planar.Joints.Revolute  wheel_brg(useAxisFlange=true,
          a(fixed=fix_wheel_brg_a),
          phi(fixed=fix_wheel_brg_phi),
          w(fixed=fix_wheel_brg_w),
          stateSelect=stateSelect) if use_mass_and_viz
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        MSL_Extend.Mechanics.Planar.Parts.Body  body(
          m=m_wheel, J=I_zz_wheel) if
                              use_mass_and_viz
          annotation (Placement(transformation(extent={{180,30},{200,50}})));
        Modelica.Mechanics.Translational.Components.IdealGearR2T R2T_a(useSupportT=
              true, ratio=-2/D_wheel)   annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={50,190})));
        Modelica.Mechanics.Translational.Components.IdealGearR2T R2T_b(useSupportT=
              true, ratio=-2/D_wheel)   annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=90,
              origin={50,-190})));
        MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange(
            includeBearingConnector=true)                                annotation (
            Placement(transformation(extent={{-10,-10},{10,10}}), iconTransformation(
                extent={{-10,-10},{10,10}})));
      equation
        connect(revolute3.frame_b, fixedTranslation4.frame_b) annotation (Line(
            points={{-10,40},{0,40},{0,60},{-1.83697e-015,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute.frame_b, fixedTranslation1.frame_a) annotation (Line(
            points={{-10,-40},{1.83697e-015,-40},{1.83697e-015,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation4.frame_a, frame_a.bearingFrame) annotation (Line(
            points={{1.83697e-015,80},{1.83697e-015,140},{130,140},{130,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation1.frame_b, frame_b.bearingFrame) annotation (Line(
            points={{-1.83697e-015,-80},{-1.83697e-015,-140},{130,-140},{130,-200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting_1D_Translational.flange_b, R2T_a.supportT)
          annotation (Line(
            points={{10,190},{20,190},{20,200},{40,200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(mounting_1D_Translational1.flange_b, R2T_b.supportT) annotation (Line(
            points={{10,-190},{20,-190},{20,-200},{40,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(R2T_b.flangeT, frame_b.flange) annotation (Line(
            points={{50,-200},{130,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(R2T_b.flangeR, R2T_a.flangeR) annotation (Line(
            points={{50,-180},{50,180}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(R2T_a.flangeT, frame_a.flange) annotation (Line(
            points={{50,200},{130,200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(R2T_a.flangeR, wheel_brg.axis) annotation (Line(
            points={{50,180},{70,180},{70,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(R2T_a.flangeR, flange.flange) annotation (Line(
            points={{50,180},{60,180},{60,40},{20,40},{20,0},{0,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(revolute3.frame_a, wheel_brg.frame_a) annotation (Line(
            points={{-30,40},{-40,40},{-40,20},{40,20},{40,0},{60,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute.frame_a, revolute3.frame_a) annotation (Line(
            points={{-30,-40},{-50,-40},{-50,40},{-30,40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute3.frame_a, flange.bearingFrame) annotation (Line(
            points={{-30,40},{-50,40},{-50,0},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting_1D_Translational.frame_a, frame_a.bearingFrame) annotation (
            Line(
            points={{0,180},{0,160},{130,160},{130,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting_1D_Translational1.frame_a, frame_b.bearingFrame) annotation (
           Line(
            points={{0,-180},{0,-160},{130,-160},{130,-200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheel.frame_a, wheel_brg.frame_b) annotation (Line(
            points={{180,0},{80,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(body.frame_a, wheel_brg.frame_b) annotation (Line(
            points={{180,40},{142,40},{142,0},{80,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheel_hub.frame_a, wheel_brg.frame_b) annotation (Line(
            points={{180,-40},{142,-40},{142,0},{80,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-200,-200},{200,200}},
                preserveAspectRatio=false),graphics), Icon(coordinateSystem(extent={{-200,
                  -200},{200,200}}, preserveAspectRatio=true), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-180,180},{180,-180}},
                lineColor={0,0,255},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-20,180},{100,200}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-20,-180},{100,-200}},
                color={0,0,255},
                smooth=Smooth.None),
              Ellipse(
                extent={{-180,180},{180,-180}},
                lineColor={0,0,255},
                fillColor={200,128,255},
                fillPattern=FillPattern.Solid,
                startAngle=95,
                endAngle=180),
              Ellipse(
                extent={{-180,180},{180,-180}},
                lineColor={0,0,255},
                fillColor={213,170,255},
                fillPattern=FillPattern.Solid,
                startAngle=180,
                endAngle=265),
              Text(
                extent={{140,170},{200,140}},
                lineColor={0,0,0},
                textString="a"),
              Text(
                extent={{140,-140},{200,-170}},
                lineColor={0,0,0},
                textString="b")}));
      end Base_Pulley;

      model Road_Wheel_Bearing_Flange
        "Attaches to \"Pulley\" model and only interacts ground (normal and friction forces, no belt interactions)"

        parameter Modelica.SIunits.Length D_wheel(min=0)=0.6
          "Road wheel diameter";
        parameter Modelica.SIunits.Length W_wheel(min=0)=0.05
          "Road wheel width (for pair of road wheels)";
        parameter Modelica.SIunits.Length Z_offset(min=0)=0
          "Thickness of single road wheel flange";
        parameter Modelica.SIunits.TranslationalSpringConstant c_tire(final min=0, start=1)=100000
          "Tire spring constant";
        parameter Modelica.SIunits.TranslationalDampingConstant d_tire(final min=0, start=1)=1000
          "Tire damping constant";
        parameter Real n_tire=1.0
          "Exponent of spring force ( f_c = -c*|s_rel-s_rel0|^n )";
        parameter Real crr(min=0)=0.01
          "Rolling resistance coefficient for the tire";
        parameter Modelica.SIunits.Mass m_wheel(min=0)=50 "Mass of wheel";
        parameter Modelica.SIunits.Inertia I_xx_wheel(min=0)=10
          "I_xx inertia of road wheel";
        parameter Modelica.SIunits.Inertia I_yy_wheel(min=0)=10
          "I_yy inertia of road wheel";
        parameter Modelica.SIunits.Inertia I_zz_wheel(min=0)=10
          "I_zz inertia of road wheel";
        parameter Boolean fix_wheel_brg_phi = false
          "=true if angular position of pulley should be zero";
        parameter Boolean fix_wheel_brg_w = false
          "=true if angular velocity of pulley should be zero";
        parameter Boolean fix_wheel_brg_a = false
          "=true if angular accel of pulley should be zero";
        parameter Modelica.SIunits.CoefficientOfFriction mue_sliding=0.35
          "[w,mue] positive sliding friction coefficient (w_rel>=0)";
        parameter Modelica.SIunits.CoefficientOfFriction mue_locked=0.7
          "[w,mue] positive sliding friction coefficient (w_rel>=0)";

      //   Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel
      //                                                  wheel(
      //     specularCoefficient=0.1,
      //     color={64,64,64},
      //     rCurvature=100,
      //     width=W_wheel,
      //     rTire=D_wheel/2,
      //     rRim=D_wheel*0.4,
      //     n_rCurvature=2,
      //     n_rTire=2)
      //     annotation (Placement(transformation(extent={{80,-40},{100,-20}})));
        MSL_Extend.Mechanics.Planar.Parts.Body
                        mass_of_wheel(
          m=m_wheel,
          animation=false,
          J=I_zz_wheel)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=180,
              origin={10,60})));
      //   Modelica.Mechanics.MultiBody.Visualizers.FixedShape fixedShape(
      //     shapeType="gearwheel",
      //     specularCoefficient=0.3,
      //     extra=6,
      //     length=W_wheel,
      //     width=D_wheel/2,
      //     height=D_wheel/2,
      //     r_shape={-W_wheel/2,0,0})
      //              annotation (Placement(transformation(extent={{80,-80},{100,-60}})));
        MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                     fixedTranslation(r={0,0})
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={60,0})));
        Modelica.Mechanics.Rotational.Components.IdealGearR2T idealGearR2T(ratio=2/
              D_wheel)
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        MSL_Extend.Mechanics.Planar.Joints.Revolute
                                             wheel_brg(
          useAxisFlange=true,
          a(fixed=fix_wheel_brg_a),
          phi(fixed=fix_wheel_brg_phi),
          w(fixed=fix_wheel_brg_w))
          annotation (Placement(transformation(extent={{160,-10},{140,10}})));

        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Tire_Contact_Force_Physical_Normal_And_Friction
          tire_Contact_Force_Physical_Normal_And_Friction(
          radius=D_wheel/2,
          c=c_tire,
          d=d_tire,
          mue_sliding=mue_sliding,
          mue_locked=mue_locked,
          n=n_tire)
          annotation (Placement(transformation(extent={{-30,-120},{-10,-100}})));
        MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange(
            includeBearingConnector=true)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        Modelica.Blocks.Math.Gain gain(k=crr)
          annotation (Placement(transformation(extent={{60,100},{80,120}})));
        Modelica.Blocks.Math.Gain normalize_for_clutch(k=1/10000)
          annotation (Placement(transformation(extent={{100,100},{120,120}})));
        MSL_Extend.Mechanics.Planar.Sensors.CutForce          cutForce(animation=false)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-20,-70})));
        Modelica.Mechanics.Rotational.Components.Clutch rolling_resistance(mue_pos=[0,
              1], fn_max=10000)
          annotation (Placement(transformation(extent={{140,50},{160,70}})));
        MSL_Extend.Mechanics.Planar.Sensors.Vector_Magnitude   vector_Magnitude
          annotation (Placement(transformation(extent={{-60,-80},{-80,-60}})));
        MSL_Extend.Mechanics.Planar.Visualizers.VoluminousWheel
                                                       wheel(
          specularCoefficient=0.1,
          color={64,64,64},
          rCurvature=100,
          width=W_wheel,
          rTire=D_wheel/2,
          rRim=D_wheel*0.4,
          n_rCurvature=2,
          n_rTire=2)
          annotation (Placement(transformation(extent={{80,-40},{100,-20}})));
        MSL_Extend.Mechanics.Planar.Visualizers.FixedShape  fixedShape(
          shapeType="gearwheel",
          specularCoefficient=0.3,
          extra=6,
          length=W_wheel,
          width=D_wheel/2,
          height=D_wheel/2,
          r_shape={-W_wheel/2,0,0})
                   annotation (Placement(transformation(extent={{80,-80},{100,-60}})));
      equation

        connect(mass_of_wheel.frame_a, fixedTranslation.frame_b) annotation (Line(
            points={{20,60},{40,60},{40,1.33227e-015},{50,1.33227e-015}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));

        connect(wheel_brg.frame_b, fixedTranslation.frame_a)
                                                            annotation (Line(
            points={{140,0},{92,0},{92,-1.22465e-015},{70,-1.22465e-015}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(idealGearR2T.flangeT, tire_Contact_Force_Physical_Normal_And_Friction.flange_b)
          annotation (Line(
            points={{-60,-30},{20,-30},{20,-105.4},{-10,-105.4}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(wheel_brg.frame_a, flange.bearingFrame) annotation (Line(
            points={{160,0},{180,0},{180,20},{0,20},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheel_brg.axis, flange.flange) annotation (Line(
            points={{150,10},{150,40},{-40,40},{-40,0},{0,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(idealGearR2T.flangeR, flange.flange) annotation (Line(
            points={{-80,-30},{-100,-30},{-100,0},{0,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(gain.y,normalize_for_clutch. u) annotation (Line(
            points={{81,110},{98,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rolling_resistance.flange_b, wheel_brg.support) annotation (Line(
            points={{160,60},{170,60},{170,10},{156,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(rolling_resistance.flange_a, wheel_brg.axis) annotation (Line(
            points={{140,60},{130,60},{130,10},{150,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(normalize_for_clutch.y, rolling_resistance.f_normalized) annotation (
            Line(
            points={{121,110},{150,110},{150,71}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cutForce.frame_b, tire_Contact_Force_Physical_Normal_And_Friction.frame_a)
          annotation (Line(
            points={{-20,-80},{-20,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(cutForce.frame_a, flange.bearingFrame) annotation (Line(
            points={{-20,-60},{-20,0},{0,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(vector_Magnitude.u, cutForce.force) annotation (Line(
            points={{-58,-70},{-44,-70},{-44,-62},{-31,-62}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vector_Magnitude.y, gain.u) annotation (Line(
            points={{-81,-70},{-124,-70},{-124,110},{58,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fixedShape.frame_a, fixedTranslation.frame_b) annotation (Line(
            points={{80,-70},{40,-70},{40,1.33227e-015},{50,1.33227e-015}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, wheel.frame_a) annotation (Line(
            points={{50,1.33227e-015},{40,1.33227e-015},{40,-30},{80,-30}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-200,-200},{200,200}},
                preserveAspectRatio=false),
                            graphics), Icon(coordinateSystem(extent={{-200,-200},{200,
                  200}},     preserveAspectRatio=true), graphics={
              Rectangle(
                extent={{-200,200},{202,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),                   Ellipse(
                extent={{-160,-160},{160,160}},
                lineColor={0,0,255},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-120,-120},{120,120}},
                lineColor={0,0,255},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360),
              Line(
                points={{-2,-178},{-2,-54}},
                color={255,0,128},
                smooth=Smooth.None),
              Line(
                points={{0,-62},{0,62}},
                color={255,0,128},
                smooth=Smooth.None,
                origin={40,-158},
                rotation=-90),
              Text(
                extent={{92,-126},{152,-186}},
                lineColor={255,0,128},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                textString="F"),
              Text(
                extent={{-32,-8},{28,-68}},
                lineColor={255,0,128},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                textString="N"),
              Line(
                points={{-198,-164},{196,-164}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{80,-178},{100,-158}},
                color={255,0,128},
                smooth=Smooth.None),
              Line(
                points={{-22,-76},{-2,-56}},
                color={255,0,128},
                smooth=Smooth.None)}));
      end Road_Wheel_Bearing_Flange;
    end Suspension;

    package Hydraulics "Building blocks for hydraulic systems"
    extends Modelica.Icons.Package;
      model Hydraulic_Manifold_Open_Center
        "Manifold with upto 5 valves that can switch between forward and reverse operation.  Only one valve can operate at a time."

        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.Hydraulic_P_T_5A_5B;

        Modelica.Blocks.Interfaces.RealInput u_1
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-160,300})));
        Modelica.Blocks.Interfaces.RealInput u_2 if num_valves > 1
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-80,300})));
        Modelica.Blocks.Interfaces.RealInput u_3 if num_valves > 2
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,300})));
        Modelica.Blocks.Interfaces.RealInput u_4 if num_valves > 3
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={80,300})));
        Modelica.Blocks.Interfaces.RealInput u_5 if num_valves > 4
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={160,300})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_Pass_Through
          valve_1
          annotation (Placement(transformation(extent={{-20,-180},{20,-140}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_Pass_Through
          valve_2 if num_valves > 1 annotation (Placement(transformation(extent={{-20,-100},{20,-60}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_Pass_Through
          valve_3 if num_valves > 2 annotation (Placement(transformation(extent={{-20,-20},{20,20}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_Pass_Through
          valve_4 if num_valves > 3 annotation (Placement(transformation(extent={{-20,60},{20,100}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_Pass_Through
          valve_5 if num_valves > 4 annotation (Placement(transformation(extent={{-20,140},{20,180}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Orifices.Short_Circuit
                                                                                short_circuit_1 if num_valves == 1
          annotation (Placement(transformation(extent={{80,-120},{100,-100}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Orifices.Short_Circuit
                                                                                short_circuit_2 if num_valves == 2
          annotation (Placement(transformation(extent={{80,-40},{100,-20}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Orifices.Short_Circuit
                                                                                short_circuit_3 if num_valves == 3
          annotation (Placement(transformation(extent={{80,40},{100,60}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Orifices.Short_Circuit
                                                                                short_circuit_4 if num_valves == 4
          annotation (Placement(transformation(extent={{80,120},{100,140}})));

        MSL_Extend.Hydraulics_Simple.Components.Valves.Pressure_Relief_Valve
          pressure_Relief_Valve(p_max=p_max)
          annotation (Placement(transformation(extent={{-120,-230},{-100,-210}})));
        parameter SI.Pressure p_max=1e5
          "Pressure that starts to open relief valve";
      equation

        connect(valve_1.T, T) annotation (Line(
            points={{12,-179.8},{12,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.A, A_1) annotation (Line(
            points={{-12,-140},{-80,-140},{-80,-180},{-210,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.B, B_1) annotation (Line(
            points={{12,-139.8},{46,-140},{46,-140},{80,-140},{80,-180},{208,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.P1, valve_2.P) annotation (Line(
            points={{0,-140.2},{-6,-140.2},{-6,-100},{-12,-100}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.T, T) annotation (Line(
            points={{12,-99.8},{112,-99.8},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.T, T) annotation (Line(
            points={{12,-19.8},{62,-19.8},{62,-20},{112,-20},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.T, T) annotation (Line(
            points={{12,60.2},{62,60.2},{62,60},{112,60},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.T, T) annotation (Line(
            points={{12,140.2},{112,140.2},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.P1, valve_3.P) annotation (Line(
            points={{0,-60.2},{-6,-60.2},{-6,-20},{-12,-20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.P1, valve_4.P) annotation (Line(
            points={{0,19.8},{-6,19.8},{-6,60},{-12,60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.P1, valve_5.P) annotation (Line(
            points={{0,99.8},{0,118.9},{-12,118.9},{-12,140}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.A, A_2) annotation (Line(
            points={{-12,-60},{-80,-60},{-80,-80},{-210,-80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.A, A_3) annotation (Line(
            points={{-12,20},{-112,20},{-112,20},{-210,20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.A, A_4) annotation (Line(
            points={{-12,100},{-80,100},{-80,120},{-210,120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.A, A_5) annotation (Line(
            points={{-12,180},{-80,180},{-80,220},{-210,220}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.B, B_5) annotation (Line(
            points={{12,180.2},{80,180.2},{80,220},{210,220}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.B, B_4) annotation (Line(
            points={{12,100.2},{80,100.2},{80,120},{210,120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.B, B_3) annotation (Line(
            points={{12,20.2},{112,20.2},{112,20},{210,20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.B, B_2) annotation (Line(
            points={{12,-59.8},{80,-59.8},{80,-80},{208,-80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.P1, T) annotation (Line(
            points={{0,179.8},{0,194},{112,194},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.P1, short_circuit_1.hyd_a) annotation (Line(
            points={{0,-140.2},{0,-110},{80,-110}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(short_circuit_1.hyd_b, T) annotation (Line(
            points={{100,-110},{140,-110},{140,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(valve_2.P1, short_circuit_2.hyd_a) annotation (Line(
            points={{0,-60.2},{0,-30},{80,-30}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(valve_3.P1, short_circuit_3.hyd_a) annotation (Line(
            points={{0,19.8},{0,50},{80,50}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(valve_4.P1, short_circuit_4.hyd_a) annotation (Line(
            points={{0,99.8},{0,130},{80,130}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(short_circuit_2.hyd_b, T) annotation (Line(
            points={{100,-30},{140,-30},{140,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(short_circuit_3.hyd_b, T) annotation (Line(
            points={{100,50},{140,50},{140,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(short_circuit_4.hyd_b, T) annotation (Line(
            points={{100,130},{140,130},{140,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(u_1, valve_1.u) annotation (Line(
            points={{-160,300},{-160,-170},{40,-170},{40,-160},{22.4,-160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_2, valve_2.u) annotation (Line(
            points={{-80,300},{-80,260},{-70,260},{-70,-92},{40,-92},{40,-80},{22.4,
                -80}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(u_3, valve_3.u) annotation (Line(
            points={{0,300},{0,260},{-60,260},{-60,-12},{40,-12},{40,0},{22.4,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_4, valve_4.u) annotation (Line(
            points={{80,300},{80,250},{-50,250},{-50,70},{40,70},{40,80},{22.4,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_5, valve_5.u) annotation (Line(
            points={{160,300},{160,240},{-40,240},{-40,150},{40,150},{40,160},{22.4,
                160}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(P, pressure_Relief_Valve.P) annotation (Line(
            points={{-210,-280},{-166,-280},{-166,-214},{-120,-214}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_1.P) annotation (Line(
            points={{-100,-214},{-14,-214},{-14,-180},{-12,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.T, T) annotation (Line(
            points={{-110,-229.9},{-110,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-320},
                  {200,280}}), graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                        extent={{-200,-320},{200,280}}), graphics={
              Rectangle(
                extent={{-178,60},{182,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={255,240,250},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,60},{58,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={255,240,250},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-152,-40},{-152,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-92,-40},{-92,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-172,20},{-152,40},{-132,20}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-32,-60},{-32,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-42,-30},{-22,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{28,-60},{28,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{18,-30},{38,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{0,-15},{0,15}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={-32,45},
                rotation=360,
                thickness=0.5),
              Line(
                points={{-10,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={-32,30},
                rotation=360,
                thickness=0.5),
              Line(
                points={{0,-15},{0,15}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={28,45},
                rotation=360,
                thickness=0.5),
              Line(
                points={{-10,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={28,30},
                rotation=360,
                thickness=0.5),
              Line(
                points={{78,-40},{158,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{78,40},{158,-40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{134,40},{158,40},{158,16}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-20,-10},{0,10},{20,-10}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5,
                origin={-92,-30},
                rotation=180),
              Line(
                points={{134,-40},{158,-40},{158,-16}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Text(
                extent={{-172,110},{178,60}},
                lineColor={128,128,128},
                textString="1        0       -1"),
              Line(
                points={{2.70103e-015,-42},{0,-80}},
                color={0,0,127},
                smooth=Smooth.None,
                origin={142,0},
                rotation=90)}));
      end Hydraulic_Manifold_Open_Center;

      model Hydraulic_Manifold_Closed_Center
        "Manifold with upto 5 valves that can switch between forward and reverse operation.  Multiple valves can operate simultaneously"

        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.Hydraulic_P_T_5A_5B;

        Modelica.Blocks.Interfaces.RealInput u_1
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-160,300})));
        Modelica.Blocks.Interfaces.RealInput u_2 if num_valves > 1
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-80,300})));
        Modelica.Blocks.Interfaces.RealInput u_3 if num_valves > 2
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,300})));
        Modelica.Blocks.Interfaces.RealInput u_4 if num_valves > 3
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={80,300})));
        Modelica.Blocks.Interfaces.RealInput u_5 if num_valves > 4
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={160,300})));
        MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_No_Bypass
          valve_1
          annotation (Placement(transformation(extent={{-20,-180},{20,-140}})));
        MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_No_Bypass
          valve_2 if num_valves > 1 annotation (Placement(transformation(extent={{-20,-100},{20,-60}})));
        MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_No_Bypass
          valve_3 if num_valves > 2 annotation (Placement(transformation(extent={{-20,-20},{20,20}})));
        MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_No_Bypass
          valve_4 if num_valves > 3 annotation (Placement(transformation(extent={{-20,60},{20,100}})));
        MSL_Extend.Hydraulics_Simple.Components.Control_Elements.Crossover_Continuous_No_Bypass
          valve_5 if num_valves > 4 annotation (Placement(transformation(extent={{-20,140},{20,180}})));

        MSL_Extend.Hydraulics_Simple.Components.Valves.Pressure_Relief_Valve
          pressure_Relief_Valve(p_max=p_max)
          annotation (Placement(transformation(extent={{-160,-236},{-140,-216}})));
        parameter SI.Pressure p_max=1e5
          "Pressure that starts to open relief valve";
      equation

        connect(valve_1.T, T) annotation (Line(
            points={{12,-179.8},{12,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.A, A_1) annotation (Line(
            points={{-12,-140},{-80,-140},{-80,-180},{-210,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_1.B, B_1) annotation (Line(
            points={{12,-139.8},{46,-140},{46,-140},{80,-140},{80,-180},{208,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.T, T) annotation (Line(
            points={{12,-99.8},{112,-99.8},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.T, T) annotation (Line(
            points={{12,-19.8},{62,-19.8},{62,-20},{112,-20},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.T, T) annotation (Line(
            points={{12,60.2},{62,60.2},{62,60},{112,60},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.T, T) annotation (Line(
            points={{12,140.2},{112,140.2},{112,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.A, A_2) annotation (Line(
            points={{-12,-60},{-80,-60},{-80,-80},{-210,-80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.A, A_3) annotation (Line(
            points={{-12,20},{-112,20},{-112,20},{-210,20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.A, A_4) annotation (Line(
            points={{-12,100},{-80,100},{-80,120},{-210,120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.A, A_5) annotation (Line(
            points={{-12,180},{-80,180},{-80,220},{-210,220}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_5.B, B_5) annotation (Line(
            points={{12,180.2},{80,180.2},{80,220},{210,220}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_4.B, B_4) annotation (Line(
            points={{12,100.2},{80,100.2},{80,120},{210,120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_3.B, B_3) annotation (Line(
            points={{12,20.2},{112,20.2},{112,20},{210,20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(valve_2.B, B_2) annotation (Line(
            points={{12,-59.8},{80,-59.8},{80,-80},{208,-80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(u_1, valve_1.u) annotation (Line(
            points={{-160,300},{-160,-170},{40,-170},{40,-160},{22.4,-160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_2, valve_2.u) annotation (Line(
            points={{-80,300},{-80,260},{-70,260},{-70,-92},{40,-92},{40,-80},{22.4,
                -80}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(u_3, valve_3.u) annotation (Line(
            points={{0,300},{0,260},{-60,260},{-60,-12},{40,-12},{40,0},{22.4,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_4, valve_4.u) annotation (Line(
            points={{80,300},{80,250},{-50,250},{-50,70},{40,70},{40,80},{22.4,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_5, valve_5.u) annotation (Line(
            points={{160,300},{160,240},{-40,240},{-40,150},{40,150},{40,160},{22.4,
                160}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(P, pressure_Relief_Valve.P) annotation (Line(
            points={{-210,-280},{-174,-280},{-174,-220},{-160,-220}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.T, T) annotation (Line(
            points={{-150,-235.9},{-150,-280},{210,-280}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_1.P) annotation (Line(
            points={{-140,-220},{-120,-220},{-120,-194},{-12,-194},{-12,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_2.P) annotation (Line(
            points={{-140,-220},{-120,-220},{-120,-100},{-12,-100}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_3.P) annotation (Line(
            points={{-140,-220},{-120,-220},{-120,-20},{-12,-20}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_4.P) annotation (Line(
            points={{-140,-220},{-120,-220},{-120,60},{-12,60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve.A, valve_5.P) annotation (Line(
            points={{-140,-220},{-120,-220},{-120,140},{-12,140}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-320},
                  {200,280}}), graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                        extent={{-200,-320},{200,280}}), graphics={
              Rectangle(
                extent={{-178,60},{182,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={255,240,250},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,60},{58,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={255,240,250},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-152,-40},{-152,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-92,-40},{-92,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-172,20},{-152,40},{-132,20}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-32,-60},{-32,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-42,-30},{-22,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{28,-60},{28,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{18,-30},{38,-30}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{0,-15},{0,15}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={-32,45},
                rotation=360,
                thickness=0.5),
              Line(
                points={{-10,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={-32,30},
                rotation=360,
                thickness=0.5),
              Line(
                points={{0,-15},{0,15}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={28,45},
                rotation=360,
                thickness=0.5),
              Line(
                points={{-10,0},{10,0}},
                color={0,0,0},
                smooth=Smooth.None,
                origin={28,30},
                rotation=360,
                thickness=0.5),
              Line(
                points={{78,-40},{158,40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{78,40},{158,-40}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{134,40},{158,40},{158,16}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-20,-10},{0,10},{20,-10}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5,
                origin={-92,-30},
                rotation=180),
              Line(
                points={{134,-40},{158,-40},{158,-16}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Text(
                extent={{-172,110},{178,60}},
                lineColor={128,128,128},
                textString="1        0       -1"),
              Line(
                points={{2.70103e-015,-42},{0,-80}},
                color={0,0,127},
                smooth=Smooth.None,
                origin={142,0},
                rotation=90)}));
      end Hydraulic_Manifold_Closed_Center;

      model Test_Hydraulic_Manifold_Open_Center
        "Observe that only the lowest number ram will actuate if multiple are commanded"
      extends C2M2L_Ext.Icons.Simple_Test_Case;
        Hydraulic_Manifold_Open_Center
          hydraulic_manifold(p_max=10000000)
          annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
        Modelica.Mechanics.Translational.Components.Mass mass(
          L=0.01,
          m=100)
          annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
            P_constant=2000000)
          annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
              rotation=90,
              origin={-40.5,-10})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
            P_constant=100000)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,-10})));
        Modelica.Mechanics.Translational.Components.Mass mass1(
          L=0.01, m=200)
          annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
        Modelica.Mechanics.Translational.Components.Mass mass2(
          L=0.01, m=300)
          annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
        Modelica.Mechanics.Translational.Components.Mass mass3(
          L=0.01, m=400)
          annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational3(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
        Modelica.Mechanics.Translational.Components.Mass mass4(
          L=0.01, m=500)
          annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational4(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
        inner Modelica.Mechanics.MultiBody.World world(enableAnimation=false)
          annotation (Placement(transformation(extent={{-52,-46},{-32,-26}})));
        Modelica.Blocks.Sources.Trapezoid trapezoid[5](
          amplitude=1,
          rising=2,
          width=40,
          falling=2,
          period={60,80,100,120,140})
          annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
      equation

        connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
          annotation (Line(
            points={{-30,-170},{60,-170}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
          annotation (Line(
            points={{-30,-140},{60,-140}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
          annotation (Line(
            points={{-30,-110},{60,-110}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational3.flange, mass3.flange_a)
          annotation (Line(
            points={{-30,-80},{60,-80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational4.flange, mass4.flange_a)
          annotation (Line(
            points={{-30,-50},{60,-50}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
          annotation (Line(
            points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
          annotation (Line(
            points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
            points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
            points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_3,
          hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
            points={{-49.15,55.6667},{-80,55.6667},{-80,-120},{-40,-120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_3,
          hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
            points={{-0.85,55.6667},{28,55.6667},{28,-120},{-20,-120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_4,
          hydraulic_Mechanical_Conversion_Translational3.hyd_a) annotation (Line(
            points={{-49.15,67.3333},{-70,67.3333},{-70,-90},{-40,-90}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_4,
          hydraulic_Mechanical_Conversion_Translational3.hyd_b) annotation (Line(
            points={{-0.85,67.3333},{20,67.3333},{20,-90},{-20,-90}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_5,
          hydraulic_Mechanical_Conversion_Translational4.hyd_a) annotation (Line(
            points={{-49.15,79},{-60,79},{-60,-60},{-40,-60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_5,
          hydraulic_Mechanical_Conversion_Translational4.hyd_b) annotation (Line(
            points={{-0.85,79},{10,79},{10,-60},{-20,-60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
            Line(
            points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
            Line(
            points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(world.frame_b, hydraulic_manifold.mount_01) annotation (Line(
            points={{-32,-36},{-28,-36},{-28,-34},{-25,-34},{-25,16}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
            points={{-79,130},{-43.4,130},{-43.4,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
            points={{-79,130},{-34.2,130},{-34.2,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
            points={{-79,130},{-25,130},{-25,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
            points={{-79,130},{-15.8,130},{-15.8,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
            points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                preserveAspectRatio=true),
                            graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                  160}}),                   graphics));
      end Test_Hydraulic_Manifold_Open_Center;

      model Test_Hydraulic_Manifold_Closed_Center
        "Observe that multiple rams can actuate simultaneously."
      extends C2M2L_Ext.Icons.Simple_Test_Case;
        Hydraulic_Manifold_Closed_Center
          hydraulic_manifold(p_max=10000000)
          annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
        Modelica.Mechanics.Translational.Components.Mass mass(
          L=0.01,
          m=100)
          annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
            P_constant=2000000)
          annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
              rotation=90,
              origin={-40.5,-10})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
            P_constant=100000)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,-10})));
        Modelica.Mechanics.Translational.Components.Mass mass1(
          L=0.01, m=200)
          annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
        Modelica.Mechanics.Translational.Components.Mass mass2(
          L=0.01, m=300)
          annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
        Modelica.Mechanics.Translational.Components.Mass mass3(
          L=0.01, m=400)
          annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational3(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
        Modelica.Mechanics.Translational.Components.Mass mass4(
          L=0.01, m=500)
          annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational4(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
        inner Modelica.Mechanics.MultiBody.World world(enableAnimation=false)
          annotation (Placement(transformation(extent={{-52,-46},{-32,-26}})));
        Modelica.Blocks.Sources.Trapezoid trapezoid[5](
          amplitude=1,
          rising=2,
          width=40,
          falling=2,
          period={60,80,100,120,140})
          annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
      equation

        connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
          annotation (Line(
            points={{-30,-170},{60,-170}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
          annotation (Line(
            points={{-30,-140},{60,-140}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
          annotation (Line(
            points={{-30,-110},{60,-110}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational3.flange, mass3.flange_a)
          annotation (Line(
            points={{-30,-80},{60,-80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational4.flange, mass4.flange_a)
          annotation (Line(
            points={{-30,-50},{60,-50}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
          annotation (Line(
            points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
          annotation (Line(
            points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
            points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
            points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_3,
          hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
            points={{-49.15,55.6667},{-80,55.6667},{-80,-120},{-40,-120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_3,
          hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
            points={{-0.85,55.6667},{28,55.6667},{28,-120},{-20,-120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_4,
          hydraulic_Mechanical_Conversion_Translational3.hyd_a) annotation (Line(
            points={{-49.15,67.3333},{-70,67.3333},{-70,-90},{-40,-90}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_4,
          hydraulic_Mechanical_Conversion_Translational3.hyd_b) annotation (Line(
            points={{-0.85,67.3333},{20,67.3333},{20,-90},{-20,-90}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_5,
          hydraulic_Mechanical_Conversion_Translational4.hyd_a) annotation (Line(
            points={{-49.15,79},{-60,79},{-60,-60},{-40,-60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_5,
          hydraulic_Mechanical_Conversion_Translational4.hyd_b) annotation (Line(
            points={{-0.85,79},{10,79},{10,-60},{-20,-60}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
            Line(
            points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
            Line(
            points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(world.frame_b, hydraulic_manifold.mount_01) annotation (Line(
            points={{-32,-36},{-28,-36},{-28,-34},{-25,-34},{-25,16}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
            points={{-79,130},{-43.4,130},{-43.4,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
            points={{-79,130},{-34.2,130},{-34.2,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
            points={{-79,130},{-25,130},{-25,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
            points={{-79,130},{-15.8,130},{-15.8,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
            points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-100,-200},{100,100}},
                preserveAspectRatio=true),
                            graphics), Icon(coordinateSystem(extent={{-100,-200},{100,
                  100}}),                   graphics));
      end Test_Hydraulic_Manifold_Closed_Center;

      model Test_Hydraulic_Manifold_Open_Center_2_Valves
        "Check that removing valves works"
      extends C2M2L_Ext.Icons.Simple_Test_Case;
        Hydraulic_Manifold_Open_Center
          hydraulic_manifold(num_valves=2, p_max=10000000)
          annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
        Modelica.Mechanics.Translational.Components.Mass mass(
          L=0.01,
          m=100)
          annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
            P_constant=2000000)
          annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
              rotation=90,
              origin={-40.5,-10})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
            P_constant=100000)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,-10})));
        Modelica.Mechanics.Translational.Components.Mass mass1(
          L=0.01, m=200)
          annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
        C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
          hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
          annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
        inner Modelica.Mechanics.MultiBody.World world(enableAnimation=false)
          annotation (Placement(transformation(extent={{-52,-46},{-32,-26}})));
        Modelica.Blocks.Sources.Trapezoid trapezoid[5](
          amplitude=1,
          rising=2,
          width=40,
          falling=2,
          period={60,80,100,120,140})
          annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
      equation

        connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
          annotation (Line(
            points={{-30,-170},{60,-170}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
          annotation (Line(
            points={{-30,-140},{60,-140}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
          annotation (Line(
            points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
          annotation (Line(
            points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.A_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
            points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_manifold.B_2,
          hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
            points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
            Line(
            points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
            Line(
            points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(world.frame_b, hydraulic_manifold.mount_01) annotation (Line(
            points={{-32,-36},{-28,-36},{-28,-34},{-25,-34},{-25,16}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
            points={{-79,130},{-43.4,130},{-43.4,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
            points={{-79,130},{-34.2,130},{-34.2,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
            points={{-79,130},{-25,130},{-25,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
            points={{-79,130},{-15.8,130},{-15.8,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
            points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-100,-200},{100,100}},
                preserveAspectRatio=true),
                            graphics), Icon(coordinateSystem(extent={{-100,-200},{100,
                  100}}),                   graphics));
      end Test_Hydraulic_Manifold_Open_Center_2_Valves;
    end Hydraulics;
  end C2M2L_Component_Building_Blocks;

  package C2M2L_Delivered_Component_Implementations
    "Contains delivered component implementations organized by vehicle sub-system.  Does not contain instance information"
    extends Modelica.Icons.Package;

    package Drive_Line "Building blocks related to the vehicle drive line"
      extends Modelica.Icons.Package;

      package Final_Drive "Implementations of final drives"
          extends Modelica.Icons.Package;

        package Interfaces
          extends Modelica.Icons.Package;

          partial model Example_Standalone_Final_Drive_Implementation
            "A simple final drive example"
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
              annotation (Placement(transformation(extent={{-210,-10},{-190,10}}),
                  iconTransformation(extent={{-212,-10},{-192,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b brg_02
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={200,0}),   iconTransformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={200,2})));
          protected
            Modelica.Mechanics.Rotational.Components.Fixed
                             fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-231},{30,-211}})));
          public
            Modelica.Mechanics.Rotational.Interfaces.Support
                    support if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-244},{10,-224}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support
                    internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-217},{3,-211}})));
          equation
            connect(fixed.flange,internalSupport)  annotation (Line(
                points={{20,-221},{20,-214},{0,-214}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport,support)  annotation (Line(
                points={{0,-214},{0,-234}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                      {200,280}}),
                                graphics), Icon(coordinateSystem(preserveAspectRatio=false,
                    extent={{-200,-320},{200,280}}),
                                                graphics={
                  Rectangle(
                    extent={{-200,17},{-64,-17}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-80,184},{-34,62}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-80,48},{-34,-52}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{-74,138},{48,112}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{36,150},{82,102}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{36,90},{82,-110}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent={{74,18},{200,-16}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(revisions="<html>
</html>",           info="<html>
<p>Notes:</p>
<p><ul>
<li>User must input final drive ratio and efficiency</li>
<li>Component will output max torque and speed</li>
</ul></p>
</html>"));
          end Example_Standalone_Final_Drive_Implementation;
        end Interfaces;

        model Example_Standalone_Final_Drive_Implementation
          "A simple final drive example"
        extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Interfaces.Example_Standalone_Final_Drive_Implementation;
          Modelica.Mechanics.Rotational.Components.IdealGear lossyGear(
            useSupport=true,
            ratio=ratio)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          parameter Real ratio=3.0
            "Transmission ratio (flange_a.phi/flange_b.phi)"
            annotation (Dialog(group="Transfer Case"));
          parameter Real lossTable[:,5]=[0,0.97,0.97,0,0]
            "Array for mesh efficiencies and bearing friction depending on speed"
            annotation (Dialog(group="Transfer Case"));

          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment
            simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{80,188},{100,208}})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume env(
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            fixed_htc=3000,
            initial_T=293.15)
            annotation (Placement(transformation(extent={{-192,172},{-172,192}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{92,230},{112,250}})));
        equation
          connect(inertia.flange_b, lossyGear.flange_a) annotation (Line(
              points={{-40,0},{-10,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{87,205},{87,218.5},{102,218.5},{102,240}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_a, brg_01) annotation (Line(
              points={{-60,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lossyGear.flange_b, brg_02) annotation (Line(
              points={{10,0},{200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lossyGear.support, internalSupport) annotation (Line(
              points={{0,-10},{0,-214}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-200,-320},{200,280}}),
                                              graphics),
            Documentation(revisions="<html>
</html>",         info="<html>
<p>Notes:</p>
<p><ul>
<li>User must input final drive ratio and efficiency</li>
<li>Component will output max torque and speed</li>
</ul></p>
</html>"));
        end Example_Standalone_Final_Drive_Implementation;

        model Example_Standalone_Final_Drive_Implementation_loss
          "A simple final drive example"
        extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Interfaces.Example_Standalone_Final_Drive_Implementation;
          MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.Lossy_Gear_With_Environment
                                                             lossyGear(
            useSupport=true,
            ratio=ratio,
            lossTable=lossTable,
            use_environment_heat_port=true)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          parameter Real ratio=3.0
            "Transmission ratio (flange_a.phi/flange_b.phi)"
            annotation (Dialog(group="Transfer Case"));
          parameter Real lossTable[:,5]=[0,0.97,0.97,0,0]
            "Array for mesh efficiencies and bearing friction depending on speed"
            annotation (Dialog(group="Transfer Case"));

          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-76,-10},{-56,10}})));
          MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment
            simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{80,188},{100,208}})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume env(
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            fixed_htc=3000,
            initial_T=293.15)
            annotation (Placement(transformation(extent={{-192,172},{-172,192}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{92,230},{112,250}})));
        equation
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{87,205},{87,218.5},{102,218.5},{102,240}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_a, brg_01) annotation (Line(
              points={{-76,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lossyGear.flange_b, brg_02) annotation (Line(
              points={{10,0},{200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lossyGear.support, internalSupport) annotation (Line(
              points={{0,-10},{0,-214}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lossyGear.flange_a, inertia.flange_b) annotation (Line(
              points={{-10,0},{-56,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-200,-320},{200,280}}),
                                              graphics),
            Documentation(revisions="<html>
</html>",         info="<html>
<p>Notes:</p>
<p><ul>
<li>User must input final drive ratio and efficiency</li>
<li>Component will output max torque and speed</li>
</ul></p>
</html>"));
        end Example_Standalone_Final_Drive_Implementation_loss;

        package Tests
          extends Modelica.Icons.Package;

          model Test_Final_Drive "test model for final drive"
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                        env(fixed_htc=130)
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Example_Standalone_Final_Drive_Implementation
              example_Standalone_Transfer_Case_Implementation(
              case_heat_transfer_area=0.5,
              case_heat_transfer_thickness=0.008,
              lossTable=[0,0.94,0.94,5,5],
              case_thermal_conductivity=50)
              annotation (Placement(transformation(extent={{-12,-28},{8,4}})));
            Modelica.Blocks.Sources.Step step(
              offset=1500,
              height=-1500,
              startTime=500)
              annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
            MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
              thermal_To_Environment_Thru_Area(area_for_heat_transfer=2)
              annotation (Placement(transformation(extent={{14,16},{34,36}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia2(J=1)
              annotation (Placement(transformation(extent={{-36,-22},{-16,-2}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-68,-22},{-48,-2}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load(d=30)
              annotation (Placement(transformation(extent={{60,-22},{80,-2}})));
          equation
            connect(thermal_To_Environment_Thru_Area.solid,
              example_Standalone_Transfer_Case_Implementation.outer_surface_heat_port)
              annotation (Line(
                points={{14,26},{3.1,26},{3.1,1.86667}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(inertia2.flange_a,torque. flange) annotation (Line(
                points={{-36,-12},{-48,-12}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torque.tau, step.y) annotation (Line(
                points={{-70,-12},{-74,-12},{-74,-10},{-79,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia2.flange_b,
              example_Standalone_Transfer_Case_Implementation.brg_01) annotation (
               Line(
                points={{-16,-12},{-14.05,-12},{-14.05,-10.9333},{-12.1,-10.9333}},
                color={0,0,0},
                smooth=Smooth.None));

            connect(load.flange_a, example_Standalone_Transfer_Case_Implementation.brg_02)
              annotation (Line(
                points={{60,-12},{34,-12},{34,-10.8267},{8,-10.8267}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-160,-100},{160,100}},
                    preserveAspectRatio=false),
                                graphics),
              experiment(StopTime=2),
              __Dymola_experimentSetupOutput,
              Icon(coordinateSystem(extent={{-160,-100},{160,100}})));
          end Test_Final_Drive;

          model Test_Bench_Final_Drive "test model for final drive"
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Constant
                                         step(k=100)
              annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
            MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
              thermal_To_Environment_Thru_Area(area_for_heat_transfer=2)
              annotation (Placement(transformation(extent={{12,30},{32,50}})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC
                                                        env
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Example_Standalone_Final_Drive_Implementation
              example_Standalone_Final_Drive_Implementation
              annotation (Placement(transformation(extent={{-20,-42},{20,18}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia2(J=1)
              annotation (Placement(transformation(extent={{-44,-20},{-24,0}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-68,-20},{-48,0}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load(d=30)
              annotation (Placement(transformation(extent={{44,-20},{64,0}})));
          equation
            connect(example_Standalone_Final_Drive_Implementation.outer_surface_heat_port,
              thermal_To_Environment_Thru_Area.solid) annotation (Line(
                points={{10.2,14},{10,14},{10,40},{12,40}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(inertia2.flange_a,torque. flange) annotation (Line(
                points={{-44,-10},{-48,-10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(example_Standalone_Final_Drive_Implementation.brg_01,
              inertia2.flange_b) annotation (Line(
                points={{-20.2,-10},{-24,-10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torque.tau, step.y) annotation (Line(
                points={{-70,-10},{-79,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.flange_a, example_Standalone_Final_Drive_Implementation.brg_02)
              annotation (Line(
                points={{44,-10},{32,-10},{32,-9.8},{20,-9.8}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-160,-100},{160,100}},
                    preserveAspectRatio=false),
                                graphics),
              experiment(StopTime=10, Interval=0.01),
              __Dymola_experimentSetupOutput,
              Icon(coordinateSystem(extent={{-160,-100},{160,100}})),
              Commands(file="Scripts/Final_Drive_Instance_Test.mos"
                  "Final_Drive_Instance_Test"));
          end Test_Bench_Final_Drive;
        end Tests;
      end Final_Drive;

      package Power_Take_Off_Module
        "Components that attach to the engine or driveline and distribute shaft power to systems"
          extends Modelica.Icons.Package;

        package Interfaces
          extends Modelica.Icons.Package;

          partial model PTM
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_05
              annotation (Placement(transformation(extent={{-210,90},{-190,110}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
              annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_04
              annotation (Placement(transformation(extent={{-210,-110},{-190,-90}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_02
              annotation (Placement(transformation(extent={{130,190},{150,210}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_03
              annotation (Placement(transformation(extent={{130,-210},{150,-190}})));

            Modelica.Mechanics.Rotational.Interfaces.Support
                    support if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-210},{10,-190}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support
                    internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-183},{3,-177}})));
            Modelica.Mechanics.Rotational.Components.Fixed
                             fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-197},{30,-177}})));

          equation
            connect(fixed.flange, internalSupport) annotation (Line(
                points={{20,-187},{20,-180},{0,-180}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, support) annotation (Line(
                points={{0,-180},{0,-200}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Icon(coordinateSystem(extent={{-200,-200},{140,200}},
                    preserveAspectRatio=false),
                             graphics),
                                    Diagram(coordinateSystem(preserveAspectRatio=false,
                             extent={{-200,-200},{140,200}}), graphics={
                                                   Text(
                    extent={{20,-197},{82,-200}},
                    lineColor={95,95,95},
                    textString="(if not useSupport)"),
                                         Text(
                    extent={{-52,-200},{0,-198}},
                    lineColor={95,95,95},
                    textString="(if useSupport)")}));
          end PTM;
        end Interfaces;

        model PTM_without_TC
          "Example PTM that includes 2 PTOs and 2 swim (waterjet) power take offs"
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.Interfaces.PTM;
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true, Dialog(tab="Fluid Model"));
        //inertia
          parameter SI.Inertia moi_rotational=0.2
            "rotational moment of inertia";

        //PTO 1
          parameter Real ratio_PTO1(start=1) = 1
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="PTO 1"));
          parameter Real lossTable_PTO1[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="PTO 1"));

        //PTO 2
          parameter Real ratio_PTO2(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="PTO 2"));
          parameter Real lossTable_PTO2[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="PTO 2"));

        //waterjet 1
          parameter Real ratio_WJ1(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Waterjet 1"));
          parameter Real lossTable_WJ1[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Waterjet 1"));

        //Waterjet 2
          parameter Real ratio_WJ2(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Waterjet 2"));
          parameter Real lossTable_WJ2[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Waterjet 2"));

        //Clutch Waterjet
          parameter SI.Force clutch_F_max_waterjet=100000
            "Maximum clutch apply force"                                               annotation (Dialog(group="Clutch Waterjet"));
          parameter Integer clutch_N_plate_waterjet(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(group="Clutch Waterjet"));
          parameter SI.Length clutch_R_eff_waterjet=0.1
            "Friction plate mean radius"                                             annotation (Dialog(group="Clutch Waterjet"));
          parameter Real clutch_mu_waterjet[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0)"
                                                                                                                annotation (Dialog(group="Clutch Waterjet"));
        //Clutch PTO 2
          parameter SI.Force clutch_F_max_PTO2=10000
            "Maximum clutch apply force"                                          annotation (Dialog(group="Clutch PTO 2"));
          parameter Integer clutch_N_plate_PTO2(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(group="Clutch PTO 2"));
          parameter SI.Length clutch_R_eff_PTO2=0.1
            "Friction plate mean radius"                                         annotation (Dialog(group="Clutch PTO 2"));
          parameter Real clutch_mu_PTO2[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0)"
                                                                                                                annotation (Dialog(group="Clutch PTO 2"));
          parameter Real hx_dp_a=1000 "HX quadratic loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter Real hx_dp_b=100 "HX linear loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_internal_area=1
            "Heat transfer area internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.CoefficientOfHeatTransfer HX_internal_HTC=2000
            "heat transfer coefficient internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_external_area=1.0
            "Area available for convective heat transferon the outside of the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
          Modelica.Mechanics.Rotational.Components.IdealGear          PTO_1(
            useSupport=true,
            ratio=ratio_PTO1)
            annotation (Placement(transformation(extent={{-50,50},{-70,70}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          PTO_2(
            useSupport=true,
            ratio=ratio_PTO2)
            annotation (Placement(transformation(extent={{-50,90},{-70,110}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_up(J=moi_rotational/2)
            annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          waterjet_1(
                                              useSupport=true,
            ratio=ratio_WJ1)
            annotation (Placement(transformation(extent={{10,10},{-10,-10}},
                rotation=270,
                origin={60,30})));
          Modelica.Mechanics.Rotational.Components.IdealGear              waterjet_bevel(ratio=1,
              useSupport=true)
            "90 degree shaft rotatio to waterjet drives. Assumes losses are in overall waterjet ratio, not this component"
            annotation (Placement(transformation(extent={{10,-10},{30,10}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          waterjet_2(
            useSupport=true,
            ratio=ratio_WJ2)
            annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                rotation=270,
                origin={60,-30})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_down(J=
                moi_rotational/2)
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
                                                                    waterjet_clutch(
            maxApply_force=clutch_F_max_waterjet,
            frictionPlate_count=clutch_N_plate_waterjet,
            meanRadius=clutch_R_eff_waterjet,
            mue=clutch_mu_waterjet)
            annotation (Placement(transformation(extent={{-16,-10},{4,10}})));
          C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
                                                                    PTO2_clutch(
            maxApply_force=clutch_F_max_PTO2,
            frictionPlate_count=clutch_N_plate_PTO2,
            meanRadius=clutch_R_eff_PTO2,
            mue=clutch_mu_PTO2)
            annotation (Placement(transformation(extent={{-26,80},{-6,100}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,-84})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test1(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,66})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test2(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-130,100})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test3(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-112,60})));
          MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{2,148},{22,168}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{10,190},{30,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(medium=medium)
            annotation (Placement(transformation(extent={{-210,190},{-190,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b flowPort_b(medium=medium)
            annotation (Placement(transformation(extent={{-150,190},{-130,210}})));
          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Volume_Flow_Rate_With_Heat_Addition
                                                        volume_Flow_Rate_With_Heat_Addition(
            alpha0=HX_internal_HTC,
            surface_area=HX_internal_area,
            a=hx_dp_a,
            b=hx_dp_b,
            medium=medium,
            m_flow_nom=1,
            delta_T(start=0))
            annotation (Placement(transformation(extent={{-170,130},{-150,150}})));
          MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=HX_external_area)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-160,74})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume       env(
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            fluid_height=0.02,
            fixed_htc=2000,
            initial_T=353.15)
            annotation (Placement(transformation(extent={{-190,110},{-170,130}})));
          Modelica.Blocks.Interfaces.RealInput waterjet_clutch_apply_command
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,208})));
          Modelica.Blocks.Interfaces.RealInput PTO2_clutch_apply_command
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-100,208})));
        equation
          connect(inertia_up.flange_b, PTO_1.flange_a) annotation (Line(
              points={{-44,0},{-24,0},{-24,60},{-50,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_down.flange_b, waterjet_1.flange_a) annotation (Line(
              points={{60,0},{60,20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_down.flange_b, waterjet_2.flange_a) annotation (Line(
              points={{60,0},{60,-20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_bevel.flange_b, inertia_down.flange_a) annotation (Line(
              points={{30,0},{40,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch.flange_b, waterjet_bevel.flange_a)
                                                                  annotation (Line(
              points={{4,0},{10,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch.flange_a, inertia_up.flange_b)
                                                              annotation (Line(
              points={{-16,0},{-44,0}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(PTO_2.flange_a, PTO2_clutch.flange_a) annotation (Line(
              points={{-50,100},{-28,100},{-28,90},{-26,90}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO2_clutch.flange_b, inertia_up.flange_b) annotation (Line(
              points={{-6,90},{-2,90},{-2,60},{-24,60},{-24,0},{-44,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_1.support, waterjet_2.support) annotation (Line(
              points={{70,30},{80,30},{80,-30},{70,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test.flange_b, waterjet_2.flange_b) annotation (Line(
              points={{60,-74},{60,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_a, waterjet_1.flange_b) annotation (Line(
              points={{60,56},{60,40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test2.flange_a, PTO_2.flange_b) annotation (Line(
              points={{-120,100},{-70,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test3.flange_a, PTO_1.flange_b) annotation (Line(
              points={{-102,60},{-70,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test.flange_a, brg_03) annotation (Line(
              points={{60,-94},{60,-180},{140,-180},{140,-200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_b, brg_02) annotation (Line(
              points={{60,76},{60,180},{140,180},{140,200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO_2.support, internalSupport) annotation (Line(
              points={{-60,90},{-80,90},{-80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO_1.support, internalSupport) annotation (Line(
              points={{-60,50},{-80,50},{-80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_bevel.support, internalSupport) annotation (Line(
              points={{20,-10},{20,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_2.support, internalSupport) annotation (Line(
              points={{70,-30},{80,-30},{80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test2.flange_b, brg_05) annotation (Line(
              points={{-140,100},{-200,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_up.flange_a, brg_01) annotation (Line(
              points={{-64,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test3.flange_b, brg_04) annotation (Line(
              points={{-122,60},{-160,60},{-160,-100},{-200,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{9,165},{9,178.5},{20,178.5},{20,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_a,flowPort_a)
                                                annotation (Line(
              points={{-170,140},{-200,140},{-200,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.heatPort,
            thermal_To_Environment_Thru_Area.solid) annotation (Line(
              points={{-160,130},{-160,84}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch_apply_command, waterjet_clutch.brake_clutch_command)
            annotation (Line(
              points={{-40,208},{-40,54},{-14,54},{-14,11.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PTO2_clutch.brake_clutch_command, PTO2_clutch_apply_command)
            annotation (Line(
              points={{-24,101.4},{-24,132},{-100,132},{-100,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_b, flowPort_b)
            annotation (Line(
              points={{-150,140},{-140,140},{-140,200}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -200},{200,200}}),
                              graphics={Text(
                  extent={{-66,-16},{-16,-84}},
                  lineColor={255,0,0},
                  textString="Bevel modeled as ideal.
Losses assumed to be
in waterjet ratios")}),                  Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-200},{200,200}}),
                                              graphics={
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={-60,88},
                  rotation=180,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={-82,88},
                  rotation=180,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-125.5,9.5},{125.5,-9.5}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={-79.5,-0.5},
                  rotation=180),
                Polygon(
                  points={{-57,-10},{-29,18},{-1,18},{29,-10},{-57,-10}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={50,-15},
                  rotation=270,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-22,-68},{-22,-90},{10,-90},{10,-50},{-22,-20},{-22,-68}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={30,-26},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{200,-9},{-200,9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={139,0},
                  rotation=90),
                Rectangle(
                  extent={{16,-2},{-16,2}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={106,-16},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={113,2},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={121,16},
                  rotation=90),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={121,-10},
                  rotation=90),
                Polygon(
                  points={{-22,70},{-22,90},{10,90},{10,46},{-22,46},{-22,70}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={244,-26},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{16,-2},{-16,2}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={174,-16},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={167,2},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={157,16},
                  rotation=90),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={157,-10},
                  rotation=90),
                Polygon(
                  points={{15,0},{5,14},{5,6},{-15,6},{-15,-6},{5,-6},{5,-14},{15,0}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid,
                  origin={119,40},
                  rotation=270),
                Rectangle(
                  extent={{-26.5,9.5},{26.5,-9.5}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={-176.5,-100.5},
                  rotation=180),
                Rectangle(
                  extent={{-72.5,9.5},{72.5,-9.5}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={-130.5,99.5},
                  rotation=180),
                Rectangle(
                  extent={{70,-14},{-70,14}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-140,-2},
                  rotation=90),
                Rectangle(
                  extent={{22,-14},{-22,14}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-140,-102},
                  rotation=90),
                Rectangle(
                  extent={{11,-14},{-11,14}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-72,63},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{42,-14},{-42,14}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-72,0},
                  rotation=90),
                Rectangle(
                  extent={{7,-3.5},{-7,3.5}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-71.5,77},
                  rotation=90,
                  lineColor={0,0,0}),
                Polygon(
                  points={{15,0},{5,14},{5,6},{-15,6},{-15,-6},{5,-6},{5,-14},{15,0}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid,
                  origin={-41,82},
                  rotation=180)}),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Power take off module outputs include PTO1, PTO2, Waterjet 1, and Waterjet 2</li>
<li>Input from the cross drive transmission with torque converter (This PTM has no torque converter)</li>
<li>User must input ratios and efficiencies for PTO1, PTO2, Waterjet 1, and Waterjet 2</li>
<li>There are two clutches to control operation to the waterjets and PTO2</li>
<li>User must input clutch parameters(max apply force, number of plates, effective radius, mu)</li>
</ul></p>
</html>"));
        end PTM_without_TC;

        model PTM_with_TC
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.Interfaces.PTM;
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true, Dialog(tab="Fluid Model"));
        //inertia
          parameter SI.Inertia moi_rotational=0.2
            "rotational moment of inertia";

        //PTO 1
          parameter Real ratio_PTO1(start=1) = 1
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="PTO 1"));
          parameter Real lossTable_PTO1[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="PTO 1"));

        //PTO 2
          parameter Real ratio_PTO2(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="PTO 2"));
          parameter Real lossTable_PTO2[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="PTO 2"));

        //waterjet 1
          parameter Real ratio_WJ1(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Waterjet 1"));
          parameter Real lossTable_WJ1[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Waterjet 1"));

        //Waterjet 2
          parameter Real ratio_WJ2(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(group="Waterjet 2"));
          parameter Real lossTable_WJ2[:, 5]=[0, 0.97, 0.97, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(group="Waterjet 2"));

        //Clutch Waterjet
          parameter SI.Force clutch_F_max_waterjet=100000
            "Maximum clutch apply force"                                               annotation (Dialog(group="Clutch Waterjet"));
          parameter Integer clutch_N_plate_waterjet(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(group="Clutch Waterjet"));
          parameter SI.Length clutch_R_eff_waterjet=0.1
            "Friction plate mean radius"                                             annotation (Dialog(group="Clutch Waterjet"));
          parameter Real clutch_mu_waterjet[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0)"
                                                                                                                annotation (Dialog(group="Clutch Waterjet"));
        //Clutch PTO 2
          parameter SI.Force clutch_F_max_PTO2=10000
            "Maximum clutch apply force"                                          annotation (Dialog(group="Clutch PTO 2"));
          parameter Integer clutch_N_plate_PTO2(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(group="Clutch PTO 2"));
          parameter SI.Length clutch_R_eff_PTO2=0.1
            "Friction plate mean radius"                                         annotation (Dialog(group="Clutch PTO 2"));
          parameter Real clutch_mu_PTO2[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0)"
                                                                                                                annotation (Dialog(group="Clutch PTO 2"));
          parameter Real hx_dp_a=1000 "HX quadratic loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter Real hx_dp_b=100 "HX linear loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_internal_area=1
            "Heat transfer area internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.CoefficientOfHeatTransfer HX_internal_HTC=2000
            "heat transfer coefficient internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_external_area=1.0
            "Area available for convective heat transferon the outside of the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));

          parameter Real powerCoeffTable_TC[:,2]=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488;
              0.2,0.2712; 0.3,0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712;
              0.9,0.2488; 1,0.2]
            "Table for power coefficientas a function of speed ratio"                                                                                                     annotation (Dialog(tab="Torque Converter"));
          parameter Real torqueConverTable_TC[:,2]=[-10,2; 0,2; 0.00001,2; 0.1,1.9; 0.2,1.8; 0.3,1.7; 0.4,1.6; 0.5,1.5; 0.6,1.4; 0.7,1.3; 0.8,1.0; 0.9,0.90; 0.95,0.85; 0.985,0.8; 1,0.8; 10,0.0]
            "Torque Ratio as a function of speed ratio"                                                                                                     annotation (Dialog(tab="Torque Converter"));
          parameter Modelica.SIunits.Length Diameter_TC=0.2
            "Torque Converter Diameter"            annotation (Dialog(tab="Torque Converter"));
          parameter Modelica.SIunits.Density fluidDensity_TC=850
            "Density of transmission fluid"                                                          annotation (Dialog(tab="Torque Converter"));

              // TC Lockup clutch gubbins
          parameter Modelica.SIunits.Torque locked_max_torque_TC=1200
            "Max torque transmitted when TC clutch is locked"    annotation (Dialog(group="Lock-up Clutch",tab="Torque Converter"));
          parameter Modelica.SIunits.Torque synchronizer_max_torque_TC=800
            "Max torque transmitted while synchronizing impeller & turbine" annotation (Dialog(group="Lock-up Clutch",tab="Torque Converter"));

          Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_06
            annotation (Placement(transformation(extent={{190,-10},{210,10}})));

          Modelica.Blocks.Interfaces.RealOutput input_speed_torque_converter
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-80,-206})));
          Modelica.Blocks.Interfaces.RealInput lockup_torque_converter annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={80,208})));
          Modelica.Blocks.Interfaces.RealOutput output_speed_torque_converter
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-140,-206})));
          C2M2L_Component_Building_Blocks.Drive_Line.Torque_Converters.Torque_Converter_Lockup
                                                                          torque_Converter_Lockup(
            powerCoeffTable=powerCoeffTable_TC,
            torqueConverTable=torqueConverTable_TC,
            Diameter=Diameter_TC,
            fluidDensity=fluidDensity_TC,
            locked_max_torque=locked_max_torque_TC,
            synchronizer_max_torque=synchronizer_max_torque_TC,
            use_environment_heat_port=true)
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_small(J=1e-3)
            "needed to run simulation when TC is not used"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={166,34})));
        public
          Modelica.Mechanics.Rotational.Components.IdealGear          PTO_1(
            useSupport=true,
            ratio=ratio_PTO1)
            annotation (Placement(transformation(extent={{-50,50},{-70,70}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          PTO_2(
            useSupport=true,
            ratio=ratio_PTO2)
            annotation (Placement(transformation(extent={{-50,90},{-70,110}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_up(J=moi_rotational/2)
            annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          waterjet_1(
                                              useSupport=true,
            ratio=ratio_WJ1)
            annotation (Placement(transformation(extent={{10,10},{-10,-10}},
                rotation=270,
                origin={60,30})));
          Modelica.Mechanics.Rotational.Components.IdealGear              waterjet_bevel(ratio=1,
              useSupport=true)
            "90 degree shaft rotatio to waterjet drives. Assumes losses are in overall waterjet ratio, not this component"
            annotation (Placement(transformation(extent={{10,-10},{30,10}})));
          Modelica.Mechanics.Rotational.Components.IdealGear          waterjet_2(
            useSupport=true,
            ratio=ratio_WJ2)
            annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                rotation=270,
                origin={60,-30})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_down(J=
                moi_rotational/2)
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
                                                                    waterjet_clutch(
            maxApply_force=clutch_F_max_waterjet,
            frictionPlate_count=clutch_N_plate_waterjet,
            meanRadius=clutch_R_eff_waterjet,
            mue=clutch_mu_waterjet)
            annotation (Placement(transformation(extent={{-16,-10},{4,10}})));
          C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
                                                                    PTO2_clutch(
            maxApply_force=clutch_F_max_PTO2,
            frictionPlate_count=clutch_N_plate_PTO2,
            meanRadius=clutch_R_eff_PTO2,
            mue=clutch_mu_PTO2)
            annotation (Placement(transformation(extent={{-26,80},{-6,100}})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,-84})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test1(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,66})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test2(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-130,100})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test3(J=0.0001)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-112,60})));
          MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{2,148},{22,168}})));
          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Volume_Flow_Rate_With_Heat_Addition
                                                        volume_Flow_Rate_With_Heat_Addition(
            alpha0=HX_internal_HTC,
            surface_area=HX_internal_area,
            a=hx_dp_a,
            b=hx_dp_b,
            medium=medium,
            m_flow_nom=1,
            delta_T(start=0))
            annotation (Placement(transformation(extent={{-170,130},{-150,150}})));
          MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=HX_external_area)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-160,74})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume       env(
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            fluid_height=0.02,
            fixed_htc=2000,
            initial_T=353.15)
            annotation (Placement(transformation(extent={{-190,110},{-170,130}})));
        public
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{10,190},{30,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(medium=medium)
            annotation (Placement(transformation(extent={{-210,190},{-190,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b flowPort_b(medium=medium)
            annotation (Placement(transformation(extent={{-150,190},{-130,210}})));
          Modelica.Blocks.Interfaces.RealInput waterjet_clutch_apply_command
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,208})));
          Modelica.Blocks.Interfaces.RealInput PTO2_clutch_apply_command
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-100,208})));
        equation
          connect(inertia_up.flange_b, torque_Converter_Lockup.TC_Input)
            annotation (Line(
              points={{-44,0},{-24,0},{-24,-46},{90,-46},{90,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup.TC_Output, brg_06)   annotation (Line(
              points={{110,0},{200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_small.flange_a, brg_06)   annotation (Line(
              points={{176,34},{200,34},{200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup.TC_Stator, internalSupport) annotation (
              Line(
              points={{110,3.4},{114,3.4},{114,4},{120,4},{120,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(torque_Converter_Lockup.lockup_torque_converter,
            lockup_torque_converter) annotation (Line(
              points={{100,10.8},{100,186},{80,186},{80,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(inertia_up.flange_b,PTO_1. flange_a) annotation (Line(
              points={{-44,0},{-24,0},{-24,60},{-50,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_down.flange_b,waterjet_1. flange_a) annotation (Line(
              points={{60,0},{60,20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_down.flange_b,waterjet_2. flange_a) annotation (Line(
              points={{60,0},{60,-20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_bevel.flange_b,inertia_down. flange_a) annotation (Line(
              points={{30,0},{40,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch.flange_b,waterjet_bevel. flange_a)
                                                                  annotation (Line(
              points={{4,0},{10,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch.flange_a,inertia_up. flange_b)
                                                              annotation (Line(
              points={{-16,0},{-44,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO_2.flange_a,PTO2_clutch. flange_a) annotation (Line(
              points={{-50,100},{-28,100},{-28,90},{-26,90}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO2_clutch.flange_b,inertia_up. flange_b) annotation (Line(
              points={{-6,90},{-2,90},{-2,60},{-24,60},{-24,0},{-44,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_1.support,waterjet_2. support) annotation (Line(
              points={{70,30},{80,30},{80,-30},{70,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test.flange_b,waterjet_2. flange_b) annotation (Line(
              points={{60,-74},{60,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_a,waterjet_1. flange_b) annotation (Line(
              points={{60,56},{60,40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test2.flange_a,PTO_2. flange_b) annotation (Line(
              points={{-120,100},{-70,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test3.flange_a,PTO_1. flange_b) annotation (Line(
              points={{-102,60},{-70,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test.flange_a,brg_03)  annotation (Line(
              points={{60,-94},{60,-180},{140,-180},{140,-200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_b,brg_02)  annotation (Line(
              points={{60,76},{60,180},{140,180},{140,200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO_2.support,internalSupport)  annotation (Line(
              points={{-60,90},{-80,90},{-80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(PTO_1.support,internalSupport)  annotation (Line(
              points={{-60,50},{-80,50},{-80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_bevel.support,internalSupport)  annotation (Line(
              points={{20,-10},{20,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_2.support,internalSupport)  annotation (Line(
              points={{70,-30},{80,-30},{80,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test3.flange_b,brg_04)  annotation (Line(
              points={{-122,60},{-160,60},{-160,-100},{-200,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{9,165},{9,178.5},{20,178.5},{20,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_a,flowPort_a)
                                                annotation (Line(
              points={{-170,140},{-200,140},{-200,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.heatPort,
            thermal_To_Environment_Thru_Area.solid) annotation (Line(
              points={{-160,130},{-160,84}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(waterjet_clutch_apply_command,waterjet_clutch. brake_clutch_command)
            annotation (Line(
              points={{-40,208},{-40,54},{-14,54},{-14,11.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PTO2_clutch.brake_clutch_command,PTO2_clutch_apply_command)
            annotation (Line(
              points={{-24,101.4},{-24,132},{-100,132},{-100,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_b, flowPort_b)
            annotation (Line(
              points={{-150,140},{-140,140},{-140,200}},
              color={255,0,0},
              smooth=Smooth.None));

          connect(torque_Converter_Lockup.output_speed_torque_converter,
            output_speed_torque_converter) annotation (Line(
              points={{106,10.6},{106,26},{144,26},{144,-134},{-140,-134},{-140,-206}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(torque_Converter_Lockup.input_speed_torque_converter,
            input_speed_torque_converter) annotation (Line(
              points={{94,10.6},{94,40},{152,40},{152,-166},{-80,-166},{-80,-206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(inertia_test2.flange_b, brg_05) annotation (Line(
              points={{-140,100},{-172,100},{-172,100},{-200,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_up.flange_a, brg_01) annotation (Line(
              points={{-64,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                    -200},{200,200}}), graphics={
                                        Text(
                  extent={{-66,-16},{-16,-84}},
                  lineColor={255,0,0},
                  textString="Bevel modeled as ideal.
Losses assumed to be
in waterjet ratios")}),         Icon(coordinateSystem(preserveAspectRatio=false, extent=
                   {{-200,-200},{200,200}}), graphics={
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={-163,88},
                  rotation=180,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={-181,88},
                  rotation=180,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-22,8.5},{22,-8.5}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={-180,100.5},
                  rotation=180),
                Polygon(
                  points={{15,0},{5,14},{5,6},{-6,6},{-6,-6},{5,-6},{5,-14},{15,0}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid,
                  origin={-148,86},
                  rotation=180),
                Rectangle(
                  extent={{7,-3.5},{-7,3.5}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-171.5,78},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{10,-8.5},{-10,8.5}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-171.5,65},
                  rotation=90,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-89,-9},{-59,17},{27,17},{59,-9},{-89,-9}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid,
                  origin={51,-15},
                  rotation=270,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-15,9.5},{15,-9.5}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={-187,-100.5},
                  rotation=180),
                Polygon(
                  points={{-22,-68},{-22,-90},{10,-90},{10,-50},{-22,-20},{-22,-68}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={31,-60},
                  rotation=90,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-22,70},{-22,90},{10,90},{10,46},{-22,46},{-22,70}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={245,-60},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{16,-2},{-16,2}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={175,-50},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{16,-2},{-16,2}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={107,-50},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={114,-32},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={168,-32},
                  rotation=90,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={158,-44},
                  rotation=90),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={122,-44},
                  rotation=90),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={122,-18},
                  rotation=90),
                Rectangle(
                  extent={{2,9},{-2,-9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={158,-18},
                  rotation=90),
                Polygon(
                  points={{-144,8},{-144,60},{-124,84},{-72,88},{-54,86},{-34,82},{-14,
                      66},{-14,46},{-34,28},{-52,22},{-66,44},{-60,50},{-60,58},{-72,62},
                      {-72,84},{-122,80},{-140,58},{-140,-52},{-118,-82},{-72,-92},{-72,
                      -68},{-60,-62},{-60,-54},{-66,-48},{-52,-28},{-34,-36},{-14,-50},
                      {-14,-74},{-34,-88},{-54,-94},{-72,-96},{-120,-86},{-144,-60},{
                      -144,8}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-200,10},{-142,-10}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{-76,64},{-76,80},{-92,80},{-112,78},{-122,60},{-122,40},{
                      -106,20},{-106,-20},{-122,-40},{-122,-60},{-112,-78},{-92,-84},{
                      -76,-84},{-76,-66},{-88,-60},{-88,-52},{-78,-46},{-90,-26},{-90,
                      -10},{208,-10},{208,10},{-90,10},{-90,26},{-78,46},{-88,50},{-88,
                      60},{-76,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={231,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-70,44},{-74,44},{-86,24},{-86,14},{10,14},{10,22},{34,22},{
                      34,24},{-2,24},{-2,22},{6,22},{6,18},{-58,18},{-58,24},{-70,44}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{34,-24},{34,-22},{10,-22},{10,-14},{-86,-14},{-86,-24},{-74,
                      -44},{-68,-44},{-56,-26},{-56,-18},{6,-18},{6,-22},{-2,-22},{-2,
                      -24},{34,-24}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{53,-8},{-53,8}},
                  pattern=LinePattern.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  origin={-172,-3},
                  rotation=90),
                Rectangle(
                  extent={{38,-9},{-38,9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={-173,-100},
                  rotation=90),
                Rectangle(
                  extent={{200,-9},{-200,9}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  origin={140,0},
                  rotation=90),
                Polygon(
                  points={{15,0},{5,14},{5,6},{-15,6},{-15,-6},{5,-6},{5,-14},{15,0}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,85,85},
                  fillPattern=FillPattern.Solid,
                  origin={120,6},
                  rotation=270)}));
        end PTM_with_TC;

        package Tests
          extends Modelica.Icons.Package;

          model Test_Driver_no_TC
            extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;

            Modelica.Blocks.Sources.Ramp waterjet_clutch_ramp(
              duration=5,
              height=1,
              startTime=15)
              annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
            Modelica.Blocks.Sources.Ramp PTO2_clutch_ramp(
              duration=5,
              height=1,
              startTime=5)
              annotation (Placement(transformation(extent={{-100,30},{-80,50}})));
            Modelica.Blocks.Interfaces.RealOutput waterjet_clutch_apply_command
              annotation (Placement(transformation(extent={{96,60},{116,80}})));
            Modelica.Blocks.Interfaces.RealOutput PTO2_clutch_apply_command
              annotation (Placement(transformation(extent={{96,30},{116,50}})));
          equation
            connect(waterjet_clutch_ramp.y, waterjet_clutch_apply_command)
              annotation (Line(
                points={{-79,70},{106,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(PTO2_clutch_apply_command, PTO2_clutch_ramp.y) annotation (Line(
                points={{106,40},{-79,40}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{
                      -100,-100},{100,100}}),
                                graphics));
          end Test_Driver_no_TC;

          model Test_Driver_with_TC
            extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;

            Modelica.Blocks.Sources.Ramp waterjet_clutch_ramp(
              duration=5,
              height=1,
              startTime=15)
              annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
            Modelica.Blocks.Sources.Ramp PTO2_clutch_ramp(
              duration=5,
              height=1,
              startTime=5)
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            Modelica.Blocks.Sources.Ramp     TC_lockup(
              height=1,
              duration=3,
              startTime=20)
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            Modelica.Blocks.Interfaces.RealOutput waterjet_clutch_apply_command
              annotation (Placement(transformation(extent={{96,62},{116,82}})));
            Modelica.Blocks.Interfaces.RealOutput PTO2_clutch_apply_command
              annotation (Placement(transformation(extent={{96,32},{116,52}})));
            Modelica.Blocks.Interfaces.RealOutput lockup_torque_converter
              annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          equation
            connect(waterjet_clutch_ramp.y, waterjet_clutch_apply_command)
              annotation (Line(
                points={{-59,70},{18.5,70},{18.5,72},{106,72}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(PTO2_clutch_apply_command, PTO2_clutch_ramp.y) annotation (Line(
                points={{106,42},{18.5,42},{18.5,30},{-59,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(TC_lockup.y, lockup_torque_converter) annotation (Line(
                points={{-59,-10},{22,-10},{22,0},{106,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{
                      -100,-100},{100,100}}),
                                graphics));
          end Test_Driver_with_TC;

          model test_PTM_simple "Tests the PTM_TC_only implementation"
            extends MSL_Extend.Icons.Simple_Test_Case;
            PTM_without_TC         pTM_without_TC(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{2,-44},{42,4}})));
            Modelica.Blocks.Sources.Constant torque_input(k=1000)
              annotation (Placement(transformation(extent={{-100,-30},{-80,-10}})));
            Test_Driver_no_TC test_Driver_no_TC
              annotation (Placement(transformation(extent={{-60,46},{-40,66}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia1(J=1)
              annotation (Placement(transformation(extent={{-34,-30},{-14,-10}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC env
              annotation (Placement(transformation(extent={{82,70},{102,90}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load(d=30)
              annotation (Placement(transformation(extent={{70,-6},{90,14}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load1(d=30)
              annotation (Placement(transformation(extent={{70,-54},{90,-34}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load2(d=4)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-36,-58})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load3(d=20)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-52,14})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                               fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), p=200000)
              annotation (Placement(transformation(extent={{-12,18},{8,38}})));
          equation
            connect(torque.tau, torque_input.y) annotation (Line(
                points={{-62,-20},{-79,-20}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia1.flange_b, pTM_without_TC.brg_01) annotation (Line(
                points={{-14,-20},{2,-20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia1.flange_a, torque.flange) annotation (Line(
                points={{-34,-20},{-40,-20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pTM_without_TC.waterjet_clutch_apply_command, test_Driver_no_TC.waterjet_clutch_apply_command)
              annotation (Line(
                points={{18,4.96},{18,63},{-39.4,63}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.PTO2_clutch_apply_command, pTM_without_TC.PTO2_clutch_apply_command)
              annotation (Line(
                points={{-39.4,60},{12,60},{12,4.96}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.flange_a, pTM_without_TC.brg_02) annotation (Line(
                points={{70,4},{36,4}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load1.flange_a, pTM_without_TC.brg_03) annotation (Line(
                points={{70,-44},{36,-44}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load2.flange_a, pTM_without_TC.brg_04) annotation (Line(
                points={{-26,-58},{2,-58},{2,-32}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load3.flange_a, pTM_without_TC.brg_05) annotation (Line(
                points={{-42,14},{-22,14},{-22,-8},{2,-8}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, pTM_without_TC.flowPort_b) annotation (
               Line(
                points={{4,18},{6,18},{6,4},{8,4}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, pTM_without_TC.flowPort_a) annotation (
               Line(
                points={{-8,18},{-4,18},{-4,4},{2,4}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=30),
              __Dymola_experimentSetupOutput);
          end test_PTM_simple;

          model test_PTM_simple_with_TC "Tests the PTM_TC_only implementation"
            extends MSL_Extend.Icons.Simple_Test_Case;
            PTM_with_TC pTM_with_TC(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{20,-72},{60,-12}})));
            Modelica.Blocks.Sources.Constant Engine(k=1000)
              annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
            Test_Driver_with_TC test_Driver_with_TC annotation (Placement(transformation(
                    rotation=0, extent={{-80,46},{-60,66}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia1(J=1)
              annotation (Placement(transformation(extent={{-26,-50},{-6,-30}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-52,-50},{-32,-30}})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC env
              annotation (Placement(transformation(extent={{72,60},{92,80}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load(d=15)
              annotation (Placement(transformation(extent={{78,-52},{98,-32}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load1(d=15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={94,-72})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load2(d=0.1)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-12,-64})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load3(d=10)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-22,-16})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(d=15)
              annotation (Placement(transformation(extent={{74,-22},{94,-2}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                               fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), p=200000)
              annotation (Placement(transformation(extent={{8,10},{28,30}})));
          equation
            connect(inertia1.flange_a,torque. flange) annotation (Line(
                points={{-26,-40},{-32,-40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torque.tau, Engine.y) annotation (Line(
                points={{-54,-40},{-79,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(inertia1.flange_b, pTM_with_TC.brg_01) annotation (Line(
                points={{-6,-40},{8,-40},{8,-42},{20,-42}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pTM_with_TC.lockup_torque_converter, test_Driver_with_TC.lockup_torque_converter)
              annotation (Line(
                points={{48,-10.8},{48,56},{-59.4,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver_with_TC.PTO2_clutch_apply_command, pTM_with_TC.PTO2_clutch_apply_command)
              annotation (Line(
                points={{-59.4,60.2},{30,60.2},{30,-10.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pTM_with_TC.waterjet_clutch_apply_command, test_Driver_with_TC.waterjet_clutch_apply_command)
              annotation (Line(
                points={{36,-10.8},{36,63.2},{-59.4,63.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.flange_a, pTM_with_TC.brg_06) annotation (Line(
                points={{78,-42},{60,-42}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load1.flange_a, pTM_with_TC.brg_03) annotation (Line(
                points={{84,-72},{54,-72}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(pTM_with_TC.brg_04, load2.flange_a) annotation (Line(
                points={{20,-57},{10,-57},{10,-64},{-2,-64}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load3.flange_a, pTM_with_TC.brg_05) annotation (Line(
                points={{-12,-16},{0,-16},{0,-27},{20,-27}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load4.flange_a, pTM_with_TC.brg_02) annotation (Line(
                points={{74,-12},{54,-12}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, pTM_with_TC.flowPort_a) annotation (
                Line(
                points={{12,10},{12,-12},{20,-12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, pTM_with_TC.flowPort_b) annotation (
                Line(
                points={{24,10},{26,10},{26,-12}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=30, Interval=0.01),
              __Dymola_experimentSetupOutput);
          end test_PTM_simple_with_TC;
        end Tests;
      end Power_Take_Off_Module;

      package Drive_Shafts "Test area for drive shafts"
          extends Modelica.Icons.Package;

        model Drive_Shaft
          "Drive shaft implementation with replaceable mechanical and thermal sub-models"
          //extends Interfaces.Base_C2M2L(use_environment_heat_port=true,thermal_To_Environment(area_for_heat_transfer=
          //        0.1));

        //Mechanical
          parameter SI.Length length(final min=0) = 1
            "Length of shaft, slip joint collapsed" annotation(Dialog(group="Mechanical"));
          parameter SI.Length length_flange_to_joint_center(final min=0) = 0.1
            "Length of from connection flanges to the center of the articulating joints"
                                                                                         annotation(Dialog(group="Mechanical"));
          parameter SI.Length max_length(final min=0) = 1.1
            "Maximum length with slip joint at max extension" annotation(Dialog(group="Mechanical"));
          parameter SI.Diameter Tube_Outside_Diameter(final min=0) = 0.05
            "Outer diameter of shaft"                                                   annotation(Dialog(group="Mechanical"));
          parameter SI.Diameter Tube_Thickness = 0.005
            "Wall thickness of shaft"                                                       annotation(Dialog(group="Mechanical"));

          parameter Real lossTable[:,5]=[0,0.97,0.97,0,0;1000,0.97,0.97,0,0]
            "losses at drive shaft joint"                                                                       annotation(Dialog(group="Mechanical"));

          //parameter SI.Diameter wall_thick(final min=0) = 0.005
          //  "Wall thickness of shaft" annotation(Dialog(group="Mechanical"));
          //parameter SI.Density rho(final min=0) = 8000 "Material density of shaft" annotation(Dialog(group="Mechanical"));
          //parameter SI.ShearModulus G(final min=0) = 79.3e9
          //  "Shear modulus of shaft material" annotation(Dialog(group="Mechanical"));
          //Bevel **has no effect on model, removed
          //parameter Real k=5 "Torque (Nm) lost in each joint per radian of deflection"  annotation(Dialog(group="Mechanical"));

        //Thermal
          parameter SI.ThermalConductivity k_thermal = 40
            "Conductivity of shaft material" annotation(Dialog(group="Thermal"));
          parameter SI.SpecificHeatCapacity c_thermal = 466
            "Specific heat of shaft material" annotation(Dialog(group="Thermal"));

          C2M2L_Component_Building_Blocks.Drive_Line.Drive_Shafts.Components.Mechanical_Models.Mechanical_Simple_1D_Bevel
            mechanical_Simple_1D_Bevel(
            length=length,
            length_flange_to_joint_center=length_flange_to_joint_center,
            max_slip=max_length - length,
            outer_dia=Tube_Outside_Diameter,
            wall_thick=Tube_Thickness)
            annotation (Placement(transformation(extent={{-9,-10},{11,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a frame_a
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_b frame_b
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        equation

          connect(mechanical_Simple_1D_Bevel.frame_b, frame_b) annotation (Line(
              points={{11,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(mechanical_Simple_1D_Bevel.frame_a, frame_a) annotation (Line(
              points={{-9,0},{-100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
            Documentation(info="<html>
<p>Partial model that specifies the connections a drive shaft provides and the sub-models a drive shaft must contain and how they are internally connected.</p>
<p>A drive shaft must contain:</p>
<p><ul>
<li>A mechanical model that extends Partial_Mechanical</li>
<li>A thermal model that extends Partial_Thermal</li>
<li>A data record that extends Drive_Shaft_Record_Template</li>
</ul></p>
<p><br/>The mechanical model must connect to the two external MultiBody frames as well as internally via two heat ports to the thermal model. These two heat ports can be used to represent heat generation within the joints of the drive shaft. The thermal model connects to the mechanical model via two heat ports and must also connect to an external heat port.</p>
<p>The data record is specified as an<b> inner </b>and will be available to the mechanical and thermal models as an <b>outer</b> component.</p>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Polygon(
                  points={{56,74},{48,74},{46,80},{48,86},{56,88},{60,86},{72,86},{82,
                      88},{86,86},{88,76},{82,72},{86,72},{86,66},{80,60},{72,62},{68,
                      66},{66,64},{62,62},{58,60},{52,62},{48,68},{56,74}},
                  lineColor={0,0,0},
                  smooth=Smooth.Bezier,
                  fillColor={254,254,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-82,84},{-60,56}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder),
                Rectangle(
                  extent={{62,30},{84,2}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder),
                Polygon(
                  points={{-46,80},{58,30},{48,8},{-56,60},{-46,80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  smooth=Smooth.None,
                  fillColor={175,175,175}),
                Line(
                  points={{-98,8},{-88,8},{-88,72},{-54,72},{58,14},{100,14}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.DashDot),
                Line(
                  points={{60,14},{60,46},{58,64}},
                  color={255,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{60,86},{60,80},{58,74},{52,70}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{68,66},{68,68},{68,72},{74,74},{82,72}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{58,74},{64,74},{68,70}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{72,86},{70,80},{70,78},{74,74}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{52,54},{58,64},{64,54}},
                  color={255,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-6,-5},{0,5},{6,-5}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  origin={42,81},
                  rotation=270),
                Line(
                  points={{-54,72},{-50,90},{46,80}},
                  color={255,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-120,-20},{-100,-40}},
                  lineColor={215,215,215},
                  fillColor={254,254,255},
                  fillPattern=FillPattern.Solid,
                  textString="a"),
                Text(
                  extent={{100,-20},{120,-40}},
                  lineColor={215,215,215},
                  fillColor={254,254,255},
                  fillPattern=FillPattern.Solid,
                  textString="b"),
                Text(
                  extent={{-140,-40},{140,-80}},
                  lineColor={0,0,255},
                  fillColor={254,254,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name")}));
        end Drive_Shaft;

        package Tests
          extends Modelica.Icons.Package;

          model Test_Bench_Drive_Shaft
            "Tests operation of a driveshaft model with source and sink mounted on isolators"
          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Real efficiency;

            Drive_Shaft drive_Shaft
              annotation (Placement(transformation(extent={{-9,-10},{11,10}})));
            Modelica.Blocks.Sources.Constant torque_input(k=600)
              annotation (Placement(transformation(extent={{-84,-10},{-64,10}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-54,-10},{-34,10}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(d=15)
              annotation (Placement(transformation(extent={{34,-10},{54,10}})));
          equation

          if torque_Source.shaft_power > 1e-3 then
            efficiency = (abs(simple_Dyno.actual_speed * simple_Dyno.actual_torque)) /torque_Source.shaft_power;
          else
            efficiency = 1.0;
          end if;

            connect(torque.tau,torque_input. y) annotation (Line(
                points={{-56,0},{-63,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(drive_Shaft.flange_b, load4.flange_a)          annotation (Line(
                points={{11,0},{34,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(drive_Shaft.flange_a, torque.flange)          annotation (Line(
                points={{-9,0},{-34,0}},
                color={0,0,0},
                smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
            Documentation(info="<html>
<p>A test bench for exercising drive shaft models through a range of articulation angles.</p>
<p>Includes:</p>
<p><ul>
<li>Torque source that sets the input torque</li>
<li>Torque sink that sets the rpm by using a controller to set the required reaction torque</li>
<li>A replaceable drive shaft model</li>
<li>A translation that sets the distance between the source and sink</li>
<li>A moving element that adjusts the height of the sink relative to the source</li>
</ul></p>
<p>fhfj</p>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
                graphics),
            experiment(
                StopTime=8,
                NumberOfIntervals=5000,
                Algorithm="Dassl"),
            __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Drive_Shaft_Basic_Test.mos"
                  "Drive_Shaft_Basic_Test"));
          end Test_Bench_Drive_Shaft;
        end Tests;
      end Drive_Shafts;

      package Gearbox_90_Degree "90 degree gearbox"
        extends Modelica.Icons.Package;

        model Gearbox_90_Degree "90 degree gearbox bevel"
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Gearbox_90_Degree.Interfaces.Gearbox_90_Degree;
          parameter Real ratio = 3.10
            "Bevel or hypoid gear ratio from prop shaft"                          annotation(Dialog(group="Bevel"));
          parameter Real efficiency[:, 5]=[0, 0.96, 0.96, 0, 0]
            "losses for bevel gear mesh"
            annotation(Dialog(group="Bevel"));
          parameter SI.Inertia moi_rotational=0.01
            "Input moment of inertia (seen at bevel input)"
            annotation (Dialog(group="Bevel"));
          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));

          MSL_Extend.Mechanics.Rotational.Components.Gear_Ratios.Lossy_Gear_With_Environment_simple
                                   bevel_Gear_Rotation_Axis(ratio=ratio, lossTable=
                efficiency,
            useHeatPort=false,
            use_environment_heat_port=true,
            useSupport=true)
            annotation (Placement(transformation(extent={{-10,-18},{10,2}})));
          Modelica.Mechanics.Rotational.Components.Inertia gearbox_inertia(J=
                moi_rotational) "inertia of 90 degree inertia"
            annotation (Placement(transformation(extent={{-38,-18},{-18,2}})));
          MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment
            simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{-18,148},{2,168}})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume       env(
            fluid_area=0.5,
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
            annotation (Placement(transformation(extent={{-194,110},{-174,130}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{-10,190},{10,210}})));
        equation

          connect(gearbox_inertia.flange_b, bevel_Gear_Rotation_Axis.flange_a)
            annotation (Line(
              points={{-18,-8},{-10,-8}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(bevel_Gear_Rotation_Axis.flange_b, brg_2) annotation (Line(
              points={{10,-8},{140,-8},{140,202}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(gearbox_inertia.flange_a, brg_1) annotation (Line(
              points={{-38,-8},{-120,-8},{-120,6},{-200,6}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(bevel_Gear_Rotation_Axis.support, internalSupport) annotation (
              Line(
              points={{0,-18},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{-11,165},{-11,178.5},{0,178.5},{0,200}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                    -100},{140,200}}),
                           graphics),               Diagram(coordinateSystem(
                  preserveAspectRatio=false,extent={{-200,-100},{140,200}}),
                                                            graphics),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Model uses Differential_Bevel_Gear_Open and lossy_Gear_With_Environment for bevel ratio</li>
<li>User must input spider and side gear teeth count, mesh efficiency, torque &AMP; speed limits, input bevel ratio and efficiency</li>
</ul></p>
</html>"),  experiment(StopTime=400),
            __Dymola_experimentSetupOutput);
        end Gearbox_90_Degree;

        package Interfaces
          extends Modelica.Icons.Package;
          partial model Gearbox_90_Degree
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

            Modelica.Mechanics.Rotational.Interfaces.Flange_a         brg_1
              annotation (Placement(transformation(extent={{-210,-4},{-190,16}}),
                  iconTransformation(extent={{-200,-4},{-180,16}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_b         brg_2
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={140,202}), iconTransformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={150,212})));

            Modelica.Mechanics.Rotational.Interfaces.Support
                    support if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support
                    internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
            Modelica.Mechanics.Rotational.Components.Fixed
                             fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-97},{30,-77}})));

          equation
            connect(fixed.flange, internalSupport) annotation (Line(
                points={{20,-87},{20,-80},{0,-80}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, support) annotation (Line(
                points={{0,-80},{0,-100}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                      -100},{140,200}}),        graphics), Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-200,-100},{140,200}}),
                  graphics={
                  Rectangle(
                    extent={{139,-16.5},{-139,16.5}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid,
                    origin={149.5,71},
                    rotation=90),
                  Polygon(
                    points={{-10,-68},{-10,-220},{20,-220},{20,-52},{-10,-22},{-10,-68}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid,
                    origin={-10,-58},
                    rotation=90),
                  Rectangle(
                    extent={{-96,13},{96,-13}},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.HorizontalCylinder,
                    origin={-94,10},
                    rotation=180),
                  Polygon(
                    points={{-75,-8},{-47,24},{39,24},{69,-8},{-75,-8}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    origin={8,7},
                    rotation=270)}));
          end Gearbox_90_Degree;
        end Interfaces;

        package Tests
          extends Modelica.Icons.Package;

          model Test_90degree_Gearbox
            " Torques at the input and the outputs can be varied."
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

            Gearbox_90_Degree gearbox_90_Degree
              annotation (Placement(transformation(extent={{0,-18},{20,15}})));
            Modelica.Blocks.Sources.Constant torque_input(k=100)
              annotation (Placement(transformation(extent={{-94,-10},{-74,10}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia2(J=1)
              annotation (Placement(transformation(extent={{-26,-16},{-6,4}})));
            Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heatCapacitor(C=100000,
                T(start=313.15, fixed=true))
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(d=15)
              annotation (Placement(transformation(extent={{44,6},{64,26}})));
          equation
            connect(torque.tau, torque_input.y) annotation (Line(
                points={{-66,0},{-73,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(gearbox_90_Degree.brg_1, inertia2.flange_b) annotation (Line(
                points={{0.588235,-6.34},{-2.70588,-6.34},{-2.70588,-6},{-6,-6}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia2.flange_a, torque.flange) annotation (Line(
                points={{-26,-6},{-34,-6},{-34,0},{-44,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(heatCapacitor.port, gearbox_90_Degree.outer_surface_heat_port)
              annotation (Line(
                points={{0,50},{6,50},{6,15},{11.7647,15}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(load4.flange_a, gearbox_90_Degree.brg_2) annotation (Line(
                points={{44,16},{20.5882,16.32}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=80, Interval=0.01),
              __Dymola_experimentSetupOutput(events=false));
          end Test_90degree_Gearbox;
        end Tests;
      end Gearbox_90_Degree;

      package Cross_Drive_Transmission
        "Cross drive transmission implementations"
          extends Modelica.Icons.Package;

        package Interfaces
          extends Modelica.Icons.Package;

          partial model Cross_Drive
            parameter Boolean useSupport=false
              "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
              annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_02
              annotation (Placement(transformation(extent={{130,190},{150,210}})));
            Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_03
              annotation (Placement(transformation(extent={{130,-210},{150,-190}})));

            Modelica.Mechanics.Rotational.Interfaces.Support
                    support if useSupport "Support/housing of component"
              annotation (Placement(transformation(extent={{-10,-210},{10,-190}})));
          protected
            Modelica.Mechanics.Rotational.Interfaces.Support
                    internalSupport
              "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
              annotation (Placement(transformation(extent={{-3,-183},{3,-177}})));
            Modelica.Mechanics.Rotational.Components.Fixed
                             fixed if not useSupport
              "Fixed support/housing, if not useSupport"
              annotation (Placement(transformation(extent={{10,-197},{30,-177}})));

          equation
            connect(fixed.flange, internalSupport) annotation (Line(
                points={{20,-187},{20,-180},{0,-180}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(internalSupport, support) annotation (Line(
                points={{0,-180},{0,-200}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Icon(coordinateSystem(extent={{-200,-200},{140,200}}),
                             graphics={
                  Rectangle(
                    extent={{-48.5,8},{48.5,-8}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-54,-15.5},
                    rotation=90),
                  Line(
                    points={{68,178},{84,186}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{68,166},{84,174}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{68,156},{84,164}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Rectangle(
                    extent={{112,188},{84,158}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-35.5,7.5},{35.5,-7.5}},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={139.5,165.5},
                    rotation=90),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={174,117},
                    rotation=90),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={106,119},
                    rotation=90),
                  Rectangle(
                    extent={{-1.5,37},{1.5,-37}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={140,128.5},
                    rotation=90),
                  Rectangle(
                    extent={{-6.5,9.5},{6.5,-9.5}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={105.5,113.5},
                    rotation=90),
                  Rectangle(
                    extent={{-6.5,9.5},{6.5,-9.5}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={172.5,113.5},
                    rotation=90),
                  Rectangle(
                    extent={{-7,18},{7,-18}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={138,113},
                    rotation=90),
                  Rectangle(
                    extent={{-7,3},{7,-3}},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={190,113},
                    rotation=90,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-7,3},{7,-3}},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={88,113},
                    rotation=90,
                    lineColor={0,0,0}),
                  Line(
                    points={{74,-64},{74,112},{88,112}},
                    color={0,128,255},
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-6.5,47.5},{6.5,-47.5}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={138.5,87.5},
                    rotation=90),
                  Rectangle(
                    extent={{-120,7},{120,-7}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={137,-10},
                    rotation=90),
                  Rectangle(
                    extent={{-7,18},{7,-18}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={136,-129},
                    rotation=90),
                  Rectangle(
                    extent={{-6.5,9.5},{6.5,-9.5}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={170.5,-128.5},
                    rotation=90),
                  Rectangle(
                    extent={{-7,3},{7,-3}},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={188,-129},
                    rotation=90,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={172,-135},
                    rotation=90),
                  Rectangle(
                    extent={{-1.5,37},{1.5,-37}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={138,-143.5},
                    rotation=90),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={104,-133},
                    rotation=90),
                  Rectangle(
                    extent={{-6.5,9.5},{6.5,-9.5}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={103.5,-128.5},
                    rotation=90),
                  Line(
                    points={{74,-104},{74,-130},{86,-130}},
                    color={0,128,255},
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-7,3},{7,-3}},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={86,-129},
                    rotation=90,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-118,-64},{100,-104}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,128,255}),
                  Text(
                    extent={{-94,-80},{46,-92}},
                    lineColor={0,128,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="Steer"),
                  Rectangle(
                    extent={{-30,8},{30,-8}},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={140,-172},
                    rotation=90),
                  Rectangle(
                    extent={{112,-162},{84,-192}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Line(
                    points={{68,-194},{84,-186}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{68,-184},{84,-176}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Line(
                    points={{68,-172},{84,-164}},
                    smooth=Smooth.None,
                    color={0,0,0}),
                  Rectangle(
                    extent={{-4,56},{4,-56}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-54,106},
                    rotation=90),
                  Rectangle(
                    extent={{-15,4},{15,-4}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={1,94},
                    rotation=90),
                  Rectangle(
                    extent={{-6,35.5},{6,-35.5}},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={48.5,86},
                    rotation=90,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-15,4},{15,-4}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-111,94},
                    rotation=90),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-86,75},
                    rotation=90),
                  Rectangle(
                    extent={{9,2},{-9,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-22,73},
                    rotation=90),
                  Rectangle(
                    extent={{-10,9},{10,-9}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-22,81},
                    rotation=90),
                  Rectangle(
                    extent={{-10,18},{10,-18}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-52,82},
                    rotation=90),
                  Rectangle(
                    extent={{-10,9},{10,-9}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-86,82},
                    rotation=90),
                  Rectangle(
                    extent={{-14.5,8.5},{14.5,-8.5}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-54.5,65.5},
                    rotation=90),
                  Rectangle(
                    extent={{-2,18},{2,-18}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-100,64},
                    rotation=90),
                  Rectangle(
                    extent={{-2,17},{2,-17}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-8,63},
                    rotation=90),
                  Rectangle(
                    extent={{-27,2},{27,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={9,36},
                    rotation=90),
                  Rectangle(
                    extent={{-27,2},{27,-2}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-117,36},
                    rotation=90),
                  Rectangle(
                    extent={{-4,56},{4,-56}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-54,52},
                    rotation=90),
                  Rectangle(
                    extent={{-15,4},{15,-4}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-3,32},
                    rotation=90),
                  Rectangle(
                    extent={{-15,4},{15,-4}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-103,36},
                    rotation=90),
                  Rectangle(
                    extent={{-10,3},{10,-3}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-86,21},
                    rotation=90),
                  Rectangle(
                    extent={{-2,17},{2,-17}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-10,9},
                    rotation=90),
                  Rectangle(
                    extent={{-10,9},{10,-9}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-22,27},
                    rotation=90),
                  Rectangle(
                    extent={{-10,3},{10,-3}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-24,21},
                    rotation=90),
                  Rectangle(
                    extent={{-10,9},{10,-9}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-86,29},
                    rotation=90),
                  Rectangle(
                    extent={{-10,18},{10,-18}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={-54,28},
                    rotation=90),
                  Rectangle(
                    extent={{-2,18},{2,-18}},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    origin={-100,8},
                    rotation=90),
                  Polygon(
                    points={{-6,35},{-6,-101},{10,-89},{10,19},{-6,35}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    origin={-87,-28},
                    rotation=90),
                  Polygon(
                    points={{-132,36},{-132,-32},{-110,-12},{-110,14},{-132,36}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{8,44},{-8,-44}},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={140,174},
                    rotation=90),
                  Rectangle(
                    extent={{8,44},{-8,-44}},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    origin={140,-176},
                    rotation=90)}), Diagram(coordinateSystem(preserveAspectRatio=false,
                             extent={{-200,-200},{140,200}}), graphics={
                                                   Text(
                    extent={{20,-197},{82,-200}},
                    lineColor={95,95,95},
                    textString="(if not useSupport)"),
                                         Text(
                    extent={{-52,-200},{0,-198}},
                    lineColor={95,95,95},
                    textString="(if useSupport)")}));
          end Cross_Drive;
        end Interfaces;

        model Cross_Drive_without_TC
          "cross drie transmission with braking, steering, range pack. This model has no torque converter"
          import C2M2L_OM;
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Interfaces.Cross_Drive;
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Medium()
            "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true, Dialog(tab="Fluid Model"));
          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
          parameter Real hx_dp_a=1000 "HX quadratic loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter Real hx_dp_b=100 "HX linear loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_internal_area=1
            "Heat transfer area internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.CoefficientOfHeatTransfer HX_internal_HTC=2000
            "heat transfer coefficient internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_external_area=1.0
            "Area available for convective heat transferon the outside of the HX"
                                                                                  annotation (Dialog(tab="Fluid Model"));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Range_Pack.Simplified_Range_Pack.Range_Pack_Internals
                                          range_Pack_Internals(
            gear_nums=gear_nums_RP,
            ratios=ratios_RP,
            lossTables=lossTables_RP,
            locked_max_torque=locked_max_torque_RP,
            synchronizer_max_torque=synchronizer_max_torque_RP,
            num_gears=num_gears_RP,
            useSupport=true,
            use_environment_heat_port=true)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,70})));
        //General
         parameter SI.Inertia moi_rotational = 0.1 "Trans Inertia";

        //range pack
        public
          parameter Integer num_gears_RP=4
            "The number of gear ratios in the contained range pack (including reverse if applicable)"
            annotation (Dialog(tab="Range Pack"));
          parameter Integer gear_nums_RP[num_gears_RP]={1,2,3,4}
            "Identifiers for the contained gears.  E.g {-1,1,2,3,4} for a pack with 1 reverse and 4 forward gears"
            annotation (Dialog(tab="Range Pack"));
          parameter Real lossTables_RP[num_gears_RP,:,5]={[0,0.95,0.95,0,0],[0,0.95,0.95,0,0],
              [0,0.95,0.95,0,0],[0,0.95,0.95,0,0]}
            "Array of arrays of mesh efficiencies and bearing friction depending on speed for each contained gear"
            annotation (Dialog(tab="Range Pack"));
          parameter SI.Torque locked_max_torque_RP=10000
            "Max torque transmitted when gear sync clutches are locked"
            annotation (Dialog(tab="Range Pack"));
          parameter SI.Torque synchronizer_max_torque_RP=4000
            "Max torque transmitted while synchronizing each gear"
            annotation (Dialog(tab="Range Pack"));
          parameter Real ratios_RP[num_gears_RP]={3.2,2.2,1.5,0.9}
            "Transmission ratios (flange_a.phi/flange_b.phi) of contained gears"
            annotation (Dialog(tab="Range Pack"));
        //   parameter SI.Temperature initial_T=Medium.T_default
        //     "Initial temperature of the contained environment";

        //Brakes
        parameter SI.Force maxApply_force_Brk=10000
            "Maximum clutch apply force"                                         annotation (Dialog(tab="Brakes"));
          parameter Integer frictionPlate_count_Brk(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(tab="Brakes"));
          parameter SI.Length meanRadius_Brk=0.1 "Friction plate mean radius" annotation (Dialog(tab="Brakes"));
          parameter Real mue_Brk[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0). "
                                                                                                                annotation (Dialog(tab="Brakes"));

        //front_PTO
          parameter Real ratio_frontPTO(start=1) = 1
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(tab="PTO",group="Front PTO"));
          parameter Real lossTable_frontPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(tab="PTO",group="Front PTO"));

        //rear_PTO
          parameter Real ratio_rearPTO(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(tab="PTO",group="Rear PTO"));
          parameter Real lossTable_rearPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(tab="PTO",group="Rear PTO"));

        //Hydrostatic pump and motor steering unit
        // Pump_variableDisp parameters
          parameter SI.AbsolutePressure P_constant=10000000
                                                           annotation(Dialog(tab="Steering"));

        ////pump parameters
          parameter Real min_multiplier_pump=0.1
            "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u"
                                                                                    annotation(Dialog(tab="Steering",group="Pump"));
         parameter SI.Volume vol_per_radian_pump = 1e-6
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(tab="Steering",group="Pump"));
         parameter SI.Volume Nm_per_pascal_pump = 1e-6
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(tab="Steering",group="Pump"));
         parameter Real lossTable_pump[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(tab="Steering",group="Pump"));
         //parameter Boolean useInertia_pump=true
         //   "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(tab="Steering",group="Pump"));

          parameter SI.Inertia J_pump(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(tab="Steering",group="Pump"));
         //parameter Boolean useLeakage_pump=true
         //   "= true if leakage enabled, otherwise not used in model"
         //         annotation(Dialog(tab="Steering",group="Pump"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_pump=1.0 "Leakage loss factor" annotation(Dialog(tab="Steering",group="Pump"));

        ////motor parameters
         parameter SI.Volume vol_per_radian_motor = 1e-6
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(tab="Steering",group="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1e-6
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(tab="Steering",group="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(tab="Steering",group="Motor"));
         //parameter Boolean useInertia_motor=true
         //   "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(tab="Steering",group="Motor"));

          parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(tab="Steering",group="Motor"));
         //parameter Boolean useLeakage_motor=true
         //   "= true if leakage enabled, otherwise not used in model"
         //         annotation(Dialog(tab="Steering",group="Motor"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                  annotation(Dialog(tab="Steering",group="Motor"));
        //Motor output planetary
          parameter Integer N_sun = 50 "Number of teeth on Sun gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          parameter Integer N_ring = 100 "Number of teeth on Ring gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          parameter Integer N_planet = 25 "Number of teeth on Planet gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          Modelica.Mechanics.Rotational.Components.IdealPlanetary
            right_combine_planetary(ratio=1) "steering and range pack combiner"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={100,108})));
          Modelica.Mechanics.Rotational.Components.IdealPlanetary
            left_combine_planetary(ratio=1) "steering and range pack combiner"
            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={100,-74})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test(J=
                moi_rotational)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-18,0})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
            left_brake(maxApply_force=maxApply_force_Brk,
            frictionPlate_count=frictionPlate_count_Brk,
            meanRadius=meanRadius_Brk,
            mue=mue_Brk)
                       annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={120,-48})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
            left_brake1(
            maxApply_force=maxApply_force_Brk,
            frictionPlate_count=frictionPlate_count_Brk,
            meanRadius=meanRadius_Brk,
            mue=mue_Brk)
                        annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=270,
                origin={120,28})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Steering_Cross_Drive.Steering_Cross_Drive
                                          steering_Cross_Drive(
            P_constant=P_constant,
            min_multiplier_pump=min_multiplier_pump,
            vol_per_radian_pump=vol_per_radian_pump,
            Nm_per_pascal_pump=Nm_per_pascal_pump,
            lossTable_pump=lossTable_pump,
            J_pump=J_pump,
            leakage_pump=leakage_pump,
            vol_per_radian_motor=vol_per_radian_motor,
            Nm_per_pascal_motor=Nm_per_pascal_motor,
            lossTable_motor=lossTable_motor,
            J_motor=J_motor,
            leakage_motor=leakage_motor,
            N_sun=N_sun,
            N_ring=N_ring,
            N_planet=N_planet,
            useInertia_pump=true,
            useInertia_motor=true,
            useLeakage_motor=false)                                      annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,0})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={30,100})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor1 annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={30,54})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test1(
                                                                        J=
                moi_rotational)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={66,98})));
          Modelica.Mechanics.Rotational.Components.IdealGear trans_input_bevel(ratio=1,
              useSupport=true)
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

          Modelica.Blocks.Interfaces.RealInput steer_command annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-100,208})));
          Modelica.Blocks.Interfaces.IntegerInput gear_selected annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,208})));
          Modelica.Blocks.Interfaces.RealOutput input_speed_range_pack annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-80,-204})));
          Modelica.Blocks.Interfaces.RealOutput output_speed_range_pack annotation (
             Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-120,-204})));
          Modelica.Blocks.Interfaces.RealInput brake_apply_command annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,208})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(medium=medium)
            annotation (Placement(transformation(extent={{-210,190},{-190,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b flowPort_b(medium=medium)
            annotation (Placement(transformation(extent={{-150,190},{-130,210}})));
          C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Volume_Flow_Rate_With_Heat_Addition
                                                        volume_Flow_Rate_With_Heat_Addition(
            alpha0=HX_internal_HTC,
            surface_area=HX_internal_area,
            a=hx_dp_a,
            b=hx_dp_b,
            medium=medium,
            m_flow_nom=1,
            delta_T(start=0),
            m=0,
            T0=293.15)
            annotation (Placement(transformation(extent={{-160,130},{-140,150}})));
          C2M2L_OM.MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=HX_external_area)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-150,74})));
          C2M2L_OM.MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment
            simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{2,148},{22,168}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{10,190},{30,210}})));
          inner
            C2M2L_OM.MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume
                                                                                   env(
                                fixed_htc=1500,
            fluid_area=0.5,
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            initial_T=353.15)
            annotation (Placement(transformation(extent={{-190,110},{-170,130}})));
          Modelica.Mechanics.Rotational.Components.IdealGear idealGear_sign_flip(ratio=
                -1) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={100,142})));
        equation
          connect(inertia_test.flange_b, range_Pack_Internals.flange_a) annotation (
              Line(
              points={{-8,0},{16,0},{16,36},{50,36},{50,60}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(steering_Cross_Drive.pumpIn, inertia_test.flange_b) annotation (Line(
              points={{40,6.12323e-016},{18,6.12323e-016},{18,0},{-8,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor.flange, range_Pack_Internals.flange_b) annotation (Line(
              points={{40,100},{50,100},{50,80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor1.flange, range_Pack_Internals.flange_a) annotation (Line(
              points={{40,54},{50,54},{50,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_b, right_combine_planetary.ring) annotation (Line(
              points={{120,38},{120,118},{100,118}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_a, range_Pack_Internals.flange_b) annotation (
              Line(
              points={{56,98},{50,98},{50,80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_a, left_brake.flange_a) annotation (Line(
              points={{120,18},{120,-38}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(trans_input_bevel.flange_b, inertia_test.flange_a)
            annotation (Line(
              points={{-40,0},{-28,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(trans_input_bevel.flange_a, brg_01)           annotation (Line(
              points={{-60,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_a, internalSupport) annotation (Line(
              points={{120,18},{120,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(steering_Cross_Drive.support, internalSupport) annotation (Line(
              points={{60,0},{72,0},{72,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(range_Pack_Internals.support, internalSupport) annotation (Line(
              points={{60,70},{72,70},{72,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(trans_input_bevel.support, internalSupport)           annotation (
             Line(
              points={{-50,-10},{-50,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(range_Pack_Internals.gear_selected, gear_selected) annotation (
              Line(
              points={{40,69.4},{-40,69.4},{-40,208}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(left_brake1.brake_clutch_command, brake_apply_command)
            annotation (Line(
              points={{131.4,20},{140,20},{140,180},{60,180},{60,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(left_brake.brake_clutch_command, brake_apply_command) annotation (
             Line(
              points={{131.4,-40},{140,-40},{140,180},{60,180},{60,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(steering_Cross_Drive.steer_command, steer_command) annotation (
              Line(
              points={{39.2,-8},{30,-8},{30,18},{-100,18},{-100,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_b,flowPort_b)
                                                annotation (Line(
              points={{-140,140},{-140,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_a,flowPort_a)
                                                annotation (Line(
              points={{-160,140},{-200,140},{-200,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.heatPort,
            thermal_To_Environment_Thru_Area.solid) annotation (Line(
              points={{-150,130},{-150,84}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{9,165},{9,178.5},{20,178.5},{20,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(speedSensor.w, output_speed_range_pack) annotation (Line(
              points={{19,100},{-64,100},{-64,-160},{-120,-160},{-120,-204}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor1.w, input_speed_range_pack) annotation (Line(
              points={{19,54},{-34,54},{-34,-178},{-80,-178},{-80,-204}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(left_combine_planetary.sun, right_combine_planetary.sun) annotation (
              Line(
              points={{100,-64},{100,98}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_b, left_combine_planetary.sun) annotation (Line(
              points={{76,98},{82,98},{82,68},{100,68},{100,-64}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_combine_planetary.sun, steering_Cross_Drive.leftOut) annotation (
             Line(
              points={{100,-64},{50,-64},{50,-10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(steering_Cross_Drive.rightOut, right_combine_planetary.carrier)
            annotation (Line(
              points={{50,10},{50,24},{96,24},{96,98}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealGear_sign_flip.flange_b, right_combine_planetary.ring)
            annotation (Line(
              points={{100,132},{100,118}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealGear_sign_flip.flange_a, brg_02) annotation (Line(
              points={{100,152},{100,200},{140,200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(brg_03, left_combine_planetary.ring) annotation (Line(
              points={{140,-200},{100,-200},{100,-84}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -200},{140,200}}),
                              graphics), Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-200,-200},{140,200}}),
                                              graphics={
                Rectangle(
                  extent={{-128,8},{-206,-10}},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0})}),
            Documentation(info="<html>
<p><h4><font color=\"#008000\">Bearing connections: </font></h4></p>
<p><ul>
<li>brg_01: Input from PTM</li>
<li>brg_02: Output to right final drive / track </li>
<li>brg_03: Output to left final drive / track </li>
<li>brg_04: output to front PTO </li>
<li>brg_05: output to rear PTO </li>
</ul></p>
</html>"));
        end Cross_Drive_without_TC;

        model Cross_Drive_with_TC
          "cross drie transmission with braking, steering, range pack, and torque converter"
          import C2M2L_OM;
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Interfaces.Cross_Drive;
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
                annotation(__Dymola_choicesAllMatching=true, Dialog(tab="Fluid Model"));
          parameter SI.Area case_heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.Thickness case_heat_transfer_thickness=0.005
            "Effective case thickness for heat transfer"
            annotation (Dialog(tab="Thermal Model"));
          parameter SI.ThermalConductivity case_thermal_conductivity=50
            "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
          parameter Real hx_dp_a=1000 "HX quadratic loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter Real hx_dp_b=100 "HX linear loss term"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_internal_area=1
            "Heat transfer area internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.CoefficientOfHeatTransfer HX_internal_HTC=2000
            "heat transfer coefficient internal to the HX"
            annotation (Dialog(tab="Fluid Model"));
          parameter SI.Area HX_external_area=1.0
            "Area available for convective heat transferon the outside of the HX"
                                                                                  annotation (Dialog(tab="Fluid Model"));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Range_Pack.Simplified_Range_Pack.Range_Pack_Internals
                                          range_Pack_Internals(
            gear_nums=gear_nums_RP,
            ratios=ratios_RP,
            lossTables=lossTables_RP,
            locked_max_torque=locked_max_torque_RP,
            synchronizer_max_torque=synchronizer_max_torque_RP,
            num_gears=num_gears_RP,
            useSupport=true,
            use_environment_heat_port=true)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,70})));
        //General
         parameter SI.Inertia moi_rotational = 0.1 "Trans Inertia";

        //range pack
        public
          parameter Integer num_gears_RP=4
            "The number of gear ratios in the contained range pack (including reverse if applicable)"
            annotation (Dialog(tab="Range Pack"));
          parameter Integer gear_nums_RP[num_gears_RP]={1,2,3,4}
            "Identifiers for the contained gears.  E.g {-1,1,2,3,4} for a pack with 1 reverse and 4 forward gears"
            annotation (Dialog(tab="Range Pack"));
          parameter Real lossTables_RP[num_gears_RP,:,5]={[0,0.95,0.95,0,0],[0,0.95,0.95,0,0],
              [0,0.95,0.95,0,0],[0,0.95,0.95,0,0]}
            "Array of arrays of mesh efficiencies and bearing friction depending on speed for each contained gear"
            annotation (Dialog(tab="Range Pack"));
          parameter SI.Torque locked_max_torque_RP=10000
            "Max torque transmitted when gear sync clutches are locked"
            annotation (Dialog(tab="Range Pack"));
          parameter SI.Torque synchronizer_max_torque_RP=4000
            "Max torque transmitted while synchronizing each gear"
            annotation (Dialog(tab="Range Pack"));
          parameter Real ratios_RP[num_gears_RP]={3.2,2.2,1.5,0.9}
            "Transmission ratios (flange_a.phi/flange_b.phi) of contained gears"
            annotation (Dialog(tab="Range Pack"));
        //   parameter SI.Temperature initial_T=Medium.T_default
        //     "Initial temperature of the contained environment";

        //Torque Converter Inputs
            parameter Real powerCoeffTable_TC[:, 2]=
            [-10, 0.2; 0, 0.2; 0.00001, 0.2; 0.1, 0.2488; 0.2, 0.2712; 0.3, 0.2872; 0.4, 0.2968; 0.5, 0.3; 0.6, 0.2968; 0.7, 0.2872; 0.8, 0.2712; 0.9, 0.2488; 1, 0.2]
            "Table for power coefficientas a function of speed ratio"                                                                                                     annotation (Dialog(tab="Torque Converter"));
            parameter Real torqueConverTable_TC[:, 2]=
            [-10, 2;  0, 2; 0.00001, 2; 0.1, 1.9; 0.2, 1.8; 0.3, 1.7; 0.4, 1.6; 0.5, 1.5; 0.6, 1.4; 0.7, 1.3; 0.8, 1.0; 0.9, 0.90; 0.95, 0.85; 0.985, 0.8; 1, 0.8; 10, 0.0]
            "Torque Ratio as a function of speed ratio"                                                                                                     annotation (Dialog(tab="Torque Converter"));
            parameter SI.Length Diameter_TC = 0.2 "Torque Converter Diameter"
                                                   annotation (Dialog(tab="Torque Converter"));
            parameter SI.Density fluidDensity_TC = 850
            "Density of transmission fluid"                                            annotation (Dialog(tab="Torque Converter"));

              // TC Lockup clutch gubbins
              parameter SI.Torque locked_max_torque_TC= 550
            "Max torque transmitted when TC clutch is locked"    annotation (Dialog(group="Lock-up Clutch",tab="Torque Converter"));
              parameter SI.Torque synchronizer_max_torque_TC=400
            "Max torque transmitted while synchronizing impeller & turbine"     annotation (Dialog(group="Lock-up Clutch",tab="Torque Converter"));

        //Brakes
        parameter SI.Force maxApply_force_Brk=10000
            "Maximum clutch apply force"                                         annotation (Dialog(tab="Brakes"));
          parameter Integer frictionPlate_count_Brk(min=1)=3
            "Number of clutch friction plates" annotation (Dialog(tab="Brakes"));
          parameter SI.Length meanRadius_Brk=0.1 "Friction plate mean radius" annotation (Dialog(tab="Brakes"));
          parameter Real mue_Brk[:,2]=[0,0.14]
            "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0). "
                                                                                                                annotation (Dialog(tab="Brakes"));

        //front_PTO
          parameter Real ratio_frontPTO(start=1) = 1
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(tab="PTO",group="Front PTO"));
          parameter Real lossTable_frontPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(tab="PTO",group="Front PTO"));

        //rear_PTO
          parameter Real ratio_rearPTO(start=1) = 2
            "Transmission ratio (flange_a.phi/flange_b.phi)"
                                                            annotation (Dialog(tab="PTO",group="Rear PTO"));
          parameter Real lossTable_rearPTO[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed"
                                                                                 annotation (Dialog(tab="PTO",group="Rear PTO"));

        //Hydrostatic pump and motor steering unit
        // Pump_variableDisp parameters
          parameter SI.AbsolutePressure P_constant=10000000
                                                           annotation(Dialog(tab="Steering"));

        ////pump parameters
          parameter Real min_multiplier_pump=0.1
            "if |u| < |min_mult| then u_limited = sign(u) * min_mult else u_limit=u"
                                                                                    annotation(Dialog(tab="Steering",group="Pump"));
         parameter SI.Volume vol_per_radian_pump = 1e-6
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(tab="Steering",group="Pump"));
         parameter SI.Volume Nm_per_pascal_pump = 1e-6
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(tab="Steering",group="Pump"));
         parameter Real lossTable_pump[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(tab="Steering",group="Pump"));
         //parameter Boolean useInertia_pump=true
         //   "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(tab="Steering",group="Pump"));

          parameter SI.Inertia J_pump(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(tab="Steering",group="Pump"));
         //parameter Boolean useLeakage_pump=true
         //   "= true if leakage enabled, otherwise not used in model"
         //         annotation(Dialog(tab="Steering",group="Pump"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_pump=0.001 "Leakage loss factor" annotation(Dialog(tab="Steering",group="Pump"));

        ////motor parameters
         parameter SI.Volume vol_per_radian_motor = 1e-6
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(tab="Steering",group="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1e-6
            "Pressure rise for 1 Nm of torque input"                                         annotation(Dialog(tab="Steering",group="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(tab="Steering",group="Motor"));
         //parameter Boolean useInertia_motor=true
         //   "= true if inertia enabled, otherwise not used in model" annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true),Dialog(tab="Steering",group="Motor"));

          parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(tab="Steering",group="Motor"));
         //parameter Boolean useLeakage_motor=true
         //   "= true if leakage enabled, otherwise not used in model"
         //         annotation(Dialog(tab="Steering",group="Motor"), Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                  annotation(Dialog(tab="Steering",group="Motor"));
        //Motor output planetary
          parameter Integer N_sun = 50 "Number of teeth on Sun gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          parameter Integer N_ring = 100 "Number of teeth on Ring gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          parameter Integer N_planet = 25 "Number of teeth on Planet gear" annotation(Dialog(tab="Steering",group="Motor Ouput Planet"));
          Modelica.Mechanics.Rotational.Components.IdealPlanetary
            right_combine_planetary(ratio=1) "steering and range pack combiner"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={100,108})));
          Modelica.Mechanics.Rotational.Components.IdealPlanetary
            left_combine_planetary(ratio=1) "steering and range pack combiner"
            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={100,-74})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test(J=
                moi_rotational)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-18,0})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
            left_brake(maxApply_force=maxApply_force_Brk,
            frictionPlate_count=frictionPlate_count_Brk,
            meanRadius=meanRadius_Brk,
            mue=mue_Brk)
                       annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={120,-48})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
            left_brake1(
            maxApply_force=maxApply_force_Brk,
            frictionPlate_count=frictionPlate_count_Brk,
            meanRadius=meanRadius_Brk,
            mue=mue_Brk)
                        annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=270,
                origin={120,28})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Steering_Cross_Drive.Steering_Cross_Drive
                                          steering_Cross_Drive(
            P_constant=P_constant,
            min_multiplier_pump=min_multiplier_pump,
            vol_per_radian_pump=vol_per_radian_pump,
            Nm_per_pascal_pump=Nm_per_pascal_pump,
            lossTable_pump=lossTable_pump,
            J_pump=J_pump,
            leakage_pump=leakage_pump,
            vol_per_radian_motor=vol_per_radian_motor,
            Nm_per_pascal_motor=Nm_per_pascal_motor,
            lossTable_motor=lossTable_motor,
            J_motor=J_motor,
            leakage_motor=leakage_motor,
            N_sun=N_sun,
            N_ring=N_ring,
            N_planet=N_planet,
            useInertia_pump=true,
            useInertia_motor=true,
            useLeakage_motor=true)                                       annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,0})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={30,100})));
          Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor1 annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={30,54})));
        public
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test1(
                                                                        J=
                moi_rotational)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={66,98})));
          Modelica.Mechanics.Rotational.Components.IdealGear trans_input_bevel(ratio=1,
              useSupport=true)
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

          Modelica.Blocks.Interfaces.RealInput steer_command annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-100,208})));
          Modelica.Blocks.Interfaces.IntegerInput gear_selected annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,208})));
          Modelica.Blocks.Interfaces.RealInput brake_apply_command annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,208})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(medium=medium)
            annotation (Placement(transformation(extent={{-210,190},{-190,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b flowPort_b(medium=medium)
            annotation (Placement(transformation(extent={{-150,190},{-130,210}})));
          C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Volume_Flow_Rate_With_Heat_Addition
                                                        volume_Flow_Rate_With_Heat_Addition(
            alpha0=HX_internal_HTC,
            surface_area=HX_internal_area,
            a=hx_dp_a,
            b=hx_dp_b,
            medium=medium,
            m_flow_nom=1,
            delta_T(start=0))
            annotation (Placement(transformation(extent={{-160,130},{-140,150}})));
          C2M2L_OM.MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=HX_external_area)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-150,74})));
          C2M2L_OM.MSL_Extend.Thermal.Simple_Conduction_From_Internal_Environment
            simple_Conduction_From_Internal_Environment(
            case_thermal_conductivity=case_thermal_conductivity,
            case_heat_transfer_thickness=case_heat_transfer_thickness,
            case_heat_transfer_area=case_heat_transfer_area)
            annotation (Placement(transformation(extent={{2,148},{22,168}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
            annotation (Placement(transformation(extent={{10,190},{30,210}})));
          inner
            C2M2L_OM.MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume
                                                                                   env(
                                fixed_htc=1500,
            fluid_area=0.5,
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            initial_T=353.15)
            annotation (Placement(transformation(extent={{-190,110},{-170,130}})));

          Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_06
            annotation (Placement(transformation(extent={{130,-10},{150,10}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Drive_Line.Torque_Converters.Torque_Converter_Lockup_with_2PTO
            torque_Converter_Lockup_with_2PTO_thermal(
            useSupport=true,
            use_environment_heat_port=true,
            powerCoeffTable_TC=powerCoeffTable_TC,
            torqueConverTable_TC=torqueConverTable_TC,
            Diameter_TC=Diameter_TC,
            fluidDensity_TC=fluidDensity_TC,
            locked_max_torque_TC=locked_max_torque_TC,
            synchronizer_max_torque_TC=synchronizer_max_torque_TC,
            ratio_frontPTO=ratio_frontPTO,
            lossTable_frontPTO=lossTable_frontPTO,
            ratio_rearPTO=ratio_rearPTO,
            lossTable_rearPTO=lossTable_rearPTO)
            annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test2(J=0.0001)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-76,-26})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_test3(J=0.0001)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-170,-100})));
          Modelica.Blocks.Interfaces.RealInput lockup_torque_converter annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={100,210})));
          Modelica.Blocks.Interfaces.RealOutput input_speed_range_pack1
                                                                       annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-80,-204})));
          Modelica.Blocks.Interfaces.RealOutput output_speed_range_pack1
                                                                        annotation (
             Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-120,-204})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_05
            annotation (Placement(transformation(extent={{-210,90},{-190,110}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_04
            annotation (Placement(transformation(extent={{-210,-110},{-190,-90}})));
          Modelica.Mechanics.Rotational.Components.IdealGear idealGear_sign_flip(ratio=
                -1) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={116,158})));
        equation
          connect(inertia_test.flange_b, range_Pack_Internals.flange_a) annotation (
              Line(
              points={{-8,0},{16,0},{16,36},{50,36},{50,60}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(steering_Cross_Drive.pumpIn, inertia_test.flange_b) annotation (Line(
              points={{40,6.12323e-016},{18,6.12323e-016},{18,0},{-8,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor.flange, range_Pack_Internals.flange_b) annotation (Line(
              points={{40,100},{50,100},{50,80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speedSensor1.flange, range_Pack_Internals.flange_a) annotation (Line(
              points={{40,54},{50,54},{50,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_b, right_combine_planetary.ring) annotation (Line(
              points={{120,38},{120,118},{100,118}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_a, range_Pack_Internals.flange_b) annotation (
              Line(
              points={{56,98},{50,98},{50,80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_a, left_brake.flange_a) annotation (Line(
              points={{120,18},{120,-38}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(trans_input_bevel.flange_b, inertia_test.flange_a)
            annotation (Line(
              points={{-40,0},{-28,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake1.flange_a, internalSupport) annotation (Line(
              points={{120,18},{120,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(steering_Cross_Drive.support, internalSupport) annotation (Line(
              points={{60,0},{72,0},{72,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(range_Pack_Internals.support, internalSupport) annotation (Line(
              points={{60,70},{72,70},{72,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(trans_input_bevel.support, internalSupport)           annotation (
             Line(
              points={{-50,-10},{-50,-34},{0,-34},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(range_Pack_Internals.gear_selected, gear_selected) annotation (
              Line(
              points={{40,69.4},{-40,69.4},{-40,208}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(left_brake1.brake_clutch_command, brake_apply_command)
            annotation (Line(
              points={{131.4,20},{140,20},{140,180},{60,180},{60,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(left_brake.brake_clutch_command, brake_apply_command) annotation (
             Line(
              points={{131.4,-40},{140,-40},{140,180},{60,180},{60,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(steering_Cross_Drive.steer_command, steer_command) annotation (
              Line(
              points={{39.2,-8},{-2,-8},{-2,22},{-100,22},{-100,208}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_b,flowPort_b)
                                                annotation (Line(
              points={{-140,140},{-140,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.flowPort_a,flowPort_a)
                                                annotation (Line(
              points={{-160,140},{-200,140},{-200,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(volume_Flow_Rate_With_Heat_Addition.heatPort,
            thermal_To_Environment_Thru_Area.solid) annotation (Line(
              points={{-150,130},{-150,84}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(simple_Conduction_From_Internal_Environment.port_a,
            outer_surface_heat_port)
            annotation (Line(
              points={{9,165},{9,178.5},{20,178.5},{20,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.flange_rear_PTO,
            inertia_test2.flange_a) annotation (Line(
              points={{-100,7},{-96,7},{-96,-26},{-86,-26}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.flange_front_PTO,
            inertia_test3.flange_b) annotation (Line(
              points={{-120,7},{-140,7},{-140,-100},{-160,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.flange_a, brg_01)
            annotation (Line(
              points={{-120,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.flange_b, trans_input_bevel.flange_a)
            annotation (Line(
              points={{-100,0},{-60,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test2.flange_b, brg_06) annotation (Line(
              points={{-66,-26},{106,-26},{106,0},{140,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.support, internalSupport)
            annotation (Line(
              points={{-110,-10},{-110,-70},{0,-70},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(lockup_torque_converter, torque_Converter_Lockup_with_2PTO_thermal.lockup_torque_converter)
            annotation (Line(
              points={{100,210},{100,146},{-110,146},{-110,10.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor.w, output_speed_range_pack1) annotation (Line(
              points={{19,100},{-64,100},{-64,-160},{-120,-160},{-120,-204}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(speedSensor1.w, input_speed_range_pack1) annotation (Line(
              points={{19,54},{-34,54},{-34,-178},{-80,-178},{-80,-204}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(torque_Converter_Lockup_with_2PTO_thermal.flange_a, brg_05)
            annotation (Line(
              points={{-120,0},{-172,0},{-172,100},{-200,100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test3.flange_a, brg_04) annotation (Line(
              points={{-180,-100},{-200,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_combine_planetary.sun, right_combine_planetary.sun) annotation (
              Line(
              points={{100,-64},{100,98}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_test1.flange_b, left_combine_planetary.sun) annotation (Line(
              points={{76,98},{82,98},{82,60},{100,60},{100,-64}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(right_combine_planetary.carrier, steering_Cross_Drive.rightOut)
            annotation (Line(
              points={{96,98},{96,24},{50,24},{50,10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_combine_planetary.carrier, steering_Cross_Drive.leftOut)
            annotation (Line(
              points={{96,-64},{96,-48},{50,-48},{50,-10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_brake.flange_b, left_combine_planetary.ring) annotation (Line(
              points={{120,-58},{120,-100},{100,-100},{100,-84}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(right_combine_planetary.ring, idealGear_sign_flip.flange_b)
            annotation (Line(
              points={{100,118},{100,134},{116,134},{116,148}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(idealGear_sign_flip.flange_a, brg_02) annotation (Line(
              points={{116,168},{118,168},{118,200},{140,200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(left_combine_planetary.ring, brg_03) annotation (Line(
              points={{100,-84},{100,-200},{140,-200}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},
                    {140,200}}),
                              graphics), Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-200,-200},{140,200}}),
                                              graphics={
                Ellipse(
                  extent={{-186,-40},{-152,-72}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-208,10},{-186,-10}},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-186,54},{-182,-58}},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-186,72},{-152,40}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-178,68},{-156,44}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{-186,70},{-164,44}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-178,-44},{-156,-68}},
                  pattern=LinePattern.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{-186,-42},{-164,-68}},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-164,50},{-160,-46}},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-128,10},{-164,-10}},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0})}),
            Documentation(info="<html>
<p><h4><font color=\"#008000\">Bearing connections: </font></h4></p>
<p><ul>
<li>brg_01: Input from PTM</li>
<li>brg_02: Output to right final drive / track </li>
<li>brg_03: Output to left final drive / track </li>
<li>brg_04: output to front PTO </li>
<li>brg_05: output to rear PTO </li>
</ul></p>
</html>"));
        end Cross_Drive_with_TC;

        package Tests
          extends Modelica.Icons.Package;

          model Dummy_Engine_Lookup
            "A simple engine with constant torque and inertia.  Torque is reacted to the bearing frame"

            Modelica.Mechanics.Rotational.Components.Inertia engine_inertia(
              stateSelect=StateSelect.prefer,
              w(start=0, fixed=true),
              J=engine_inertia_J)
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            Modelica.Mechanics.Rotational.Sources.Torque         constantTorque(
                useSupport=false)
              annotation (Placement(transformation(extent={{10,-10},{30,10}})));
            parameter SI.Inertia engine_inertia_J=1
              "Moment of inertia for dummy engine";
            parameter SI.Torque engine_torque[:,2]=[0, 20; 100, 30; 250, 100; 500, 200; 750, 300; 1000, 450; 1250, 475; 1500, 500; 1750, 500; 2000, 500; 2250, 500; 2500, 450; 2750, 350; 3000, 200; 3250, 100; 3500, 0]
              "Engine torque table";
            Modelica.Blocks.Tables.CombiTable1Ds EnginePowerCurve(table=engine_torque)
              annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
            Modelica.Mechanics.Rotational.Sensors.SpeedSensor EngineSpeed annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={40,50})));
            Modelica.Blocks.Math.UnitConversions.To_rpm to_rpm
              annotation (Placement(transformation(extent={{20,80},{0,100}})));
            Modelica.Blocks.Sources.Constant min_eng_spd_trq_out(k=min_speed_rpm) annotation (
               Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={10,50})));
            parameter Real min_speed_rpm=0
              "Use the value of torque at this speed when the real speed is lower (e.g. to stop engine 'stalling')";
            Modelica.Blocks.Logical.Switch reduce_trq_above_max_speed
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
            Modelica.Blocks.Logical.Hysteresis       max_spd_lim_applied(uLow=
                  max_speed_rpm - 100, uHigh=max_speed_rpm)
              "y = true when engine torque is reduced because of overspeed"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Modelica.Blocks.Sources.Constant const(k=0)
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            parameter Real max_speed_rpm=20000
              "Beyond this speed the engine torque is always zero";
            Modelica.Blocks.Logical.Switch apply_minimum_speed
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-80,70})));
            Modelica.Blocks.Logical.Greater min_spd_lim_applied annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-30,70})));
            Modelica.Blocks.Math.Gain apply_multiplier(k=multiplier)
              "allows for scaling the engine torque without having to adjust an entire table"
              annotation (Placement(transformation(extent={{-48,-54},{-38,-44}})));
            parameter Real multiplier=1
              "Multiply table torque values by this amount";
            Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            connect(constantTorque.flange,engine_inertia. flange_a) annotation (Line(
                points={{30,0},{60,0}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(constantTorque.flange, EngineSpeed.flange) annotation (Line(
                points={{30,0},{40,0},{40,40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(EngineSpeed.w, to_rpm.u) annotation (Line(
                points={{40,61},{40,90},{22,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(reduce_trq_above_max_speed.y, constantTorque.tau) annotation (Line(
                points={{1,0},{8,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(to_rpm.y, max_spd_lim_applied.u)
                                                  annotation (Line(
                points={{-1,90},{-64,90},{-64,30},{-62,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(max_spd_lim_applied.y, reduce_trq_above_max_speed.u2)
                                                                       annotation (Line(
                points={{-39,30},{-32,30},{-32,0},{-22,0}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(const.y, reduce_trq_above_max_speed.u1) annotation (Line(
                points={{-59,-10},{-44,-10},{-44,8},{-22,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(apply_minimum_speed.y, EnginePowerCurve.u) annotation (Line(
                points={{-91,70},{-96,70},{-96,-50},{-82,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(min_spd_lim_applied.y, apply_minimum_speed.u2) annotation (Line(
                points={{-41,70},{-68,70}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(apply_minimum_speed.u1, min_eng_spd_trq_out.y) annotation (Line(
                points={{-68,62},{-50,62},{-50,50},{-1,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(apply_minimum_speed.u3, to_rpm.y) annotation (Line(
                points={{-68,78},{-64,78},{-64,90},{-1,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(min_eng_spd_trq_out.y, min_spd_lim_applied.u1) annotation (Line(
                points={{-1,50},{-10,50},{-10,70},{-18,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(min_spd_lim_applied.u2, to_rpm.y) annotation (Line(
                points={{-18,78},{-10,78},{-10,90},{-1,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(EnginePowerCurve.y[1], apply_multiplier.u) annotation (Line(
                points={{-59,-50},{-54,-50},{-54,-49},{-49,-49}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(apply_multiplier.y, reduce_trq_above_max_speed.u3) annotation (Line(
                points={{-37.5,-49},{-32.75,-49},{-32.75,-8},{-22,-8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(engine_inertia.flange_b, flange_a) annotation (Line(
                points={{80,0},{100,0}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={
                  Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    fillColor={255,255,255}),
                  Rectangle(
                    extent={{-70,20},{100,-20}},
                    lineColor={0,0,0},
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-58,10},{-38,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-34,10},{-14,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-10,10},{10,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{14,10},{34,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{38,10},{58,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{62,10},{82,-10}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}));
          end Dummy_Engine_Lookup;

          model Test_Driver_no_TC
            import C2M2L_OM;
            extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;
            parameter Real shift_table[:,2]=[0,0; 0.2,1; 4,2; 6,3; 8,4; 10,3; 12,2; 14,4; 16,0]
              "Shift table vs time";
            parameter Real steer_table[:,2]=[0,0; 1,0] "Steer table vs time";

            Modelica.Blocks.Sources.IntegerTable
                                        timeTable(table=shift_table)
              annotation (Placement(transformation(extent={{-70,64},{-50,84}})));
            Modelica.Blocks.Sources.TimeTable
                                         steering(table=steer_table)
              annotation (Placement(transformation(extent={{-70,32},{-50,52}})));
            Modelica.Blocks.Sources.Step brake(height=0.25,startTime=25)
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            Modelica.Blocks.Interfaces.RealOutput steer_command
                                                               annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={112,26})));
            Modelica.Blocks.Interfaces.IntegerOutput gear_selected
                                                                  annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={112,62})));
            Modelica.Blocks.Interfaces.RealOutput brake_apply_command
                                                                     annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={110,100})));
          equation
            connect(brake_apply_command, brake.y) annotation (Line(
                points={{110,100},{16,100},{16,90},{-79,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(steer_command, steering.y) annotation (Line(
                points={{112,26},{18,26},{18,42},{-49,42}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(gear_selected, timeTable.y) annotation (Line(
                points={{112,62},{32,62},{32,74},{-49,74}},
                color={255,127,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics));
          end Test_Driver_no_TC;

          model Test_Driver_with_TC
            import C2M2L_OM;
            extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;
            parameter Real shift_table[:,2]=[0,0; 0.2,1; 4,2; 6,3; 8,4; 10,3; 12,2; 14,4; 16,0]
              "Shift table vs time";
            parameter Real steer_table[:,2]=[0,0; 1,0] "Steer table vs time";
            Modelica.Blocks.Interfaces.RealOutput steer_command
                                                               annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={112,26})));
            Modelica.Blocks.Interfaces.IntegerOutput gear_selected
                                                                  annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={112,62})));
            Modelica.Blocks.Interfaces.RealOutput brake_apply_command
                                                                     annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={110,100})));
            Modelica.Blocks.Sources.Ramp TC_lockup(
              height=1,
              duration=2,
              startTime=8)
              annotation (Placement(transformation(extent={{-102,-10},{-82,10}})));
            Modelica.Blocks.Interfaces.RealOutput lockup_torque_converter
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{92,-20},{132,20}})));
            Modelica.Blocks.Sources.IntegerTable
                                        timeTable(table=shift_table)
              annotation (Placement(transformation(extent={{-70,52},{-50,72}})));
            Modelica.Blocks.Sources.TimeTable
                                         steering(table=steer_table)
              annotation (Placement(transformation(extent={{-70,20},{-50,40}})));
            Modelica.Blocks.Sources.Step brake(height=0.25,startTime=25)
              annotation (Placement(transformation(extent={{-100,68},{-80,88}})));
          equation
            connect(TC_lockup.y, lockup_torque_converter) annotation (Line(
                points={{-81,0},{112,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(brake_apply_command,brake. y) annotation (Line(
                points={{110,100},{16,100},{16,78},{-79,78}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(steer_command,steering. y) annotation (Line(
                points={{112,26},{18,26},{18,30},{-49,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(gear_selected,timeTable. y) annotation (Line(
                points={{112,62},{-49,62}},
                color={255,127,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics));
          end Test_Driver_with_TC;

          model Test_X_Drive_Only "Unit test for X-Drive"
            extends MSL_Extend.Icons.Simple_Test_Case;

            Cross_Drive_without_TC
              cross_Drive_without_TC(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
                        annotation (Placement(transformation(extent={{14,-40},{40,-10}})));
            C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Tests.Dummy_Engine_Lookup
              dummy_Engine_Lookup(multiplier=4)
              annotation (Placement(transformation(extent={{-78,-60},{-38,-20}})));
            C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Tests.Test_Driver_no_TC
              test_Driver_no_TC
              annotation (Placement(transformation(extent={{-20,50},{0,70}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(J=10)
              annotation (Placement(transformation(extent={{60,-20},{80,0}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load1(J=10)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={66,-40})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                               fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-36,22},{-16,42}})));
          equation

            connect(cross_Drive_without_TC.brg_01, dummy_Engine_Lookup.flange_a)
              annotation (Line(
                points={{14,-25},{-19.5,-25},{-19.5,-40},{-38,-40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.steer_command, cross_Drive_without_TC.steer_command)
              annotation (Line(
                points={{1.2,62.6},{1.2,26.3},{21.6471,26.3},{21.6471,-9.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.gear_selected, cross_Drive_without_TC.gear_selected)
              annotation (Line(
                points={{1.2,66.2},{26.2353,66.2},{26.2353,-9.4}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.brake_apply_command, cross_Drive_without_TC.brake_apply_command)
              annotation (Line(
                points={{1,70},{33.8824,70},{33.8824,-9.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load4.flange_a, cross_Drive_without_TC.brg_02) annotation (Line(
                points={{60,-10},{40,-10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load1.flange_a, cross_Drive_without_TC.brg_03) annotation (Line(
                points={{56,-40},{40,-40}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, cross_Drive_without_TC.flowPort_b)
              annotation (Line(
                points={{-20,22},{18,22},{18,-10},{18.5882,-10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, cross_Drive_without_TC.flowPort_a)
              annotation (Line(
                points={{-32,22},{-32,8},{14,8},{14,-10}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-100,-100},{140,120}},
                    preserveAspectRatio=false),
                                graphics),
              experiment(StopTime=70),
              __Dymola_experimentSetupOutput,
              Icon(coordinateSystem(extent={{-100,-100},{140,120}})));
          end Test_X_Drive_Only;

          model Test_Bench_Cross_Drive_without_TC
            extends MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Constant torque_input(k=500)
              annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
             Cross_Drive_without_TC                        cross_Drive_without_TC(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{6,-42},{38,-6}})));
            Test_Driver_no_TC                                              test_Driver_no_TC
                                                   annotation (Placement(transformation(
                    rotation=0, extent={{-20,60},{0,80}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia1(J=1)
              annotation (Placement(transformation(extent={{-40,-34},{-20,-14}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-66,-34},{-46,-14}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(d=15)
              annotation (Placement(transformation(extent={{54,-16},{74,4}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load1(d=15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={62,-42})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                               fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-12,22},{8,42}})));
          equation
            connect(torque.flange, inertia1.flange_a)
                                                     annotation (Line(
                points={{-46,-24},{-40,-24}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(torque.tau, torque_input.y) annotation (Line(
                points={{-68,-24},{-74,-24},{-74,-30},{-79,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(cross_Drive_without_TC.brg_01, inertia1.flange_b) annotation (
                Line(
                points={{6,-24},{-20,-24}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.gear_selected, cross_Drive_without_TC.gear_selected)
              annotation (Line(
                points={{1.2,76.2},{21.0588,76.2},{21.0588,-5.28}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.brake_apply_command, cross_Drive_without_TC.brake_apply_command)
              annotation (Line(
                points={{1,80},{30.4706,80},{30.4706,-5.28}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver_no_TC.steer_command, cross_Drive_without_TC.steer_command)
              annotation (Line(
                points={{1.2,72.6},{15.4118,72.6},{15.4118,-5.28}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load4.flange_a, cross_Drive_without_TC.brg_02) annotation (Line(
                points={{54,-6},{38,-6}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load1.flange_a, cross_Drive_without_TC.brg_03) annotation (Line(
                points={{52,-42},{46,-42},{46,-42},{38,-42}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, cross_Drive_without_TC.flowPort_b)
              annotation (Line(
                points={{4,22},{12,22},{12,-6},{11.6471,-6}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, cross_Drive_without_TC.flowPort_a)
              annotation (Line(
                points={{-8,22},{-8,2},{6,2},{6,-6}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=30, Interval=0.01),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Cross_Drive_without_TC_Basic_Test.mos"
                  "Cross_Drive_without_TC_Basic_Test"));
          end Test_Bench_Cross_Drive_without_TC;

          model Test_Bench_Cross_Drive_with_TC
            extends MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Blocks.Sources.Constant torque_input(k=500)
              annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
            Cross_Drive_with_TC
              cross_Drive_with_TC
              annotation (Placement(transformation(extent={{2,-62},{42,-2}})));
            Test_Driver_with_TC test_Driver_with_TC annotation (Placement(transformation(
                    rotation=0, extent={{-16,50},{4,70}})));
            Modelica.Mechanics.Rotational.Components.Inertia inertia1(J=1)
              annotation (Placement(transformation(extent={{-36,-40},{-16,-20}})));
            Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
              annotation (Placement(transformation(extent={{-62,-40},{-42,-20}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load4(d=15)
              annotation (Placement(transformation(extent={{62,-12},{82,8}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load(d=3)
              annotation (Placement(transformation(extent={{66,-42},{86,-22}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load1(d=15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={82,-62})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load2(d=2)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-24,-54})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                 load3(d=10)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-34,-6})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                               fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-14,26},{6,46}})));
          equation
            connect(torque.tau, torque_input.y) annotation (Line(
                points={{-64,-30},{-79,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.brg_01, inertia1.flange_b) annotation (
                Line(
                points={{2,-32},{-8,-32},{-8,-30},{-16,-30}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(inertia1.flange_a, torque.flange) annotation (Line(
                points={{-36,-30},{-42,-30}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver_with_TC.lockup_torque_converter,
              cross_Drive_with_TC.lockup_torque_converter) annotation (Line(
                points={{5.2,60},{37.2941,60},{37.2941,-0.5}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver_with_TC.brake_apply_command,
              cross_Drive_with_TC.brake_apply_command) annotation (Line(
                points={{5,70},{32.5882,70},{32.5882,-0.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.steer_command, test_Driver_with_TC.steer_command)
              annotation (Line(
                points={{13.7647,-0.8},{13.7647,12},{26,12},{26,62.6},{5.2,62.6}},
                color={0,0,127},
                smooth=Smooth.None));

            connect(test_Driver_with_TC.gear_selected, cross_Drive_with_TC.gear_selected)
              annotation (Line(
                points={{5.2,66.2},{20.8235,66.2},{20.8235,-0.8}},
                color={255,127,0},
                smooth=Smooth.None));
            connect(load4.flange_a, cross_Drive_with_TC.brg_02) annotation (Line(
                points={{62,-2},{42,-2}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.brg_06, load.flange_a) annotation (Line(
                points={{42,-32},{66,-32}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(load1.flange_a, cross_Drive_with_TC.brg_03) annotation (Line(
                points={{72,-62},{42,-62}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.brg_04, load2.flange_a) annotation (Line(
                points={{2,-47},{-6,-47},{-6,-54},{-14,-54}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.brg_05, load3.flange_a) annotation (Line(
                points={{2,-17},{-12,-17},{-12,-6},{-24,-6}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, cross_Drive_with_TC.flowPort_a)
              annotation (Line(
                points={{-10,26},{-10,-2},{2,-2}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(cross_Drive_with_TC.flowPort_b, fluid_Source_Sink.return_port)
              annotation (Line(
                points={{9.05882,-2},{10,-2},{10,26},{2,26}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics),
              experiment(StopTime=100),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Cross_Drive_with_TC_Basic_Test.mos"
                  "Cross_Drive_with_TC_Basic_Test", file=
                    "Scripts/Cross_Drive_with_TC_Basic_Test.mos"
                  "Cross_Drive_with_TC_Basic_Test"));
          end Test_Bench_Cross_Drive_with_TC;
        end Tests;
      end Cross_Drive_Transmission;
    end Drive_Line;

    package Prime_Movers
      "Devices that convert chemical energy to mechanical energy (e.g. engines)"
    extends Modelica.Icons.Package;

      package Reciprocating
        "Engines that use a linear piston motion to extract mechanical power from heated gases"
        extends Modelica.Icons.Package;
        package Compression_Ignition
          "Internal combustion engines that use a compression process to ignite the fuel-air mixture"
          extends Modelica.Icons.Package;
          package Engine_Basic
            "Uses the Table_Based_Engine submodels to implement a basic engine"
            extends Modelica.Icons.Package;

            package Interfaces
              extends Modelica.Icons.Package;
              partial model Example_Engine_Basic
                parameter Boolean useSupport=false
                  "= true, if support flange enabled, otherwise implicitly grounded"
                  annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

                Modelica.Mechanics.Rotational.Interfaces.Support
                        support if useSupport "Support/housing of component"
                  annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
              protected
                Modelica.Mechanics.Rotational.Interfaces.Support
                        internalSupport
                  "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
                  annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
                Modelica.Mechanics.Rotational.Components.Fixed
                                 fixed if not useSupport
                  "Fixed support/housing, if not useSupport"
                  annotation (Placement(transformation(extent={{10,-97},{30,-77}})));

              public
                Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
                  annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b brg_02
                  annotation (Placement(transformation(extent={{190,-10},{210,10}})));
              equation
                connect(fixed.flange, internalSupport) annotation (Line(
                    points={{20,-87},{20,-80},{0,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(internalSupport, support) annotation (Line(
                    points={{0,-80},{0,-100}},
                    color={0,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                          -100},{200,240}}),        graphics), Icon(coordinateSystem(
                        preserveAspectRatio=false, extent={{-200,-100},{200,240}}),
                      graphics={
                      Rectangle(
                        extent={{-54,50},{-14,30}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-36,36},{-32,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-76,56},{-72,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,74},{-54,54}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-174,74},{-134,54}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-156,56},{-152,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,16},{-134,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,16},{-170,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{66,6},{96,-2}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-156,64},{-152,60}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-138,16},{-134,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-204,6},{-174,-2}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-98,16},{-94,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-134,-4},{-94,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,16},{-54,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-58,16},{-54,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-54,-4},{-14,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-116,36},{-112,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-134,50},{-94,30}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Ellipse(
                        extent={{-116,40},{-112,36}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-76,64},{-72,60}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-36,40},{-32,36}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-16,16},{-12,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-264,192},{-46,152}},
                        lineColor={128,128,128},
                        textString="air path"),
                      Rectangle(
                        extent={{42,38},{46,-8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{2,58},{6,12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-16,76},{24,56}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-16,18},{24,12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{20,18},{24,-8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,-2},{64,-8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{2,66},{6,62}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{42,42},{46,38}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,52},{64,32}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{62,18},{66,-8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{42,42},{46,38}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,116},{-134,74}},
                        lineColor={0,0,0},
                        pattern=LinePattern.Dot),
                      Line(
                        points={{-200,236},{-200,130},{-168,116}},
                        color={0,128,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-142,116},{-118,134},{-118,238}},
                        color={255,0,0},
                        smooth=Smooth.None),
                      Line(
                        points={{-128,210},{-118,228}},
                        color={255,0,0},
                        smooth=Smooth.None),
                      Line(
                        points={{-5,-9},{11,-1}},
                        color={0,128,255},
                        smooth=Smooth.None,
                        origin={-177,121},
                        rotation=90),
                      Rectangle(
                        extent={{24,114},{64,52}},
                        lineColor={255,255,255},
                        pattern=LinePattern.Dot,
                        fillPattern=FillPattern.Sphere,
                        fillColor={255,100,0}),
                      Rectangle(
                        extent={{70,112},{82,64}},
                        lineColor={0,128,255},
                        fillColor={0,128,255},
                        fillPattern=FillPattern.Solid,
                        radius=10),
                      Line(
                        points={{202,-100},{76,-100},{76,64}},
                        color={0,128,255},
                        smooth=Smooth.None),
                      Line(
                        points={{202,140},{76,140},{76,102}},
                        color={200,128,255},
                        smooth=Smooth.None),
                      Rectangle(
                        extent={{24,114},{64,52}},
                        lineColor={0,0,0},
                        pattern=LinePattern.Dot),
                      Line(
                        points={{-5,-9},{11,-1}},
                        color={0,128,255},
                        smooth=Smooth.None,
                        origin={75,53},
                        rotation=90),
                      Line(
                        points={{-5,9},{11,1}},
                        color={200,128,255},
                        smooth=Smooth.None,
                        origin={181,139},
                        rotation=360),
                      Ellipse(
                        extent={{92,-54},{152,-114}},
                        lineColor={255,255,255},
                        fillColor={0,128,255},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{112,-74},{132,-94}},
                        lineColor={255,255,255},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                      Line(
                        points={{136,-84},{196,-84}},
                        color={255,255,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-30,0},{30,0}},
                        color={255,255,255},
                        smooth=Smooth.None,
                        origin={122,-84},
                        rotation=90),
                      Line(
                        points={{100,-62},{144,-106}},
                        color={255,255,255},
                        smooth=Smooth.None),
                      Line(
                        points={{100,-106},{144,-62}},
                        color={255,255,255},
                        smooth=Smooth.None)}));
              end Example_Engine_Basic;
            end Interfaces;

            model Example_Engine_Basic
              "Example of an engine implemented using tables"
              extends
                C2M2L_OM.C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Interfaces.Example_Engine_Basic;
              import NonSI = Modelica.SIunits.Conversions.NonSIunits;

              parameter SI.Area case_heat_transfer_area=1.0
                "Area available for heat to transfer through case"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.Thickness case_heat_transfer_thickness=0.005
                "Effective case thickness for heat transfer"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.ThermalConductivity case_thermal_conductivity=50
                "Conductivity of case" annotation (Dialog(tab="Thermal Model"));

              parameter SI.Torque friction_map[:,2]=[0,1; 1,120; 10,120; 187.5001584,220;
                  375.0003167,325; 562.5004751,425; 700.0005913,500; 750.0006335,527;
                  800.0006757,555; 850.000718,580; 900.0007602,610; 950.0008024,636;
                  1000.000845,665; 1050.000887,690; 1100.000929,720; 1150.000971,745;
                  1200.001014,770; 1250.001056,800; 1300.001098,825; 1350.00114,855;
                  1400.001183,880; 1450.001225,910; 1500.001267,935; 1550.001309,965;
                  1600.001351,990; 1650.001394,1020; 1700.001436,1045; 1750.001478,1070;
                  1800.00152,1100; 1850.001563,1125; 1900.001605,1153; 1950.001647,1180;
                  2000.001689,1210; 2050.001732,1235; 2100.001774,1260; 2150.001816,1290;
                  2250,1290; 2300,1290]
                "Table of speed (rpm) vs engine friction torque";
              parameter SI.Torque torque_map[:,2]=[562.5004751,420; 700.0005913,1000;
                  750.0006335,1225; 800.0006757,1360; 850.000718,1480; 900.0007602,1585;
                  950.0008024,1685; 1000.000845,1775; 1050.000887,1860; 1100.000929,1945;
                  1150.000971,2025; 1200.001014,2065; 1250.001056,2080; 1300.001098,2080;
                  1350.00114,2060; 1400.001183,2035; 1450.001225,2010; 1500.001267,1975;
                  1550.001309,1925; 1600.001351,1875; 1650.001394,1825; 1700.001436,1775;
                  1750.001478,1725; 1800.00152,1675; 1850.001563,1625; 1900.001605,1585;
                  1950.001647,1535; 2000.001689,1485; 2050.001732,1440; 2100.001774,1390;
                  2150.001816,1330; 2250,0; 2255,0]
                " Table of speed(rpm) vs engine torque at WOT";
              parameter SI.MassFlowRate fuel_map[:,:]=[0,0,10,500.0004223,550.0004646,
                  600.0005068,650.000549,700.0005913,750.0006335,800.0006757,850.000718,
                  900.0007602,950.0008024,1000.000845,1050.000887,1100.000929,1150.000971,
                  1200.001014,1250.001056,1300.001098,1350.00114,1400.001183,1450.001225,
                  1500.001267,1550.001309,1600.001351,1650.001394,1700.001436,1750.001478,
                  1800.00152,1850.001563,1900.001605,1950.001647,2000.001689,2050.001732,
                  2100.001774,2150.001816,2200.001858,2250.0019; 0,0,0,0.000115077,
                  0.000134841,0.000157082,0.000179875,0.000207374,0.000234876,0.000261386,
                  0.000291112,0.00032447,0.000358984,0.000388806,0.000425181,0.000469451,
                  0.000503569,0.000546567,0.0006147,0.000690695,0.000757855,0.000830525,
                  0.000923075,0.001003919,0.001082698,0.001182413,0.001283234,0.001374041,
                  0.001458324,0.001582554,0.001698684,0.001792534,0.001896859,0.002015258,
                  0.002136724,0.002289975,0.002394179,0.002556089,0.002698939; 70.05060006,
                  0,0,0.000357347,0.000396983,0.000438847,0.000478967,0.000520609,
                  0.000566196,0.000605333,0.000651545,0.000704011,0.000754256,0.000801822,
                  0.000851797,0.000906041,0.00094958,0.001009562,0.001087556,0.001184368,
                  0.001253784,0.001365088,0.001437915,0.00155706,0.001661825,0.001756577,
                  0.00185663,0.00199224,0.002101612,0.002218382,0.002333051,0.002469539,
                  0.002592001,0.002730314,0.002859046,0.003012337,0.003133989,0.003293779,
                  0.003461377; 140.1012001,0,0,0.000599708,0.000648694,0.000708328,
                  0.000766908,0.000838683,0.000887612,0.000951407,0.001025648,0.001067673,
                  0.001150541,0.001201261,0.001278282,0.001350712,0.001411658,0.001475311,
                  0.001579904,0.001680621,0.001773634,0.00186571,0.001972046,0.002103904,
                  0.002226054,0.002312078,0.002449318,0.002587895,0.00268291,0.002833754,
                  0.002957563,0.003137412,0.00325725,0.003436602,0.0035697,0.00375666,
                  0.003909565,0.004083891,0.004273732; 210.1518002,0,0,0.000828053,
                  0.000905628,0.000990726,0.001058494,0.001144932,0.001214673,0.001295964,
                  0.001377572,0.001468351,0.001530065,0.001614283,0.001681968,0.001772218,
                  0.001871811,0.001952415,0.002032151,0.00214057,0.002270388,0.002369926,
                  0.002511775,0.002612639,0.002748628,0.002923005,0.003051573,0.003149479,
                  0.003329422,0.003473512,0.003627706,0.003772651,0.00394143,0.004157803,
                  0.004346105,0.004472209,0.0046636,0.004865091,0.005114112; 280.2024002,0,
                  0,0.001075936,0.001172941,0.001274854,0.001370625,0.001455299,0.001563224,
                  0.001660534,0.001745645,0.001832013,0.001913631,0.002028647,0.002126145,
                  0.002195082,0.002322944,0.002393616,0.002525453,0.002671998,0.002754556,
                  0.002905384,0.003072071,0.003182469,0.003329846,0.003495536,0.003630398,
                  0.003807147,0.003921153,0.004084166,0.004275935,0.004434841,0.00465945,
                  0.004813804,0.005017551,0.005215954,0.005449868,0.005690319,0.005955481;
                  350.2530003,0,0,0.001322565,0.001421465,0.001557601,0.00165054,
                  0.001774169,0.00188381,0.002007638,0.002112904,0.002213298,0.002294493,
                  0.002434271,0.002523673,0.002623304,0.002741966,0.002871303,0.002972217,
                  0.003120798,0.003255239,0.003426645,0.003548528,0.003743814,0.003853752,
                  0.004037267,0.004204037,0.004442107,0.004580722,0.004736006,0.00492388,
                  0.005188689,0.0053141,0.005609333,0.005778653,0.006059417,0.006295564,
                  0.006489461,0.006661956; 420.3036003,0,0,0.001554639,0.001699166,
                  0.001811233,0.001955902,0.002099137,0.002223466,0.002321325,0.002469554,
                  0.002598381,0.002733371,0.002842161,0.002928576,0.003094608,0.003199881,
                  0.003316755,0.003482078,0.00360855,0.003804304,0.003923034,0.004077374,
                  0.004278201,0.004421149,0.004590714,0.004858417,0.004996542,0.005158069,
                  0.005357129,0.005601556,0.005858407,0.00599737,0.006304847,0.0065581,
                  0.006816798,0.006995613,0.007301837,0.007497616; 490.3542004,0,0,
                  0.001807824,0.001956499,0.002097762,0.002263333,0.002402906,0.002517197,
                  0.002693621,0.002811624,0.002969092,0.003076745,0.003218626,0.003399024,
                  0.003545868,0.003659694,0.003826696,0.003951532,0.004119462,0.00427216,
                  0.004484229,0.004653266,0.004846958,0.005071501,0.005196311,0.00543916,
                  0.005668657,0.00583742,0.006097476,0.006294829,0.006470421,0.006733115,
                  0.006955381,0.007232631,0.007482187,0.007866234,0.008037662,0.008337939;
                  560.4048004,0,0,0.002036092,0.002185866,0.002364543,0.002540243,
                  0.00271881,0.002886187,0.003052666,0.0031862,0.003362409,0.003457437,
                  0.003634524,0.00380104,0.003921823,0.004135659,0.004275741,0.004433496,
                  0.004649183,0.004805937,0.005019275,0.005235527,0.005354848,0.005572661,
                  0.005844605,0.006073066,0.006220582,0.006458678,0.006740624,0.006977103,
                  0.00721282,0.007497557,0.007742057,0.008040882,0.008362483,0.008608584,
                  0.008867068,0.009170346; 630.4554005,0,0,0.002257567,0.002467794,
                  0.002675342,0.00284593,0.002995089,0.003165995,0.003346948,0.003566379,
                  0.003680615,0.003885091,0.00408557,0.004212524,0.004397487,0.004525951,
                  0.004755746,0.00487956,0.005113773,0.005353434,0.005508666,0.005781315,
                  0.00597662,0.006146354,0.006348415,0.006624572,0.006883208,0.007064022,
                  0.007378966,0.007621634,0.007916153,0.008093021,0.008500802,0.00880721,
                  0.009061799,0.009338996,0.009702039,0.010115007; 700.5060006,0,0,
                  0.002484499,0.002698238,0.002925589,0.003104628,0.003304758,0.003550228,
                  0.003678892,0.003886873,0.004102561,0.004264028,0.004433628,0.00464125,
                  0.004826817,0.005020603,0.005233626,0.005404906,0.005634196,0.00576674,
                  0.005996037,0.006205576,0.006536924,0.006784112,0.007039717,0.007208007,
                  0.007494016,0.007758994,0.008054669,0.008301443,0.008603607,0.008843489,
                  0.00918076,0.009455755,0.009868793,0.010143845,0.010617307,0.010818546;
                  770.5566006,0,0,0.002732385,0.002974377,0.003225061,0.003416013,
                  0.003603968,0.0038798,0.004042562,0.004265259,0.00448914,0.00466634,
                  0.004877442,0.0050133,0.00520751,0.00541228,0.00566104,0.005867669,
                  0.006148112,0.006361315,0.006529102,0.006866272,0.007037468,0.007355363,
                  0.007573933,0.007789419,0.008177144,0.008415082,0.008628315,0.008948014,
                  0.009288249,0.00956245,0.010012595,0.010269215,0.010657043,0.011082045,
                  0.01139578,0.011688953; 840.6072007,0,0,0.00299129,0.003260322,
                  0.003471621,0.003712241,0.003981027,0.004162821,0.004406188,0.004603203,
                  0.004848076,0.005038012,0.005217561,0.005515822,0.005638551,0.005882173,
                  0.006138352,0.0063399,0.00656249,0.006818514,0.007139423,0.007277906,
                  0.007552308,0.00789139,0.00815197,0.008443037,0.008802596,0.0089559,
                  0.009277344,0.00958275,0.009928593,0.010407144,0.010767236,0.011064698,
                  0.01131228,0.011908425,0.012226302,0.012517; 910.6578007,0,0,0.003216134,
                  0.003483667,0.003727712,0.004030699,0.004229468,0.004461442,0.004776539,
                  0.005026396,0.005233455,0.005421065,0.005727613,0.005867425,0.006069297,
                  0.006320983,0.006520323,0.006802302,0.00703797,0.007297502,0.007678125,
                  0.007925697,0.008129177,0.008529737,0.008778909,0.00912278,0.009316539,
                  0.009753951,0.009913522,0.010246687,0.010697352,0.011008774,0.011440212,
                  0.011722308,0.012302719,0.012506738,0.012942023,0.013455971; 980.7084008,
                  0,0,0.00346327,0.003740348,0.004012176,0.004323632,0.004555522,
                  0.004839654,0.005090728,0.005288571,0.005621454,0.00583595,0.006080784,
                  0.006367581,0.006510202,0.006834616,0.007071574,0.007269451,0.007653234,
                  0.007868246,0.008137207,0.008502116,0.008804794,0.008965911,0.009314721,
                  0.009674163,0.010077612,0.010362149,0.010686452,0.010993431,0.011303646,
                  0.011694833,0.012169998,0.012631742,0.012933236,0.013334194,0.013962171,
                  0.014385005; 1050.759001,0,0,0.003677872,0.003967137,0.004313352,
                  0.004613478,0.00487842,0.00516083,0.005393888,0.005656384,0.006004634,
                  0.006183179,0.006453491,0.006739075,0.007018065,0.00724722,0.007564644,
                  0.007821356,0.008163492,0.008397831,0.008601057,0.009004931,0.009303597,
                  0.009518848,0.010008583,0.010316464,0.010538598,0.011037697,0.011420607,
                  0.011643522,0.012020386,0.012588258,0.013046583,0.01327526,0.013873753,
                  0.014384339,0.014667764,0.015256557; 1120.809601,0,0,0.003931094,
                  0.004261234,0.00454188,0.004890058,0.005177477,0.005484366,0.005786588,
                  0.006043486,0.006344013,0.006550229,0.006837473,0.007164386,0.007450865,
                  0.007666174,0.007994788,0.008268723,0.008554573,0.008916318,0.009216168,
                  0.009467362,0.009919672,0.010231056,0.010536456,0.010956879,0.011342154,
                  0.011587639,0.01194467,0.012401861,0.012784508,0.013336535,0.013670403,
                  0.014160269,0.014677751,0.015108747,0.015685437,0.016035555; 1190.860201,
                  0,0,0.004168882,0.004481686,0.004843021,0.005199923,0.005430119,
                  0.005753059,0.00609522,0.006411217,0.006712729,0.006979124,0.007223317,
                  0.007513525,0.007807537,0.008118786,0.00841761,0.008741523,0.009118388,
                  0.009453152,0.009706962,0.010066364,0.010510908,0.0108627,0.011087475,
                  0.011408834,0.011843639,0.012258113,0.012582015,0.013125443,0.013553887,
                  0.013970755,0.014454671,0.014797075,0.015347466,0.015807182,0.016451679,
                  0.017075723; 1260.910801,0,0,0.004397181,0.004757047,0.005103052,
                  0.005491066,0.005831324,0.006158052,0.006383534,0.006760492,0.0070166,
                  0.007411542,0.00770397,0.00802494,0.008359863,0.008666293,0.008957514,
                  0.009165463,0.009594792,0.009855532,0.010207109,0.010626353,0.010935797,
                  0.011337457,0.011712058,0.012085334,0.012594147,0.012999442,0.013397101,
                  0.013751069,0.014172464,0.014810247,0.015235835,0.015700934,0.016293985,
                  0.016644077,0.017285695,0.017768817; 1330.961401,0,0,0.004651163,
                  0.005026823,0.005402895,0.005766842,0.006061432,0.006487762,0.006843933,
                  0.007121371,0.007487373,0.007826556,0.008121261,0.008456308,0.008785913,
                  0.009064373,0.009295403,0.009715569,0.009988033,0.010339149,0.010802942,
                  0.01125246,0.011575269,0.012000549,0.012269241,0.01267643,0.013191945,
                  0.013525161,0.014115653,0.014486879,0.015029543,0.015500716,0.015916054,
                  0.016528683,0.017148035,0.017749178,0.018321747,0.018778942; 1401.012001,
                  0,0,0.004868125,0.005268141,0.005672144,0.005970351,0.006417673,
                  0.006731039,0.007147921,0.007520983,0.007815652,0.008226698,0.008541171,
                  0.008921184,0.009227145,0.009536486,0.009822676,0.010242214,0.010575352,
                  0.011010919,0.011302544,0.011657088,0.012215878,0.012565798,0.012986346,
                  0.013348034,0.013769634,0.014290683,0.014740778,0.01530434,0.015688458,
                  0.01632077,0.016784045,0.017251392,0.018000138,0.018483624,0.018983713,
                  0.019807532; 1471.062601,0,0,0.005084936,0.005458776,0.00593416,
                  0.006288746,0.006705037,0.007120778,0.007409511,0.007822573,0.008223948,
                  0.008592197,0.008875517,0.009276453,0.009626549,0.010026559,0.010408733,
                  0.010669618,0.011086296,0.011514068,0.011913256,0.012178626,0.012588932,
                  0.013140048,0.013414875,0.014120182,0.014448596,0.014856152,0.015279907,
                  0.015778582,0.016450611,0.016915405,0.017692328,0.01805522,0.018849983,
                  0.019250228,0.019863646,0.020545776; 1541.113201,0,0,0.005322789,
                  0.005760758,0.006144848,0.006579486,0.007019394,0.007385693,0.00788008,
                  0.008154316,0.008590492,0.008907259,0.009299089,0.009645807,0.009964867,
                  0.01039708,0.010727767,0.01110816,0.011517292,0.012030419,0.012294601,
                  0.012942519,0.013381089,0.01381138,0.014049788,0.014509783,0.015113865,
                  0.015674113,0.016055315,0.016715072,0.017077274,0.017767526,0.018364758,
                  0.019097406,0.019658994,0.020167293,0.020711705,0.021391838; 1611.163801,
                  0,0,0.005585518,0.006046334,0.006470078,0.006881721,0.007337968,
                  0.007706548,0.008128958,0.008600037,0.008956296,0.009412755,0.00963958,
                  0.010207281,0.010398253,0.010972285,0.011184975,0.011718407,0.012009637,
                  0.012512584,0.012829528,0.0134051,0.013778829,0.014205722,0.014634989,
                  0.015223219,0.015681341,0.016192232,0.016789262,0.017301545,0.01802162,
                  0.018672868,0.019055634,0.019606547,0.020318571,0.020995307,0.021948286,
                  0.022369534; 1681.214401,0,0,0.00580822,0.006239558,0.006725818,
                  0.007139663,0.007598026,0.00799661,0.008437593,0.008858054,0.009240434,
                  0.009632173,0.010052063,0.010562072,0.011024636,0.011266265,0.01175001,
                  0.012083814,0.012547809,0.013101742,0.013421004,0.014077723,0.014457881,
                  0.014888169,0.015515448,0.015774752,0.016279644,0.016911205,0.017575726,
                  0.018203882,0.018572337,0.019327737,0.020080611,0.020663778,0.0214107,
                  0.022161204,0.022609906,0.023371961; 1751.265001,0,0,0.006024714,
                  0.006524754,0.006973102,0.007467878,0.007965018,0.008346405,0.00876786,
                  0.0093003,0.009735957,0.010048707,0.010506915,0.011003701,0.0112886,
                  0.011873966,0.012182415,0.012726615,0.013171612,0.013452978,0.014120787,
                  0.014422004,0.015045127,0.015438329,0.015986429,0.01667792,0.016990224,
                  0.017617956,0.018109371,0.018640698,0.019358914,0.019885114,0.020795869,
                  0.02145395,0.022212409,0.023022136,0.023531056,0.024393712; 1821.315601,0,
                  0,0.006272467,0.006799419,0.007236376,0.007695629,0.008155356,0.008670651,
                  0.009106478,0.009672616,0.010037909,0.010507354,0.010960744,0.011448319,
                  0.011745923,0.012329444,0.012592855,0.013187059,0.013701727,0.014060923,
                  0.014664001,0.015039247,0.015403357,0.016007313,0.016716368,0.01707071,
                  0.017727,0.018115521,0.01888072,0.019690098,0.020004921,0.020978982,
                  0.021659837,0.022280838,0.022975004,0.023647303,0.024311889,0.02559746;
                  1891.366202,0,0,0.006451807,0.007065943,0.007524016,0.008031644,
                  0.008482568,0.009054633,0.009543535,0.009909258,0.010355249,0.010971986,
                  0.011240071,0.011812855,0.012327586,0.01261866,0.013166196,0.013694648,
                  0.014173035,0.014572982,0.015143891,0.015588356,0.016204265,0.016764909,
                  0.017131201,0.017687068,0.018377646,0.019015188,0.019588018,0.020158352,
                  0.020765252,0.021555828,0.022338739,0.022873158,0.023919424,0.024481686,
                  0.02534381,0.02629189; 1961.416802,0,0,0.006644101,0.007278485,
                  0.007740381,0.00824903,0.008828371,0.009303714,0.009845574,0.010417954,
                  0.010786239,0.011292367,0.011774379,0.012270877,0.012786042,0.013133381,
                  0.01365294,0.014200706,0.014710744,0.015224217,0.015763964,0.016080231,
                  0.01658222,0.017370076,0.017916173,0.018290227,0.019046945,0.019666603,
                  0.020390539,0.020815857,0.021869176,0.022230402,0.022930344,0.023677488,
                  0.024656159,0.025679501,0.02638297,0.027530874; 2031.467402,0,0,
                  0.006991992,0.007541484,0.008060435,0.00863469,0.00915203,0.009640107,
                  0.01011446,0.010721655,0.011211114,0.011601947,0.012173628,0.012510673,
                  0.012996707,0.013525757,0.013990039,0.014574776,0.015208654,0.015583794,
                  0.016138746,0.016631649,0.017241436,0.017782328,0.018353765,0.019213338,
                  0.019591734,0.020354047,0.021136093,0.021535369,0.022461781,0.023355324,
                  0.023785039,0.024910293,0.025395595,0.026504677,0.027371219,0.028347706;
                  2101.518002,0,0,0.00711227,0.007825692,0.008386875,0.008821081,
                  0.009531429,0.010064099,0.010446801,0.011058935,0.011485645,0.011931689,
                  0.012452276,0.01316248,0.013495873,0.0141893,0.014528201,0.014996621,
                  0.015470075,0.016294783,0.016789196,0.017403116,0.017701422,0.018529787,
                  0.019158365,0.019546969,0.020381831,0.020910089,0.021522199,0.022246257,
                  0.023312282,0.023847191,0.024739252,0.025439506,0.026378624,0.027245106,
                  0.028302627,0.029169502; 2206.593902,0,0,0.007561035,0.008160022,
                  0.008767591,0.009368683,0.009916778,0.010523499,0.011094384,0.011516654,
                  0.012133043,0.012525073,0.01328019,0.013556141,0.014341048,0.014597805,
                  0.015248034,0.015901825,0.016412546,0.01700199,0.017579766,0.01817544,
                  0.018789176,0.0195313,0.019943298,0.020785771,0.021429322,0.022239235,
                  0.022849524,0.023330276,0.024443997,0.025100091,0.026140335,0.027033896,
                  0.027525471,0.028760312,0.029741564,0.030796861; 2416.745702,0,0,
                  0.008201428,0.008778953,0.009596892,0.010103863,0.010792793,0.011495883,
                  0.012075489,0.012693154,0.013148647,0.013725104,0.014330988,0.014805847,
                  0.015454547,0.016070843,0.016773119,0.017262488,0.018027268,0.018470603,
                  0.019064396,0.019678926,0.020359141,0.021230578,0.022064378,0.022415805,
                  0.023237888,0.024362868,0.025094342,0.02577939,0.026504248,0.02739454,
                  0.028258016,0.029405284,0.030489104,0.031149239,0.032686382,0.033448493]
                "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
              parameter SI.Inertia Jengine=3.75 "engine inertia";
              parameter SI.Mass engine_mass=900 "mass of engine";

              parameter Real engine_displacement=10
                "engine displacement in liters"                                     annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

              parameter SI.AngularVelocity crank_speed=62.831853071796
                "crank speed";

              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Engine_Heating_Model_2
                engine_heating_model_2(engine_mass=engine_mass)
                annotation (Placement(transformation(extent={{-22,38},{-2,58}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Torque_And_Fueling_1
                torque_and_fueling_1_1(
                friction_map=friction_map,
                torque_map=torque_map,
                fuel_map=fuel_map,
                crank_speed=crank_speed)
                annotation (Placement(transformation(extent={{-15,-10},{15,10}},
                    rotation=0,
                    origin={-57,2})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Inertia
                inertia(Jengine=Jengine)
                annotation (Placement(transformation(extent={{60,-10},{80,10}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Airflow_Submodel
                airflow_Submodel(
                engine_displacement=engine_displacement,
                voleff=voleff,
                Medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{2,10},{22,30}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.dummy_starter_motor
                starter_motor
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={-100,-20})));
              MSL_Extend.Mechanics.Rotational.Components.Pulley_System_1D_ideal
                                                               pulley_System_1D(
                useSupport=true,
                drive_pulley_diameter=0.12,
                pulley_1_diameter=0.06)
                annotation (Placement(transformation(extent={{102,-70},{122,-50}})));
              parameter Real voleff[:,:]=[0,600,1200,1500,1800; 0,0.867641652,0.867641652,
                  0.867641652,0.867641652; 300,0.867641652,1,1.05,1.1; 400,0.867641652,
                  1.027886075,1.074580184,1.122243498; 500,0.867641652,1.027886075,
                  1.169487592,1.318243069; 600,0.867641652,1.098542293,1.264395,1.514242641;
                  700,0.867641652,1.169198511,1.359303369,1.514242641; 800,0.867641652,
                  1.239854728,1.454211738,1.514242641; 900,0.867641652,1.310510946,
                  1.454211738,1.706250056; 1000,0.867641652,1.391266152,1.693757702,
                  1.898257471; 1200,0.867641652,1.552776565,1.933303667,2.059404565; 1300,
                  0.867641652,1.633531772,1.933303667,2.220551658; 1400,0.867641652,
                  1.712133134,2.11370574,2.220551658; 1600,0.867641652,1.790734496,
                  2.294107813,2.220551658; 1700,0.867641652,1.869335858,2.294107813,
                  2.220551658; 1800,0.867641652,1.94793722,2.3,2.220551658]
                "Table of volumetric efficiency";

              MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.Fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc
                fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc(
                flow_characteristic=flow_characteristic,
                N_ref=N_ref,
                efficiency_characteristic=efficiency_characteristic,
                medium=Coolant_Medium,
                m=0,
                useSupport=true,
                K=K)                                                 annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={160,-50})));
              MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
                thermal_Bridge_With_Pressure_Drop(
                effectiveness_nom=effectiveness_nom,
                cooling_Q_nom=cooling_Q_nom,
                T_inlet_nom=T_inlet_nom,
                V_dot_nom=V_dot_nom,
                dp_nom=dp_nom,
                medium=Coolant_Medium,
                m=0)           annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={160,70})));
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Coolant_Medium = Modelica.Thermal.FluidHeatFlow.Media.Water()
                "Fluid used for cooling the engine"                                                                                                     annotation (choicesAllMatching=true, Dialog(tab="Cooling System"));
              MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                                                            oil_convection(
                  area_for_heat_transfer=0.25)
                "Represents convection path for oil to lose heat through case"
                annotation (Placement(transformation(extent={{120,170},{140,190}})));
              MSL_Extend.Environments.Thermal_To_Environment_Direct
                                                         heat_to_oil
                "heat to oil is sent to environment (which IS the oil)"
                annotation (Placement(transformation(extent={{58,36},{78,56}})));
              parameter Real flow_characteristic[:,:]=[0.000167,1.3e5; 0.0025,1e5; 0.004,
                  0.6e5; 0.005,0.2e5]
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref"
                                                                                        annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter SI.AngularVelocity N_ref=314.15926535898
                "Rotational speed at which table data is provided"
                                                                  annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real K=1e-6
                "(Volume flow rate/delta P) Loss Coefficient to model the pump as a simple restriction at low speeds"
                                                                                                                    annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real efficiency_characteristic[:,:]=[-1,0.8; 0,0.8; 1,0.8]
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref"
                                                                          annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real effectiveness_nom=0.95
                "Nominal effectiveness of the thermal bridge"
                                                             annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Power cooling_Q_nom=300000
                "Nominal heat rejection to the cooling system"
                                                              annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Temperature T_inlet_nom=358.15
                "Nominal coolant inlet temperature"
                annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.VolumeFlowRate V_dot_nom=0.003
                "Nominal coolant volume flow rate"
                                                  annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Pressure dp_nom=50000
                "Nominal pressure drop in the engine coolant jacket"
                                                                    annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,232},{-190,252}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-128,230},{-108,250}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a top_hose_outlet(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,130},{210,150}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b bottom_hose_in(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,-110},{210,-90}})));
              Modelica.Blocks.Interfaces.RealOutput net_torque annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-40,-106})));
              Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,250})));
              Modelica.Blocks.Interfaces.RealOutput speed annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-160,-106})));
              Modelica.Blocks.Interfaces.BooleanInput starter_engage annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={-60,250})));
              Modelica.Blocks.Interfaces.RealOutput fuel_flow annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-100,-106})));
              MSL_Extend.Thermal.Simple_Conduction_Through_Case
                simple_Conduction_From_Internal_Environment(
                case_thermal_conductivity=case_thermal_conductivity,
                case_heat_transfer_thickness=case_heat_transfer_thickness,
                case_heat_transfer_area=case_heat_transfer_area)
                annotation (Placement(transformation(extent={{82,188},{102,208}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
                annotation (Placement(transformation(extent={{90,230},{110,250}})));
              inner
                MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume           env(fixed_htc=
                   500, medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                annotation (Placement(transformation(extent={{-192,188},{-172,208}})));
            equation
              connect(engine_heating_model_2.engine_heat_in, torque_and_fueling_1_1.engine_heat_out)
                annotation (Line(
                  points={{-22,48},{-40,48},{-40,5.84615},{-42,5.84615}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.exhaust_heat_out, airflow_Submodel.exhaust_heat_in)
                annotation (Line(
                  points={{-2,40},{12,40},{12,29.8},{16,29.8}},
                  color={191,0,0},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.flange_b, airflow_Submodel.flange_a)
                annotation (Line(
                  points={{-42,-0.307692},{-33,-0.307692},{-33,12},{2,12}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.flange_b, inertia.flange_a) annotation (Line(
                  points={{22,12},{42,12},{42,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(starter_motor.flange_b, torque_and_fueling_1_1.flange_a)
                annotation (Line(
                  points={{-90,-19.9},{-90,-2},{-86,-2},{-86,-0.307692},{-72,-0.307692}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.pulley_1_flange,
                fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc.flange) annotation (
                  Line(
                  points={{122,-50},{150,-50}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.nominally_driven_pulley, torque_and_fueling_1_1.flange_a)
                annotation (Line(
                  points={{102,-60},{-136,-60},{-136,-0.307692},{-72,-0.307692}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_oil, heat_to_oil.solid) annotation (
                  Line(
                  points={{-2,45.4},{42,45.4},{42,46},{58,46}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.intake_port, fluid_in) annotation (Line(
                  points={{2,20},{-138,20},{-138,242},{-200,242}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.speed, speed) annotation (Line(
                  points={{-66,12.4615},{-160,12.4615},{-160,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.ECU_Throttle_Out, ECU_Throttle_Out)
                annotation (Line(
                  points={{-60,12.7692},{-60,158},{0,158},{0,250}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.fuel_flow, fuel_flow) annotation (Line(
                  points={{-54.6,12.4615},{-54.6,144},{-100,144},{-100,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(simple_Conduction_From_Internal_Environment.port_a,
                outer_surface_heat_port)
                annotation (Line(
                  points={{89,205},{89,218.5},{100,218.5},{100,240}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(oil_convection.solid, simple_Conduction_From_Internal_Environment.port_b)
                annotation (Line(
                  points={{120,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_ambient,
                simple_Conduction_From_Internal_Environment.port_b) annotation (Line(
                  points={{-2,56},{26,56},{26,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(starter_motor.support, internalSupport) annotation (Line(
                  points={{-100.1,-30},{-100.1,-50},{0,-50},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.support, internalSupport) annotation (Line(
                  points={{112,-70},{112,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.support, internalSupport) annotation (Line(
                  points={{-57,-7.84615},{-57,-50},{0,-50},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_coolant,
                thermal_Bridge_With_Pressure_Drop.heatPort) annotation (Line(
                  points={{-2,50.6},{52,50.6},{52,70},{170,70}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc.flowPort_a,
                bottom_hose_in)
                            annotation (Line(
                  points={{160,-60},{160,-100},{200,-100}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(thermal_Bridge_With_Pressure_Drop.flowPort_a,
                fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc.flowPort_b)
                annotation (Line(
                  points={{160,60},{160,-40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(top_hose_outlet, thermal_Bridge_With_Pressure_Drop.flowPort_b)
                                                                               annotation (
                  Line(
                  points={{200,140},{160,140},{160,80}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(brg_02, inertia.flange_b) annotation (Line(
                  points={{200,0},{80,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.flange_a, brg_01) annotation (
                  Line(
                  points={{-72,-0.307692},{-134,-0.307692},{-134,0},{-200,0}},
                  color={0,0,0},
                  smooth=Smooth.None));

              connect(fan_Or_Pump_Affinity_Law_Eff_Implemented_BlendingFnc.support,
                internalSupport) annotation (Line(
                  points={{170,-50},{184,-50},{184,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(net_torque, torque_and_fueling_1_1.net_torque) annotation (Line(
                  points={{-40,-106},{-40,-38},{-18,-38},{-18,28},{-48.8,28},{-48.8,12.4615}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(airflow_Submodel.exhaust_port, fluid_out) annotation (Line(
                  points={{22,20},{48,20},{48,172},{-118,172},{-118,240}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(starter_motor.crank, starter_engage) annotation (Line(
                  points={{-112,-20},{-126,-20},{-126,164},{-60,164},{-60,250}},
                  color={255,0,255},
                  smooth=Smooth.None));
              annotation (
                Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-100},{200,
                        240}}), graphics),
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-100},{200,
                        240}}), graphics),
                Documentation(info="<html>
<p>Operation:</p>
<p><br/>Transmits torque at output flange, torque output is based on flange speed and a torque demand signal. Generates heat proportional to power produced, and is split between exhaust, coolant, ambient air, and engine oil. An airflow submodel generates mass flows required for intake and exhaust streams.</p>
<p><br/>Model Limitations: </p>
<p>The model does not simulate combustion.</p>
<p><br/>Physical Limits:</p>
</html>"));
            end Example_Engine_Basic;

            model Example_Engine_Basic_wFuel
              "Example of an engine implemented using tables"
              extends
                C2M2L_OM.C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Interfaces.Example_Engine_Basic;
              import NonSI = Modelica.SIunits.Conversions.NonSIunits;
             parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Fuel_Medium = C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8() annotation(choicesAllMatching=true);
              parameter SI.Area case_heat_transfer_area=1.0
                "Area available for heat to transfer through case"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.Thickness case_heat_transfer_thickness=0.005
                "Effective case thickness for heat transfer"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.ThermalConductivity case_thermal_conductivity=50
                "Conductivity of case" annotation (Dialog(tab="Thermal Model"));

              parameter SI.Torque friction_map[:,2]=[0,1; 1,120; 10,120; 187.5001584,220;
                  375.0003167,325; 562.5004751,425; 700.0005913,500; 750.0006335,527;
                  800.0006757,555; 850.000718,580; 900.0007602,610; 950.0008024,636;
                  1000.000845,665; 1050.000887,690; 1100.000929,720; 1150.000971,745;
                  1200.001014,770; 1250.001056,800; 1300.001098,825; 1350.00114,855;
                  1400.001183,880; 1450.001225,910; 1500.001267,935; 1550.001309,965;
                  1600.001351,990; 1650.001394,1020; 1700.001436,1045; 1750.001478,1070;
                  1800.00152,1100; 1850.001563,1125; 1900.001605,1153; 1950.001647,1180;
                  2000.001689,1210; 2050.001732,1235; 2100.001774,1260; 2150.001816,1290;
                  2250,1290; 2300,1290]
                "Table of speed (rpm) vs engine friction torque";
              parameter SI.Torque torque_map[:,2]=[562.5004751,420; 700.0005913,1000;
                  750.0006335,1225; 800.0006757,1360; 850.000718,1480; 900.0007602,1585;
                  950.0008024,1685; 1000.000845,1775; 1050.000887,1860; 1100.000929,1945;
                  1150.000971,2025; 1200.001014,2065; 1250.001056,2080; 1300.001098,2080;
                  1350.00114,2060; 1400.001183,2035; 1450.001225,2010; 1500.001267,1975;
                  1550.001309,1925; 1600.001351,1875; 1650.001394,1825; 1700.001436,1775;
                  1750.001478,1725; 1800.00152,1675; 1850.001563,1625; 1900.001605,1585;
                  1950.001647,1535; 2000.001689,1485; 2050.001732,1440; 2100.001774,1390;
                  2150.001816,1330; 2250,0; 2255,0]
                " Table of speed(rpm) vs engine torque at WOT";
              parameter SI.MassFlowRate fuel_map[:,:]=[0,0,10,500.0004223,550.0004646,
                  600.0005068,650.000549,700.0005913,750.0006335,800.0006757,850.000718,
                  900.0007602,950.0008024,1000.000845,1050.000887,1100.000929,1150.000971,
                  1200.001014,1250.001056,1300.001098,1350.00114,1400.001183,1450.001225,
                  1500.001267,1550.001309,1600.001351,1650.001394,1700.001436,1750.001478,
                  1800.00152,1850.001563,1900.001605,1950.001647,2000.001689,2050.001732,
                  2100.001774,2150.001816,2200.001858,2250.0019; 0,0,0,0.000115077,
                  0.000134841,0.000157082,0.000179875,0.000207374,0.000234876,0.000261386,
                  0.000291112,0.00032447,0.000358984,0.000388806,0.000425181,0.000469451,
                  0.000503569,0.000546567,0.0006147,0.000690695,0.000757855,0.000830525,
                  0.000923075,0.001003919,0.001082698,0.001182413,0.001283234,0.001374041,
                  0.001458324,0.001582554,0.001698684,0.001792534,0.001896859,0.002015258,
                  0.002136724,0.002289975,0.002394179,0.002556089,0.002698939; 70.05060006,
                  0,0,0.000357347,0.000396983,0.000438847,0.000478967,0.000520609,
                  0.000566196,0.000605333,0.000651545,0.000704011,0.000754256,0.000801822,
                  0.000851797,0.000906041,0.00094958,0.001009562,0.001087556,0.001184368,
                  0.001253784,0.001365088,0.001437915,0.00155706,0.001661825,0.001756577,
                  0.00185663,0.00199224,0.002101612,0.002218382,0.002333051,0.002469539,
                  0.002592001,0.002730314,0.002859046,0.003012337,0.003133989,0.003293779,
                  0.003461377; 140.1012001,0,0,0.000599708,0.000648694,0.000708328,
                  0.000766908,0.000838683,0.000887612,0.000951407,0.001025648,0.001067673,
                  0.001150541,0.001201261,0.001278282,0.001350712,0.001411658,0.001475311,
                  0.001579904,0.001680621,0.001773634,0.00186571,0.001972046,0.002103904,
                  0.002226054,0.002312078,0.002449318,0.002587895,0.00268291,0.002833754,
                  0.002957563,0.003137412,0.00325725,0.003436602,0.0035697,0.00375666,
                  0.003909565,0.004083891,0.004273732; 210.1518002,0,0,0.000828053,
                  0.000905628,0.000990726,0.001058494,0.001144932,0.001214673,0.001295964,
                  0.001377572,0.001468351,0.001530065,0.001614283,0.001681968,0.001772218,
                  0.001871811,0.001952415,0.002032151,0.00214057,0.002270388,0.002369926,
                  0.002511775,0.002612639,0.002748628,0.002923005,0.003051573,0.003149479,
                  0.003329422,0.003473512,0.003627706,0.003772651,0.00394143,0.004157803,
                  0.004346105,0.004472209,0.0046636,0.004865091,0.005114112; 280.2024002,0,
                  0,0.001075936,0.001172941,0.001274854,0.001370625,0.001455299,0.001563224,
                  0.001660534,0.001745645,0.001832013,0.001913631,0.002028647,0.002126145,
                  0.002195082,0.002322944,0.002393616,0.002525453,0.002671998,0.002754556,
                  0.002905384,0.003072071,0.003182469,0.003329846,0.003495536,0.003630398,
                  0.003807147,0.003921153,0.004084166,0.004275935,0.004434841,0.00465945,
                  0.004813804,0.005017551,0.005215954,0.005449868,0.005690319,0.005955481;
                  350.2530003,0,0,0.001322565,0.001421465,0.001557601,0.00165054,
                  0.001774169,0.00188381,0.002007638,0.002112904,0.002213298,0.002294493,
                  0.002434271,0.002523673,0.002623304,0.002741966,0.002871303,0.002972217,
                  0.003120798,0.003255239,0.003426645,0.003548528,0.003743814,0.003853752,
                  0.004037267,0.004204037,0.004442107,0.004580722,0.004736006,0.00492388,
                  0.005188689,0.0053141,0.005609333,0.005778653,0.006059417,0.006295564,
                  0.006489461,0.006661956; 420.3036003,0,0,0.001554639,0.001699166,
                  0.001811233,0.001955902,0.002099137,0.002223466,0.002321325,0.002469554,
                  0.002598381,0.002733371,0.002842161,0.002928576,0.003094608,0.003199881,
                  0.003316755,0.003482078,0.00360855,0.003804304,0.003923034,0.004077374,
                  0.004278201,0.004421149,0.004590714,0.004858417,0.004996542,0.005158069,
                  0.005357129,0.005601556,0.005858407,0.00599737,0.006304847,0.0065581,
                  0.006816798,0.006995613,0.007301837,0.007497616; 490.3542004,0,0,
                  0.001807824,0.001956499,0.002097762,0.002263333,0.002402906,0.002517197,
                  0.002693621,0.002811624,0.002969092,0.003076745,0.003218626,0.003399024,
                  0.003545868,0.003659694,0.003826696,0.003951532,0.004119462,0.00427216,
                  0.004484229,0.004653266,0.004846958,0.005071501,0.005196311,0.00543916,
                  0.005668657,0.00583742,0.006097476,0.006294829,0.006470421,0.006733115,
                  0.006955381,0.007232631,0.007482187,0.007866234,0.008037662,0.008337939;
                  560.4048004,0,0,0.002036092,0.002185866,0.002364543,0.002540243,
                  0.00271881,0.002886187,0.003052666,0.0031862,0.003362409,0.003457437,
                  0.003634524,0.00380104,0.003921823,0.004135659,0.004275741,0.004433496,
                  0.004649183,0.004805937,0.005019275,0.005235527,0.005354848,0.005572661,
                  0.005844605,0.006073066,0.006220582,0.006458678,0.006740624,0.006977103,
                  0.00721282,0.007497557,0.007742057,0.008040882,0.008362483,0.008608584,
                  0.008867068,0.009170346; 630.4554005,0,0,0.002257567,0.002467794,
                  0.002675342,0.00284593,0.002995089,0.003165995,0.003346948,0.003566379,
                  0.003680615,0.003885091,0.00408557,0.004212524,0.004397487,0.004525951,
                  0.004755746,0.00487956,0.005113773,0.005353434,0.005508666,0.005781315,
                  0.00597662,0.006146354,0.006348415,0.006624572,0.006883208,0.007064022,
                  0.007378966,0.007621634,0.007916153,0.008093021,0.008500802,0.00880721,
                  0.009061799,0.009338996,0.009702039,0.010115007; 700.5060006,0,0,
                  0.002484499,0.002698238,0.002925589,0.003104628,0.003304758,0.003550228,
                  0.003678892,0.003886873,0.004102561,0.004264028,0.004433628,0.00464125,
                  0.004826817,0.005020603,0.005233626,0.005404906,0.005634196,0.00576674,
                  0.005996037,0.006205576,0.006536924,0.006784112,0.007039717,0.007208007,
                  0.007494016,0.007758994,0.008054669,0.008301443,0.008603607,0.008843489,
                  0.00918076,0.009455755,0.009868793,0.010143845,0.010617307,0.010818546;
                  770.5566006,0,0,0.002732385,0.002974377,0.003225061,0.003416013,
                  0.003603968,0.0038798,0.004042562,0.004265259,0.00448914,0.00466634,
                  0.004877442,0.0050133,0.00520751,0.00541228,0.00566104,0.005867669,
                  0.006148112,0.006361315,0.006529102,0.006866272,0.007037468,0.007355363,
                  0.007573933,0.007789419,0.008177144,0.008415082,0.008628315,0.008948014,
                  0.009288249,0.00956245,0.010012595,0.010269215,0.010657043,0.011082045,
                  0.01139578,0.011688953; 840.6072007,0,0,0.00299129,0.003260322,
                  0.003471621,0.003712241,0.003981027,0.004162821,0.004406188,0.004603203,
                  0.004848076,0.005038012,0.005217561,0.005515822,0.005638551,0.005882173,
                  0.006138352,0.0063399,0.00656249,0.006818514,0.007139423,0.007277906,
                  0.007552308,0.00789139,0.00815197,0.008443037,0.008802596,0.0089559,
                  0.009277344,0.00958275,0.009928593,0.010407144,0.010767236,0.011064698,
                  0.01131228,0.011908425,0.012226302,0.012517; 910.6578007,0,0,0.003216134,
                  0.003483667,0.003727712,0.004030699,0.004229468,0.004461442,0.004776539,
                  0.005026396,0.005233455,0.005421065,0.005727613,0.005867425,0.006069297,
                  0.006320983,0.006520323,0.006802302,0.00703797,0.007297502,0.007678125,
                  0.007925697,0.008129177,0.008529737,0.008778909,0.00912278,0.009316539,
                  0.009753951,0.009913522,0.010246687,0.010697352,0.011008774,0.011440212,
                  0.011722308,0.012302719,0.012506738,0.012942023,0.013455971; 980.7084008,
                  0,0,0.00346327,0.003740348,0.004012176,0.004323632,0.004555522,
                  0.004839654,0.005090728,0.005288571,0.005621454,0.00583595,0.006080784,
                  0.006367581,0.006510202,0.006834616,0.007071574,0.007269451,0.007653234,
                  0.007868246,0.008137207,0.008502116,0.008804794,0.008965911,0.009314721,
                  0.009674163,0.010077612,0.010362149,0.010686452,0.010993431,0.011303646,
                  0.011694833,0.012169998,0.012631742,0.012933236,0.013334194,0.013962171,
                  0.014385005; 1050.759001,0,0,0.003677872,0.003967137,0.004313352,
                  0.004613478,0.00487842,0.00516083,0.005393888,0.005656384,0.006004634,
                  0.006183179,0.006453491,0.006739075,0.007018065,0.00724722,0.007564644,
                  0.007821356,0.008163492,0.008397831,0.008601057,0.009004931,0.009303597,
                  0.009518848,0.010008583,0.010316464,0.010538598,0.011037697,0.011420607,
                  0.011643522,0.012020386,0.012588258,0.013046583,0.01327526,0.013873753,
                  0.014384339,0.014667764,0.015256557; 1120.809601,0,0,0.003931094,
                  0.004261234,0.00454188,0.004890058,0.005177477,0.005484366,0.005786588,
                  0.006043486,0.006344013,0.006550229,0.006837473,0.007164386,0.007450865,
                  0.007666174,0.007994788,0.008268723,0.008554573,0.008916318,0.009216168,
                  0.009467362,0.009919672,0.010231056,0.010536456,0.010956879,0.011342154,
                  0.011587639,0.01194467,0.012401861,0.012784508,0.013336535,0.013670403,
                  0.014160269,0.014677751,0.015108747,0.015685437,0.016035555; 1190.860201,
                  0,0,0.004168882,0.004481686,0.004843021,0.005199923,0.005430119,
                  0.005753059,0.00609522,0.006411217,0.006712729,0.006979124,0.007223317,
                  0.007513525,0.007807537,0.008118786,0.00841761,0.008741523,0.009118388,
                  0.009453152,0.009706962,0.010066364,0.010510908,0.0108627,0.011087475,
                  0.011408834,0.011843639,0.012258113,0.012582015,0.013125443,0.013553887,
                  0.013970755,0.014454671,0.014797075,0.015347466,0.015807182,0.016451679,
                  0.017075723; 1260.910801,0,0,0.004397181,0.004757047,0.005103052,
                  0.005491066,0.005831324,0.006158052,0.006383534,0.006760492,0.0070166,
                  0.007411542,0.00770397,0.00802494,0.008359863,0.008666293,0.008957514,
                  0.009165463,0.009594792,0.009855532,0.010207109,0.010626353,0.010935797,
                  0.011337457,0.011712058,0.012085334,0.012594147,0.012999442,0.013397101,
                  0.013751069,0.014172464,0.014810247,0.015235835,0.015700934,0.016293985,
                  0.016644077,0.017285695,0.017768817; 1330.961401,0,0,0.004651163,
                  0.005026823,0.005402895,0.005766842,0.006061432,0.006487762,0.006843933,
                  0.007121371,0.007487373,0.007826556,0.008121261,0.008456308,0.008785913,
                  0.009064373,0.009295403,0.009715569,0.009988033,0.010339149,0.010802942,
                  0.01125246,0.011575269,0.012000549,0.012269241,0.01267643,0.013191945,
                  0.013525161,0.014115653,0.014486879,0.015029543,0.015500716,0.015916054,
                  0.016528683,0.017148035,0.017749178,0.018321747,0.018778942; 1401.012001,
                  0,0,0.004868125,0.005268141,0.005672144,0.005970351,0.006417673,
                  0.006731039,0.007147921,0.007520983,0.007815652,0.008226698,0.008541171,
                  0.008921184,0.009227145,0.009536486,0.009822676,0.010242214,0.010575352,
                  0.011010919,0.011302544,0.011657088,0.012215878,0.012565798,0.012986346,
                  0.013348034,0.013769634,0.014290683,0.014740778,0.01530434,0.015688458,
                  0.01632077,0.016784045,0.017251392,0.018000138,0.018483624,0.018983713,
                  0.019807532; 1471.062601,0,0,0.005084936,0.005458776,0.00593416,
                  0.006288746,0.006705037,0.007120778,0.007409511,0.007822573,0.008223948,
                  0.008592197,0.008875517,0.009276453,0.009626549,0.010026559,0.010408733,
                  0.010669618,0.011086296,0.011514068,0.011913256,0.012178626,0.012588932,
                  0.013140048,0.013414875,0.014120182,0.014448596,0.014856152,0.015279907,
                  0.015778582,0.016450611,0.016915405,0.017692328,0.01805522,0.018849983,
                  0.019250228,0.019863646,0.020545776; 1541.113201,0,0,0.005322789,
                  0.005760758,0.006144848,0.006579486,0.007019394,0.007385693,0.00788008,
                  0.008154316,0.008590492,0.008907259,0.009299089,0.009645807,0.009964867,
                  0.01039708,0.010727767,0.01110816,0.011517292,0.012030419,0.012294601,
                  0.012942519,0.013381089,0.01381138,0.014049788,0.014509783,0.015113865,
                  0.015674113,0.016055315,0.016715072,0.017077274,0.017767526,0.018364758,
                  0.019097406,0.019658994,0.020167293,0.020711705,0.021391838; 1611.163801,
                  0,0,0.005585518,0.006046334,0.006470078,0.006881721,0.007337968,
                  0.007706548,0.008128958,0.008600037,0.008956296,0.009412755,0.00963958,
                  0.010207281,0.010398253,0.010972285,0.011184975,0.011718407,0.012009637,
                  0.012512584,0.012829528,0.0134051,0.013778829,0.014205722,0.014634989,
                  0.015223219,0.015681341,0.016192232,0.016789262,0.017301545,0.01802162,
                  0.018672868,0.019055634,0.019606547,0.020318571,0.020995307,0.021948286,
                  0.022369534; 1681.214401,0,0,0.00580822,0.006239558,0.006725818,
                  0.007139663,0.007598026,0.00799661,0.008437593,0.008858054,0.009240434,
                  0.009632173,0.010052063,0.010562072,0.011024636,0.011266265,0.01175001,
                  0.012083814,0.012547809,0.013101742,0.013421004,0.014077723,0.014457881,
                  0.014888169,0.015515448,0.015774752,0.016279644,0.016911205,0.017575726,
                  0.018203882,0.018572337,0.019327737,0.020080611,0.020663778,0.0214107,
                  0.022161204,0.022609906,0.023371961; 1751.265001,0,0,0.006024714,
                  0.006524754,0.006973102,0.007467878,0.007965018,0.008346405,0.00876786,
                  0.0093003,0.009735957,0.010048707,0.010506915,0.011003701,0.0112886,
                  0.011873966,0.012182415,0.012726615,0.013171612,0.013452978,0.014120787,
                  0.014422004,0.015045127,0.015438329,0.015986429,0.01667792,0.016990224,
                  0.017617956,0.018109371,0.018640698,0.019358914,0.019885114,0.020795869,
                  0.02145395,0.022212409,0.023022136,0.023531056,0.024393712; 1821.315601,0,
                  0,0.006272467,0.006799419,0.007236376,0.007695629,0.008155356,0.008670651,
                  0.009106478,0.009672616,0.010037909,0.010507354,0.010960744,0.011448319,
                  0.011745923,0.012329444,0.012592855,0.013187059,0.013701727,0.014060923,
                  0.014664001,0.015039247,0.015403357,0.016007313,0.016716368,0.01707071,
                  0.017727,0.018115521,0.01888072,0.019690098,0.020004921,0.020978982,
                  0.021659837,0.022280838,0.022975004,0.023647303,0.024311889,0.02559746;
                  1891.366202,0,0,0.006451807,0.007065943,0.007524016,0.008031644,
                  0.008482568,0.009054633,0.009543535,0.009909258,0.010355249,0.010971986,
                  0.011240071,0.011812855,0.012327586,0.01261866,0.013166196,0.013694648,
                  0.014173035,0.014572982,0.015143891,0.015588356,0.016204265,0.016764909,
                  0.017131201,0.017687068,0.018377646,0.019015188,0.019588018,0.020158352,
                  0.020765252,0.021555828,0.022338739,0.022873158,0.023919424,0.024481686,
                  0.02534381,0.02629189; 1961.416802,0,0,0.006644101,0.007278485,
                  0.007740381,0.00824903,0.008828371,0.009303714,0.009845574,0.010417954,
                  0.010786239,0.011292367,0.011774379,0.012270877,0.012786042,0.013133381,
                  0.01365294,0.014200706,0.014710744,0.015224217,0.015763964,0.016080231,
                  0.01658222,0.017370076,0.017916173,0.018290227,0.019046945,0.019666603,
                  0.020390539,0.020815857,0.021869176,0.022230402,0.022930344,0.023677488,
                  0.024656159,0.025679501,0.02638297,0.027530874; 2031.467402,0,0,
                  0.006991992,0.007541484,0.008060435,0.00863469,0.00915203,0.009640107,
                  0.01011446,0.010721655,0.011211114,0.011601947,0.012173628,0.012510673,
                  0.012996707,0.013525757,0.013990039,0.014574776,0.015208654,0.015583794,
                  0.016138746,0.016631649,0.017241436,0.017782328,0.018353765,0.019213338,
                  0.019591734,0.020354047,0.021136093,0.021535369,0.022461781,0.023355324,
                  0.023785039,0.024910293,0.025395595,0.026504677,0.027371219,0.028347706;
                  2101.518002,0,0,0.00711227,0.007825692,0.008386875,0.008821081,
                  0.009531429,0.010064099,0.010446801,0.011058935,0.011485645,0.011931689,
                  0.012452276,0.01316248,0.013495873,0.0141893,0.014528201,0.014996621,
                  0.015470075,0.016294783,0.016789196,0.017403116,0.017701422,0.018529787,
                  0.019158365,0.019546969,0.020381831,0.020910089,0.021522199,0.022246257,
                  0.023312282,0.023847191,0.024739252,0.025439506,0.026378624,0.027245106,
                  0.028302627,0.029169502; 2206.593902,0,0,0.007561035,0.008160022,
                  0.008767591,0.009368683,0.009916778,0.010523499,0.011094384,0.011516654,
                  0.012133043,0.012525073,0.01328019,0.013556141,0.014341048,0.014597805,
                  0.015248034,0.015901825,0.016412546,0.01700199,0.017579766,0.01817544,
                  0.018789176,0.0195313,0.019943298,0.020785771,0.021429322,0.022239235,
                  0.022849524,0.023330276,0.024443997,0.025100091,0.026140335,0.027033896,
                  0.027525471,0.028760312,0.029741564,0.030796861; 2416.745702,0,0,
                  0.008201428,0.008778953,0.009596892,0.010103863,0.010792793,0.011495883,
                  0.012075489,0.012693154,0.013148647,0.013725104,0.014330988,0.014805847,
                  0.015454547,0.016070843,0.016773119,0.017262488,0.018027268,0.018470603,
                  0.019064396,0.019678926,0.020359141,0.021230578,0.022064378,0.022415805,
                  0.023237888,0.024362868,0.025094342,0.02577939,0.026504248,0.02739454,
                  0.028258016,0.029405284,0.030489104,0.031149239,0.032686382,0.033448493]
                "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
              parameter SI.Inertia Jengine=3.75 "engine inertia";
              parameter SI.Mass engine_mass=900 "mass of engine";

              parameter Real engine_displacement=10
                "engine displacement in liters"                                     annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

              parameter SI.AngularVelocity crank_speed=62.831853071796
                "crank speed";

              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Engine_Heating_Model_2
                engine_heating_model_2(engine_mass=engine_mass)
                annotation (Placement(transformation(extent={{-22,38},{-2,58}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Torque_And_Fueling_1_Advanced
                torque_and_fueling_1_1(
                friction_map=friction_map,
                torque_map=torque_map,
                fuel_map=fuel_map,
                crank_speed=crank_speed,
                Fuel_Medium=Fuel_Medium)
                annotation (Placement(transformation(extent={{-15,-10},{15,10}},
                    rotation=0,
                    origin={-57,2})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Inertia
                inertia(Jengine=Jengine)
                annotation (Placement(transformation(extent={{60,-10},{80,10}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Airflow_Submodel
                airflow_Submodel(
                engine_displacement=engine_displacement,
                voleff=voleff,
                Medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{2,10},{22,30}})));
              MSL_Extend.Mechanics.Rotational.Components.Pulley_System_1D_ideal
                                                               pulley_System_1D(
                useSupport=true,
                drive_pulley_diameter=0.12,
                pulley_1_diameter=0.06)
                annotation (Placement(transformation(extent={{102,-34},{122,-14}})));
              parameter Real voleff[:,:]=[0,600,1200,1500,1800; 0,0.867641652,0.867641652,
                  0.867641652,0.867641652; 300,0.867641652,1,1.05,1.1; 400,0.867641652,
                  1.027886075,1.074580184,1.122243498; 500,0.867641652,1.027886075,
                  1.169487592,1.318243069; 600,0.867641652,1.098542293,1.264395,1.514242641;
                  700,0.867641652,1.169198511,1.359303369,1.514242641; 800,0.867641652,
                  1.239854728,1.454211738,1.514242641; 900,0.867641652,1.310510946,
                  1.454211738,1.706250056; 1000,0.867641652,1.391266152,1.693757702,
                  1.898257471; 1200,0.867641652,1.552776565,1.933303667,2.059404565; 1300,
                  0.867641652,1.633531772,1.933303667,2.220551658; 1400,0.867641652,
                  1.712133134,2.11370574,2.220551658; 1600,0.867641652,1.790734496,
                  2.294107813,2.220551658; 1700,0.867641652,1.869335858,2.294107813,
                  2.220551658; 1800,0.867641652,1.94793722,2.3,2.220551658]
                "Table of volumetric efficiency";

              MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.Pump_Base
                                                            Pump_Base(
                flow_characteristic=flow_characteristic,
                N_ref=N_ref,
                efficiency_characteristic=efficiency_characteristic,
                medium=Coolant_Medium,
                useSupport=true,
                m=0)                                                 annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={160,-50})));
              MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
                thermal_Bridge_With_Pressure_Drop(
                effectiveness_nom=effectiveness_nom,
                cooling_Q_nom=cooling_Q_nom,
                T_inlet_nom=T_inlet_nom,
                V_dot_nom=V_dot_nom,
                dp_nom=dp_nom,
                medium=Coolant_Medium,
                m=0)           annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={160,50})));
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Coolant_Medium = Modelica.Thermal.FluidHeatFlow.Media.Water()
                "Fluid used for cooling the engine"                                                                                                     annotation (choicesAllMatching=true, Dialog(tab="Cooling System"));
              MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                                                            oil_convection(
                  area_for_heat_transfer=0.25)
                "Represents convection path for oil to lose heat through case"
                annotation (Placement(transformation(extent={{120,170},{140,190}})));
              MSL_Extend.Environments.Thermal_To_Environment_Direct
                                                         heat_to_oil
                "heat to oil is sent to environment (which IS the oil)"
                annotation (Placement(transformation(extent={{58,36},{78,56}})));
              parameter Real flow_characteristic[:,:]=[0.000167,1.3e5; 0.0025,1e5; 0.004,
                  0.6e5; 0.005,0.2e5]
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref"
                                                                                        annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter SI.AngularVelocity N_ref=314.15926535898
                "Rotational speed at which table data is provided"
                                                                  annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real K=1e-6
                "(Volume flow rate/delta P) Loss Coefficient to model the pump as a simple restriction at low speeds"
                                                                                                                    annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real efficiency_characteristic[:,:]=[-1,0.8; 0,0.8; 1,0.8]
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref"
                                                                          annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real effectiveness_nom=0.95
                "Nominal effectiveness of the thermal bridge"
                                                             annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Power cooling_Q_nom=300000
                "Nominal heat rejection to the cooling system"
                                                              annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Temperature T_inlet_nom=358.15
                "Nominal coolant inlet temperature"
                annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.VolumeFlowRate V_dot_nom=0.003
                "Nominal coolant volume flow rate"
                                                  annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Pressure dp_nom=50000
                "Nominal pressure drop in the engine coolant jacket"
                                                                    annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,232},{-190,252}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-128,230},{-108,250}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a top_hose_outlet(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,130},{210,150}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b bottom_hose_in(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,-110},{210,-90}})));
              Modelica.Blocks.Interfaces.RealOutput net_torque annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-40,-106})));
              Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,250})));
              Modelica.Blocks.Interfaces.RealOutput speed annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-160,-106})));
              Modelica.Blocks.Interfaces.BooleanInput starter_engage annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={-60,250})));
              Modelica.Blocks.Interfaces.RealOutput fuel_flow annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-100,-106})));
              MSL_Extend.Thermal.Simple_Conduction_Through_Case
                simple_Conduction_From_Internal_Environment(
                case_thermal_conductivity=case_thermal_conductivity,
                case_heat_transfer_thickness=case_heat_transfer_thickness,
                case_heat_transfer_area=case_heat_transfer_area)
                annotation (Placement(transformation(extent={{82,188},{102,208}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
                annotation (Placement(transformation(extent={{90,230},{110,250}})));
              inner
                MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume           env(fixed_htc=
                   500, medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                annotation (Placement(transformation(extent={{-182,216},{-162,236}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b to_cac(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a from_cac(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,150},{-190,170}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Dummy_Turbo
                dummy_Turbo annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={-146,182})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fuel_in(medium=
                    Fuel_Medium)
                annotation (Placement(transformation(extent={{-210,-50},{-190,-30}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.dummy_starter_motor
                starter_motor
                annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={-112,-14})));
            equation
              connect(engine_heating_model_2.engine_heat_in, torque_and_fueling_1_1.engine_heat_out)
                annotation (Line(
                  points={{-22,48},{-40,48},{-40,5.84615},{-42,5.84615}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.exhaust_heat_out, airflow_Submodel.exhaust_heat_in)
                annotation (Line(
                  points={{-2,40},{12,40},{12,29.8},{16,29.8}},
                  color={191,0,0},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.flange_b, airflow_Submodel.flange_a)
                annotation (Line(
                  points={{-42,-0.307692},{-33,-0.307692},{-33,12},{2,12}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.flange_b, inertia.flange_a) annotation (Line(
                  points={{22,12},{42,12},{42,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.pulley_1_flange, Pump_Base.flange)    annotation (
                  Line(
                  points={{122,-14},{136,-14},{136,-50},{150,-50}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.nominally_driven_pulley, torque_and_fueling_1_1.flange_a)
                annotation (Line(
                  points={{102,-24},{-136,-24},{-136,-0.307692},{-72,-0.307692}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_oil, heat_to_oil.solid) annotation (
                  Line(
                  points={{-2,45.4},{42,45.4},{42,46},{58,46}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.speed, speed) annotation (Line(
                  points={{-68,12.4615},{-160,12.4615},{-160,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.ECU_Throttle_Out, ECU_Throttle_Out)
                annotation (Line(
                  points={{-60,12.7692},{-60,158},{0,158},{0,250}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.fuel_flow, fuel_flow) annotation (Line(
                  points={{-56,12.4615},{-56,144},{-100,144},{-100,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(simple_Conduction_From_Internal_Environment.port_a,
                outer_surface_heat_port)
                annotation (Line(
                  points={{89,205},{89,218.5},{100,218.5},{100,240}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(oil_convection.solid, simple_Conduction_From_Internal_Environment.port_b)
                annotation (Line(
                  points={{120,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_ambient,
                simple_Conduction_From_Internal_Environment.port_b) annotation (Line(
                  points={{-2,56},{26,56},{26,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.support, internalSupport) annotation (Line(
                  points={{112,-34},{112,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.support, internalSupport) annotation (Line(
                  points={{-57,-7.84615},{-57,-50},{0,-50},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_coolant,
                thermal_Bridge_With_Pressure_Drop.heatPort) annotation (Line(
                  points={{-2,50.6},{52,50.6},{52,50},{150,50}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(Pump_Base.flowPort_a, bottom_hose_in)
                            annotation (Line(
                  points={{160,-60},{160,-100},{200,-100}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(brg_02, inertia.flange_b) annotation (Line(
                  points={{200,0},{80,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.flange_a, brg_01) annotation (
                  Line(
                  points={{-72,-0.307692},{-134,-0.307692},{-134,0},{-200,0}},
                  color={0,0,0},
                  smooth=Smooth.None));

              connect(Pump_Base.support, internalSupport)
                                 annotation (Line(
                  points={{170,-50},{182,-50},{182,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(net_torque, torque_and_fueling_1_1.net_torque) annotation (Line(
                  points={{-40,-106},{-40,-38},{-18,-38},{-18,28},{-52,28},{-52,12.4615}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(airflow_Submodel.intake_port, from_cac) annotation (Line(
                  points={{2,20},{-136,20},{-136,160},{-200,160}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.exhaust_port, dummy_Turbo.exh_from_engine)
                annotation (Line(
                  points={{22,20},{38,20},{38,172},{-144,172}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.exh_to_downpipe, fluid_out) annotation (Line(
                  points={{-138,192},{-118,192},{-118,240}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.from_filter, fluid_in) annotation (Line(
                  points={{-154,192},{-200,192},{-200,242}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.to_cac, to_cac) annotation (Line(
                  points={{-148,192},{-148,206},{-180,206},{-180,120},{-200,120}},
                  color={255,0,0},
                  smooth=Smooth.None));

              connect(fuel_in, torque_and_fueling_1_1.port_a) annotation (Line(
                  points={{-200,-40},{-48,-40},{-48,12}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(starter_motor.crank, starter_engage) annotation (Line(
                  points={{-124,-14},{-130,-14},{-130,168},{-60,168},{-60,250}},
                  color={255,0,255},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.flange_a, starter_motor.flange_b) annotation (
                  Line(
                  points={{-72,-0.307692},{-88,-0.307692},{-88,-13.9},{-102,-13.9}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(starter_motor.support, internalSupport) annotation (Line(
                  points={{-112.1,-24},{-116,-24},{-116,-76},{0,-76},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(thermal_Bridge_With_Pressure_Drop.flowPort_b, Pump_Base.flowPort_b)
                annotation (Line(
                  points={{160,40},{160,-40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(thermal_Bridge_With_Pressure_Drop.flowPort_a, top_hose_outlet)
                annotation (Line(
                  points={{160,60},{160,140},{200,140}},
                  color={255,0,0},
                  smooth=Smooth.None));
              annotation (
                Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-100},{200,
                        240}}), graphics),
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-100},{200,
                        240}}), graphics),
                Documentation(info="<html>
<p>Operation:</p>
<p><br/>Transmits torque at output flange, torque output is based on flange speed and a torque demand signal. Generates heat proportional to power produced, and is split between exhaust, coolant, ambient air, and engine oil. An airflow submodel generates mass flows required for intake and exhaust streams.</p>
<p><br/>Model Limitations: </p>
<p>The model does not simulate combustion.</p>
<p><br/>Physical Limits:</p>
</html>"));
            end Example_Engine_Basic_wFuel;

            model Example_Engine_Basic_Advanced
              "Example of an engine implemented using tables"
              extends
                C2M2L_OM.C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Interfaces.Example_Engine_Basic;
              import NonSI = Modelica.SIunits.Conversions.NonSIunits;
             parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Fuel_Medium = C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8() annotation(choicesAllMatching=true);
              parameter SI.Area case_heat_transfer_area=1.0
                "Area available for heat to transfer through case"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.Thickness case_heat_transfer_thickness=0.005
                "Effective case thickness for heat transfer"
                annotation (Dialog(tab="Thermal Model"));
              parameter SI.ThermalConductivity case_thermal_conductivity=50
                "Conductivity of case" annotation (Dialog(tab="Thermal Model"));
              parameter SI.Voltage v_nom=24
                "Nominal voltage that device is intended to operate at"
                annotation (Dialog(tab="Electrical Model"));
              parameter SI.Torque friction_map[:,2]=[0,1; 1,120; 10,120; 187.5001584,220;
                  375.0003167,325; 562.5004751,425; 700.0005913,500; 750.0006335,527;
                  800.0006757,555; 850.000718,580; 900.0007602,610; 950.0008024,636;
                  1000.000845,665; 1050.000887,690; 1100.000929,720; 1150.000971,745;
                  1200.001014,770; 1250.001056,800; 1300.001098,825; 1350.00114,855;
                  1400.001183,880; 1450.001225,910; 1500.001267,935; 1550.001309,965;
                  1600.001351,990; 1650.001394,1020; 1700.001436,1045; 1750.001478,1070;
                  1800.00152,1100; 1850.001563,1125; 1900.001605,1153; 1950.001647,1180;
                  2000.001689,1210; 2050.001732,1235; 2100.001774,1260; 2150.001816,1290;
                  2250,1290; 2300,1290]
                "Table of speed (rpm) vs engine friction torque";
              parameter SI.Torque torque_map[:,2]=[562.5004751,420; 700.0005913,1000;
                  750.0006335,1225; 800.0006757,1360; 850.000718,1480; 900.0007602,1585;
                  950.0008024,1685; 1000.000845,1775; 1050.000887,1860; 1100.000929,1945;
                  1150.000971,2025; 1200.001014,2065; 1250.001056,2080; 1300.001098,2080;
                  1350.00114,2060; 1400.001183,2035; 1450.001225,2010; 1500.001267,1975;
                  1550.001309,1925; 1600.001351,1875; 1650.001394,1825; 1700.001436,1775;
                  1750.001478,1725; 1800.00152,1675; 1850.001563,1625; 1900.001605,1585;
                  1950.001647,1535; 2000.001689,1485; 2050.001732,1440; 2100.001774,1390;
                  2150.001816,1330; 2250,0; 2255,0]
                " Table of speed(rpm) vs engine torque at WOT";
              parameter SI.MassFlowRate fuel_map[:,:]=[0,0,10,500.0004223,550.0004646,
                  600.0005068,650.000549,700.0005913,750.0006335,800.0006757,850.000718,
                  900.0007602,950.0008024,1000.000845,1050.000887,1100.000929,1150.000971,
                  1200.001014,1250.001056,1300.001098,1350.00114,1400.001183,1450.001225,
                  1500.001267,1550.001309,1600.001351,1650.001394,1700.001436,1750.001478,
                  1800.00152,1850.001563,1900.001605,1950.001647,2000.001689,2050.001732,
                  2100.001774,2150.001816,2200.001858,2250.0019; 0,0,0,0.000115077,
                  0.000134841,0.000157082,0.000179875,0.000207374,0.000234876,0.000261386,
                  0.000291112,0.00032447,0.000358984,0.000388806,0.000425181,0.000469451,
                  0.000503569,0.000546567,0.0006147,0.000690695,0.000757855,0.000830525,
                  0.000923075,0.001003919,0.001082698,0.001182413,0.001283234,0.001374041,
                  0.001458324,0.001582554,0.001698684,0.001792534,0.001896859,0.002015258,
                  0.002136724,0.002289975,0.002394179,0.002556089,0.002698939; 70.05060006,
                  0,0,0.000357347,0.000396983,0.000438847,0.000478967,0.000520609,
                  0.000566196,0.000605333,0.000651545,0.000704011,0.000754256,0.000801822,
                  0.000851797,0.000906041,0.00094958,0.001009562,0.001087556,0.001184368,
                  0.001253784,0.001365088,0.001437915,0.00155706,0.001661825,0.001756577,
                  0.00185663,0.00199224,0.002101612,0.002218382,0.002333051,0.002469539,
                  0.002592001,0.002730314,0.002859046,0.003012337,0.003133989,0.003293779,
                  0.003461377; 140.1012001,0,0,0.000599708,0.000648694,0.000708328,
                  0.000766908,0.000838683,0.000887612,0.000951407,0.001025648,0.001067673,
                  0.001150541,0.001201261,0.001278282,0.001350712,0.001411658,0.001475311,
                  0.001579904,0.001680621,0.001773634,0.00186571,0.001972046,0.002103904,
                  0.002226054,0.002312078,0.002449318,0.002587895,0.00268291,0.002833754,
                  0.002957563,0.003137412,0.00325725,0.003436602,0.0035697,0.00375666,
                  0.003909565,0.004083891,0.004273732; 210.1518002,0,0,0.000828053,
                  0.000905628,0.000990726,0.001058494,0.001144932,0.001214673,0.001295964,
                  0.001377572,0.001468351,0.001530065,0.001614283,0.001681968,0.001772218,
                  0.001871811,0.001952415,0.002032151,0.00214057,0.002270388,0.002369926,
                  0.002511775,0.002612639,0.002748628,0.002923005,0.003051573,0.003149479,
                  0.003329422,0.003473512,0.003627706,0.003772651,0.00394143,0.004157803,
                  0.004346105,0.004472209,0.0046636,0.004865091,0.005114112; 280.2024002,0,
                  0,0.001075936,0.001172941,0.001274854,0.001370625,0.001455299,0.001563224,
                  0.001660534,0.001745645,0.001832013,0.001913631,0.002028647,0.002126145,
                  0.002195082,0.002322944,0.002393616,0.002525453,0.002671998,0.002754556,
                  0.002905384,0.003072071,0.003182469,0.003329846,0.003495536,0.003630398,
                  0.003807147,0.003921153,0.004084166,0.004275935,0.004434841,0.00465945,
                  0.004813804,0.005017551,0.005215954,0.005449868,0.005690319,0.005955481;
                  350.2530003,0,0,0.001322565,0.001421465,0.001557601,0.00165054,
                  0.001774169,0.00188381,0.002007638,0.002112904,0.002213298,0.002294493,
                  0.002434271,0.002523673,0.002623304,0.002741966,0.002871303,0.002972217,
                  0.003120798,0.003255239,0.003426645,0.003548528,0.003743814,0.003853752,
                  0.004037267,0.004204037,0.004442107,0.004580722,0.004736006,0.00492388,
                  0.005188689,0.0053141,0.005609333,0.005778653,0.006059417,0.006295564,
                  0.006489461,0.006661956; 420.3036003,0,0,0.001554639,0.001699166,
                  0.001811233,0.001955902,0.002099137,0.002223466,0.002321325,0.002469554,
                  0.002598381,0.002733371,0.002842161,0.002928576,0.003094608,0.003199881,
                  0.003316755,0.003482078,0.00360855,0.003804304,0.003923034,0.004077374,
                  0.004278201,0.004421149,0.004590714,0.004858417,0.004996542,0.005158069,
                  0.005357129,0.005601556,0.005858407,0.00599737,0.006304847,0.0065581,
                  0.006816798,0.006995613,0.007301837,0.007497616; 490.3542004,0,0,
                  0.001807824,0.001956499,0.002097762,0.002263333,0.002402906,0.002517197,
                  0.002693621,0.002811624,0.002969092,0.003076745,0.003218626,0.003399024,
                  0.003545868,0.003659694,0.003826696,0.003951532,0.004119462,0.00427216,
                  0.004484229,0.004653266,0.004846958,0.005071501,0.005196311,0.00543916,
                  0.005668657,0.00583742,0.006097476,0.006294829,0.006470421,0.006733115,
                  0.006955381,0.007232631,0.007482187,0.007866234,0.008037662,0.008337939;
                  560.4048004,0,0,0.002036092,0.002185866,0.002364543,0.002540243,
                  0.00271881,0.002886187,0.003052666,0.0031862,0.003362409,0.003457437,
                  0.003634524,0.00380104,0.003921823,0.004135659,0.004275741,0.004433496,
                  0.004649183,0.004805937,0.005019275,0.005235527,0.005354848,0.005572661,
                  0.005844605,0.006073066,0.006220582,0.006458678,0.006740624,0.006977103,
                  0.00721282,0.007497557,0.007742057,0.008040882,0.008362483,0.008608584,
                  0.008867068,0.009170346; 630.4554005,0,0,0.002257567,0.002467794,
                  0.002675342,0.00284593,0.002995089,0.003165995,0.003346948,0.003566379,
                  0.003680615,0.003885091,0.00408557,0.004212524,0.004397487,0.004525951,
                  0.004755746,0.00487956,0.005113773,0.005353434,0.005508666,0.005781315,
                  0.00597662,0.006146354,0.006348415,0.006624572,0.006883208,0.007064022,
                  0.007378966,0.007621634,0.007916153,0.008093021,0.008500802,0.00880721,
                  0.009061799,0.009338996,0.009702039,0.010115007; 700.5060006,0,0,
                  0.002484499,0.002698238,0.002925589,0.003104628,0.003304758,0.003550228,
                  0.003678892,0.003886873,0.004102561,0.004264028,0.004433628,0.00464125,
                  0.004826817,0.005020603,0.005233626,0.005404906,0.005634196,0.00576674,
                  0.005996037,0.006205576,0.006536924,0.006784112,0.007039717,0.007208007,
                  0.007494016,0.007758994,0.008054669,0.008301443,0.008603607,0.008843489,
                  0.00918076,0.009455755,0.009868793,0.010143845,0.010617307,0.010818546;
                  770.5566006,0,0,0.002732385,0.002974377,0.003225061,0.003416013,
                  0.003603968,0.0038798,0.004042562,0.004265259,0.00448914,0.00466634,
                  0.004877442,0.0050133,0.00520751,0.00541228,0.00566104,0.005867669,
                  0.006148112,0.006361315,0.006529102,0.006866272,0.007037468,0.007355363,
                  0.007573933,0.007789419,0.008177144,0.008415082,0.008628315,0.008948014,
                  0.009288249,0.00956245,0.010012595,0.010269215,0.010657043,0.011082045,
                  0.01139578,0.011688953; 840.6072007,0,0,0.00299129,0.003260322,
                  0.003471621,0.003712241,0.003981027,0.004162821,0.004406188,0.004603203,
                  0.004848076,0.005038012,0.005217561,0.005515822,0.005638551,0.005882173,
                  0.006138352,0.0063399,0.00656249,0.006818514,0.007139423,0.007277906,
                  0.007552308,0.00789139,0.00815197,0.008443037,0.008802596,0.0089559,
                  0.009277344,0.00958275,0.009928593,0.010407144,0.010767236,0.011064698,
                  0.01131228,0.011908425,0.012226302,0.012517; 910.6578007,0,0,0.003216134,
                  0.003483667,0.003727712,0.004030699,0.004229468,0.004461442,0.004776539,
                  0.005026396,0.005233455,0.005421065,0.005727613,0.005867425,0.006069297,
                  0.006320983,0.006520323,0.006802302,0.00703797,0.007297502,0.007678125,
                  0.007925697,0.008129177,0.008529737,0.008778909,0.00912278,0.009316539,
                  0.009753951,0.009913522,0.010246687,0.010697352,0.011008774,0.011440212,
                  0.011722308,0.012302719,0.012506738,0.012942023,0.013455971; 980.7084008,
                  0,0,0.00346327,0.003740348,0.004012176,0.004323632,0.004555522,
                  0.004839654,0.005090728,0.005288571,0.005621454,0.00583595,0.006080784,
                  0.006367581,0.006510202,0.006834616,0.007071574,0.007269451,0.007653234,
                  0.007868246,0.008137207,0.008502116,0.008804794,0.008965911,0.009314721,
                  0.009674163,0.010077612,0.010362149,0.010686452,0.010993431,0.011303646,
                  0.011694833,0.012169998,0.012631742,0.012933236,0.013334194,0.013962171,
                  0.014385005; 1050.759001,0,0,0.003677872,0.003967137,0.004313352,
                  0.004613478,0.00487842,0.00516083,0.005393888,0.005656384,0.006004634,
                  0.006183179,0.006453491,0.006739075,0.007018065,0.00724722,0.007564644,
                  0.007821356,0.008163492,0.008397831,0.008601057,0.009004931,0.009303597,
                  0.009518848,0.010008583,0.010316464,0.010538598,0.011037697,0.011420607,
                  0.011643522,0.012020386,0.012588258,0.013046583,0.01327526,0.013873753,
                  0.014384339,0.014667764,0.015256557; 1120.809601,0,0,0.003931094,
                  0.004261234,0.00454188,0.004890058,0.005177477,0.005484366,0.005786588,
                  0.006043486,0.006344013,0.006550229,0.006837473,0.007164386,0.007450865,
                  0.007666174,0.007994788,0.008268723,0.008554573,0.008916318,0.009216168,
                  0.009467362,0.009919672,0.010231056,0.010536456,0.010956879,0.011342154,
                  0.011587639,0.01194467,0.012401861,0.012784508,0.013336535,0.013670403,
                  0.014160269,0.014677751,0.015108747,0.015685437,0.016035555; 1190.860201,
                  0,0,0.004168882,0.004481686,0.004843021,0.005199923,0.005430119,
                  0.005753059,0.00609522,0.006411217,0.006712729,0.006979124,0.007223317,
                  0.007513525,0.007807537,0.008118786,0.00841761,0.008741523,0.009118388,
                  0.009453152,0.009706962,0.010066364,0.010510908,0.0108627,0.011087475,
                  0.011408834,0.011843639,0.012258113,0.012582015,0.013125443,0.013553887,
                  0.013970755,0.014454671,0.014797075,0.015347466,0.015807182,0.016451679,
                  0.017075723; 1260.910801,0,0,0.004397181,0.004757047,0.005103052,
                  0.005491066,0.005831324,0.006158052,0.006383534,0.006760492,0.0070166,
                  0.007411542,0.00770397,0.00802494,0.008359863,0.008666293,0.008957514,
                  0.009165463,0.009594792,0.009855532,0.010207109,0.010626353,0.010935797,
                  0.011337457,0.011712058,0.012085334,0.012594147,0.012999442,0.013397101,
                  0.013751069,0.014172464,0.014810247,0.015235835,0.015700934,0.016293985,
                  0.016644077,0.017285695,0.017768817; 1330.961401,0,0,0.004651163,
                  0.005026823,0.005402895,0.005766842,0.006061432,0.006487762,0.006843933,
                  0.007121371,0.007487373,0.007826556,0.008121261,0.008456308,0.008785913,
                  0.009064373,0.009295403,0.009715569,0.009988033,0.010339149,0.010802942,
                  0.01125246,0.011575269,0.012000549,0.012269241,0.01267643,0.013191945,
                  0.013525161,0.014115653,0.014486879,0.015029543,0.015500716,0.015916054,
                  0.016528683,0.017148035,0.017749178,0.018321747,0.018778942; 1401.012001,
                  0,0,0.004868125,0.005268141,0.005672144,0.005970351,0.006417673,
                  0.006731039,0.007147921,0.007520983,0.007815652,0.008226698,0.008541171,
                  0.008921184,0.009227145,0.009536486,0.009822676,0.010242214,0.010575352,
                  0.011010919,0.011302544,0.011657088,0.012215878,0.012565798,0.012986346,
                  0.013348034,0.013769634,0.014290683,0.014740778,0.01530434,0.015688458,
                  0.01632077,0.016784045,0.017251392,0.018000138,0.018483624,0.018983713,
                  0.019807532; 1471.062601,0,0,0.005084936,0.005458776,0.00593416,
                  0.006288746,0.006705037,0.007120778,0.007409511,0.007822573,0.008223948,
                  0.008592197,0.008875517,0.009276453,0.009626549,0.010026559,0.010408733,
                  0.010669618,0.011086296,0.011514068,0.011913256,0.012178626,0.012588932,
                  0.013140048,0.013414875,0.014120182,0.014448596,0.014856152,0.015279907,
                  0.015778582,0.016450611,0.016915405,0.017692328,0.01805522,0.018849983,
                  0.019250228,0.019863646,0.020545776; 1541.113201,0,0,0.005322789,
                  0.005760758,0.006144848,0.006579486,0.007019394,0.007385693,0.00788008,
                  0.008154316,0.008590492,0.008907259,0.009299089,0.009645807,0.009964867,
                  0.01039708,0.010727767,0.01110816,0.011517292,0.012030419,0.012294601,
                  0.012942519,0.013381089,0.01381138,0.014049788,0.014509783,0.015113865,
                  0.015674113,0.016055315,0.016715072,0.017077274,0.017767526,0.018364758,
                  0.019097406,0.019658994,0.020167293,0.020711705,0.021391838; 1611.163801,
                  0,0,0.005585518,0.006046334,0.006470078,0.006881721,0.007337968,
                  0.007706548,0.008128958,0.008600037,0.008956296,0.009412755,0.00963958,
                  0.010207281,0.010398253,0.010972285,0.011184975,0.011718407,0.012009637,
                  0.012512584,0.012829528,0.0134051,0.013778829,0.014205722,0.014634989,
                  0.015223219,0.015681341,0.016192232,0.016789262,0.017301545,0.01802162,
                  0.018672868,0.019055634,0.019606547,0.020318571,0.020995307,0.021948286,
                  0.022369534; 1681.214401,0,0,0.00580822,0.006239558,0.006725818,
                  0.007139663,0.007598026,0.00799661,0.008437593,0.008858054,0.009240434,
                  0.009632173,0.010052063,0.010562072,0.011024636,0.011266265,0.01175001,
                  0.012083814,0.012547809,0.013101742,0.013421004,0.014077723,0.014457881,
                  0.014888169,0.015515448,0.015774752,0.016279644,0.016911205,0.017575726,
                  0.018203882,0.018572337,0.019327737,0.020080611,0.020663778,0.0214107,
                  0.022161204,0.022609906,0.023371961; 1751.265001,0,0,0.006024714,
                  0.006524754,0.006973102,0.007467878,0.007965018,0.008346405,0.00876786,
                  0.0093003,0.009735957,0.010048707,0.010506915,0.011003701,0.0112886,
                  0.011873966,0.012182415,0.012726615,0.013171612,0.013452978,0.014120787,
                  0.014422004,0.015045127,0.015438329,0.015986429,0.01667792,0.016990224,
                  0.017617956,0.018109371,0.018640698,0.019358914,0.019885114,0.020795869,
                  0.02145395,0.022212409,0.023022136,0.023531056,0.024393712; 1821.315601,0,
                  0,0.006272467,0.006799419,0.007236376,0.007695629,0.008155356,0.008670651,
                  0.009106478,0.009672616,0.010037909,0.010507354,0.010960744,0.011448319,
                  0.011745923,0.012329444,0.012592855,0.013187059,0.013701727,0.014060923,
                  0.014664001,0.015039247,0.015403357,0.016007313,0.016716368,0.01707071,
                  0.017727,0.018115521,0.01888072,0.019690098,0.020004921,0.020978982,
                  0.021659837,0.022280838,0.022975004,0.023647303,0.024311889,0.02559746;
                  1891.366202,0,0,0.006451807,0.007065943,0.007524016,0.008031644,
                  0.008482568,0.009054633,0.009543535,0.009909258,0.010355249,0.010971986,
                  0.011240071,0.011812855,0.012327586,0.01261866,0.013166196,0.013694648,
                  0.014173035,0.014572982,0.015143891,0.015588356,0.016204265,0.016764909,
                  0.017131201,0.017687068,0.018377646,0.019015188,0.019588018,0.020158352,
                  0.020765252,0.021555828,0.022338739,0.022873158,0.023919424,0.024481686,
                  0.02534381,0.02629189; 1961.416802,0,0,0.006644101,0.007278485,
                  0.007740381,0.00824903,0.008828371,0.009303714,0.009845574,0.010417954,
                  0.010786239,0.011292367,0.011774379,0.012270877,0.012786042,0.013133381,
                  0.01365294,0.014200706,0.014710744,0.015224217,0.015763964,0.016080231,
                  0.01658222,0.017370076,0.017916173,0.018290227,0.019046945,0.019666603,
                  0.020390539,0.020815857,0.021869176,0.022230402,0.022930344,0.023677488,
                  0.024656159,0.025679501,0.02638297,0.027530874; 2031.467402,0,0,
                  0.006991992,0.007541484,0.008060435,0.00863469,0.00915203,0.009640107,
                  0.01011446,0.010721655,0.011211114,0.011601947,0.012173628,0.012510673,
                  0.012996707,0.013525757,0.013990039,0.014574776,0.015208654,0.015583794,
                  0.016138746,0.016631649,0.017241436,0.017782328,0.018353765,0.019213338,
                  0.019591734,0.020354047,0.021136093,0.021535369,0.022461781,0.023355324,
                  0.023785039,0.024910293,0.025395595,0.026504677,0.027371219,0.028347706;
                  2101.518002,0,0,0.00711227,0.007825692,0.008386875,0.008821081,
                  0.009531429,0.010064099,0.010446801,0.011058935,0.011485645,0.011931689,
                  0.012452276,0.01316248,0.013495873,0.0141893,0.014528201,0.014996621,
                  0.015470075,0.016294783,0.016789196,0.017403116,0.017701422,0.018529787,
                  0.019158365,0.019546969,0.020381831,0.020910089,0.021522199,0.022246257,
                  0.023312282,0.023847191,0.024739252,0.025439506,0.026378624,0.027245106,
                  0.028302627,0.029169502; 2206.593902,0,0,0.007561035,0.008160022,
                  0.008767591,0.009368683,0.009916778,0.010523499,0.011094384,0.011516654,
                  0.012133043,0.012525073,0.01328019,0.013556141,0.014341048,0.014597805,
                  0.015248034,0.015901825,0.016412546,0.01700199,0.017579766,0.01817544,
                  0.018789176,0.0195313,0.019943298,0.020785771,0.021429322,0.022239235,
                  0.022849524,0.023330276,0.024443997,0.025100091,0.026140335,0.027033896,
                  0.027525471,0.028760312,0.029741564,0.030796861; 2416.745702,0,0,
                  0.008201428,0.008778953,0.009596892,0.010103863,0.010792793,0.011495883,
                  0.012075489,0.012693154,0.013148647,0.013725104,0.014330988,0.014805847,
                  0.015454547,0.016070843,0.016773119,0.017262488,0.018027268,0.018470603,
                  0.019064396,0.019678926,0.020359141,0.021230578,0.022064378,0.022415805,
                  0.023237888,0.024362868,0.025094342,0.02577939,0.026504248,0.02739454,
                  0.028258016,0.029405284,0.030489104,0.031149239,0.032686382,0.033448493]
                "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
              parameter SI.Inertia Jengine=3.75 "engine inertia";
              parameter SI.Mass engine_mass=900 "mass of engine";

              parameter Real engine_displacement=10
                "engine displacement in liters"                                     annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

             parameter SI.AngularVelocity crank_speed=62.831853071796
                "crank speed";

              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Engine_Heating_Model_2
                engine_heating_model_2(engine_mass=engine_mass)
                annotation (Placement(transformation(extent={{-22,38},{-2,58}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Torque_And_Fueling_1_Advanced
                torque_and_fueling_1_1(
                friction_map=friction_map,
                torque_map=torque_map,
                fuel_map=fuel_map,
                crank_speed=crank_speed,
                Fuel_Medium=Fuel_Medium)
                annotation (Placement(transformation(extent={{-15,-10},{15,10}},
                    rotation=0,
                    origin={-57,2})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Inertia
                inertia(Jengine=Jengine)
                annotation (Placement(transformation(extent={{60,-10},{80,10}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Airflow_Submodel
                airflow_Submodel(
                engine_displacement=engine_displacement,
                voleff=voleff,
                Medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{2,10},{22,30}})));
              MSL_Extend.Mechanics.Rotational.Components.Pulley_System_1D_ideal
                                                               pulley_System_1D(
                useSupport=true,
                drive_pulley_diameter=0.12,
                pulley_1_diameter=0.06)
                annotation (Placement(transformation(extent={{102,-34},{122,-14}})));
              parameter Real voleff[:,:]=[0,600,1200,1500,1800; 0,0.867641652,0.867641652,
                  0.867641652,0.867641652; 300,0.867641652,1,1.05,1.1; 400,0.867641652,
                  1.027886075,1.074580184,1.122243498; 500,0.867641652,1.027886075,
                  1.169487592,1.318243069; 600,0.867641652,1.098542293,1.264395,1.514242641;
                  700,0.867641652,1.169198511,1.359303369,1.514242641; 800,0.867641652,
                  1.239854728,1.454211738,1.514242641; 900,0.867641652,1.310510946,
                  1.454211738,1.706250056; 1000,0.867641652,1.391266152,1.693757702,
                  1.898257471; 1200,0.867641652,1.552776565,1.933303667,2.059404565; 1300,
                  0.867641652,1.633531772,1.933303667,2.220551658; 1400,0.867641652,
                  1.712133134,2.11370574,2.220551658; 1600,0.867641652,1.790734496,
                  2.294107813,2.220551658; 1700,0.867641652,1.869335858,2.294107813,
                  2.220551658; 1800,0.867641652,1.94793722,2.3,2.220551658]
                "Table of volumetric efficiency";

              MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.Pump_Base
                                                            Pump_Base(
                flow_characteristic=flow_characteristic,
                N_ref=N_ref,
                efficiency_characteristic=efficiency_characteristic,
                medium=Coolant_Medium,
                useSupport=true,
                m=0)                                                 annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={160,-50})));
              MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
                thermal_Bridge_With_Pressure_Drop(
                effectiveness_nom=effectiveness_nom,
                cooling_Q_nom=cooling_Q_nom,
                T_inlet_nom=T_inlet_nom,
                V_dot_nom=V_dot_nom,
                dp_nom=dp_nom,
                medium=Coolant_Medium,
                m=0)           annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={160,50})));
              parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Coolant_Medium = Modelica.Thermal.FluidHeatFlow.Media.Water()
                "Fluid used for cooling the engine"                                                                                                     annotation (choicesAllMatching=true, Dialog(tab="Cooling System"));
              MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                                                            oil_convection(
                  area_for_heat_transfer=0.25)
                "Represents convection path for oil to lose heat through case"
                annotation (Placement(transformation(extent={{120,170},{140,190}})));
              MSL_Extend.Environments.Thermal_To_Environment_Direct
                                                         heat_to_oil
                "heat to oil is sent to environment (which IS the oil)"
                annotation (Placement(transformation(extent={{58,36},{78,56}})));
              parameter Real flow_characteristic[:,:]=[0.000167,1.3e5; 0.0025,1e5; 0.004,
                  0.6e5; 0.005,0.2e5]
                "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref"
                                                                                        annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter SI.AngularVelocity N_ref=314.15926535898
                "Rotational speed at which table data is provided"
                                                                  annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real K=1e-6
                "(Volume flow rate/delta P) Loss Coefficient to model the pump as a simple restriction at low speeds"
                                                                                                                    annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real efficiency_characteristic[:,:]=[-1,0.8; 0,0.8; 1,0.8]
                "Table with efficiency vs. volume flow rate(m3/s) at N_ref"
                                                                          annotation (Dialog(tab="Cooling System", group="Water Pump"));
              parameter Real effectiveness_nom=0.95
                "Nominal effectiveness of the thermal bridge"
                                                             annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Power cooling_Q_nom=300000
                "Nominal heat rejection to the cooling system"
                                                              annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Temperature T_inlet_nom=358.15
                "Nominal coolant inlet temperature"
                annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.VolumeFlowRate V_dot_nom=0.003
                "Nominal coolant volume flow rate"
                                                  annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              parameter SI.Pressure dp_nom=50000
                "Nominal pressure drop in the engine coolant jacket"
                                                                    annotation (Dialog(tab="Cooling System", group="Water Jacket"));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,232},{-190,252}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-128,230},{-108,250}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a top_hose_outlet(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,130},{210,150}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b bottom_hose_in(medium=
                    Coolant_Medium)
                annotation (Placement(transformation(extent={{190,-110},{210,-90}})));
              Modelica.Blocks.Interfaces.RealOutput net_torque annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-40,-106})));
              Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={0,250})));
              Modelica.Blocks.Interfaces.RealOutput speed annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-160,-106})));
              Modelica.Blocks.Interfaces.BooleanInput starter_engage annotation (
                  Placement(transformation(
                    extent={{-20,-20},{20,20}},
                    rotation=270,
                    origin={-60,250})));
              Modelica.Blocks.Interfaces.RealOutput fuel_flow annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=270,
                    origin={-100,-106})));
              MSL_Extend.Thermal.Simple_Conduction_Through_Case
                simple_Conduction_From_Internal_Environment(
                case_thermal_conductivity=case_thermal_conductivity,
                case_heat_transfer_thickness=case_heat_transfer_thickness,
                case_heat_transfer_area=case_heat_transfer_area)
                annotation (Placement(transformation(extent={{82,188},{102,208}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
                annotation (Placement(transformation(extent={{90,230},{110,250}})));
              inner
                MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume           env(fixed_htc=
                   500, medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                annotation (Placement(transformation(extent={{-182,216},{-162,236}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b to_cac(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a from_cac(medium=
                    Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                annotation (Placement(transformation(extent={{-210,150},{-190,170}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Dummy_Turbo
                dummy_Turbo annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=0,
                    origin={-146,182})));
              Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
                annotation (Placement(transformation(extent={{-210,70},{-190,90}})));
              Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
                annotation (Placement(transformation(extent={{-210,30},{-190,50}})));
              MSL_Extend.Electrical.Electric_Machines.Electric_Motor electric_Motor(
                v_nom=24,
                trq_max=600,
                efficiency=1,
                v_max=28,
                trq_nom=500,
                pow_max=60000,
                temp_max=413.15)
                annotation (Placement(transformation(extent={{-164,52},{-144,72}})));
              Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fuel_in(medium=
                    Fuel_Medium)
                annotation (Placement(transformation(extent={{-210,-50},{-190,-30}})));
              C2M2L_Component_Building_Blocks.Prime_Movers.Reciprocating.Compression_Ignition.Table_Based_Engine.Sub_Models.Engine_To_Starter_Motor_Bridge
                engine_To_Starter_Motor_Bridge annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=180,
                    origin={-118,92})));
              MSL_Extend.Thermal.FluidHeatFlow.Components.Thermostats.Thermostat_Simple
                mechanical_Thermostat_Thermal_Inertia(medium=Coolant_Medium)
                                                      annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={164,102})));
              Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe smallResistance(
                medium=Coolant_Medium,
                m=1e-3,
                h_g=0,
                T0=293.15) annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={160,14})));
              Modelica.Blocks.Interfaces.BooleanOutput engine_running annotation (Placement(
                    transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=90,
                    origin={58,250})));
            equation
              connect(engine_heating_model_2.engine_heat_in, torque_and_fueling_1_1.engine_heat_out)
                annotation (Line(
                  points={{-22,48},{-40,48},{-40,5.84615},{-42,5.84615}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.exhaust_heat_out, airflow_Submodel.exhaust_heat_in)
                annotation (Line(
                  points={{-2,40},{12,40},{12,29.8},{16,29.8}},
                  color={191,0,0},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.flange_b, airflow_Submodel.flange_a)
                annotation (Line(
                  points={{-42,-0.307692},{-33,-0.307692},{-33,12},{2,12}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.flange_b, inertia.flange_a) annotation (Line(
                  points={{22,12},{42,12},{42,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.pulley_1_flange, Pump_Base.flange)    annotation (
                  Line(
                  points={{122,-14},{136,-14},{136,-50},{150,-50}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.nominally_driven_pulley, torque_and_fueling_1_1.flange_a)
                annotation (Line(
                  points={{102,-24},{-136,-24},{-136,-0.307692},{-72,-0.307692}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_oil, heat_to_oil.solid) annotation (
                  Line(
                  points={{-2,45.4},{42,45.4},{42,46},{58,46}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.speed, speed) annotation (Line(
                  points={{-68,12.4615},{-160,12.4615},{-160,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.ECU_Throttle_Out, ECU_Throttle_Out)
                annotation (Line(
                  points={{-60,12.7692},{-60,158},{0,158},{0,250}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.fuel_flow, fuel_flow) annotation (Line(
                  points={{-56,12.4615},{-56,144},{-100,144},{-100,-106}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(simple_Conduction_From_Internal_Environment.port_a,
                outer_surface_heat_port)
                annotation (Line(
                  points={{89,205},{89,218.5},{100,218.5},{100,240}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(oil_convection.solid, simple_Conduction_From_Internal_Environment.port_b)
                annotation (Line(
                  points={{120,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_ambient,
                simple_Conduction_From_Internal_Environment.port_b) annotation (Line(
                  points={{-2,56},{26,56},{26,180},{89,180},{89,197}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(pulley_System_1D.support, internalSupport) annotation (Line(
                  points={{112,-34},{112,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.support, internalSupport) annotation (Line(
                  points={{-57,-7.84615},{-57,-50},{0,-50},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(engine_heating_model_2.heat_to_coolant,
                thermal_Bridge_With_Pressure_Drop.heatPort) annotation (Line(
                  points={{-2,50.6},{52,50.6},{52,50},{150,50}},
                  color={191,0,0},
                  smooth=Smooth.None));
              connect(Pump_Base.flowPort_a, bottom_hose_in)
                            annotation (Line(
                  points={{160,-60},{160,-100},{200,-100}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(brg_02, inertia.flange_b) annotation (Line(
                  points={{200,0},{80,0}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.flange_a, brg_01) annotation (
                  Line(
                  points={{-72,-0.307692},{-134,-0.307692},{-134,0},{-200,0}},
                  color={0,0,0},
                  smooth=Smooth.None));

              connect(Pump_Base.support, internalSupport)
                                 annotation (Line(
                  points={{170,-50},{182,-50},{182,-74},{0,-74},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(net_torque, torque_and_fueling_1_1.net_torque) annotation (Line(
                  points={{-40,-106},{-40,-38},{-18,-38},{-18,28},{-52,28},{-52,12.4615}},
                  color={0,0,127},
                  smooth=Smooth.None));

              connect(airflow_Submodel.intake_port, from_cac) annotation (Line(
                  points={{2,20},{-136,20},{-136,160},{-200,160}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(airflow_Submodel.exhaust_port, dummy_Turbo.exh_from_engine)
                annotation (Line(
                  points={{22,20},{38,20},{38,172},{-144,172}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.exh_to_downpipe, fluid_out) annotation (Line(
                  points={{-138,192},{-118,192},{-118,240}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.from_filter, fluid_in) annotation (Line(
                  points={{-154,192},{-200,192},{-200,242}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(dummy_Turbo.to_cac, to_cac) annotation (Line(
                  points={{-148,192},{-148,206},{-180,206},{-180,120},{-200,120}},
                  color={255,0,0},
                  smooth=Smooth.None));

              connect(electric_Motor.n, pin_n) annotation (Line(
                  points={{-154,54},{-154,40},{-200,40}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(electric_Motor.p, pin_p) annotation (Line(
                  points={{-154,70},{-154,80},{-200,80}},
                  color={0,0,255},
                  smooth=Smooth.None));
              connect(electric_Motor.support, internalSupport) annotation (Line(
                  points={{-164,62},{-172,62},{-172,-50},{0,-50},{0,-80}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(fuel_in, torque_and_fueling_1_1.port_a) annotation (Line(
                  points={{-200,-40},{-48,-40},{-48,12}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(engine_To_Starter_Motor_Bridge.demand, electric_Motor.demand)
                annotation (Line(
                  points={{-128,92},{-132,92},{-132,65},{-143.4,65}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(torque_and_fueling_1_1.engine_running, engine_To_Starter_Motor_Bridge.engine_running)
                annotation (Line(
                  points={{-64,12.4615},{-64,94},{-108,94}},
                  color={255,0,255},
                  smooth=Smooth.None));
              connect(engine_To_Starter_Motor_Bridge.starter_engage, starter_engage)
                annotation (Line(
                  points={{-108,90},{-76,90},{-76,202},{-60,202},{-60,250}},
                  color={255,0,255},
                  smooth=Smooth.None));
              connect(electric_Motor.flange, torque_and_fueling_1_1.flange_a) annotation (
                  Line(
                  points={{-144,62},{-132,62},{-132,60},{-114,60},{-114,-0.307692},{-72,
                      -0.307692}},
                  color={0,0,0},
                  smooth=Smooth.None));
              connect(mechanical_Thermostat_Thermal_Inertia.main_outlet, top_hose_outlet)
                annotation (Line(
                  points={{160,112},{160,140},{200,140}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(thermal_Bridge_With_Pressure_Drop.flowPort_b, smallResistance.flowPort_b)
                annotation (Line(
                  points={{160,40},{160,24}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(smallResistance.flowPort_a, Pump_Base.flowPort_b)
                annotation (Line(
                  points={{160,4},{160,-40}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(mechanical_Thermostat_Thermal_Inertia.inlet,
                thermal_Bridge_With_Pressure_Drop.flowPort_a) annotation (Line(
                  points={{160,92},{160,60}},
                  color={255,0,0},
                  smooth=Smooth.None));
              connect(mechanical_Thermostat_Thermal_Inertia.bypass_outlet, Pump_Base.flowPort_a)
                annotation (Line(
                  points={{167.8,112},{167.8,118},{186,118},{186,-76},{160,-76},{160,-60}},
                  color={255,0,0},
                  smooth=Smooth.None));

              connect(torque_and_fueling_1_1.engine_running, engine_running) annotation (
                  Line(
                  points={{-64,12.4615},{-64,128},{58,128},{58,250}},
                  color={255,0,255},
                  smooth=Smooth.None));
              annotation (
                Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-100},{200,
                        240}}), graphics),
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-100},{200,
                        240}}), graphics),
                Documentation(info="<html>
<p>Operation:</p>
<p><br/>Transmits torque at output flange, torque output is based on flange speed and a torque demand signal. Generates heat proportional to power produced, and is split between exhaust, coolant, ambient air, and engine oil. An airflow submodel generates mass flows required for intake and exhaust streams.</p>
<p><br/>Model Limitations: </p>
<p>The model does not simulate combustion.</p>
<p><br/>Physical Limits:</p>
</html>"));
            end Example_Engine_Basic_Advanced;

            package Tests
              extends Modelica.Icons.Package;

              model Test_Driver
                extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;
                Modelica.Blocks.Sources.Constant wot(k=1) "wide open throttle"
                  annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
                Modelica.Blocks.Sources.BooleanConstant booleanConstant(k=false)
                  annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
                Modelica.Blocks.Interfaces.BooleanOutput starter_engage
                  annotation (Placement(transformation(extent={{96,40},{116,60}})));
                Modelica.Blocks.Interfaces.RealOutput ECU_Throttle_Out
                  annotation (Placement(transformation(extent={{96,-10},{116,10}})));
              equation
                connect(booleanConstant.y, starter_engage) annotation (Line(
                    points={{-19,50},{106,50}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(wot.y, ECU_Throttle_Out) annotation (Line(
                    points={{-19,0},{106,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                        preserveAspectRatio=false),graphics),                          Icon(
                      coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=
                          true), graphics));
              end Test_Driver;

              model Test_Driver_adv
                extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;
                Modelica.Blocks.Sources.Constant wot(k=1) "wide open throttle"
                  annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
                Modelica.Blocks.Sources.BooleanTable    booleanConstant(table={0.1,10})
                  annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
                Modelica.Blocks.Interfaces.BooleanOutput starter_engage
                  annotation (Placement(transformation(extent={{96,40},{116,60}})));
                Modelica.Blocks.Interfaces.RealOutput ECU_Throttle_Out
                  annotation (Placement(transformation(extent={{96,-10},{116,10}})));
              equation
                connect(wot.y, ECU_Throttle_Out) annotation (Line(
                    points={{-19,0},{106,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(starter_engage, booleanConstant.y) annotation (Line(
                    points={{106,50},{-19,50}},
                    color={255,0,255},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                        preserveAspectRatio=false),graphics),                          Icon(
                      coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=
                          true), graphics));
              end Test_Driver_adv;

              model test_engine "Test engine on a dyno"
                extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

                MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Simple_Dyno
                                           simple_Dyno(
                  J=1,
                  max_res_trq=40000,
                  k=50,
                  Ti=10,
                  controllerType=Modelica.Blocks.Types.SimpleController.PI,
                  trq_start=1,
                  use_rpm=true)
                  annotation (Placement(transformation(extent={{76,-32},{116,28}})));
                Example_Engine_Basic
                  example_Engine_Basic
                  annotation (Placement(transformation(extent={{-40,-32},{2,4}})));

                C2M2L_OM.MSL_Extend.Blocks.Sources.Steps_Multiple speed_steps(
                  offset=700,
                  length=100,
                  height=200) annotation (Placement(transformation(extent={{30,60},{50,80}})));
                Tests.Test_Driver
                  test_driver annotation (Placement(transformation(rotation=0, extent={{-80,
                          80},{-60,100}})));
                inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                                env(fixed_htc=
                     200) annotation (Placement(transformation(extent={{-6,74},{14,94}})));
                MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                  thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
                  annotation (Placement(transformation(extent={{-6,34},{14,54}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                                      air_Path_For_Testing(
                    medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                  annotation (Placement(transformation(extent={{-50,24},{-30,44}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
                  cooling_Cart_For_Testing(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(extent={{18,-34},{38,-14}})));
              equation

                connect(speed_steps.y, simple_Dyno.request_speed) annotation (Line(
                    points={{51,70},{96,70},{96,31}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(simple_Dyno.flange_a, example_Engine_Basic.brg_02)
                  annotation (Line(
                    points={{76,-2},{38,-2},{38,-21.4118},{2,-21.4118}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(test_driver.ECU_Throttle_Out, example_Engine_Basic.ECU_Throttle_Out)
                  annotation (Line(
                    points={{-59.4,90},{-19,90},{-19,5.05882}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(test_driver.starter_engage, example_Engine_Basic.starter_engage)
                  annotation (Line(
                    points={{-59.4,95},{-25.3,95},{-25.3,5.05882}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
                  annotation (Line(
                    points={{-6,44},{-8.5,44},{-8.5,4}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
                  annotation (Line(
                    points={{-34,24},{-34,15},{-31.39,15},{-31.39,4}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
                  annotation (Line(
                    points={{-40,4.21176},{-44,4.21176},{-44,24},{-46,24}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
                  annotation (Line(
                    points={{18,-18},{12,-18},{12,-6.58824},{2,-6.58824}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
                  annotation (Line(
                    points={{18,-30},{10,-30},{10,-32},{2,-32}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(extent={{-100,-100},{140,120}},
                        preserveAspectRatio=false),
                                    graphics),
                  experiment(StopTime=1000),
                  __Dymola_experimentSetupOutput,
                  Icon(coordinateSystem(extent={{-100,-100},{140,120}})));
              end test_engine;

              model test_engine_adv "Test engine on a dyno"
                extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

                MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Dyno_Non_Motoring
                                           simple_Dyno(w_start=0)
                  annotation (Placement(transformation(extent={{76,-32},{116,28}})));
                Example_Engine_Basic_Advanced
                  example_Engine_Basic
                  annotation (Placement(transformation(extent={{-40,-32},{2,4}})));

                C2M2L_OM.MSL_Extend.Blocks.Sources.Steps_Multiple speed_steps(
                  offset=700,
                  length=100,
                  height=200) annotation (Placement(transformation(extent={{30,60},{50,80}})));
                Test_Driver_adv
                  test_driver annotation (Placement(transformation(rotation=0, extent={{-80,
                          80},{-60,100}})));
                inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                                env(fixed_htc=
                     200) annotation (Placement(transformation(extent={{-6,74},{14,94}})));
                MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                  thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
                  annotation (Placement(transformation(extent={{-6,34},{14,54}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                                      air_Path_For_Testing(
                    medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                  annotation (Placement(transformation(extent={{-50,24},{-30,44}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
                  cooling_Cart_For_Testing(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(extent={{18,-34},{38,-14}})));

                Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=24)
                  annotation (Placement(transformation(extent={{-80,-42},{-60,-22}})));
                Modelica.Electrical.Analog.Basic.Ground ground
                  annotation (Placement(transformation(extent={{-54,-58},{-34,-38}})));
                Fuel_System.Fuel_Tank fuel_Tank(medium=
                      C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
                  annotation (Placement(transformation(extent={{-96,-116},{-56,-56}})));
              equation

                connect(test_driver.ECU_Throttle_Out, example_Engine_Basic.ECU_Throttle_Out)
                  annotation (Line(
                    points={{-59.4,90},{-19,90},{-19,5.05882}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(test_driver.starter_engage, example_Engine_Basic.starter_engage)
                  annotation (Line(
                    points={{-59.4,95},{-25.3,95},{-25.3,5.05882}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
                  annotation (Line(
                    points={{-6,44},{-8.5,44},{-8.5,4}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
                  annotation (Line(
                    points={{-34,24},{-34,15},{-31.39,15},{-31.39,4}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
                  annotation (Line(
                    points={{-40,4.21176},{-44,4.21176},{-44,24},{-46,24}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.pin_p, constantVoltage.p) annotation (Line(
                    points={{-40,-12.9412},{-62,-12.9412},{-62,-14},{-80,-14},{-80,-32}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(constantVoltage.n, example_Engine_Basic.pin_n) annotation (Line(
                    points={{-60,-32},{-58,-32},{-58,-24},{-44,-24},{-44,-17.1765},{-40,
                        -17.1765}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(ground.p, constantVoltage.n) annotation (Line(
                    points={{-44,-38},{-52,-38},{-52,-32},{-60,-32}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(fuel_Tank.fluid_out, example_Engine_Basic.fuel_in) annotation (Line(
                    points={{-84.2,-59.8},{-50.1,-59.8},{-50.1,-25.6471},{-40,-25.6471}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.from_cac, example_Engine_Basic.to_cac)
                  annotation (Line(
                    points={{-40,-4.47059},{-46,-4.47059},{-46,-6},{-50,-6},{-50,-8.70588},{
                        -40,-8.70588}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(simple_Dyno.Set_Speed_rpm, speed_steps.y) annotation (Line(
                    points={{96,24},{96,70},{51,70}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(simple_Dyno.brg_01, example_Engine_Basic.brg_02) annotation (Line(
                    points={{76,0},{38,0},{38,-21.4118},{2,-21.4118}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
                  annotation (Line(
                    points={{18,-18},{2,-18},{2,-6.58824}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
                  annotation (Line(
                    points={{18,-30},{12,-30},{12,-32},{2,-32}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(extent={{-100,-100},{140,120}},
                        preserveAspectRatio=false),
                                    graphics),
                  experiment(StopTime=1000),
                  __Dymola_experimentSetupOutput,
                  Icon(coordinateSystem(extent={{-100,-100},{140,120}})));
              end test_engine_adv;

              model test_engine_adv_wo_electric_and_termostat
                "Test engine on a dyno"
                extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

                MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Simple_Dyno
                                           simple_Dyno(
                  J=1,
                  max_res_trq=40000,
                  k=50,
                  Ti=10,
                  controllerType=Modelica.Blocks.Types.SimpleController.PI,
                  trq_start=1,
                  use_rpm=true)
                  annotation (Placement(transformation(extent={{76,-52},{116,8}})));
                Example_Engine_Basic_wFuel
                  example_Engine_Basic
                  annotation (Placement(transformation(extent={{-40,-32},{2,4}})));

                C2M2L_OM.MSL_Extend.Blocks.Sources.Steps_Multiple speed_steps(
                  offset=700,
                  length=100,
                  height=200) annotation (Placement(transformation(extent={{30,60},{50,80}})));
                Test_Driver_adv
                  test_driver annotation (Placement(transformation(rotation=0, extent={{-80,
                          80},{-60,100}})));
                inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                                env(fixed_htc=
                     200) annotation (Placement(transformation(extent={{-6,74},{14,94}})));
                MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
                  thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
                  annotation (Placement(transformation(extent={{-6,34},{14,54}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                                      air_Path_For_Testing(
                    medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                  annotation (Placement(transformation(extent={{-50,24},{-30,44}})));
                MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
                  cooling_Cart_For_Testing(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(extent={{18,-34},{38,-14}})));

                Fuel_System.Fuel_Tank fuel_Tank(medium=
                      C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
                  annotation (Placement(transformation(extent={{-96,-116},{-56,-56}})));
              equation

                connect(test_driver.ECU_Throttle_Out, example_Engine_Basic.ECU_Throttle_Out)
                  annotation (Line(
                    points={{-59.4,90},{-19,90},{-19,5.05882}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(test_driver.starter_engage, example_Engine_Basic.starter_engage)
                  annotation (Line(
                    points={{-59.4,95},{-25.3,95},{-25.3,5.05882}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
                  annotation (Line(
                    points={{-6,44},{-8.5,44},{-8.5,4}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
                  annotation (Line(
                    points={{-34,24},{-34,15},{-31.39,15},{-31.39,4}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
                  annotation (Line(
                    points={{-40,4.21176},{-44,4.21176},{-44,24},{-46,24}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fuel_Tank.fluid_out, example_Engine_Basic.fuel_in) annotation (Line(
                    points={{-84.2,-59.8},{-50.1,-59.8},{-50.1,-25.6471},{-40,-25.6471}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic.from_cac, example_Engine_Basic.to_cac)
                  annotation (Line(
                    points={{-40,-4.47059},{-46,-4.47059},{-46,-6},{-50,-6},{-50,-8.70588},{
                        -40,-8.70588}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
                  annotation (Line(
                    points={{18,-18},{2,-18},{2,-6.58824}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
                  annotation (Line(
                    points={{18,-30},{12,-30},{12,-32},{2,-32}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(simple_Dyno.request_speed, speed_steps.y) annotation (Line(
                    points={{96,11},{100,11},{100,66},{51,66},{51,70}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(simple_Dyno.flange_a, example_Engine_Basic.brg_02) annotation (Line(
                    points={{76,-22},{39,-22},{39,-21.4118},{2,-21.4118}},
                    color={0,0,0},
                    smooth=Smooth.None));
                annotation (Diagram(coordinateSystem(extent={{-100,-100},{140,120}},
                        preserveAspectRatio=false),
                                    graphics),
                  experiment(StopTime=1000),
                  __Dymola_experimentSetupOutput,
                  Icon(coordinateSystem(extent={{-100,-100},{140,120}})));
              end test_engine_adv_wo_electric_and_termostat;
            end Tests;

            package OM2EXT
              extends Modelica.Icons.Package;
              expandable connector Engine_Control_Bus
                "An expandable connector used as engine control bus"
              extends
                  C2M2L_OM.MSL_Extend.Icons.Signal_Sub_Buses_Colored.Light_Gray;
                Real ECU_Throttle_Out
                  "Adjusted throttle from ECU, goes to engine 0-1";
                Boolean starter_engage "if true engage starting device";
                SI.Conversions.NonSIunits.AngularVelocity_rpm speed
                  "Speed of engine";
                SI.Torque net_torque "Net torque out of engine";
                SI.MassFlowRate fuel_flow "Fuel flow rate into engine";
                Boolean engine_running
                  "=true, if engine is sulf sustaining (e.g. above cranking speed)";
              //  Real airflow "Airflow into combustion chamber for cycle, in g/s";
              //  Real fuel_mass
              //   "Fuel mass requested into the combustion chamber for the current cycle, in grams";

                annotation (
                  defaultComponentPrefixes="protected",
                  Icon(graphics={Rectangle(
                        extent={{-48,28},{44,-18}},
                        lineColor={175,175,175},
                        lineThickness=0.5)}),
                  Documentation(info="<html>
<p>Should be used to contain signals determined in the engine controller.  It is defined as an empty expandable connector.</p>
</html>"));
              end Engine_Control_Bus;

              model Example_Engine_Basic_Advanced_OM2EXT
                "Example of an engine implemented using tables"
                parameter Boolean useSupport=false
                  "= true, if support flange enabled, otherwise implicitly grounded"
                  annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
                import NonSI = Modelica.SIunits.Conversions.NonSIunits;
                parameter Boolean useSimpleCoolant = false;
                parameter Boolean useSimpleFuel = false;
                parameter Boolean useSimpleAir = false;
                parameter Boolean useSimpleMechanics = false;
                parameter Boolean useBus = true;
                parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Coolant_Medium = Modelica.Thermal.FluidHeatFlow.Media.Water()
                  "Coolant medium Fluid Heat Flow"                                                                                                     annotation (choicesAllMatching=true, Dialog(tab="Cooling System"));
                parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Fuel_Medium = C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8()
                  "Fuel medium Fluid Heat Flow"                                                                                                     annotation (choicesAllMatching=true);
                replaceable package Air_Medium_Fluid =
                  Modelica.Media.Interfaces.PartialMedium "Air medium Fluid" annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));
                replaceable package Coolant_Medium_Fluid =
                  Modelica.Media.Interfaces.PartialMedium
                  "Coolant medium Fluid"                                         annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));
                replaceable package Fuel_Medium_Fluid =
                  Modelica.Media.Interfaces.PartialMedium "Fuel medium Fluid" annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

                parameter SI.Area case_heat_transfer_area=1.0
                  "Area available for heat to transfer through case"
                  annotation (Dialog(tab="Thermal Model"));
                parameter SI.Thickness case_heat_transfer_thickness=0.005
                  "Effective case thickness for heat transfer"
                  annotation (Dialog(tab="Thermal Model"));
                parameter SI.ThermalConductivity case_thermal_conductivity=50
                  "Conductivity of case" annotation (Dialog(tab="Thermal Model"));

                parameter SI.Torque friction_map[:,2]=[0,1; 1,120; 10,120; 187.5001584,220;
                    375.0003167,325; 562.5004751,425; 700.0005913,500; 750.0006335,527;
                    800.0006757,555; 850.000718,580; 900.0007602,610; 950.0008024,636;
                    1000.000845,665; 1050.000887,690; 1100.000929,720; 1150.000971,745;
                    1200.001014,770; 1250.001056,800; 1300.001098,825; 1350.00114,855;
                    1400.001183,880; 1450.001225,910; 1500.001267,935; 1550.001309,965;
                    1600.001351,990; 1650.001394,1020; 1700.001436,1045; 1750.001478,1070;
                    1800.00152,1100; 1850.001563,1125; 1900.001605,1153; 1950.001647,1180;
                    2000.001689,1210; 2050.001732,1235; 2100.001774,1260; 2150.001816,1290;
                    2250,1290; 2300,1290]
                  "Table of speed (rpm) vs engine friction torque";
                parameter SI.Torque torque_map[:,2]=[562.5004751,420; 700.0005913,1000;
                    750.0006335,1225; 800.0006757,1360; 850.000718,1480; 900.0007602,1585;
                    950.0008024,1685; 1000.000845,1775; 1050.000887,1860; 1100.000929,1945;
                    1150.000971,2025; 1200.001014,2065; 1250.001056,2080; 1300.001098,2080;
                    1350.00114,2060; 1400.001183,2035; 1450.001225,2010; 1500.001267,1975;
                    1550.001309,1925; 1600.001351,1875; 1650.001394,1825; 1700.001436,1775;
                    1750.001478,1725; 1800.00152,1675; 1850.001563,1625; 1900.001605,1585;
                    1950.001647,1535; 2000.001689,1485; 2050.001732,1440; 2100.001774,1390;
                    2150.001816,1330; 2250,0; 2255,0]
                  " Table of speed(rpm) vs engine torque at WOT";
                parameter SI.MassFlowRate fuel_map[:,:]=[0,0,10,500.0004223,550.0004646,
                    600.0005068,650.000549,700.0005913,750.0006335,800.0006757,850.000718,
                    900.0007602,950.0008024,1000.000845,1050.000887,1100.000929,1150.000971,
                    1200.001014,1250.001056,1300.001098,1350.00114,1400.001183,1450.001225,
                    1500.001267,1550.001309,1600.001351,1650.001394,1700.001436,1750.001478,
                    1800.00152,1850.001563,1900.001605,1950.001647,2000.001689,2050.001732,
                    2100.001774,2150.001816,2200.001858,2250.0019; 0,0,0,0.000115077,
                    0.000134841,0.000157082,0.000179875,0.000207374,0.000234876,0.000261386,
                    0.000291112,0.00032447,0.000358984,0.000388806,0.000425181,0.000469451,
                    0.000503569,0.000546567,0.0006147,0.000690695,0.000757855,0.000830525,
                    0.000923075,0.001003919,0.001082698,0.001182413,0.001283234,0.001374041,
                    0.001458324,0.001582554,0.001698684,0.001792534,0.001896859,0.002015258,
                    0.002136724,0.002289975,0.002394179,0.002556089,0.002698939; 70.05060006,
                    0,0,0.000357347,0.000396983,0.000438847,0.000478967,0.000520609,
                    0.000566196,0.000605333,0.000651545,0.000704011,0.000754256,0.000801822,
                    0.000851797,0.000906041,0.00094958,0.001009562,0.001087556,0.001184368,
                    0.001253784,0.001365088,0.001437915,0.00155706,0.001661825,0.001756577,
                    0.00185663,0.00199224,0.002101612,0.002218382,0.002333051,0.002469539,
                    0.002592001,0.002730314,0.002859046,0.003012337,0.003133989,0.003293779,
                    0.003461377; 140.1012001,0,0,0.000599708,0.000648694,0.000708328,
                    0.000766908,0.000838683,0.000887612,0.000951407,0.001025648,0.001067673,
                    0.001150541,0.001201261,0.001278282,0.001350712,0.001411658,0.001475311,
                    0.001579904,0.001680621,0.001773634,0.00186571,0.001972046,0.002103904,
                    0.002226054,0.002312078,0.002449318,0.002587895,0.00268291,0.002833754,
                    0.002957563,0.003137412,0.00325725,0.003436602,0.0035697,0.00375666,
                    0.003909565,0.004083891,0.004273732; 210.1518002,0,0,0.000828053,
                    0.000905628,0.000990726,0.001058494,0.001144932,0.001214673,0.001295964,
                    0.001377572,0.001468351,0.001530065,0.001614283,0.001681968,0.001772218,
                    0.001871811,0.001952415,0.002032151,0.00214057,0.002270388,0.002369926,
                    0.002511775,0.002612639,0.002748628,0.002923005,0.003051573,0.003149479,
                    0.003329422,0.003473512,0.003627706,0.003772651,0.00394143,0.004157803,
                    0.004346105,0.004472209,0.0046636,0.004865091,0.005114112; 280.2024002,0,
                    0,0.001075936,0.001172941,0.001274854,0.001370625,0.001455299,0.001563224,
                    0.001660534,0.001745645,0.001832013,0.001913631,0.002028647,0.002126145,
                    0.002195082,0.002322944,0.002393616,0.002525453,0.002671998,0.002754556,
                    0.002905384,0.003072071,0.003182469,0.003329846,0.003495536,0.003630398,
                    0.003807147,0.003921153,0.004084166,0.004275935,0.004434841,0.00465945,
                    0.004813804,0.005017551,0.005215954,0.005449868,0.005690319,0.005955481;
                    350.2530003,0,0,0.001322565,0.001421465,0.001557601,0.00165054,
                    0.001774169,0.00188381,0.002007638,0.002112904,0.002213298,0.002294493,
                    0.002434271,0.002523673,0.002623304,0.002741966,0.002871303,0.002972217,
                    0.003120798,0.003255239,0.003426645,0.003548528,0.003743814,0.003853752,
                    0.004037267,0.004204037,0.004442107,0.004580722,0.004736006,0.00492388,
                    0.005188689,0.0053141,0.005609333,0.005778653,0.006059417,0.006295564,
                    0.006489461,0.006661956; 420.3036003,0,0,0.001554639,0.001699166,
                    0.001811233,0.001955902,0.002099137,0.002223466,0.002321325,0.002469554,
                    0.002598381,0.002733371,0.002842161,0.002928576,0.003094608,0.003199881,
                    0.003316755,0.003482078,0.00360855,0.003804304,0.003923034,0.004077374,
                    0.004278201,0.004421149,0.004590714,0.004858417,0.004996542,0.005158069,
                    0.005357129,0.005601556,0.005858407,0.00599737,0.006304847,0.0065581,
                    0.006816798,0.006995613,0.007301837,0.007497616; 490.3542004,0,0,
                    0.001807824,0.001956499,0.002097762,0.002263333,0.002402906,0.002517197,
                    0.002693621,0.002811624,0.002969092,0.003076745,0.003218626,0.003399024,
                    0.003545868,0.003659694,0.003826696,0.003951532,0.004119462,0.00427216,
                    0.004484229,0.004653266,0.004846958,0.005071501,0.005196311,0.00543916,
                    0.005668657,0.00583742,0.006097476,0.006294829,0.006470421,0.006733115,
                    0.006955381,0.007232631,0.007482187,0.007866234,0.008037662,0.008337939;
                    560.4048004,0,0,0.002036092,0.002185866,0.002364543,0.002540243,
                    0.00271881,0.002886187,0.003052666,0.0031862,0.003362409,0.003457437,
                    0.003634524,0.00380104,0.003921823,0.004135659,0.004275741,0.004433496,
                    0.004649183,0.004805937,0.005019275,0.005235527,0.005354848,0.005572661,
                    0.005844605,0.006073066,0.006220582,0.006458678,0.006740624,0.006977103,
                    0.00721282,0.007497557,0.007742057,0.008040882,0.008362483,0.008608584,
                    0.008867068,0.009170346; 630.4554005,0,0,0.002257567,0.002467794,
                    0.002675342,0.00284593,0.002995089,0.003165995,0.003346948,0.003566379,
                    0.003680615,0.003885091,0.00408557,0.004212524,0.004397487,0.004525951,
                    0.004755746,0.00487956,0.005113773,0.005353434,0.005508666,0.005781315,
                    0.00597662,0.006146354,0.006348415,0.006624572,0.006883208,0.007064022,
                    0.007378966,0.007621634,0.007916153,0.008093021,0.008500802,0.00880721,
                    0.009061799,0.009338996,0.009702039,0.010115007; 700.5060006,0,0,
                    0.002484499,0.002698238,0.002925589,0.003104628,0.003304758,0.003550228,
                    0.003678892,0.003886873,0.004102561,0.004264028,0.004433628,0.00464125,
                    0.004826817,0.005020603,0.005233626,0.005404906,0.005634196,0.00576674,
                    0.005996037,0.006205576,0.006536924,0.006784112,0.007039717,0.007208007,
                    0.007494016,0.007758994,0.008054669,0.008301443,0.008603607,0.008843489,
                    0.00918076,0.009455755,0.009868793,0.010143845,0.010617307,0.010818546;
                    770.5566006,0,0,0.002732385,0.002974377,0.003225061,0.003416013,
                    0.003603968,0.0038798,0.004042562,0.004265259,0.00448914,0.00466634,
                    0.004877442,0.0050133,0.00520751,0.00541228,0.00566104,0.005867669,
                    0.006148112,0.006361315,0.006529102,0.006866272,0.007037468,0.007355363,
                    0.007573933,0.007789419,0.008177144,0.008415082,0.008628315,0.008948014,
                    0.009288249,0.00956245,0.010012595,0.010269215,0.010657043,0.011082045,
                    0.01139578,0.011688953; 840.6072007,0,0,0.00299129,0.003260322,
                    0.003471621,0.003712241,0.003981027,0.004162821,0.004406188,0.004603203,
                    0.004848076,0.005038012,0.005217561,0.005515822,0.005638551,0.005882173,
                    0.006138352,0.0063399,0.00656249,0.006818514,0.007139423,0.007277906,
                    0.007552308,0.00789139,0.00815197,0.008443037,0.008802596,0.0089559,
                    0.009277344,0.00958275,0.009928593,0.010407144,0.010767236,0.011064698,
                    0.01131228,0.011908425,0.012226302,0.012517; 910.6578007,0,0,0.003216134,
                    0.003483667,0.003727712,0.004030699,0.004229468,0.004461442,0.004776539,
                    0.005026396,0.005233455,0.005421065,0.005727613,0.005867425,0.006069297,
                    0.006320983,0.006520323,0.006802302,0.00703797,0.007297502,0.007678125,
                    0.007925697,0.008129177,0.008529737,0.008778909,0.00912278,0.009316539,
                    0.009753951,0.009913522,0.010246687,0.010697352,0.011008774,0.011440212,
                    0.011722308,0.012302719,0.012506738,0.012942023,0.013455971; 980.7084008,
                    0,0,0.00346327,0.003740348,0.004012176,0.004323632,0.004555522,
                    0.004839654,0.005090728,0.005288571,0.005621454,0.00583595,0.006080784,
                    0.006367581,0.006510202,0.006834616,0.007071574,0.007269451,0.007653234,
                    0.007868246,0.008137207,0.008502116,0.008804794,0.008965911,0.009314721,
                    0.009674163,0.010077612,0.010362149,0.010686452,0.010993431,0.011303646,
                    0.011694833,0.012169998,0.012631742,0.012933236,0.013334194,0.013962171,
                    0.014385005; 1050.759001,0,0,0.003677872,0.003967137,0.004313352,
                    0.004613478,0.00487842,0.00516083,0.005393888,0.005656384,0.006004634,
                    0.006183179,0.006453491,0.006739075,0.007018065,0.00724722,0.007564644,
                    0.007821356,0.008163492,0.008397831,0.008601057,0.009004931,0.009303597,
                    0.009518848,0.010008583,0.010316464,0.010538598,0.011037697,0.011420607,
                    0.011643522,0.012020386,0.012588258,0.013046583,0.01327526,0.013873753,
                    0.014384339,0.014667764,0.015256557; 1120.809601,0,0,0.003931094,
                    0.004261234,0.00454188,0.004890058,0.005177477,0.005484366,0.005786588,
                    0.006043486,0.006344013,0.006550229,0.006837473,0.007164386,0.007450865,
                    0.007666174,0.007994788,0.008268723,0.008554573,0.008916318,0.009216168,
                    0.009467362,0.009919672,0.010231056,0.010536456,0.010956879,0.011342154,
                    0.011587639,0.01194467,0.012401861,0.012784508,0.013336535,0.013670403,
                    0.014160269,0.014677751,0.015108747,0.015685437,0.016035555; 1190.860201,
                    0,0,0.004168882,0.004481686,0.004843021,0.005199923,0.005430119,
                    0.005753059,0.00609522,0.006411217,0.006712729,0.006979124,0.007223317,
                    0.007513525,0.007807537,0.008118786,0.00841761,0.008741523,0.009118388,
                    0.009453152,0.009706962,0.010066364,0.010510908,0.0108627,0.011087475,
                    0.011408834,0.011843639,0.012258113,0.012582015,0.013125443,0.013553887,
                    0.013970755,0.014454671,0.014797075,0.015347466,0.015807182,0.016451679,
                    0.017075723; 1260.910801,0,0,0.004397181,0.004757047,0.005103052,
                    0.005491066,0.005831324,0.006158052,0.006383534,0.006760492,0.0070166,
                    0.007411542,0.00770397,0.00802494,0.008359863,0.008666293,0.008957514,
                    0.009165463,0.009594792,0.009855532,0.010207109,0.010626353,0.010935797,
                    0.011337457,0.011712058,0.012085334,0.012594147,0.012999442,0.013397101,
                    0.013751069,0.014172464,0.014810247,0.015235835,0.015700934,0.016293985,
                    0.016644077,0.017285695,0.017768817; 1330.961401,0,0,0.004651163,
                    0.005026823,0.005402895,0.005766842,0.006061432,0.006487762,0.006843933,
                    0.007121371,0.007487373,0.007826556,0.008121261,0.008456308,0.008785913,
                    0.009064373,0.009295403,0.009715569,0.009988033,0.010339149,0.010802942,
                    0.01125246,0.011575269,0.012000549,0.012269241,0.01267643,0.013191945,
                    0.013525161,0.014115653,0.014486879,0.015029543,0.015500716,0.015916054,
                    0.016528683,0.017148035,0.017749178,0.018321747,0.018778942; 1401.012001,
                    0,0,0.004868125,0.005268141,0.005672144,0.005970351,0.006417673,
                    0.006731039,0.007147921,0.007520983,0.007815652,0.008226698,0.008541171,
                    0.008921184,0.009227145,0.009536486,0.009822676,0.010242214,0.010575352,
                    0.011010919,0.011302544,0.011657088,0.012215878,0.012565798,0.012986346,
                    0.013348034,0.013769634,0.014290683,0.014740778,0.01530434,0.015688458,
                    0.01632077,0.016784045,0.017251392,0.018000138,0.018483624,0.018983713,
                    0.019807532; 1471.062601,0,0,0.005084936,0.005458776,0.00593416,
                    0.006288746,0.006705037,0.007120778,0.007409511,0.007822573,0.008223948,
                    0.008592197,0.008875517,0.009276453,0.009626549,0.010026559,0.010408733,
                    0.010669618,0.011086296,0.011514068,0.011913256,0.012178626,0.012588932,
                    0.013140048,0.013414875,0.014120182,0.014448596,0.014856152,0.015279907,
                    0.015778582,0.016450611,0.016915405,0.017692328,0.01805522,0.018849983,
                    0.019250228,0.019863646,0.020545776; 1541.113201,0,0,0.005322789,
                    0.005760758,0.006144848,0.006579486,0.007019394,0.007385693,0.00788008,
                    0.008154316,0.008590492,0.008907259,0.009299089,0.009645807,0.009964867,
                    0.01039708,0.010727767,0.01110816,0.011517292,0.012030419,0.012294601,
                    0.012942519,0.013381089,0.01381138,0.014049788,0.014509783,0.015113865,
                    0.015674113,0.016055315,0.016715072,0.017077274,0.017767526,0.018364758,
                    0.019097406,0.019658994,0.020167293,0.020711705,0.021391838; 1611.163801,
                    0,0,0.005585518,0.006046334,0.006470078,0.006881721,0.007337968,
                    0.007706548,0.008128958,0.008600037,0.008956296,0.009412755,0.00963958,
                    0.010207281,0.010398253,0.010972285,0.011184975,0.011718407,0.012009637,
                    0.012512584,0.012829528,0.0134051,0.013778829,0.014205722,0.014634989,
                    0.015223219,0.015681341,0.016192232,0.016789262,0.017301545,0.01802162,
                    0.018672868,0.019055634,0.019606547,0.020318571,0.020995307,0.021948286,
                    0.022369534; 1681.214401,0,0,0.00580822,0.006239558,0.006725818,
                    0.007139663,0.007598026,0.00799661,0.008437593,0.008858054,0.009240434,
                    0.009632173,0.010052063,0.010562072,0.011024636,0.011266265,0.01175001,
                    0.012083814,0.012547809,0.013101742,0.013421004,0.014077723,0.014457881,
                    0.014888169,0.015515448,0.015774752,0.016279644,0.016911205,0.017575726,
                    0.018203882,0.018572337,0.019327737,0.020080611,0.020663778,0.0214107,
                    0.022161204,0.022609906,0.023371961; 1751.265001,0,0,0.006024714,
                    0.006524754,0.006973102,0.007467878,0.007965018,0.008346405,0.00876786,
                    0.0093003,0.009735957,0.010048707,0.010506915,0.011003701,0.0112886,
                    0.011873966,0.012182415,0.012726615,0.013171612,0.013452978,0.014120787,
                    0.014422004,0.015045127,0.015438329,0.015986429,0.01667792,0.016990224,
                    0.017617956,0.018109371,0.018640698,0.019358914,0.019885114,0.020795869,
                    0.02145395,0.022212409,0.023022136,0.023531056,0.024393712; 1821.315601,0,
                    0,0.006272467,0.006799419,0.007236376,0.007695629,0.008155356,0.008670651,
                    0.009106478,0.009672616,0.010037909,0.010507354,0.010960744,0.011448319,
                    0.011745923,0.012329444,0.012592855,0.013187059,0.013701727,0.014060923,
                    0.014664001,0.015039247,0.015403357,0.016007313,0.016716368,0.01707071,
                    0.017727,0.018115521,0.01888072,0.019690098,0.020004921,0.020978982,
                    0.021659837,0.022280838,0.022975004,0.023647303,0.024311889,0.02559746;
                    1891.366202,0,0,0.006451807,0.007065943,0.007524016,0.008031644,
                    0.008482568,0.009054633,0.009543535,0.009909258,0.010355249,0.010971986,
                    0.011240071,0.011812855,0.012327586,0.01261866,0.013166196,0.013694648,
                    0.014173035,0.014572982,0.015143891,0.015588356,0.016204265,0.016764909,
                    0.017131201,0.017687068,0.018377646,0.019015188,0.019588018,0.020158352,
                    0.020765252,0.021555828,0.022338739,0.022873158,0.023919424,0.024481686,
                    0.02534381,0.02629189; 1961.416802,0,0,0.006644101,0.007278485,
                    0.007740381,0.00824903,0.008828371,0.009303714,0.009845574,0.010417954,
                    0.010786239,0.011292367,0.011774379,0.012270877,0.012786042,0.013133381,
                    0.01365294,0.014200706,0.014710744,0.015224217,0.015763964,0.016080231,
                    0.01658222,0.017370076,0.017916173,0.018290227,0.019046945,0.019666603,
                    0.020390539,0.020815857,0.021869176,0.022230402,0.022930344,0.023677488,
                    0.024656159,0.025679501,0.02638297,0.027530874; 2031.467402,0,0,
                    0.006991992,0.007541484,0.008060435,0.00863469,0.00915203,0.009640107,
                    0.01011446,0.010721655,0.011211114,0.011601947,0.012173628,0.012510673,
                    0.012996707,0.013525757,0.013990039,0.014574776,0.015208654,0.015583794,
                    0.016138746,0.016631649,0.017241436,0.017782328,0.018353765,0.019213338,
                    0.019591734,0.020354047,0.021136093,0.021535369,0.022461781,0.023355324,
                    0.023785039,0.024910293,0.025395595,0.026504677,0.027371219,0.028347706;
                    2101.518002,0,0,0.00711227,0.007825692,0.008386875,0.008821081,
                    0.009531429,0.010064099,0.010446801,0.011058935,0.011485645,0.011931689,
                    0.012452276,0.01316248,0.013495873,0.0141893,0.014528201,0.014996621,
                    0.015470075,0.016294783,0.016789196,0.017403116,0.017701422,0.018529787,
                    0.019158365,0.019546969,0.020381831,0.020910089,0.021522199,0.022246257,
                    0.023312282,0.023847191,0.024739252,0.025439506,0.026378624,0.027245106,
                    0.028302627,0.029169502; 2206.593902,0,0,0.007561035,0.008160022,
                    0.008767591,0.009368683,0.009916778,0.010523499,0.011094384,0.011516654,
                    0.012133043,0.012525073,0.01328019,0.013556141,0.014341048,0.014597805,
                    0.015248034,0.015901825,0.016412546,0.01700199,0.017579766,0.01817544,
                    0.018789176,0.0195313,0.019943298,0.020785771,0.021429322,0.022239235,
                    0.022849524,0.023330276,0.024443997,0.025100091,0.026140335,0.027033896,
                    0.027525471,0.028760312,0.029741564,0.030796861; 2416.745702,0,0,
                    0.008201428,0.008778953,0.009596892,0.010103863,0.010792793,0.011495883,
                    0.012075489,0.012693154,0.013148647,0.013725104,0.014330988,0.014805847,
                    0.015454547,0.016070843,0.016773119,0.017262488,0.018027268,0.018470603,
                    0.019064396,0.019678926,0.020359141,0.021230578,0.022064378,0.022415805,
                    0.023237888,0.024362868,0.025094342,0.02577939,0.026504248,0.02739454,
                    0.028258016,0.029405284,0.030489104,0.031149239,0.032686382,0.033448493]
                  "Engine Fuel Consumption (kg/s), Row 1 contains speed values, column 1 contains torque values";
                parameter SI.Inertia Jengine=3.75 "engine inertia";
                parameter SI.Mass engine_mass=900 "mass of engine";

                parameter Real engine_displacement=10
                  "engine displacement in liters"                                     annotation (choicesAllMatching=true, Dialog(tab="Fluid Model"));

                parameter Real voleff[:,:]=[0,600,1200,1500,1800; 0,0.867641652,0.867641652,
                    0.867641652,0.867641652; 300,0.867641652,1,1.05,1.1; 400,0.867641652,
                    1.027886075,1.074580184,1.122243498; 500,0.867641652,1.027886075,
                    1.169487592,1.318243069; 600,0.867641652,1.098542293,1.264395,1.514242641;
                    700,0.867641652,1.169198511,1.359303369,1.514242641; 800,0.867641652,
                    1.239854728,1.454211738,1.514242641; 900,0.867641652,1.310510946,
                    1.454211738,1.706250056; 1000,0.867641652,1.391266152,1.693757702,
                    1.898257471; 1200,0.867641652,1.552776565,1.933303667,2.059404565; 1300,
                    0.867641652,1.633531772,1.933303667,2.220551658; 1400,0.867641652,
                    1.712133134,2.11370574,2.220551658; 1600,0.867641652,1.790734496,
                    2.294107813,2.220551658; 1700,0.867641652,1.869335858,2.294107813,
                    2.220551658; 1800,0.867641652,1.94793722,2.3,2.220551658]
                  "Table of volumetric efficiency";

                parameter SI.AngularVelocity crank_speed=62.831853071796
                  "crank speed";

                parameter Real flow_characteristic[:,:]=[0.000167,1.3e5; 0.0025,1e5; 0.004,
                    0.6e5; 0.005,0.2e5]
                  "Table with volume flow rate[m3] and pressure rise[pa] columns at N_ref"
                                                                                          annotation (Dialog(tab="Cooling System", group="Water Pump"));
                parameter SI.AngularVelocity N_ref=314.15926535898
                  "Rotational speed at which table data is provided"
                                                                    annotation (Dialog(tab="Cooling System", group="Water Pump"));
                parameter Real K=1e-6
                  "(Volume flow rate/delta P) Loss Coefficient to model the pump as a simple restriction at low speeds"
                                                                                                                      annotation (Dialog(tab="Cooling System", group="Water Pump"));
                parameter Real efficiency_characteristic[:,:]=[-1,0.8; 0,0.8; 1,0.8]
                  "Table with efficiency vs. volume flow rate(m3/s) at N_ref"
                                                                            annotation (Dialog(tab="Cooling System", group="Water Pump"));
                parameter Real effectiveness_nom=0.95
                  "Nominal effectiveness of the thermal bridge"
                                                               annotation (Dialog(tab="Cooling System", group="Water Jacket"));
                parameter SI.Power cooling_Q_nom=300000
                  "Nominal heat rejection to the cooling system"
                                                                annotation (Dialog(tab="Cooling System", group="Water Jacket"));
                parameter SI.Temperature T_inlet_nom=358.15
                  "Nominal coolant inlet temperature"
                  annotation (Dialog(tab="Cooling System", group="Water Jacket"));
                parameter SI.VolumeFlowRate V_dot_nom=0.003
                  "Nominal coolant volume flow rate"
                                                    annotation (Dialog(tab="Cooling System", group="Water Jacket"));
                parameter SI.Pressure dp_nom=50000
                  "Nominal pressure drop in the engine coolant jacket"
                                                                      annotation (Dialog(tab="Cooling System", group="Water Jacket"));
                Modelica.Fluid.Interfaces.FluidPort_a                fluid_in(redeclare
                    package Medium = Air_Medium_Fluid) if not useSimpleAir
                  annotation (Placement(transformation(extent={{-210,230},{-190,250}})));
                Modelica.Fluid.Interfaces.FluidPort_b                fluid_out(redeclare
                    package Medium = Air_Medium_Fluid) if not useSimpleAir
                  annotation (Placement(transformation(extent={{-128,230},{-108,250}})));
                Modelica.Fluid.Interfaces.FluidPort_a                top_hose_outlet(
                    redeclare package Medium = Coolant_Medium_Fluid) if not useSimpleCoolant
                  annotation (Placement(transformation(extent={{190,130},{210,150}})));
                Modelica.Fluid.Interfaces.FluidPort_b                bottom_hose_in(
                    redeclare package Medium = Coolant_Medium_Fluid) if not useSimpleCoolant
                  annotation (Placement(transformation(extent={{190,-110},{210,-90}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a outer_surface_heat_port
                  annotation (Placement(transformation(extent={{90,230},{110,250}})));
                Modelica.Fluid.Interfaces.FluidPort_b                to_cac(redeclare
                    package Medium =
                             Air_Medium_Fluid) if not useSimpleAir
                  annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
                Modelica.Fluid.Interfaces.FluidPort_a                from_cac(redeclare
                    package Medium = Air_Medium_Fluid) if not useSimpleAir
                  annotation (Placement(transformation(extent={{-210,150},{-190,170}})));
                Modelica.Fluid.Interfaces.FluidPort_b                fuel_in(redeclare
                    package Medium = Fuel_Medium_Fluid) if not useSimpleFuel
                  annotation (Placement(transformation(extent={{-210,-50},{-190,-30}})));
                Example_Engine_Basic_Advanced
                                           example_Engine_Basic_wFuel(
                  useSupport=true,
                  Fuel_Medium=Fuel_Medium,
                  case_heat_transfer_area=case_heat_transfer_area,
                  case_heat_transfer_thickness=case_heat_transfer_thickness,
                  case_thermal_conductivity=case_thermal_conductivity,
                  friction_map=friction_map,
                  torque_map=torque_map,
                  fuel_map=fuel_map,
                  Jengine=Jengine,
                  engine_mass=engine_mass,
                  engine_displacement=engine_displacement,
                  voleff=voleff,
                  crank_speed=crank_speed,
                  flow_characteristic=flow_characteristic,
                  N_ref=N_ref,
                  K=K,
                  efficiency_characteristic=efficiency_characteristic,
                  effectiveness_nom=effectiveness_nom,
                  cooling_Q_nom=cooling_Q_nom,
                  T_inlet_nom=T_inlet_nom,
                  V_dot_nom=V_dot_nom,
                  dp_nom=dp_nom,
                  Coolant_Medium=Coolant_Medium)
                  annotation (Placement(transformation(extent={{-20,46},{20,80}})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor(
                    redeclare package Medium = Air_Medium_Fluid, HeatFlowMedium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if not useSimpleAir
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-118,212})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor1(
                    redeclare package Medium = Air_Medium_Fluid, HeatFlowMedium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if not useSimpleAir
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-200,214})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor2(
                    redeclare package Medium = Air_Medium_Fluid, HeatFlowMedium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if not useSimpleAir
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={-150,160})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor3(
                    redeclare package Medium = Air_Medium_Fluid, HeatFlowMedium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if not useSimpleAir
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={-150,120})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor4(
                    HeatFlowMedium=Fuel_Medium, redeclare package Medium =
                      Fuel_Medium_Fluid) if not useSimpleFuel
                  annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=180,
                      origin={-150,-40})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor5(
                                                   redeclare package Medium =
                      Coolant_Medium_Fluid, HeatFlowMedium=Coolant_Medium) if not useSimpleCoolant
                                                                 annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={170,140})));
                MSL_Extend.Thermal.FluidHeatFlow.Adaptors.FluidAdaptor fluidAdaptor6(
                                                   redeclare package Medium =
                      Coolant_Medium_Fluid, HeatFlowMedium=Coolant_Medium) if not useSimpleCoolant
                                                                 annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={170,-100})));
              protected
                Modelica.Mechanics.Rotational.Components.Fixed
                                 fixed if not useSupport
                  "Fixed support/housing, if not useSupport"
                  annotation (Placement(transformation(extent={{10,-97},{30,-77}})));
              public
                Modelica.Mechanics.Rotational.Interfaces.Support
                        support if useSupport "Support/housing of component"
                  annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
              protected
                Modelica.Mechanics.Rotational.Interfaces.Support
                        internalSupport
                  "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
                  annotation (Placement(transformation(extent={{-3,-83},{3,-77}})));
              public
                Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                                  brg_01 if not useSimpleMechanics
                  annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
                Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                                  brg_02 if not useSimpleMechanics
                  annotation (Placement(transformation(extent={{188,-10},{208,10}})));
              public
                Engine_Control_Bus
                  engineControlBus if  useBus
                  annotation (Placement(transformation(extent={{-10,230},{10,250}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fuel_in_OM(medium=
                      Fuel_Medium) if useSimpleFuel
                  annotation (Placement(transformation(extent={{-210,-50},{-190,-30}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01_OM if useSimpleMechanics
                  annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b to_cac_OM(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if useSimpleAir
                  annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a from_cac_OM(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if useSimpleAir
                  annotation (Placement(transformation(extent={{-210,150},{-190,170}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in_OM(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if useSimpleAir
                  annotation (Placement(transformation(extent={{-210,230},{-190,250}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out_OM(medium=
                      Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()) if useSimpleAir
                  annotation (Placement(transformation(extent={{-128,230},{-108,250}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a top_hose_outlet_OM(
                    medium=Coolant_Medium) if useSimpleCoolant
                  annotation (Placement(transformation(extent={{190,130},{210,150}})));
                Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b bottom_hose_in_OM(medium=
                     Coolant_Medium) if useSimpleCoolant
                  annotation (Placement(transformation(extent={{190,-110},{210,-90}})));
                Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
                  annotation (Placement(transformation(extent={{-210,76},{-190,96}})));
                Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
                  annotation (Placement(transformation(extent={{-210,50},{-190,70}})));
                Modelica.Mechanics.Rotational.Interfaces.Flange_b brg_02_OM if useSimpleMechanics
                  annotation (Placement(transformation(extent={{188,-10},{208,10}})));
                Modelica.Blocks.Interfaces.RealOutput speed if not useBus annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-184,-104})));
                Modelica.Blocks.Interfaces.RealOutput fuel_flow if not useBus annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-160,-104})));
                Modelica.Blocks.Interfaces.RealOutput net_torque if not useBus annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=270,
                      origin={-134,-104})));
                Modelica.Blocks.Interfaces.BooleanInput starter_engage if not useBus annotation (Placement(
                      transformation(
                      extent={{-20,-20},{20,20}},
                      rotation=270,
                      origin={20,248})));
                Modelica.Blocks.Interfaces.RealInput ECU_Throttle_Out if not useBus annotation (Placement(
                      transformation(
                      extent={{-20,-20},{20,20}},
                      rotation=270,
                      origin={60,248})));
                Modelica.Mechanics.MultiBody.Interfaces.Frame_a origin if not useSimpleMechanics   annotation (Placement(
                      transformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-66,-42}),iconTransformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-68,-132})));
                Modelica.Mechanics.MultiBody.Interfaces.Frame_a mount_01 if not useSimpleMechanics annotation (Placement(
                      transformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-100,-100}),
                                        iconTransformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-134,-148})));
                Modelica.Mechanics.MultiBody.Interfaces.Frame_a mount_02 if not useSimpleMechanics annotation (Placement(
                      transformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-78,-100}),
                                        iconTransformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-92,-148})));
                Modelica.Mechanics.MultiBody.Interfaces.Frame_a mount_03 if not useSimpleMechanics annotation (Placement(
                      transformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-54,-100}),
                                        iconTransformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-46,-148})));
                Modelica.Mechanics.MultiBody.Interfaces.Frame_a mount_04 if not useSimpleMechanics annotation (Placement(
                      transformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={-32,-100}),
                                        iconTransformation(
                      extent={{-16,-16},{16,16}},
                      rotation=90,
                      origin={2,-148})));
              equation

                connect(example_Engine_Basic_wFuel.outer_surface_heat_port,
                  outer_surface_heat_port) annotation (Line(
                    points={{10,80},{10,180},{100,180},{100,240}},
                    color={191,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.fluid_out, fluidAdaptor.fluidHeatflow_port)
                  annotation (Line(
                    points={{-11.8,80},{-12,80},{-12,180},{-118,180},{-118,202}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluidAdaptor.fluid_port, fluid_out) annotation (Line(
                    points={{-118,222},{-118,240}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluid_in, fluidAdaptor1.fluid_port) annotation (Line(
                    points={{-200,240},{-200,224}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluidAdaptor1.fluidHeatflow_port, example_Engine_Basic_wFuel.fluid_in)
                  annotation (Line(
                    points={{-200,204},{-200,176},{-20,176},{-20,80.2}},
                    color={255,0,0},
                    smooth=Smooth.None));

                connect(fluidAdaptor2.fluid_port, from_cac) annotation (Line(
                    points={{-160,160},{-200,160}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluidAdaptor2.fluidHeatflow_port, example_Engine_Basic_wFuel.from_cac)
                  annotation (Line(
                    points={{-140,160},{-100,160},{-100,72},{-20,72}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluidAdaptor3.fluid_port, to_cac) annotation (Line(
                    points={{-160,120},{-200,120}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluidAdaptor3.fluidHeatflow_port, example_Engine_Basic_wFuel.to_cac)
                  annotation (Line(
                    points={{-140,120},{-120,120},{-120,68},{-20,68}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluidAdaptor4.fluid_port, fuel_in) annotation (Line(
                    points={{-160,-40},{-200,-40}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluidAdaptor4.fluidHeatflow_port, example_Engine_Basic_wFuel.fuel_in)
                  annotation (Line(
                    points={{-140,-40},{-100,-40},{-100,52},{-20,52}},
                    color={255,0,0},
                    smooth=Smooth.None));

                connect(example_Engine_Basic_wFuel.support, internalSupport) annotation (Line(
                    points={{0,46},{0,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(bottom_hose_in, fluidAdaptor6.fluid_port) annotation (Line(
                    points={{200,-100},{180,-100}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fluidAdaptor6.fluidHeatflow_port, example_Engine_Basic_wFuel.bottom_hose_in)
                  annotation (Line(
                    points={{160,-100},{140,-100},{140,-40},{20,-40},{20,46}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.top_hose_outlet, fluidAdaptor5.fluidHeatflow_port)
                  annotation (Line(
                    points={{20,70},{140,70},{140,140},{160,140}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluidAdaptor5.fluid_port, top_hose_outlet) annotation (Line(
                    points={{180,140},{200,140}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(fixed.flange,internalSupport)  annotation (Line(
                    points={{20,-87},{20,-80},{0,-80}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(internalSupport,support)  annotation (Line(
                    points={{0,-80},{0,-100}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.starter_engage, engineControlBus.starter_engage)
                  annotation (Line(
                    points={{-6,81},{-6,240},{0,240}},
                    color={255,0,255},
                    smooth=Smooth.None), Text(
                    string="%second",
                    index=1,
                    extent={{6,3},{6,3}}));
                connect(example_Engine_Basic_wFuel.ECU_Throttle_Out, engineControlBus.ECU_Throttle_Out)
                  annotation (Line(
                    points={{0,81},{0,240}},
                    color={0,0,127},
                    smooth=Smooth.None), Text(
                    string="%second",
                    index=1,
                    extent={{6,3},{6,3}}));
                connect(example_Engine_Basic_wFuel.speed, engineControlBus.speed) annotation (
                   Line(
                    points={{-16,45.4},{-16,32},{-48,32},{-48,240},{0,240}},
                    color={0,0,127},
                    smooth=Smooth.None), Text(
                    string="%second",
                    index=1,
                    extent={{6,3},{6,3}}));
                connect(example_Engine_Basic_wFuel.fuel_flow, engineControlBus.fuel_flow)
                  annotation (Line(
                    points={{-10,45.4},{-10,28},{-52,28},{-52,240},{0,240}},
                    color={0,0,127},
                    smooth=Smooth.None), Text(
                    string="%second",
                    index=1,
                    extent={{6,3},{6,3}}));
                connect(example_Engine_Basic_wFuel.net_torque, engineControlBus.net_torque)
                  annotation (Line(
                    points={{-4,45.4},{-4,24},{-56,24},{-56,240},{0,240}},
                    color={0,0,127},
                    smooth=Smooth.None), Text(
                    string="%second",
                    index=1,
                    extent={{6,3},{6,3}}));
                connect(example_Engine_Basic_wFuel.brg_02, brg_02.flange) annotation (Line(
                    points={{20,56},{110,56},{110,0},{198,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.brg_01, brg_01.flange) annotation (Line(
                    points={{-20,56},{-110,56},{-110,0},{-200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.brg_01, brg_01_OM) annotation (Line(
                    points={{-20,56},{-110,56},{-110,0},{-200,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.pin_p, pin_p) annotation (Line(
                    points={{-20,64},{-156,64},{-156,86},{-200,86}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.pin_n, pin_n) annotation (Line(
                    points={{-20,60},{-200,60}},
                    color={0,0,255},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.brg_02, brg_02_OM) annotation (Line(
                    points={{20,56},{110,56},{110,0},{198,0}},
                    color={0,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.speed, speed) annotation (Line(
                    points={{-16,45.4},{-16,-24},{-184,-24},{-184,-104}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.fuel_flow, fuel_flow) annotation (Line(
                    points={{-10,45.4},{-10,-50},{-160,-50},{-160,-104}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.net_torque, net_torque) annotation (Line(
                    points={{-4,45.4},{-4,-64},{-134,-64},{-134,-104}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.starter_engage, starter_engage)
                  annotation (Line(
                    points={{-6,81},{-6,214},{20,214},{20,248}},
                    color={255,0,255},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.ECU_Throttle_Out, ECU_Throttle_Out)
                  annotation (Line(
                    points={{0,81},{0,200},{60,200},{60,248}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(mount_03, origin) annotation (Line(
                    points={{-54,-100},{-56,-100},{-56,-42},{-66,-42}},
                    color={95,95,95},
                    thickness=0.5,
                    smooth=Smooth.None));
                connect(origin, mount_02) annotation (Line(
                    points={{-66,-42},{-78,-42},{-78,-100}},
                    color={95,95,95},
                    thickness=0.5,
                    smooth=Smooth.None));
                connect(origin, origin) annotation (Line(
                    points={{-66,-42},{-66,-42}},
                    color={95,95,95},
                    thickness=0.5,
                    smooth=Smooth.None));
                connect(mount_04, origin) annotation (Line(
                    points={{-32,-100},{-32,-42},{-66,-42}},
                    color={95,95,95},
                    thickness=0.5,
                    smooth=Smooth.None));
                connect(mount_01, origin) annotation (Line(
                    points={{-100,-100},{-100,-42},{-66,-42}},
                    color={95,95,95},
                    thickness=0.5,
                    smooth=Smooth.None));
                connect(top_hose_outlet_OM, example_Engine_Basic_wFuel.top_hose_outlet)
                  annotation (Line(
                    points={{200,140},{140,140},{140,70},{20,70}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fuel_in_OM, example_Engine_Basic_wFuel.fuel_in) annotation (Line(
                    points={{-200,-40},{-100,-40},{-100,52},{-20,52}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(to_cac_OM, example_Engine_Basic_wFuel.to_cac) annotation (Line(
                    points={{-200,120},{-120,120},{-120,68},{-20,68}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(from_cac_OM, example_Engine_Basic_wFuel.from_cac) annotation (Line(
                    points={{-200,160},{-100,160},{-100,72},{-20,72}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluid_in_OM, example_Engine_Basic_wFuel.fluid_in) annotation (Line(
                    points={{-200,240},{-200,176},{-20,176},{-20,80.2}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(fluid_out_OM, example_Engine_Basic_wFuel.fluid_out) annotation (
                    Line(
                    points={{-118,240},{-118,180},{-11.8,180},{-11.8,80}},
                    color={255,0,0},
                    smooth=Smooth.None));
                connect(example_Engine_Basic_wFuel.bottom_hose_in, bottom_hose_in_OM)
                  annotation (Line(
                    points={{20,46},{20,-40},{140,-40},{140,-100},{200,-100}},
                    color={255,0,0},
                    smooth=Smooth.None));
                annotation (
                  Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-100},{
                          200,240}}),
                                  graphics),
                  Icon(coordinateSystem(preserveAspectRatio=false,extent={{-200,-100},{200,
                          240}}), graphics={
                      Rectangle(
                        extent={{-54,48},{-14,28}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-36,34},{-32,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-76,54},{-72,8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,72},{-54,52}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-174,72},{-134,52}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-156,54},{-152,8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,14},{-134,8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,14},{-170,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{66,4},{96,-4}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-156,62},{-152,58}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-138,14},{-134,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-204,4},{-174,-4}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-98,14},{-94,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-134,-6},{-94,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-94,14},{-54,8}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-58,14},{-54,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-54,-6},{-14,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-116,34},{-112,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-134,48},{-94,28}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Ellipse(
                        extent={{-116,38},{-112,34}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-76,62},{-72,58}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{-36,38},{-32,34}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-16,14},{-12,-12}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-264,190},{-46,150}},
                        lineColor={128,128,128},
                        textString="air path"),
                      Rectangle(
                        extent={{42,36},{46,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{2,56},{6,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-16,74},{24,54}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{-16,16},{24,10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{20,16},{24,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,-4},{64,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{2,64},{6,60}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{42,40},{46,36}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{24,50},{64,30}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.VerticalCylinder),
                      Rectangle(
                        extent={{62,16},{66,-10}},
                        lineColor={0,0,0},
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{42,40},{46,36}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-174,114},{-134,72}},
                        lineColor={0,0,0},
                        pattern=LinePattern.Dot),
                      Line(
                        points={{-200,234},{-200,128},{-168,114}},
                        color={0,128,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-142,114},{-118,132},{-118,236}},
                        color={255,0,0},
                        smooth=Smooth.None),
                      Line(
                        points={{-128,208},{-118,226}},
                        color={255,0,0},
                        smooth=Smooth.None),
                      Line(
                        points={{-5,-9},{11,-1}},
                        color={0,128,255},
                        smooth=Smooth.None,
                        origin={-177,119},
                        rotation=90),
                      Rectangle(
                        extent={{24,112},{64,50}},
                        lineColor={255,255,255},
                        pattern=LinePattern.Dot,
                        fillPattern=FillPattern.Sphere,
                        fillColor={255,100,0}),
                      Rectangle(
                        extent={{70,110},{82,62}},
                        lineColor={0,128,255},
                        fillColor={0,128,255},
                        fillPattern=FillPattern.Solid,
                        radius=10),
                      Line(
                        points={{202,-102},{76,-102},{76,62}},
                        color={0,128,255},
                        smooth=Smooth.None),
                      Line(
                        points={{202,138},{76,138},{76,100}},
                        color={200,128,255},
                        smooth=Smooth.None),
                      Rectangle(
                        extent={{24,112},{64,50}},
                        lineColor={0,0,0},
                        pattern=LinePattern.Dot),
                      Line(
                        points={{-5,-9},{11,-1}},
                        color={0,128,255},
                        smooth=Smooth.None,
                        origin={75,51},
                        rotation=90),
                      Line(
                        points={{-5,9},{11,1}},
                        color={200,128,255},
                        smooth=Smooth.None,
                        origin={181,137},
                        rotation=360),
                      Ellipse(
                        extent={{92,-56},{152,-116}},
                        lineColor={255,255,255},
                        fillColor={0,128,255},
                        fillPattern=FillPattern.Solid),
                      Ellipse(
                        extent={{112,-76},{132,-96}},
                        lineColor={255,255,255},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                      Line(
                        points={{136,-86},{196,-86}},
                        color={255,255,255},
                        smooth=Smooth.None),
                      Line(
                        points={{-30,0},{30,0}},
                        color={255,255,255},
                        smooth=Smooth.None,
                        origin={122,-86},
                        rotation=90),
                      Line(
                        points={{100,-64},{144,-108}},
                        color={255,255,255},
                        smooth=Smooth.None),
                      Line(
                        points={{100,-108},{144,-64}},
                        color={255,255,255},
                        smooth=Smooth.None)}),
                  Documentation(info="<html>
<p>Operation:</p>
<p><br/>Transmits torque at output flange, torque output is based on flange speed and a torque demand signal. Generates heat proportional to power produced, and is split between exhaust, coolant, ambient air, and engine oil. An airflow submodel generates mass flows required for intake and exhaust streams.</p>
<p><br/>Model Limitations: </p>
<p>The model does not simulate combustion.</p>
<p><br/>Physical Limits:</p>
</html>"));
              end Example_Engine_Basic_Advanced_OM2EXT;
            end OM2EXT;
          end Engine_Basic;
        end Compression_Ignition;
      end Reciprocating;

      package Air_Intake_Systems
        "Components responsible for delivering charge air to a prime mover"
      extends Modelica.Icons.Package;

        package Filtration
          "Components responsible for removing contaminants from the intake air"
        extends Modelica.Icons.Package;

          model Air_Filter_Main
            "The main filter element in the intake system (as oppose to a pre-filter)"

            MSL_Extend.Thermal.FluidHeatFlow.Components.Filter.Filter_Linear_Blockage
              filter_Valve_Concentration_Model_Equation(
                m_flow_nominal=m_flow_nominal,
              block_per_init=block_per_init,
              block_mass_init=block_mass_init,
              block_mass_1=block_mass_1,
              block_per_1=block_per_1,
              slope=slope,
              dp_nominal=dp_nominal,
              medium=Transported_Fluid)
              annotation (Placement(transformation(extent={{-6,6},{14,26}})));
            Modelica.Blocks.Interfaces.RealInput contaminants
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={0,206})));
            parameter Modelica.Thermal.FluidHeatFlow.Media.Medium Transported_Fluid = Modelica.Thermal.FluidHeatFlow.Media.Air_30degC() annotation(choicesAllMatching=true);

            parameter SI.Mass block_mass_1=0.1 "Blockage mass at point 1"
             annotation (Dialog(tab="General"));
            parameter Real block_per_1=0.05
              "Blockage percentage (0-1) at point 1"
             annotation (Dialog);
            parameter Real slope = block_per_1 / block_mass_1;
            parameter SI.Pressure dp_nominal=6250
              "Pressure drop at nominal mass flow rate";
            parameter SI.MassFlowRate m_flow_nominal=0.11
              "Flow@dp_nominal with clean filter";

            parameter Real block_per_init=0.2
              "Initial blockage percentage(0-1)"
             annotation (Dialog(tab="General"));
            parameter SI.Mass block_mass_init= 0.1;

            Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
              annotation (Placement(transformation(extent={{-210,-90},{-190,-70}})));
            Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
              annotation (Placement(transformation(extent={{190,-90},{210,-70}})));
          equation
            connect(filter_Valve_Concentration_Model_Equation.port_a, fluid_in)
              annotation (Line(
                points={{-6,20},{-104,20},{-104,-80},{-200,-80}},
                color={0,127,255},
                smooth=Smooth.None));
            connect(filter_Valve_Concentration_Model_Equation.port_b, fluid_out)
              annotation (Line(
                points={{14,20},{106,20},{106,-80},{200,-80}},
                color={0,127,255},
                smooth=Smooth.None));

            connect(filter_Valve_Concentration_Model_Equation.u, contaminants)
              annotation (Line(
                points={{-8.6,16},{-28,16},{-28,136},{0,136},{0,206}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-260},
                      {200,280}}), graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                    extent={{-200,-260},{200,280}}), graphics={
                  Rectangle(
                    extent={{-56,160},{46,-160}},
                    lineColor={0,0,255},
                    fillPattern=FillPattern.CrossDiag,
                    fillColor={255,255,255}),
                  Line(
                    points={{-194,-82},{-126,-96},{-56,-128}},
                    color={0,0,255},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{-198,-76},{-132,-36},{-100,8},{-62,12},{-54,14}},
                    color={0,0,255},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{-196,-78},{-166,-2},{-130,94},{-88,112},{-58,116}},
                    color={0,0,255},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{-58,118},{-90,134}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-58,12},{-90,28}},
                    color={0,0,255},
                    smooth=Smooth.None),
                  Line(
                    points={{-16,-8},{16,8}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    origin={-74,-138},
                    rotation=360),
                  Line(
                    points={{48,114},{122,62},{126,58},{166,-28},{198,-78}},
                    color={0,0,255},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{48,20},{54,16},{110,-26},{116,-26},{170,-58},{198,-82}},
                    color={0,0,255},
                    smooth=Smooth.Bezier),
                  Line(
                    points={{50,-136},{134,-104},{196,-82}},
                    color={0,0,255},
                    smooth=Smooth.Bezier)}));
          end Air_Filter_Main;

          model Test_Air_Filter
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Air_Filter_Main air_Filter_Main
              annotation (Placement(transformation(extent={{-20,-32},{20,28}})));
            Modelica.Blocks.Sources.Step step(
              startTime=100,
              height=0.005,
              offset=0.001)
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient inlet(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
                constantAmbientPressure=106250) annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-56,-12})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient outlet(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
                constantAmbientPressure=100000)
              annotation (Placement(transformation(extent={{50,-22},{70,-2}})));
          equation
            connect(air_Filter_Main.contaminants, step.y) annotation (Line(
                points={{0,19.7778},{0,90},{-39,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(outlet.flowPort, air_Filter_Main.fluid_out) annotation (Line(
                points={{50,-12},{20,-12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(air_Filter_Main.fluid_in, inlet.flowPort) annotation (Line(
                points={{-20,-12},{-46,-12}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                      graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/make_filter_plots.mos" "make_filter_plots"));
          end Test_Air_Filter;
        end Filtration;

        package Charge_Cooling
          "Components related to cooling of the charge air after compression (e.g. at the outlet from a turbo or supercharger)"
        extends Modelica.Icons.Package;

          model Charge_Cooler_Air_To_Air
            "Charge cooler that uses air as the cooling medium"
            extends
              C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Base_Heat_Exchanger(
              loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              core_depth=0.05,
              core_length=0.9,
              core_width=0.9,
              effectiveness_table=[0,0.3,0.7,1.5,2.2; 0.1,88.325,98.205,100.12,100.54;
                  0.15,118.96,140.29,147.37,149.17; 0.2,139.33,175.45,190.88,195.29; 0.28,
                  163.98,225.46,255.29,264.87],
              pressure_drop_b=[0,0; 0.301,72; 0.747,318; 1.507,1033; 2.213,1951],
              effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD,
              flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
              pressure_drop_a=[0,0; 0.1,2471.3; 0.15,5176; 0.2,8404.2; 0.28,17021],
              flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              ref_core_length=0.9,
              ref_core_width=0.9,
              ref_core_depth=0.05,medium_cold_fluid=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(), medium_hot_fluid=Modelica.Thermal.FluidHeatFlow.Media.Air_70degC());

            //parameter SI.Area area_ref_hot=1
            annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                      -320},{200,280}}), graphics),
                        Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                      {200,280}}), graphics));
          end Charge_Cooler_Air_To_Air;

          model Charge_Cooler_Air_To_Liquid
            "Charge cooler that uses liquid (e.g. water/ethylene-glycol) as the cooling medium"
            extends
              C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Base_Heat_Exchanger(
              effectiveness_table=[0,0,0.35,0.75,1.1,1.45,1.8,2.2,2.55,2.9,3.3,3.7,4,4.35,
                  4.75,5.1,5.5,5.9,6.2,6.9; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; 0.35,
                  0,83,144,185,210,225,233,239,246,255,267,279,292,304,315,325,334,343,
                  361; 0.7,0,117,212,286,343,388,424,456,484,512,540,566,590,612,632,651,
                  668,685,720; 1.05,0,153,285,395,487,564,629,685,735,781,822,860,894,924,
                  951,976,1000,1024,1076; 1.4,0,193,364,513,641,751,846,927,998,1060,1114,
                  1162,1203,1239,1271,1301,1329,1359,1426; 1.8,0,235,448,639,806,951,1075,
                  1182,1272,1349,1414,1469,1516,1556,1590,1623,1654,1688,1769; 2.15,0,280,
                  539,772,980,1161,1316,1447,1557,1647,1721,1782,1831,1873,1909,1942,1975,
                  2011,2104; 2.5,0,328,633,912,1162,1380,1566,1722,1850,1952,2034,2098,
                  2149,2190,2225,2257,2290,2328,2431; 2.9,0,377,732,1058,1351,1607,1824,
                  2004,2149,2263,2350,2416,2467,2506,2539,2569,2601,2638,2750; 3.2,0,428,
                  833,1208,1545,1839,2088,2292,2453,2576,2667,2734,2783,2820,2850,2877,
                  2906,2943,3060; 3.6,0,480,937,1361,1742,2075,2355,2581,2757,2889,2984,
                  3050,3097,3131,3157,3180,3206,3241,3362; 3.95,0,531,1040,1514,1941,2312,
                  2622,2871,3060,3199,3296,3361,3406,3436,3459,3479,3501,3533,3655; 4.3,0,
                  583,1143,1666,2137,2546,2886,3155,3358,3502,3601,3665,3707,3734,3755,
                  3772,3791,3819,3941; 4.65,0,632,1242,1812,2327,2773,3141,3431,3645,3795,
                  3894,3957,3997,4024,4043,4058,4074,4100,4219; 5,0,679,1336,1951,2507,
                  2987,3383,3692,3918,4073,4173,4236,4275,4302,4321,4336,4350,4373,4489;
                  5.4,0,721,1421,2078,2672,3185,3606,3932,4169,4330,4433,4496,4537,4566,
                  4588,4604,4619,4639,4753; 5.75,0,758,1496,2189,2816,3358,3802,4146,4394,
                  4561,4668,4735,4780,4814,4841,4862,4879,4899,5012; 6.1,0,789,1557,2281,
                  2936,3502,3966,4325,4585,4760,4873,4946,4999,5042,5078,5106,5128,5152,
                  5267; 6.45,0,811,1603,2349,3025,3611,4092,4465,4735,4920,5042,5125,5188,
                  5242,5289,5328,5360,5389,5512; 6.8,0,825,1631,2392,3082,3681,4174,4558,
                  4840,5036,5168,5262,5337,5404,5465,5517,5559,5599,5734],
              pressure_drop_a=[0,0; 0.028185952,3.80970; 0.056371904,10.00000;
                  0.112743808,20.34330; 0.140929761,31.00000; 0.169115713,42.00000;
                  0.225487617,61.00000; 0.253673569,75.04860; 0.281859521,87.00000;
                  0.310045473,104.00000; 0.366417378,137.00000; 0.450975234,180.00000;
                  0.507347138,215.00000],
              loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
              flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
              pressure_drop_b=[0,0; 0.000880397,6143.20734; 0.00111091,8273.67991;
                  0.001349941,11445.25721; 0.001643407,16409.46516; 0.001936872,
                  21925.25177; 0.002230338,28337.35370; 0.002347724,31424.00000;
                  0.002817269,44104.46400],
              core_depth=1,
              flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              core_length=0.59,
              core_width=0.45,
              ref_core_length=0.59,
              ref_core_width=0.45,
              medium_hot_fluid = Modelica.Thermal.FluidHeatFlow.Media.Air_70degC(),
              medium_cold_fluid = Modelica.Thermal.FluidHeatFlow.Media.Water());

            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                      -320},{200,280}}), graphics));
          end Charge_Cooler_Air_To_Liquid;

          model Test_Delivered_CAC_Air_To_Liquid
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Charge_Cooler_Air_To_Liquid
              charge_cooler(medium_cold_fluid=
                  C2M2L_OM.MSL_Extend.Media.Glykol47_20degC())
              annotation (Placement(transformation(extent={{-18,4},{22,64}})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                            Hot_Fluid_Inlet(
              constantMassFlow=2,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_70degC(),
              constantAmbientTemperature=433.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-70,58})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Cold_Fluid_Out(
              medium=C2M2L_OM.MSL_Extend.Media.Glykol47_20degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(extent={{80,0},{100,20}})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor temperature_hot_side(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_70degC())
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={60,68})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
              temperature_cold_side(medium=
                  C2M2L_OM.MSL_Extend.Media.Glykol47_20degC())
                                    annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={60,0})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Hot_Fluid_Out(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_70degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=433.15)
              annotation (Placement(transformation(extent={{80,48},{100,68}})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                            Cold_Fluid_In(
              constantMassFlow=3,
              medium=C2M2L_OM.MSL_Extend.Media.Glykol47_20degC(),
              constantAmbientTemperature=293.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-70,10})));
          equation

            connect(Cold_Fluid_Out.flowPort, temperature_cold_side.flowPort) annotation (
                Line(
                points={{80,10},{60,10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_cold_side.flowPort, charge_cooler.cold_fluid_out)
              annotation (Line(
                points={{60,10},{42,10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Hot_Fluid_Out.flowPort, temperature_hot_side.flowPort) annotation (
                Line(
                points={{80,58},{60,58}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_hot_side.flowPort, charge_cooler.hot_fluid_out)
              annotation (Line(
                points={{60,58},{42,58}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(charge_cooler.hot_fluid_in, Hot_Fluid_Inlet.flowPort) annotation (
                Line(
                points={{-38,58},{-60,58}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(charge_cooler.cold_fluid_in, Cold_Fluid_In.flowPort) annotation (Line(
                points={{-38,10},{-60,10}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Commands(file=
                    "Scripts/CAC_Liq_to_Air_Test.mos" "plot_setup"));
          end Test_Delivered_CAC_Air_To_Liquid;

          model Test_Delivered_CAC_Air_To_Air
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Charge_Cooler_Air_To_Air
              charge_Cooler_Air_To_Air(
              loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              effectiveness_table=[0,0.3,0.7,1.5,2.2; 0.1,88.325,98.205,100.12,100.54;
                  0.15,118.96,140.29,147.37,149.17; 0.2,139.33,175.45,190.88,195.29; 0.28,
                  163.98,225.46,255.29,264.87],
              pressure_drop_b=[0,0; 0.301,72; 0.747,318; 1.507,1033; 2.213,1951],
              effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD,
              flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
              pressure_drop_a=[0,0; 0.1,2471.3; 0.15,5176; 0.2,8404.2; 0.28,17021],
              flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate)
              annotation (Placement(transformation(extent={{-22,-4},{20,56}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Cold_Fluid_Out(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=303.15)
              annotation (Placement(transformation(extent={{80,-8},{100,12}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Hot_Fluid_Out(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_70degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=433.15)
              annotation (Placement(transformation(extent={{80,40},{100,60}})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
              temperature_hot_side1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_70degC())
                                    annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={60,60})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
              temperature_cold_side1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
                                     annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={60,-8})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                            Cold_Fluid_In(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantMassFlow=1.5,
              constantAmbientTemperature=303.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-70,2})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                            Hot_Fluid_Inlet(
              constantMassFlow=0.5,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_70degC(),
              constantAmbientTemperature=473.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-70,50})));
          equation

            connect(Hot_Fluid_Out.flowPort, temperature_hot_side1.flowPort) annotation (
                Line(
                points={{80,50},{60,50}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_hot_side1.flowPort, charge_Cooler_Air_To_Air.hot_fluid_out)
              annotation (Line(
                points={{60,50},{41,50}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(charge_Cooler_Air_To_Air.cold_fluid_in, Cold_Fluid_In.flowPort)
              annotation (Line(
                points={{-43,2},{-60,2}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Hot_Fluid_Inlet.flowPort, charge_Cooler_Air_To_Air.hot_fluid_in)
              annotation (Line(
                points={{-60,50},{-43,50}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Cold_Fluid_Out.flowPort, temperature_cold_side1.flowPort)
              annotation (Line(
                points={{80,2},{60,2}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_cold_side1.flowPort, charge_Cooler_Air_To_Air.cold_fluid_out)
              annotation (Line(
                points={{60,2},{41,2}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Commands(file=
                    "Scripts/CAC_Air_to_Air_Test.mos" "plot_setup"));
          end Test_Delivered_CAC_Air_To_Air;
        end Charge_Cooling;
      end Air_Intake_Systems;
    end Prime_Movers;

    package Cooling_System
      extends Modelica.Icons.Package;

      package Water_Pumps
        extends Modelica.Icons.Package;

        model Ancilliary_Pump
          "Standalone pump used to provide cooling flows independantly (e.g. not reliant on main water pump in a prime-mover) "
          extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice(
            rotating_inertia=0.01,
            efficiency_characteristic=[0,1; 10,1],
            flow_characteristic=[0.00083259501,172823.2968; 0.00087131978,170206.0469;
                0.00095845365,162573.5506; 0.00098265505,160211.4067; 0.00106011088,
                152651.3054; 0.00111819802,145782.0587; 0.00115692279,141202.5609;
                0.00123921133,132120.0971; 0.00125373469,130517.0660; 0.00132150618,
                122884.5697; 0.00135539193,118774.6049; 0.00138443234,115252.0734;
                0.00145220383,107619.5771; 0.00147640523,105165.7329; 0.00151997532,
                100749.6409; 0.00158774050,92913.7492; 0.00159258583,92353.8949;
                0.00167003535,83194.8994; 0.00173780684,73933.8614; 0.00174264586,
                73272.6541; 0.00186850449,56481.0243], flow_device(useSupport=true));

          MSL_Extend.Electrical.Electric_Machines.Electric_Motor
                                                      electric_Motor(
            use_heat_port=false,
            v_nom=v_nom,
            pow_max=pow_max,
            trq_max=trq_max,
            v_max=28,
            trq_nom=5)
            annotation (Placement(transformation(extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,120})));
          parameter SI.Power pow_max=100;
          parameter SI.Torque trq_max=10 "Maximum output torque";
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{192,110},{212,130}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-100,288})));
          Modelica.Blocks.Interfaces.RealOutput tau annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-40,286})));
          Modelica.Blocks.Interfaces.RealOutput w annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,286})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={40,286})));
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={80,286})));
        equation

          connect(electric_Motor.support, internalSupport) annotation (Line(
              points={{-60,140},{-60,152},{60,152},{60,-120},{0,-120},{0,-140}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(electric_Motor.n, pin_n) annotation (Line(
              points={{-44,120},{202,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.p, pin_p) annotation (Line(
              points={{-76,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.demand, demand) annotation (Line(
              points={{-66,98.8},{-66,62},{-100,62},{-100,288}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.v, v) annotation (Line(
              points={{-81.2,113.6},{-84,113.6},{-84,158},{80,158},{80,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.i, i) annotation (Line(
              points={{-81.2,106.4},{-88,106.4},{-88,162},{40,162},{40,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.w, w) annotation (Line(
              points={{-75.6,98.8},{-92,98.8},{-92,166},{0,166},{0,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.tau, tau) annotation (Line(
              points={{-71.2,98.8},{-71.2,96},{-96,96},{-96,170},{-40,170},{-40,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.flange, flow_device.flange) annotation (Line(
              points={{-60,100},{-60,62},{0,62},{0,80}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-320},{200,280}}), graphics={
                Polygon(
                  points={{40,-40},{80,-55},{40,-70},{40,-40}},
                  lineColor={0,128,255},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  visible=showDesignFlowDirection),
                Polygon(
                  points={{40,-45},{70,-55},{40,-65},{40,-45}},
                  lineColor={255,255,255},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  visible=allowFlowReversal),
                Line(
                  points={{75,-55},{-40,-55}},
                  color={0,128,255},
                  smooth=Smooth.None,
                  visible=showDesignFlowDirection),
                Ellipse(
                  extent={{-112,106},{114,-126}},
                  lineColor={0,0,0},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-6,92},{-46,10},{34,-30},{6,-106}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Line(
                  points={{98,-4},{14,34},{-26,-46},{-92,-28}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Line(
                  points={{62,64},{-18,42},{8,-46},{-60,-86}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Ellipse(extent={{-146,138},{148,-156}},
                                                    lineColor={0,0,0}),
                Ellipse(
                  extent={{-28,18},{32,-42}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{53,71},{-15,43},{17,-45},{-77,-73}},
                  color={255,255,255},
                  smooth=Smooth.Bezier,
                  origin={-3,-11},
                  rotation=90),
                Line(
                  points={{-200,-80},{-170,-80},{-170,14},{-144,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{148,6},{176,6},{176,-82},{202,-82}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{-186,-154},{-186,-174},{-130,-174},{-130,-186},{-112,-164},{
                      -130,-142},{-130,-154},{-186,-154}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{120,-156},{120,-176},{176,-176},{176,-188},{194,-166},{176,
                      -144},{176,-156},{120,-156}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid)}));
        end Ancilliary_Pump;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Delivered_Electric_Pump
          extends MSL_Extend.Icons.Simple_Test_Case;
            replaceable Ancilliary_Pump
              ancilliary_Pump(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-20,-14},{20,46}})));
            Modelica.Electrical.Spice3.Sources.V_constant v_constant(V=24)
              annotation (Placement(transformation(extent={{-12,56},{8,76}})));
            Modelica.Blocks.Sources.Constant const(k=1)
              annotation (Placement(transformation(extent={{-100,52},{-80,72}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{48,46},{68,66}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure(
              constantAmbientPressure=100000,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-60,10})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure1(
              constantAmbientPressure=105000,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(extent={{44,0},{64,20}})));
          equation

            connect(v_constant.p, ancilliary_Pump.pin_p) annotation (Line(
                points={{-12,66},{-36,66},{-36,30},{-20,30}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(v_constant.n, ancilliary_Pump.pin_n) annotation (Line(
                points={{8,66},{36,66},{36,30},{20.2,30}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ground.p, v_constant.n) annotation (Line(
                points={{58,66},{8,66}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(absolutePressure1.flowPort, ancilliary_Pump.flowPort_b) annotation (
                Line(
                points={{44,10},{20,10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(ancilliary_Pump.flowPort_a, absolutePressure.flowPort) annotation (
                Line(
                points={{-20,10},{-50,10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(ancilliary_Pump.demand, const.y) annotation (Line(
                points={{-10,46.8},{-10,62},{-79,62}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Commands(file="Scripts/Electric_Pump_Test.mos"
                  "plot_setup_electric_pump"));
          end Test_Delivered_Electric_Pump;
        end Tests;
      end Water_Pumps;

      package Fans
        extends Modelica.Icons.Package;

        model Electric_Fan
          "Standalone pump used to provide cooling flows independantly (e.g. not reliant on main water pump in a prime-mover) "
        extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice;

          parameter SI.Power pow_max=100000;
          parameter SI.Torque trq_max=100 "Maximum output torque";
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));

          MSL_Extend.Electrical.Electric_Machines.Electric_Motor
                                                      electric_Motor(
            use_heat_port=false,
            v_nom=v_nom,
            pow_max=pow_max,
            trq_max=trq_max)
            annotation (Placement(transformation(extent={{20,-20},{-20,20}},
                rotation=90,
                origin={-100,150})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-212,110},{-192,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,288})));
          Modelica.Blocks.Interfaces.RealOutput tau annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-20,286})));
          Modelica.Blocks.Interfaces.RealOutput w annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,286})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,286})));
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={100,286})));
        equation

          connect(electric_Motor.support, internalSupport) annotation (Line(
              points={{-100,170},{-100,192},{-40,192},{-40,-140},{0,-140}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(electric_Motor.p, pin_p) annotation (Line(
              points={{-116,150},{-158,150},{-158,120},{-202,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(pin_n, electric_Motor.n) annotation (Line(
              points={{200,120},{60,120},{60,150},{-84,150}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.v, v) annotation (Line(
              points={{-121.2,143.6},{-128,143.6},{-128,198},{100,198},{100,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.i, i) annotation (Line(
              points={{-121.2,136.4},{-132,136.4},{-132,204},{60,204},{60,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.w, w) annotation (Line(
              points={{-115.6,128.8},{-136,128.8},{-136,210},{20,210},{20,286}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.tau, tau) annotation (Line(
              points={{-111.2,128.8},{-111.2,116},{-146,116},{-146,214},{-20,214},{-20,286}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(electric_Motor.demand, demand) annotation (Line(
              points={{-106,128.8},{-106,102},{-152,102},{-152,228},{-80,228},{-80,288}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(electric_Motor.flange, flow_device.flange) annotation (Line(
              points={{-100,130},{-100,42},{0,42},{0,80},{-1.33227e-015,80}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-320},{200,280}}), graphics={
                Line(
                  points={{-194,-80},{-154,-80},{-154,44},{-128,44}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Ellipse(extent={{-130,168},{164,-126}},
                                                    lineColor={0,0,0}),
                Ellipse(
                  extent={{-96,136},{130,-96}},
                  lineColor={0,0,0},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{10,122},{-30,40},{50,0},{22,-76}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Line(
                  points={{114,26},{30,64},{-10,-16},{-76,2}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Line(
                  points={{78,94},{-2,72},{24,-16},{-44,-56}},
                  color={255,255,255},
                  smooth=Smooth.Bezier),
                Ellipse(
                  extent={{-12,48},{48,-12}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-170,-124},{-170,-144},{-114,-144},{-114,-156},{-96,-134},{
                      -114,-112},{-114,-124},{-170,-124}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{136,-126},{136,-146},{192,-146},{192,-158},{210,-136},{192,
                      -114},{192,-126},{136,-126}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{53,71},{-15,43},{17,-45},{-77,-73}},
                  color={255,255,255},
                  smooth=Smooth.Bezier,
                  origin={13,19},
                  rotation=90),
                Line(
                  points={{164,38},{174,38},{174,-82},{192,-82}},
                  color={0,0,0},
                  smooth=Smooth.None)}));
        end Electric_Fan;

        model Hydraulic_Fan_Assembly "Hydraulic driven fan"
        extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice;
        //motor parameters
         parameter SI.Volume vol_per_radian_motor = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1
            "Pressure rise for 1 Nm of torque input"
                                                    annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Motor"));
         parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Motor"));
         parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                 annotation(Dialog(group="Hydraulic",tab="Motor"));

          MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Lossy
            hydraulic_Mechanical_Conversion_Lossy(
            useSupport=true,
            vol_per_radian=vol_per_radian_motor,
            Nm_per_pascal=Nm_per_pascal_motor,
            lossTable=lossTable_motor,
            J=J_motor,
            leakage=leakage_motor,
            useHeatPort=true,
            useInertia=false)  annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-110,-110})));
          MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
            annotation (Placement(transformation(extent={{-200,180},{-180,200}})));
          MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port hydraulic_Port_a
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port hydraulic_Port_b
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
        equation
          connect(thermal_To_Environment_Thru_Area.solid,
            hydraulic_Mechanical_Conversion_Lossy.heatPort) annotation (Line(
              points={{-200,190},{-200,-118},{-120,-118},{-120,-120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.support, internalSupport)
            annotation (Line(
              points={{-110,-120},{-110,-130},{0,-130},{0,-140}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(hydraulic_Port_b, hydraulic_Mechanical_Conversion_Lossy.hyd_b)
            annotation (Line(
              points={{200,120},{50,120},{50,-110},{-100,-110}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Lossy.hyd_a, hydraulic_Port_a)
            annotation (Line(
              points={{-120,-110},{-160,-110},{-160,120},{-200,120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(inertia.flange_a, hydraulic_Mechanical_Conversion_Lossy.flange)
            annotation (Line(
              points={{-28,12},{-70,12},{-70,-100},{-110,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                          extent={{-200,-320},{200,280}}),
                                                 graphics={
                Polygon(
                  points={{-79,148},{-50,148},{-50,188},{-60,188},{-40,208},{-20,188},{
                      -30,188},{-30,128},{-79,128},{-79,148}},
                  lineColor={0,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{96,-60},{148,-60},{148,-80},{198,-80}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Line(
                  points={{-196,-80},{-152,-80},{-152,-60},{-98,-60},{-98,-62}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,11},{40,-11}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95},
                  origin={-1,60},
                  rotation=90),
                Polygon(
                  points={{-120,-200},{118,-200},{60,-102},{-60,-102},{-120,-200}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-102,40},{100,-160}},
                  lineColor={0,128,255},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{20,20},{20,-20},{-20,0},{20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={81,-60},
                  rotation=180),
                Polygon(
                  points={{-62,-40},{-62,-80},{-102,-60},{-62,-40}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-60,180},{60,60}},
                  lineColor={255,0,128},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,20},{-20,-20},{20,0},{-20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={46,120},
                  rotation=180),
                Polygon(
                  points={{-66,140},{-66,100},{-26,120},{-66,140}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-200,120},{-66,120}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{66,120},{200,120}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Polygon(
                  points={{-192,-24},{-192,-44},{-136,-44},{-136,-56},{-118,-34},{-136,
                      -12},{-136,-24},{-192,-24}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{118,-24},{118,-44},{174,-44},{174,-56},{192,-34},{174,-12},{
                      174,-24},{118,-24}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p><ul>
<li></li>
</ul></p>
</html>"));
        end Hydraulic_Fan_Assembly;

        package Tests
          extends Modelica.Icons.Package;

          model Test_Delivered_Electric_Fan
          extends MSL_Extend.Icons.Simple_Test_Case;

            Electric_Fan electric_Fan(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              rotating_inertia=0.01,
              efficiency_characteristic=[0,1; 1000,1],
              flow_characteristic=[0,300; 0.1361,275; 0.2194,250; 0.4056,200; 0.4694,175;
                  0.5778,150; 0.6833,125; 0.7333,100; 0.8528,50; 0.9583,0],
              v_nom=24)
              annotation (Placement(transformation(extent={{-10,-4},{30,56}})));

            Modelica.Electrical.Spice3.Sources.V_constant v_constant(V=24)
              annotation (Placement(transformation(extent={{-2,66},{18,86}})));
            Modelica.Blocks.Sources.Constant const(k=1)
              annotation (Placement(transformation(extent={{-90,62},{-70,82}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{58,56},{78,76}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-56,20})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure1(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100100,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(extent={{48,10},{68,30}})));
          equation

            connect(ground.p, v_constant.n) annotation (Line(
                points={{68,76},{18,76}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(v_constant.p, electric_Fan.pin_p) annotation (Line(
                points={{-2,76},{-34,76},{-34,40},{-10.2,40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(v_constant.n, electric_Fan.pin_n) annotation (Line(
                points={{18,76},{28,76},{28,74},{46,74},{46,40},{30,40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(absolutePressure1.flowPort, electric_Fan.flowPort_b) annotation (Line(
                points={{48,20},{30,20}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(absolutePressure.flowPort, electric_Fan.flowPort_a) annotation (Line(
                points={{-46,20},{-10,20}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(electric_Fan.demand, const.y) annotation (Line(
                points={{2,56.8},{2,72},{-69,72}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Commands(file="Scripts/Electric_Fan_Test.mos"
                  "plot_setup_electric_fan"));
          end Test_Delivered_Electric_Fan;

          model Test_Hydraulic_Fan_Assembly
            extends MSL_Extend.Icons.Simple_Test_Case;
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                        env
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Modelica.Blocks.Sources.Constant const1(k=1000)
              annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
            Modelica.Mechanics.Rotational.Sources.Speed speed(exact=true)
              annotation (Placement(transformation(extent={{-70,60},{-50,80}})));
            inner Modelica.Fluid.System system
              annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));
            MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion
              test_hydraulic_pump(vol_per_radian=7.53982E-06)
              annotation (Placement(transformation(extent={{10,30},{-10,50}})));
            MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                            pressure_Source(P_constant=100000000)
              annotation (Placement(transformation(extent={{-56,30},{-36,50}})));

            Modelica.Blocks.Sources.Ramp ramp1(
              duration=5,
              offset=100000,
              height=10000)
              annotation (Placement(transformation(extent={{102,0},{82,20}})));
            Hydraulic_Fan_Assembly            fan_Hydraulic_Drive_Asm(
              vol_per_radian_motor=7.53982E-06,
              N_ref=418,
              rotating_inertia=0.01,
              efficiency_characteristic=[-100,1; 100,1],
              flow_characteristic=[1.212055423,1622.05821; 1.239810652,1612.01355; 1.270652418,
                  1601.96889; 1.338504302,1556.7729; 1.409438002,1496.50992; 1.46494846,1436.24943;
                  1.501958579,1401.09561; 1.56364211,1335.81279; 1.616070751,1275.54981; 1.680836099,
                  1200.22233; 1.74251963,1119.87252; 1.801116624,1039.52271; 1.835044926,999.34905;
                  1.884387031,929.04141; 1.930652039,858.73626; 1.970743974,803.49561; 2.017004262,
                  733.19046; 2.06326927,657.86298; 2.100274669,607.64466],
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
              annotation (Placement(transformation(extent={{-22,-32},{18,28}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-56,-8})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient          absolutePressure1(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100100,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(extent={{48,-18},{68,2}})));
          equation

            connect(const1.y, speed.w_ref) annotation (Line(
                points={{-79,70},{-72,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_b, pressure_Source.hydraulic_port)
              annotation (Line(
                points={{-10,40},{-36,40}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(speed.flange, test_hydraulic_pump.flange) annotation (Line(
                points={{-50,70},{0,70},{0,50}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(absolutePressure1.flowPort, fan_Hydraulic_Drive_Asm.flowPort_b)
              annotation (Line(
                points={{48,-8},{18,-8}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(absolutePressure.flowPort, fan_Hydraulic_Drive_Asm.flowPort_a)
              annotation (Line(
                points={{-46,-8},{-22,-8}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_b, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
              annotation (Line(
                points={{-10,40},{-24,40},{-24,12},{-22,12}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_a, fan_Hydraulic_Drive_Asm.hydraulic_Port_b)
              annotation (Line(
                points={{10,40},{20,40},{20,12},{18,12}},
                color={255,0,128},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=20, Interval=0.01),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Bilge_Hydraulic_Basic_Test.mos"
                  "Bilge_Hydraulic_Basic_Test", file="Scripts/Hydraulic_Fan_Test.mos"
                  "plot_setup"));
          end Test_Hydraulic_Fan_Assembly;
        end Tests;
      end Fans;

      package Radiators
        extends Modelica.Icons.Package;

        model Radiator_Main_Cooling_Pack
          "Large radiator usually intended to cool the main vehicle power plant"
          extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Base_Heat_Exchanger(
            medium_hot_fluid=Modelica.Thermal.FluidHeatFlow.Media.Water(),
            medium_cold_fluid=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
            heat_Exchanger_Map_Based_Area(T_start_hot_fluid=293.15, T_start_cold_fluid=
                  293.15));

          parameter SI.Area area_ref_hot=1 "Hot Side Reference area";

        end Radiator_Main_Cooling_Pack;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Delivered_Radiator
          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                               Hot_Fluid_Inlet(
              constantMassFlow=1.59,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientTemperature=373.15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-78,70})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                               Hot_Fluid_Out(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=373.15)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={90,70})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                               Cold_Fluid_Out(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=283.15)
              annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={90,22})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                               Cold_Fluid_In(
              constantMassFlow=13,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
              constantAmbientTemperature=283.15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-78,21})));
            Radiator_Main_Cooling_Pack        Radiator(medium_cold_fluid=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(), medium_hot_fluid=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(),
              effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
              core_length=0.59,
              core_width=0.45,
              core_depth=0.034,
              flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              pressure_drop_a=[0,0; 0.00075,6143.207; 0.00095,8273.680; 0.00115,11445.257;
                  0.00140,16409.465; 0.00165,21925.252; 0.00190,28337.354; 0.00200,
                  31424.000; 0.00240,44104.464],
              pressure_drop_b=[0,0; 0.67,23.7931452; 1.34,67.5075852; 2.01,124.430031;
                  2.68,191.9688408; 3.35,268.7501322; 4.02,353.7122688; 4.68,446.1058602;
                  5.35,545.4000882; 6.02,641.3220594; 6.69,740.647512],
              loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
              flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.volume_flow_rate,
              effectiveness_table=[0,0,0.35,0.7,1.05,1.4,1.8,2.15,2.5,2.9,3.2,3.6,3.95,
                  4.3,4.65,5,5.4,5.75,6.1,6.45,6.8; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0; 0.35,0,83,117,153,193,235,280,328,377,428,480,531,583,632,679,721,
                  758,789,811,825; 0.75,0,144,212,285,364,448,539,633,732,833,937,1040,
                  1143,1242,1336,1421,1496,1557,1603,1631; 1.1,0,185,286,395,513,639,772,
                  912,1058,1208,1361,1514,1666,1812,1951,2078,2189,2281,2349,2392; 1.45,0,
                  210,343,487,641,806,980,1162,1351,1545,1742,1941,2137,2327,2507,2672,
                  2816,2936,3025,3082; 1.8,0,225,388,564,751,951,1161,1380,1607,1839,2075,
                  2312,2546,2773,2987,3185,3358,3502,3611,3681; 2.2,0,233,424,629,846,
                  1075,1316,1566,1824,2088,2355,2622,2886,3141,3383,3606,3802,3966,4092,
                  4174; 2.55,0,239,456,685,927,1182,1447,1722,2004,2292,2581,2871,3155,
                  3431,3692,3932,4146,4325,4465,4558; 2.9,0,246,484,735,998,1272,1557,
                  1850,2149,2453,2757,3060,3358,3645,3918,4169,4394,4585,4735,4840; 3.3,0,
                  255,512,781,1060,1349,1647,1952,2263,2576,2889,3199,3502,3795,4073,4330,
                  4561,4760,4920,5036; 3.7,0,267,540,822,1114,1414,1721,2034,2350,2667,
                  2984,3296,3601,3894,4173,4433,4668,4873,5042,5168; 4,0,279,566,860,1162,
                  1469,1782,2098,2416,2734,3050,3361,3665,3957,4236,4496,4735,4946,5125,
                  5262; 4.35,0,292,590,894,1203,1516,1831,2149,2467,2783,3097,3406,3707,
                  3997,4275,4537,4780,4999,5188,5337; 4.75,0,304,612,924,1239,1556,1873,
                  2190,2506,2820,3131,3436,3734,4024,4302,4566,4814,5042,5242,5404; 5.1,0,
                  315,632,951,1271,1590,1909,2225,2539,2850,3157,3459,3755,4043,4321,4588,
                  4841,5078,5289,5465; 5.5,0,325,651,976,1301,1623,1942,2257,2569,2877,
                  3180,3479,3772,4058,4336,4604,4862,5106,5328,5517; 5.9,0,334,668,1000,
                  1329,1654,1975,2290,2601,2906,3206,3501,3791,4074,4350,4619,4879,5128,
                  5360,5559; 6.2,0,343,685,1024,1359,1688,2011,2328,2638,2943,3241,3533,
                  3819,4100,4373,4639,4899,5152,5389,5599; 6.9,0,361,720,1076,1426,1769,
                  2104,2431,2750,3060,3362,3655,3941,4219,4489,4753,5012,5267,5512,5734],
              ref_core_length=0.59,
              ref_core_width=0.45,
              ref_core_depth=0.034)
                       annotation (Placement(transformation(extent={{-2,16},{40,76}})));

             // T_start_hot_fluid=373.15,
             // T_start_cold_fluid=303.15

            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
              temperature_cold_side(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
              annotation (Placement(transformation(extent={{62,-8},{82,12}})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
              temperature_hot_side(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{68,36},{88,56}})));
          equation

            connect(Cold_Fluid_Out.flowPort, Radiator.cold_fluid_out) annotation (Line(
                points={{80,22},{61,22}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Hot_Fluid_Out.flowPort, Radiator.hot_fluid_out) annotation (Line(
                points={{80,70},{61,70}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Radiator.cold_fluid_in, Cold_Fluid_In.flowPort) annotation (Line(
                points={{-23,22},{-45.5,22},{-45.5,21},{-68,21}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(Radiator.hot_fluid_in, Hot_Fluid_Inlet.flowPort) annotation (Line(
                points={{-23,70},{-68,70}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_hot_side.flowPort, Radiator.hot_fluid_out) annotation (
                Line(
                points={{68,46},{62,46},{62,70},{61,70}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature_cold_side.flowPort, Radiator.cold_fluid_out)
              annotation (Line(
                points={{62,2},{62,22},{61,22}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Commands(file="Scripts/Radiator_Test.mos"
                  "plot_setup"));
          end Test_Delivered_Radiator;
        end Tests;
      end Radiators;

      package Fill_and_Pressurization
        "Components for filling and maintaining pressurization of coolant system"
        extends Modelica.Icons.Package;

        model Degas_Bottle

          MSL_Extend.Thermal.FluidHeatFlow.Components.Volumes.Degas_Bottle
                                          degas_Bottle(
            p_degas_bottle=p_degas_bottle)
            annotation (Placement(transformation(extent={{-20,-8},{48,50}})));
          parameter Modelica.Media.Interfaces.PartialMedium.AbsolutePressure
            p_degas_bottle=1e5 "degas bottle operating pressure";

          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a flowPort_a(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water()) annotation (
              Placement(transformation(extent={{-210,-90},{-190,-70}})));
        equation
          connect(flowPort_a, degas_Bottle.port_a) annotation (Line(
              points={{-200,-80},{-112,-80},{-112,0.7},{-20,0.7}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=
                    true, extent={{-200,-320},{200,280}}), graphics={
                Rectangle(
                  extent={{-132,98},{128,-42}},
                  radius=40,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-132,38},{128,-42}},
                  radius=40,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-132,38},{128,-2}},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-132,98},{128,-42}},
                  lineColor={0,0,0},
                  radius=40),
                Ellipse(
                  extent={{-16,-12},{4,-32}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-52,4},{-32,-16}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{4,24},{24,4}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-198,-80},{-30,-80},{-30,-42}},
                  color={170,213,255},
                  smooth=Smooth.None)}));
        end Degas_Bottle;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Degas_Bottle
          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Degas_Bottle degas_Bottle(p_degas_bottle=120000)
              annotation (Placement(transformation(extent={{-32,-18},{8,42}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient ambient(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15) annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-84,6})));
          equation

            connect(ambient.flowPort, degas_Bottle.flowPort_a) annotation (Line(
                points={{-74,6},{-32,6}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics));
          end Test_Degas_Bottle;
        end Tests;
      end Fill_and_Pressurization;

      package Contact_Cooler
        extends Modelica.Icons.Package;

        model Contact_Cooler
          "Links a fluid stream thermally with a solid component via a simplified relationship.  Also includes a pressure vs flow characteristic."
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Contact_Cooler
                                               contact_Cooler(
            ambient_water_temperature=ambient_water_temperature,
            length=length,
            width=width,
            height=height,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            medium=medium,
            m=0)
            annotation (Placement(transformation(extent={{-20,-100},{20,-60}})));
          parameter SI.Temperature ambient_water_temperature=277
            "Temperature of the ambient surrounding the contact cooler";
          parameter SI.Length length=0.1 "length along the flow tubes";
          parameter SI.Length width=0.1 "width across the tubes";
          parameter SI.Length height=0.1 "height of the tubes";
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal flow rate of the fluid";
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom";
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-210,-90},{-190,-70}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                medium)
            annotation (Placement(transformation(extent={{190,-90},{210,-70}})));
        equation
          connect(contact_Cooler.flowPort_b, fluid_out) annotation (Line(
              points={{20,-80},{200,-80}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(contact_Cooler.flowPort_a, fluid_in) annotation (Line(
              points={{-20,-80},{-200,-80}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
This component models a generic resistance parameterized
with the volume flow rate:
</p>

<pre>
    dp     = a*V_flow^2 + b*V_flow
    m_flow = rho*V_flow
</pre>

<p>
with
</p>

<table>
<tr><td><b> a              </b></td><td> as quadratic coefficient [Pa*s^2/m^6],</td></tr>
<tr><td><b> b              </b></td><td> as linear coefficient [Pa*s/m3],</td></tr>
<tr><td><b> dp             </b></td><td> as pressure loss [Pa],</td></tr>
<tr><td><b> m_flow         </b></td><td> as mass flow rate [kg/s],</td></tr>
<tr><td><b> rho            </b></td><td> as density of fluid [kg/m3],</td></tr>
<tr><td><b> V_flow         </b></td><td> as volume flow rate [m3/s].</td></tr>
</table>

<p>
The geometry parameters of energy devices necessary for the pressure loss calculations are often not exactly known. Therefore the modelling of the detailed pressure loss calculation has to be simplified. This components use a linear and a quadratic dependence of the pressure loss on the volume flow rate. It is assumed that neither mass nor energy is stored in this component.
In the model basically a function is called to compute the mass flow rate as a function
of pressure loss. Also the inverse of this function is defined, and a tool
might use this inverse function instead, in order to avoid the solution of a nonlinear equation.
</p>

<p>
The details of the model are described in the 
<a href=\"modelica://Modelica.Fluid.Dissipation.Utilities.SharedDocumentation.PressureLoss.General.dp_volumeFlowRate\">documentation of the underlying function</a>.
</p>

</html>"),  Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},{
                    200,280}}),
                            graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-320},{200,280}}),
                 graphics={
                Rectangle(
                  extent={{-80,-16},{90,-100}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,40},{90,40}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Filled}),
                Line(
                  points={{-82,0},{88,0}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  arrow={Arrow.None,Arrow.Filled}),
                Rectangle(extent={{-80,60},{90,-16}}, lineColor={0,0,0}),
                Line(
                  points={{-198,-80},{-140,-80},{-140,20},{-80,20}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{90,20},{142,20},{142,-80},{200,-80}},
                  color={0,0,255},
                  smooth=Smooth.None)}));
        end Contact_Cooler;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Contact_Cooler
          extends MSL_Extend.Icons.Simple_Test_Case;
            Contact_Cooler contact_Cooler(
              length=10,
              height=0.01,
              V_dot_nom=0.01,
              width=0.5,
              ambient_water_temperature=293.15,
              dp_nom=50000)
              annotation (Placement(transformation(extent={{-26,-12},{14,48}})));
            MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                    Coolant_Inlet(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              useMassFlowInput=true,
              constantAmbientTemperature=373.15)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-49,12})));
            Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                      temperature(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={38,22})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient
                                               Coolant_Outlet(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15)
                        annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={70,12})));

            Modelica.Blocks.Sources.Ramp ramp(
              height=10,
              duration=1,
              startTime=1,
              offset=0.001)
              annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          equation

            connect(Coolant_Inlet.massflow, ramp.y) annotation (Line(
                points={{-59,5},{-67.5,5},{-67.5,10},{-79,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(Coolant_Outlet.flowPort, temperature.flowPort) annotation (Line(
                points={{60,12},{38,12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(temperature.flowPort, contact_Cooler.fluid_out) annotation (Line(
                points={{38,12},{14,12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(contact_Cooler.fluid_in, Coolant_Inlet.flowPort) annotation (Line(
                points={{-26,12},{-39,12}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{
                      -100,-100},{100,100}}),
                                graphics),
              experiment(StopTime=3),
              __Dymola_experimentSetupOutput);
          end Test_Contact_Cooler;
        end Tests;
      end Contact_Cooler;
    end Cooling_System;

    package Electrical_System "Electrical components related to mobility"
    extends Modelica.Icons.Package;

      package Hybrid_Drive_Systems
        "Components related to high power electronics for hybrid systems (e.g. traction motors, ISGs, Lithium-Ion battery packs)"
        extends Modelica.Icons.Package;

        model Integrated_Starter_Generator
          "Device typically used on mild hybrids"
        extends
            C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.Partial_Support;
          parameter SI.Inertia rotating_inertia = 1.0
            "Moment of inertia of device around its axis of rotation";
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
            parameter SI.AngularVelocity w_cut = 50
            "Rotational speed below which the device is not designed to perform"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque max_torque=1800 "Maximum torque"
            annotation (Dialog(tab="Electrical Model"));
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion"
            annotation (Dialog(tab="Electrical Model"));

          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Real effectiveness_nom=0.7
            "Nominal effectiveness of the cooling passages"
                                                           annotation (Dialog(tab="Fluid Model"));
          parameter SI.Power cooling_Q_nom=1000
            "Nominal amount of heat rejection required"
                                                       annotation (Dialog(tab="Fluid Model"));
          parameter SI.Temperature T_inlet_nom=323.15
            "Nominal fluid inlet temperature"                                          annotation (Dialog(tab="Fluid Model"));
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal volume flow rate of fluid"
                                               annotation (Dialog(tab="Fluid Model"));
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom"                                annotation (Dialog(tab="Fluid Model"));

          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
            thermal_bridge(
            medium=medium,
            m=0,
            effectiveness_nom=effectiveness_nom,
            cooling_Q_nom=cooling_Q_nom,
            T_inlet_nom=T_inlet_nom,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            T0=293.15)
            annotation (Placement(transformation(extent={{-130,170},{-110,190}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=medium)
            annotation (Placement(transformation(extent={{-90,230},{-70,250}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-170,230},{-150,250}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          MSL_Extend.Electrical.Electric_Machines.Electric_Generator
                                                              emf(useSupport=true,
            w_cut=w_cut,
            max_torque=max_torque,
            efficiency=efficiency,
            v_nom=v_nom)
            annotation (Placement(transformation(
                extent={{-11,10},{11,-10}},
                rotation=180,
                origin={-1,0})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_1D(J=
                rotating_inertia)
            annotation (Placement(transformation(extent={{-64,-30},{-44,-10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a         brg_01
            annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,248})));
          Modelica.Blocks.Interfaces.RealOutput w
            annotation (Placement(transformation(extent={{196,30},{216,50}})));
          Modelica.Blocks.Interfaces.RealOutput tau
            annotation (Placement(transformation(extent={{196,-50},{216,-30}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{196,-10},{216,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{196,-90},{216,-70}})));
        equation
          connect(thermal_bridge.flowPort_a, fluid_in)   annotation (Line(
              points={{-130,180},{-150,180},{-150,240},{-160,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_b, fluid_out) annotation (Line(
              points={{-110,180},{-80,180},{-80,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(emf.n,pin_n)  annotation (Line(
              points={{-1,-8},{0,-8},{0,-20},{74,-20},{74,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(emf.p,pin_p)  annotation (Line(
              points={{-1,8},{-1,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(emf.flange, brg_01) annotation (Line(
              points={{-12,1.33227e-015},{-104,1.33227e-015},{-104,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_1D.flange_a, brg_01) annotation (Line(
              points={{-64,-20},{-100,-20},{-100,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(emf.heatPort, thermal_bridge.heatPort) annotation (Line(
              points={{7.8,-8},{20,-8},{20,140},{-120,140},{-120,170}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(emf.support, internalSupport) annotation (Line(
              points={{10,-1.33227e-015},{40,-1.33227e-015},{40,-60},{0,-60},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));

          connect(emf.demand, demand) annotation (Line(
              points={{-12.66,-7.3},{-40,-7.3},{-40,248}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.w, w) annotation (Line(
              points={{-12.66,-5.4},{-28,-5.4},{-28,26},{82,26},{82,40},{206,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.tau, tau) annotation (Line(
              points={{-12.66,-2.9},{-20,-2.9},{-20,18},{88,18},{88,-40},{206,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.i, i) annotation (Line(
              points={{-12.66,-4.1},{-24,-4.1},{-24,22},{106,22},{106,0},{206,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.v, v) annotation (Line(
              points={{-12.66,-1.5},{-16,-1.5},{-16,12},{70,12},{70,-80},{206,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -240},{200,240}}),
                              graphics), Icon(coordinateSystem(extent={{-200,-240},{200,
                    240}}),                   graphics={
                Rectangle(
                  extent={{-190,10},{-138,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95}),
                Line(
                  points={{-162,238},{-162,168},{-134,168},{-134,82},{-114,102},{-94,82}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-36,102},{-16,82},{6,102},{6,168},{-80,168},{-80,240}},
                  color={255,85,85},
                  smooth=Smooth.None),
                Line(
                  points={{-200,120},{-162,120},{-162,56},{-130,56}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{198,120},{42,120},{42,58},{-18,58}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-138,76},{20,-76}},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95},
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Line(
                  points={{-94,82},{-74,102},{-56,82},{-36,102}},
                  color={255,0,255},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>Basic model of a high voltage generator. The output voltage is generated when torque is applied to the shaft. The voltage is limited by the maximum torque parameter. </p>
</html>"));
        end Integrated_Starter_Generator;

        model Traction_Motor_Liquid_Cooled
          "Device typically used in full hybrids"
          extends
            C2M2L_OM.MSL_Extend.Mechanics.Rotational.Interfaces.Partial_Support;
          parameter SI.Inertia rotating_inertia = 0.1
            "Moment of inertia of device around its axis of rotation";
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
          annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque trq_max=100 "Maximum output torque"
          annotation (Dialog(tab="Electrical Model"));
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion"
            annotation (Dialog(tab="Electrical Model"));
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Real effectiveness_nom=0.7
            "Nominal effectiveness of the cooling passages"
                                                           annotation (Dialog(tab="Fluid Model"));
          parameter SI.Power cooling_Q_nom=1000
            "Nominal amount of heat rejection required"
                                                       annotation (Dialog(tab="Fluid Model"));
          parameter SI.Temperature T_inlet_nom=323.15
            "Nominal fluid inlet temperature"                                          annotation (Dialog(tab="Fluid Model"));
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal volume flow rate of fluid"
                                               annotation (Dialog(tab="Fluid Model"));
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom"                                annotation (Dialog(tab="Fluid Model"));

          MSL_Extend.Electrical.Electric_Machines.Electric_Motor
                                                      electric_Motor(
              v_nom=v_nom,
              pow_max=pow_max,
              trq_max=trq_max,
              efficiency=efficiency,
              use_heat_port=true,
              useSupport=true,
            v_max=v_max,
            trq_nom=trq_nom,
            temp_max=temp_max)
            annotation (Placement(transformation(extent={{20,-20},{-20,20}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_1D(J=
                rotating_inertia)
            annotation (Placement(transformation(extent={{-70,-30},{-50,-10}})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a         brg_01
            annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
            thermal_bridge(
            medium=medium,
            m=0,
            effectiveness_nom=effectiveness_nom,
            cooling_Q_nom=cooling_Q_nom,
            T_inlet_nom=T_inlet_nom,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            T0=293.15)
            annotation (Placement(transformation(extent={{-130,170},{-110,190}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=medium)
            annotation (Placement(transformation(extent={{-90,230},{-70,250}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-170,230},{-150,250}})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,248})));
          Modelica.Blocks.Interfaces.RealOutput w
            annotation (Placement(transformation(extent={{196,30},{216,50}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{196,-10},{216,10}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{196,-50},{216,-30}})));
          Modelica.Blocks.Interfaces.RealOutput tau
            annotation (Placement(transformation(extent={{196,70},{216,90}})));
        public
          parameter SI.Voltage v_max=250
            "Maximum voltage at which data was generated"
           annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque trq_nom=50 "Nominal output torque"
           annotation (Dialog(tab="Electrical Model"));
          parameter SI.Temperature temp_max=373.15 "Maximum device temp"
           annotation (Dialog(tab="Electrical Model"));
        equation
          connect(pin_p,electric_Motor. p) annotation (Line(
              points={{-200,120},{0,120},{0,16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.n,pin_n)  annotation (Line(
              points={{0,-16},{0,-20},{40,-20},{40,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.flange, brg_01) annotation (Line(
              points={{-20,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_1D.flange_a, brg_01) annotation (Line(
              points={{-70,-20},{-100,-20},{-100,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_a, fluid_in)   annotation (Line(
              points={{-130,180},{-150,180},{-150,240},{-160,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_b, fluid_out) annotation (Line(
              points={{-110,180},{-80,180},{-80,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.heatPort, electric_Motor.heatPort) annotation (Line(
              points={{-120,170},{-120,140},{60,140},{60,-40},{16,-40},{16,-16}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(electric_Motor.support, internalSupport) annotation (Line(
              points={{20,0},{82,0},{82,-60},{0,-60},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(electric_Motor.demand, demand) annotation (Line(
              points={{-21.2,6},{-40,6},{-40,248}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.w, w) annotation (Line(
              points={{-21.2,15.6},{-28,15.6},{-28,40},{206,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.i, i) annotation (Line(
              points={{-13.6,21.2},{-13.6,28},{160,28},{160,0},{206,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.v, v) annotation (Line(
              points={{-6.4,21.2},{136,21.2},{136,-40},{206,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.tau, tau) annotation (Line(
              points={{-21.2,11.2},{-32,11.2},{-32,80},{206,80}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -240},{200,240}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-240},{200,240}}),
                                              graphics={
                Rectangle(
                  extent={{-54,10},{-192,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95}),
                Line(
                  points={{-200,120},{-162,120},{-162,56},{-130,56}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{198,120},{42,120},{42,58},{-18,58}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{8,70},{-140,-74}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,128,255}),
                Line(
                  points={{-162,238},{-162,168},{-134,168},{-134,82},{-114,102},{-94,82}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-94,82},{-74,102},{-56,82},{-36,102}},
                  color={255,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-36,102},{-16,82},{6,102},{6,168},{-80,168},{-80,240}},
                  color={255,85,85},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>Basic model of a high voltage electric motor. The maximum torque is generated when a voltage is applied to the motor. As the motor rotational speed increases the torque is limited by a maximum value.The electrical power of the motor further limits the torque output. A typical torque curve shows where the torque and power are limited as a function of motor speed.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Electric_Machine_Curve\"/> </p>
</html>"));
        end Traction_Motor_Liquid_Cooled;

        model High_Voltage_Battery
          "Provides energy storage to support hybrid operations"
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter SI.Voltage v_nom=400
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
           parameter SI.Resistance R_batt=0.001
            "Battery internal resistance (Ohm)"
             annotation(Dialog(tab="Electrical Model"));
           parameter SI.Temperature T_ref=293.15
            "Reference temperature for battery operation"
                 annotation(Dialog(tab="Electrical Model"));
           parameter SI.Mass mass_batt=5 "Thermal mass of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.ThermalResistance R_thermal=0.01
            "Battery thermal resistance"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.SpecificHeatCapacity cp_batt=1000
            "Specific heat of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.Temperature T_start=293.15
            "Start temperature of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter Real soc_init=0.6 "Initial state of charge (0 - 1)"
               annotation(Dialog(tab="Electrical Model"));
          parameter SI.Voltage e_max = 450 "Maximum battery voltage" annotation(Dialog(tab="Electrical Model"));
          parameter SI.Charge q_max = 100000 "Maximum capacity" annotation(Dialog(tab="Electrical Model"));

          parameter Real effectiveness_nom=0.7
            "Nominal effectiveness of the cooling passages"
                                                           annotation (Dialog(tab="Fluid Model"));
          parameter SI.Power cooling_Q_nom=1000
            "Nominal amount of heat rejection required"
                                                       annotation (Dialog(tab="Fluid Model"));
          parameter SI.Temperature T_inlet_nom=323.15
            "Nominal fluid inlet temperature"                                          annotation (Dialog(tab="Fluid Model"));
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal volume flow rate of fluid"
                                               annotation (Dialog(tab="Fluid Model"));
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom"                                annotation (Dialog(tab="Fluid Model"));

        public
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,130},{-190,150}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,130},{210,150}})));
          MSL_Extend.Electrical.Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                  battery_Simplified(
              R_batt=R_batt,
              T_ref=T_ref,
              mass_batt=mass_batt,
              R_thermal=R_thermal,
              cp_batt=cp_batt,
              T_start=T_start,
              soc_init=soc_init,
            useHeatPort=true,
            v_battery(
              soc_init=soc_init,
              e_max=e_max,
              q_max=q_max,
              e_nom=v_nom))                                                             annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=0,
                origin={0,0})));
          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
            thermal_bridge(
            medium=medium,
            m=0,
            effectiveness_nom=effectiveness_nom,
            cooling_Q_nom=cooling_Q_nom,
            T_inlet_nom=T_inlet_nom,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            T0=293.15)
            annotation (Placement(transformation(extent={{-160,130},{-140,150}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-210,190},{-190,210}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
                medium)
            annotation (Placement(transformation(extent={{-150,190},{-130,210}})));
          Modelica.Blocks.Interfaces.RealOutput i
            annotation (Placement(transformation(extent={{196,30},{216,50}})));
          Modelica.Blocks.Interfaces.RealOutput v
            annotation (Placement(transformation(extent={{196,-10},{216,10}})));
          Modelica.Blocks.Interfaces.RealOutput soc
            annotation (Placement(transformation(extent={{196,-90},{216,-70}})));
          Modelica.Blocks.Interfaces.RealOutput Temp
            annotation (Placement(transformation(extent={{196,-50},{216,-30}})));
        equation
          connect(battery_Simplified.v_batt, pin_p) annotation (Line(
              points={{-16,20},{-200,20},{-200,140}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(battery_Simplified.rtn, pin_n) annotation (Line(
              points={{16,20},{108,20},{108,140},{200,140}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_b, fluid_out)
                                                annotation (Line(
              points={{-140,140},{-140,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(battery_Simplified.heatPort, thermal_bridge.heatPort) annotation (
              Line(
              points={{-20,-20},{-150,-20},{-150,130}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_a, fluid_in)   annotation (Line(
              points={{-160,140},{-180,140},{-180,200},{-200,200}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(battery_Simplified.i, i) annotation (Line(
              points={{21.2,5.6},{110.6,5.6},{110.6,40},{206,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.v, v) annotation (Line(
              points={{21.2,2.8},{110.6,2.8},{110.6,0},{206,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.Temp, Temp) annotation (Line(
              points={{21.2,0},{110,0},{110,-40},{206,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(soc, battery_Simplified.soc) annotation (Line(
              points={{206,-80},{108,-80},{108,-2.8},{21.2,-2.8}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -200},{200,200}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-200},{200,200}}), graphics={
                Line(
                  points={{-200,140},{-78,140},{-78,90}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{194,140},{72,140},{72,94}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={255,208,221},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={2,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-2.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-120,102},{-36,24}},
                  lineColor={255,0,0},
                  textString="+"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={82,67},
                  rotation=180)}),
            Documentation(info="<html>
<p>This Battery component models a voltage source with an internal resistance. The battery voltage is defined as a function of the charge of the battery. The battery voltage and current is given at the positive (+) &apos;v_batt&apos; pin. The state of charge (SOC) is given at the output connector &apos;soc&apos;. Thermal properties must be defined to determine thermal effects.A typical charge curvel is shown below.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Battery_Curve.png\"/> </p>
</html>"));
        end High_Voltage_Battery;

        model DC_DC_Converter_Liquid_Cooled
          "Device typically used on mild hybrids"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter Real gain=0.5 "Converter gain"
            annotation (Dialog(tab="Electrical Model"));
          parameter Real eff=1 "Inverter efficiency"
            annotation (Dialog(tab="Electrical Model"));
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Real effectiveness_nom=0.7
            "Nominal effectiveness of the cooling passages"
                                                           annotation (Dialog(tab="Fluid Model"));
          parameter SI.Power cooling_Q_nom=1000
            "Nominal amount of heat rejection required"
                                                       annotation (Dialog(tab="Fluid Model"));
          parameter SI.Temperature T_inlet_nom=323.15
            "Nominal fluid inlet temperature"                                          annotation (Dialog(tab="Fluid Model"));
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal volume flow rate of fluid"
                                               annotation (Dialog(tab="Fluid Model"));
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom"                                annotation (Dialog(tab="Fluid Model"));

          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
            thermal_bridge(
            medium=medium,
            m=0,
            effectiveness_nom=effectiveness_nom,
            cooling_Q_nom=cooling_Q_nom,
            T_inlet_nom=T_inlet_nom,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            T0=293.15)
            annotation (Placement(transformation(extent={{-130,170},{-110,190}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=medium)
            annotation (Placement(transformation(extent={{-90,230},{-70,250}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-170,230},{-150,250}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          MSL_Extend.Electrical.Power_Converters.DC_DC_Converter
                                                      dC_DC_Converter(
            use_heat_port=true,
            gain=gain,
            eff=eff)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,0})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n_supply
            annotation (Placement(transformation(extent={{190,-130},{210,-110}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p_supply
            annotation (Placement(transformation(extent={{-210,-130},{-190,-110}})));
        equation
          connect(thermal_bridge.flowPort_a, fluid_in)   annotation (Line(
              points={{-130,180},{-150,180},{-150,240},{-160,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_b, fluid_out) annotation (Line(
              points={{-110,180},{-80,180},{-80,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(dC_DC_Converter.neg_out,pin_n)  annotation (Line(
              points={{6,10},{6,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(dC_DC_Converter.pos_out,pin_p)  annotation (Line(
              points={{-6,10},{-6,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(pin_p_supply,dC_DC_Converter. pos_in) annotation (Line(
              points={{-200,-120},{-6,-120},{-6,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(pin_n_supply,dC_DC_Converter. neg_in) annotation (Line(
              points={{200,-120},{6,-120},{6,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(dC_DC_Converter.heatPort, thermal_bridge.heatPort) annotation (Line(
              points={{10,-6.66134e-016},{40,-6.66134e-016},{40,140},{-120,140},{-120,170}},
              color={191,0,0},
              smooth=Smooth.None));

          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -240},{200,240}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-240},{200,240}}),
                                                       graphics={
                Text(
                  extent={{-242,-28},{-102,-102}},
                  lineColor={0,0,255},
                  textString="Hi"),
                Text(
                  extent={{-248,100},{-102,24}},
                  lineColor={0,0,255},
                  textString="Lo"),
                Line(
                  points={{-160,240},{-160,152},{-78,152},{-78,38},{-58,58},{-38,38}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-38,38},{-18,58},{0,38},{20,58}},
                  color={255,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{20,58},{40,38},{62,58},{62,176},{-80,176},{-80,240}},
                  color={255,85,85},
                  smooth=Smooth.None),
                Line(
                  points={{-200,-120},{-134,-120},{-134,-16},{132,-16},{132,-120},{200,
                      -120}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-200,120},{-134,120},{-134,20},{132,20},{132,120},{200,120}},
                  color={0,0,255},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>DC DC Converter is an&nbsp;<a href=\"http://en.wikipedia.org/wiki/Electronic_circuit\">electronic circuit</a>&nbsp;which converts a DC source from one&nbsp;<a href=\"http://en.wikipedia.org/wiki/Voltage\">voltage</a>&nbsp;level to another. It contains an efficiency parameter and power loss as heat.</p>
</html>"));
        end DC_DC_Converter_Liquid_Cooled;

        model Inverter_Liquid_Cooled "Device typically used on mild hybrids"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter Real eff=1 "Converter efficiency"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Voltage v_targ=200 "Target voltage on the output side"
              annotation (Dialog(tab="Electrical Model"));
          parameter SI.Voltage v_cutoff=100
            "Minimum allowed voltage on the input side"
              annotation (Dialog(tab="Electrical Model"));
          parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=Modelica.Thermal.FluidHeatFlow.Media.Water()
            "Medium in the component"
            annotation(__Dymola_choicesAllMatching=true);
          parameter Real effectiveness_nom=0.7
            "Nominal effectiveness of the cooling passages"
                                                           annotation (Dialog(tab="Fluid Model"));
          parameter SI.Power cooling_Q_nom=1000
            "Nominal amount of heat rejection required"
                                                       annotation (Dialog(tab="Fluid Model"));
          parameter SI.Temperature T_inlet_nom=323.15
            "Nominal fluid inlet temperature"                                          annotation (Dialog(tab="Fluid Model"));
          parameter SI.VolumeFlowRate V_dot_nom=0.001
            "Nominal volume flow rate of fluid"
                                               annotation (Dialog(tab="Fluid Model"));
          parameter SI.Pressure dp_nom=2000
            "Nominal pressure drop at V_dot_nom"                                annotation (Dialog(tab="Fluid Model"));

          MSL_Extend.Thermal.FluidHeatFlow.Components.Valves_and_pipes.Thermal_Bridge_With_Pressure_Drop
            thermal_bridge(
            medium=medium,
            m=0,
            effectiveness_nom=effectiveness_nom,
            cooling_Q_nom=cooling_Q_nom,
            T_inlet_nom=T_inlet_nom,
            V_dot_nom=V_dot_nom,
            dp_nom=dp_nom,
            T0=293.15)
            annotation (Placement(transformation(extent={{-130,170},{-110,190}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=medium)
            annotation (Placement(transformation(extent={{-90,230},{-70,250}})));
          Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
            annotation (Placement(transformation(extent={{-170,230},{-150,250}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n_supply
            annotation (Placement(transformation(extent={{190,-130},{210,-110}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p_supply
            annotation (Placement(transformation(extent={{-210,-130},{-190,-110}})));
          MSL_Extend.Electrical.Power_Converters.Inverter
                                               inverter(
            use_heat_port=true,
            eff=eff,
            v_targ=v_targ,
            v_cutoff=v_cutoff)
                     annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,0})));

          Modelica.Electrical.Analog.Ideal.IdealDiode idealDiode
            annotation (Placement(transformation(extent={{-102,-130},{-82,-110}})));
        equation
          connect(thermal_bridge.flowPort_a, fluid_in)   annotation (Line(
              points={{-130,180},{-150,180},{-150,240},{-160,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(thermal_bridge.flowPort_b, fluid_out) annotation (Line(
              points={{-110,180},{-80,180},{-80,240}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(inverter.n1,pin_n_supply)  annotation (Line(
              points={{5,-10},{6,-10},{6,-120},{200,-120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(inverter.n2,pin_n)  annotation (Line(
              points={{5,10},{5,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(inverter.p2,pin_p)  annotation (Line(
              points={{-5,10},{-5,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(inverter.heatPort, thermal_bridge.heatPort) annotation (Line(
              points={{10,-6.66134e-016},{40,-6.66134e-016},{40,140},{-120,140},{-120,170}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(idealDiode.p, pin_p_supply) annotation (Line(
              points={{-102,-120},{-200,-120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(idealDiode.n, inverter.p1) annotation (Line(
              points={{-82,-120},{-5,-120},{-5,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -240},{200,240}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-240},{200,240}}),
                                                       graphics={
                Text(
                  extent={{-242,-28},{-102,-102}},
                  lineColor={0,0,255},
                  textString="DC"),
                Text(
                  extent={{-248,100},{-102,24}},
                  lineColor={0,0,255},
                  textString="AC"),
                Line(
                  points={{-160,240},{-160,152},{-78,152},{-78,38},{-58,58},{-38,38}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-38,38},{-18,58},{0,38},{20,58}},
                  color={255,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{20,58},{40,38},{62,58},{62,176},{-80,176},{-80,240}},
                  color={255,85,85},
                  smooth=Smooth.None),
                Line(
                  points={{-200,-120},{-134,-120},{-134,-16},{132,-16},{132,-120},{200,
                      -120}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-200,120},{-134,120},{-134,20},{132,20},{132,120},{200,120}},
                  color={0,0,255},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>The inverter is an&nbsp;electrical power converter&nbsp;which changes DC current to psuedo AC root mean square (RMS) current. It contains an efficiency parameter and power loss as heat.</p>
</html>"));
        end Inverter_Liquid_Cooled;

        package Tests
          extends Modelica.Icons.Package;

          model Test_DC_DC_Converter
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            DC_DC_Converter_Liquid_Cooled
                            dC_DC_Converter(gain=0.05)
              annotation (Placement(transformation(extent={{-20,-12},{20,48}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-22,60},{-2,80}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{34,-92},{46,-80}})));
            High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-20,-72},{20,-32}})));
            Modelica.Electrical.Analog.Basic.Resistor load_low_voltage(R=0.01)
              annotation (Placement(transformation(extent={{-20,80},{0,100}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-22,-22},{-2,-2}})));
          equation

            connect(ground.p,high_Voltage_Battery. pin_n) annotation (Line(
                points={{40,-80},{40,-38},{20,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_low_voltage.p, dC_DC_Converter.pin_p) annotation (Line(
                points={{-20,90},{-40,90},{-40,33},{-20,33}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_low_voltage.n, dC_DC_Converter.pin_n) annotation (Line(
                points={{0,90},{40,90},{40,33},{20,33}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.pin_p, dC_DC_Converter.pin_p_supply) annotation (
               Line(
                points={{-20,-38},{-40,-38},{-40,3},{-20,3}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.pin_n, dC_DC_Converter.pin_n_supply) annotation (
               Line(
                points={{20,-38},{40,-38},{40,3},{20,3}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, dC_DC_Converter.fluid_out) annotation (
               Line(
                points={{-6,60},{-8,60},{-8,48}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, dC_DC_Converter.fluid_in) annotation (
                Line(
                points={{-18,60},{-18,56},{-16,56},{-16,48}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-18,-22},{-20,-22},{-20,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.fluid_out, fluid_Source_Sink1.return_port)
              annotation (Line(
                points={{-14,-32},{-10,-32},{-10,-22},{-6,-22}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=5000),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/DC_DC_Converter_Liquid_Cooled_plot_script.mos"));
          end Test_DC_DC_Converter;

          model Test_High_Voltage_Battery
              extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Resistor discharge_load(useHeatPort=false, R=0.5)
                                                                     annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={7,-1})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-2,-88},{10,-76}})));
            High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-60,-72},{-20,-32}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-64,-20},{-44,0}})));
            Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch    switch_mode
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-4,32})));
            Modelica.Blocks.Logical.Hysteresis hysteresis(
              pre_y_start=false,
              uLow=0.1,
              uHigh=0.95)
              annotation (Placement(transformation(extent={{82,40},{62,60}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage charging_source(V=500)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={40,-18})));
            Modelica.Electrical.Analog.Basic.Resistor charging_current_limiter(
                useHeatPort=false, R=0.05)                           annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={9,-19})));
          equation

            connect(high_Voltage_Battery.pin_n, discharge_load.n) annotation (Line(
                points={{-20,-38},{-10,-38},{-10,-1},{-8.88178e-016,-1}},
                color={0,0,255},
                smooth=Smooth.None));

            connect(ground.p, high_Voltage_Battery.pin_n) annotation (Line(
                points={{4,-76},{4,-38},{-20,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.n1, charging_source.p) annotation (Line(
                points={{6,37},{50,37},{50,-18}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.n2, discharge_load.p) annotation (Line(
                points={{6,32},{34,32},{34,-1},{14,-1}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(hysteresis.y,switch_mode. control) annotation (Line(
                points={{61,50},{-4,50},{-4,40}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(switch_mode.p, high_Voltage_Battery.pin_p) annotation (Line(
                points={{-14,32},{-74,32},{-74,-38},{-60,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(charging_current_limiter.p,charging_source. n) annotation (Line(
                points={{16,-19},{24,-19},{24,-18},{30,-18}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.soc, hysteresis.u) annotation (Line(
                points={{-19.4,-60},{100,-60},{100,50},{84,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-60,-20},{-60,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.return_port, high_Voltage_Battery.fluid_out)
              annotation (Line(
                points={{-48,-20},{-52,-20},{-52,-32},{-54,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(charging_current_limiter.n, ground.p) annotation (Line(
                points={{2,-19},{-6,-19},{-6,-20},{-10,-20},{-10,-38},{4,-38},{4,-76}},
                color={0,0,255},
                smooth=Smooth.None));

            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/High_Voltage_Battery_plot_script.mos"));
          end Test_High_Voltage_Battery;

          model Test_Inverter
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-22,58},{-2,78}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{34,-92},{46,-80}})));
            Modelica.Electrical.Analog.Basic.Resistor load_resistor(R=0.1)
              annotation (Placement(transformation(extent={{-20,80},{0,100}})));
            Inverter_Liquid_Cooled inverter_Liquid_Cooled
              annotation (Placement(transformation(extent={{-20,-12},{20,48}})));
            High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-20,-72},{20,-32}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-20,-22},{0,-2}})));
          equation

            connect(inverter_Liquid_Cooled.pin_p, load_resistor.p)    annotation (Line(
                points={{-20,33},{-40,33},{-40,90},{-20,90}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_resistor.n, inverter_Liquid_Cooled.pin_n)    annotation (Line(
                points={{0,90},{40,90},{40,33},{20,33}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.pin_p, inverter_Liquid_Cooled.pin_p_supply)
              annotation (Line(
                points={{-20,-38},{-40,-38},{-40,3},{-20,3}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inverter_Liquid_Cooled.pin_n_supply, high_Voltage_Battery.pin_n)
              annotation (Line(
                points={{20,3},{40,3},{40,-38},{20,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ground.p, high_Voltage_Battery.pin_n) annotation (Line(
                points={{40,-80},{40,-38},{20,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(inverter_Liquid_Cooled.pin_n, ground.p) annotation (Line(
                points={{20,33},{40,33},{40,-80}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, inverter_Liquid_Cooled.fluid_out)
              annotation (Line(
                points={{-6,58},{-8,58},{-8,48}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, inverter_Liquid_Cooled.fluid_in)
              annotation (Line(
                points={{-18,58},{-18,48},{-16,48}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-16,-22},{-18,-22},{-18,-32},{-20,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.return_port, high_Voltage_Battery.fluid_out)
              annotation (Line(
                points={{-4,-22},{-8,-22},{-8,-32},{-14,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/DC_DC_Converter_Liquid_Cooled_plot_script.mos"));
          end Test_Inverter;

          model Test_Starter_Generator
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Simple_Dyno
                                       simple_Dyno(
              Ti=0.1,
              max_res_trq=1000,
              k=10,
              controllerType=Modelica.Blocks.Types.SimpleController.P,
              use_inertia=true)                                         annotation (
                Placement(transformation(
                  extent={{20,-30},{-20,30}},
                  rotation=0,
                  origin={-60,-2})));
            Modelica.Blocks.Sources.Constant const(k=100)
              annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{36,-64},{56,-44}})));
            Modelica.Blocks.Sources.Pulse    pulse1(
              amplitude=-1,
              width=50,
              period=50,
              offset=0)
              annotation (Placement(transformation(extent={{-42,74},{-22,94}})));
            Modelica.Blocks.Sources.Constant const2(k=1)
              annotation (Placement(transformation(extent={{60,-90},{40,-70}})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor annotation (Placement(
                  transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=0,
                  origin={0,-40})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
              annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC
                                                                 env
              annotation (Placement(transformation(extent={{60,80},{80,100}})));
            Integrated_Starter_Generator integrated_Starter_Generator
              annotation (Placement(transformation(extent={{-20,-32},{20,28}})));
          equation
            connect(const.y, simple_Dyno.request_speed) annotation (Line(
                points={{-79,50},{-60,50},{-60,31}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ground.p, resistor.n) annotation (Line(
                points={{46,-44},{28,-44},{28,-40},{10,-40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor.p, integrated_Starter_Generator.pin_p) annotation (Line(
                points={{-10,-40},{-30,-40},{-30,13},{-20,13}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(resistor.n, integrated_Starter_Generator.pin_n) annotation (Line(
                points={{10,-40},{32,-40},{32,13},{20,13}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(const2.y, resistor.R) annotation (Line(
                points={{39,-80},{0,-80},{0,-51}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(integrated_Starter_Generator.brg_01, simple_Dyno.flange_a)
              annotation (Line(
                points={{-20,-2},{-40,-2}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(integrated_Starter_Generator.fluid_out, fluid_Source_Sink.return_port)
              annotation (Line(
                points={{-8,28},{-10,28},{-10,40},{-24,40}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, integrated_Starter_Generator.fluid_in)
              annotation (Line(
                points={{-36,40},{-36,28},{-16,28}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(integrated_Starter_Generator.demand,pulse1. y) annotation (Line(
                points={{-4,29},{-4,84},{-21,84}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                      100,100}}),
                      graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Starter_Generator;

          model Test_Traction_Motor
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Traction_Motor_Liquid_Cooled traction_Motor_Liquid_Cooled(temp_max=355.15)
                                                                      annotation (Placement(transformation(extent={{-8,-12},
                      {12,12}})));
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Simple_Dyno
                                       simple_Dyno(
              Ti=0.1,
              max_res_trq=1000,
              controllerType=Modelica.Blocks.Types.SimpleController.PI) annotation (
                Placement(transformation(
                  extent={{10,-16},{-10,16}},
                  rotation=0,
                  origin={-52,-4})));
            Modelica.Blocks.Sources.Constant const(k=50)
              annotation (Placement(transformation(extent={{-94,42},{-74,62}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=450)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={56,-2})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{46,-46},{66,-26}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water())
              annotation (Placement(transformation(extent={{-44,58},{-24,78}})));
            Modelica.Blocks.Sources.Pulse pulse1(
              offset=0,
              amplitude=1,
              width=50,
              period=50)
              annotation (Placement(transformation(extent={{-14,80},{6,100}})));
            Modelica.Blocks.Sources.Pulse    pulse2(
              width=50,
              period=50,
              offset=0,
              amplitude=800)
              annotation (Placement(transformation(extent={{-84,76},{-64,96}})));
          equation
            connect(constantVoltage.p, traction_Motor_Liquid_Cooled.pin_p) annotation (
                Line(
                points={{56,8},{54,8},{54,24},{-14,24},{-14,6},{-8,6}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(constantVoltage.n, ground.p) annotation (Line(
                points={{56,-12},{56,-26}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(traction_Motor_Liquid_Cooled.pin_n, constantVoltage.n) annotation (
                Line(
                points={{12,6},{26,6},{26,-18},{56,-18},{56,-12}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(traction_Motor_Liquid_Cooled.brg_01, simple_Dyno.flange_a)
              annotation (Line(
                points={{-8,0},{-25,0},{-25,-4},{-42,-4}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.return_port, traction_Motor_Liquid_Cooled.fluid_out)
              annotation (Line(
                points={{-28,58},{-16,58},{-16,34},{-2,34},{-2,12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink.supply_port, traction_Motor_Liquid_Cooled.fluid_in)
              annotation (Line(
                points={{-40,58},{-40,20},{-6,20},{-6,12}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(traction_Motor_Liquid_Cooled.demand, pulse1.y) annotation (Line(
                points={{0,12.4},{2,12.4},{2,70},{24,70},{24,90},{7,90}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pulse2.y, simple_Dyno.request_speed) annotation (Line(
                points={{-63,86},{-52,86},{-52,13.6}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                      {100,100}}),
                      graphics),
              experiment(StopTime=100),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Traction_Motor_Liquid_Cooled_plot_script.mos"));
          end Test_Traction_Motor;
        end Tests;
      end Hybrid_Drive_Systems;

      package Starting_Systems
        "Components that support starting the vehicle prime mover"
      extends Modelica.Icons.Package;

        model Lead_Acid_Battery
          "Supports vehicle 24V systems and provides starting current to the vehicle prime mover starter motor"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
           parameter SI.Resistance R_batt=0.001
            "Battery internal resistance (Ohm)"
             annotation(Dialog(tab="Electrical Model"));
           parameter SI.Temperature T_ref=293.15
            "Reference temperature for battery operation"
                 annotation(Dialog(tab="Electrical Model"));
           parameter SI.Mass mass_batt=5 "Thermal mass of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.ThermalResistance R_thermal=0.01
            "Battery thermal resistance"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.SpecificHeatCapacity cp_batt=1000
            "Specific heat of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter SI.Temperature T_start=293.15
            "Start temperature of battery"
               annotation(Dialog(tab="Electrical Model"));
           parameter Real soc_init=0.6 "Initial state of charge (0 - 1)"
               annotation(Dialog(tab="Electrical Model"));

          parameter SI.Area heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));

          parameter SI.Voltage e_max=28 "Maximum battery voltage"
              annotation(Dialog(tab="Electrical Model"));
          parameter SI.Charge q_max=10000 "Maximum capacity"
                annotation(Dialog(tab="Electrical Model"));

           outer MSL_Extend.Environments.C2M2L_Environment
                                                      env
            annotation (Placement(transformation(extent={{130,220},{150,240}})));
          Modelica.Thermal.HeatTransfer.Components.Convection convection
            annotation (Placement(transformation(extent={{110,200},{122,212}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
                heat_transfer_area)
            annotation (Placement(transformation(extent={{82,222},{110,238}})));
          MSL_Extend.Electrical.Batteries.Battery_Simplified_Shepard_Equation_Extended
                                                  battery_Simplified(
              R_batt=R_batt,
              T_ref=T_ref,
              mass_batt=mass_batt,
              R_thermal=R_thermal,
              cp_batt=cp_batt,
              T_start=T_start,
              soc_init=soc_init,
            useHeatPort=true,
            v_battery(
              soc_init=soc_init,
              e_max=e_max,
              q_max=q_max,
              e_nom=v_nom))                                                             annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=0,
                origin={0,0})));
          Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,206})));
          Modelica.Blocks.Interfaces.RealOutput soc annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={40,206})));
          Modelica.Blocks.Interfaces.RealOutput Temp annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,206})));
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-20,206})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
        equation
          connect(battery_Simplified.heatPort, convection.solid) annotation (Line(
              points={{-20,-20},{-20,-74},{110,-74},{110,206}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(env.heat_port, convection.fluid) annotation (Line(
              points={{132,219.8},{132,206},{122,206}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(realExpression.y, convection.Gc) annotation (Line(
              points={{111.4,230},{116,230},{116,212}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.i,i)  annotation (Line(
              points={{21.2,5.6},{36,5.6},{36,140},{-20,140},{-20,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.Temp,Temp)  annotation (Line(
              points={{21.2,0},{44,0},{44,148},{20,148},{20,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.v,v)  annotation (Line(
              points={{21.2,2.8},{40,2.8},{40,144},{0,144},{0,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.soc,soc)  annotation (Line(
              points={{21.2,-2.8},{48,-2.8},{48,152},{40,152},{40,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(battery_Simplified.v_batt,pin_p)  annotation (Line(
              points={{-16,20},{-18,20},{-18,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(battery_Simplified.rtn,pin_n)  annotation (Line(
              points={{16,20},{18,20},{18,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}), graphics), Icon(graphics={
                Line(
                  points={{200,120},{78,120},{78,88}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-198,120},{-76,120},{-76,88}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-101,100},{101,-100}},
                  lineColor={95,95,95},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.HorizontalCylinder,
                  origin={4,1},
                  rotation=180),
                Text(
                  extent={{-62.5,20.5},{62.5,-20.5}},
                  lineColor={255,0,0},
                  origin={-0.5,-64.5},
                  rotation=360,
                  textString="Battery"),
                Text(
                  extent={{-42,39},{42,-39}},
                  lineColor={0,0,0},
                  textString="-",
                  origin={84,67},
                  rotation=180),
                Text(
                  extent={{-118,102},{-34,24}},
                  lineColor={255,0,0},
                  textString="+")}));
        end Lead_Acid_Battery;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Lead_Acid_Battery
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Resistor discharge_load(useHeatPort=false, R=0.5)
                                                                     annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={7,-1})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-2,-88},{10,-76}})));
            Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch    switch_mode
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=0,
                  origin={-4,32})));
            Modelica.Blocks.Logical.Hysteresis hysteresis(
              pre_y_start=false,
              uLow=0.1,
              uHigh=0.75)
              annotation (Placement(transformation(extent={{82,40},{62,60}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage charging_source(V=28)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={40,-18})));
            Modelica.Electrical.Analog.Basic.Resistor charging_current_limiter(
                useHeatPort=false, R=0.005)                          annotation (
                Placement(transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=180,
                  origin={9,-19})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                 env
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Lead_Acid_Battery lead_Acid_Battery
              annotation (Placement(transformation(extent={{-54,-64},{-20,-32}})));
          equation

            connect(switch_mode.n1, charging_source.p) annotation (Line(
                points={{6,37},{50,37},{50,-18}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.n2, discharge_load.p) annotation (Line(
                points={{6,32},{34,32},{34,-1},{14,-1}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(hysteresis.y,switch_mode. control) annotation (Line(
                points={{61,50},{-4,50},{-4,40}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(charging_current_limiter.p,charging_source. n) annotation (Line(
                points={{16,-19},{24,-19},{24,-18},{30,-18}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(charging_current_limiter.n, ground.p) annotation (Line(
                points={{2,-19},{-4,-19},{-4,-20},{-10,-20},{-10,-48},{4,-48},{4,-76}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(switch_mode.p, lead_Acid_Battery.pin_p) annotation (Line(
                points={{-14,32},{-44,32},{-44,34},{-78,34},{-78,-28.8},{-71,-28.8}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(lead_Acid_Battery.pin_n, ground.p) annotation (Line(
                points={{-3,-28.8},{4,-28.8},{4,-76}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(discharge_load.n, ground.p) annotation (Line(
                points={{-8.88178e-016,-1},{-10,-1},{-10,-48},{4,-48},{4,-76}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(lead_Acid_Battery.soc, hysteresis.u) annotation (Line(
                points={{-30.2,-15.04},{-30.2,10},{92,10},{92,50},{84,50}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                      {{-100,-100},{100,100}}),
                                graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Lead_Acid_Battery_plot_script.mos"));
          end Test_Lead_Acid_Battery;
        end Tests;
      end Starting_Systems;

      package Charging_Systems
        "Maintains the vehicles electrical system for supporting ancilliary loads"
      extends Modelica.Icons.Package;

        model Alternator "Mechanical to electrical generator "
          parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
            annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          parameter SI.Inertia rotating_inertia = 0.1
            "Moment of inertia of device around its axis of rotation";
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
          annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque trq_max=100 "Maximum output torque"
          annotation (Dialog(tab="Electrical Model"));
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion"
            annotation (Dialog(tab="Electrical Model"));
        public
          parameter SI.Voltage v_max=250
            "Maximum voltage at which data was generated"
           annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque trq_nom=50 "Nominal output torque"
           annotation (Dialog(tab="Electrical Model"));
          parameter SI.Temperature temp_max=373.15 "Maximum device temp"
           annotation (Dialog(tab="Electrical Model"));

          parameter SI.Area heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
        protected
          parameter Boolean consider_gyroscopic_effects = false
            "if true, take into account gyroscopic reaction forces";
          parameter Boolean use_output_diode = true
            "if true, add a diode to prevent reverse current through device";
           outer MSL_Extend.Environments.C2M2L_Environment
                                                      env
            annotation (Placement(transformation(extent={{122,180},{142,200}})));
          Modelica.Thermal.HeatTransfer.Components.Convection convection
            annotation (Placement(transformation(extent={{102,160},{114,172}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
                heat_transfer_area)
            annotation (Placement(transformation(extent={{74,182},{102,198}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia_1D(J=
                rotating_inertia)
            annotation (Placement(transformation(extent={{-70,-30},{-50,-10}})));
          MSL_Extend.Electrical.Electric_Machines.Electric_Motor_As_Generator
                                                              emf(
            efficiency=efficiency,
            v_nom=v_nom,
            pow_max=pow_max,
            trq_max=trq_max)
            annotation (Placement(transformation(
                extent={{-11,10},{11,-10}},
                rotation=180,
                origin={-7,0})));
        public
          Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,206})));
          Modelica.Blocks.Interfaces.RealOutput v   annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={40,206})));
          Modelica.Blocks.Interfaces.RealOutput tau  annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,206})));
          Modelica.Blocks.Interfaces.RealOutput w annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-20,206})));
          Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,206})));
        protected
          Modelica.Mechanics.Rotational.Components.Fixed
                           fixed if not useSupport
            "Fixed support/housing, if not useSupport"
            annotation (Placement(transformation(extent={{10,-197},{30,-177}})));
        public
          Modelica.Mechanics.Rotational.Interfaces.Support
                  support if useSupport "Support/housing of component"
            annotation (Placement(transformation(extent={{-10,-210},{10,-190}})));
        protected
          Modelica.Mechanics.Rotational.Interfaces.Support
                  internalSupport
            "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
            annotation (Placement(transformation(extent={{-3,-183},{3,-177}})));
        public
          Modelica.Mechanics.Rotational.Interfaces.Flange_b brg_01
            annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Ideal.IdealDiode idealDiode(
            Vknee=0,
            Ron=1e4,
            Goff=1e-4) if                                           use_output_diode annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-88,60})));
          Modelica.Electrical.Analog.Ideal.Short short if not use_output_diode    annotation (Placement(transformation(extent={{-100,
                    110},{-80,130}})));
        equation
          connect(emf.heatPort, convection.solid) annotation (Line(
              points={{1.8,-8},{1.8,-14},{46,-14},{46,166},{102,166}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(env.heat_port,convection. fluid) annotation (Line(
              points={{124,179.8},{124,166},{114,166}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(realExpression.y,convection. Gc) annotation (Line(
              points={{103.4,190},{108,190},{108,172}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.demand,demand)  annotation (Line(
              points={{-18.88,2.8},{-40,2.8},{-40,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.i,i)  annotation (Line(
              points={{-14.7,10.4},{-32,10.4},{-32,138},{0,138},{0,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.w,w)  annotation (Line(
              points={{-18.88,7.6},{-36,7.6},{-36,150},{-20,150},{-20,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.v,v)  annotation (Line(
              points={{-10.74,10.4},{-24,10.4},{-24,118},{40,118},{40,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(emf.tau,tau)  annotation (Line(
              points={{-18.88,5.4},{-28,5.4},{-28,126},{20,126},{20,206}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(fixed.flange,internalSupport)  annotation (Line(
              points={{20,-187},{20,-180},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(internalSupport,support)  annotation (Line(
              points={{0,-180},{0,-200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(emf.support,internalSupport)  annotation (Line(
              points={{4,0},{14,0},{14,-60},{0,-60},{0,-180}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(emf.flange,brg_01)  annotation (Line(
              points={{-18,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia_1D.flange_a,brg_01)  annotation (Line(
              points={{-70,-20},{-84,-20},{-84,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(emf.n,pin_n)  annotation (Line(
              points={{-7,-8},{-8,-8},{-8,-20},{72,-20},{72,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(emf.p, idealDiode.p) annotation (Line(
              points={{-7,8},{-7,60},{-78,60}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(emf.p, short.n) annotation (Line(
              points={{-7,8},{-7,120},{-80,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(idealDiode.n, pin_p) annotation (Line(
              points={{-98,60},{-152,60},{-152,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(short.p, pin_p) annotation (Line(
              points={{-100,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},
                    {200,200}}), graphics), Icon(coordinateSystem(preserveAspectRatio=
                    true, extent={{-200,-200},{200,200}}), graphics={
                Line(
                  points={{-130,-156},{-160,10}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Rectangle(
                  extent={{-162,10},{-110,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95}),
                Line(
                  points={{-190,0},{-178,-168}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{200,120},{24,120},{24,70}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-198,120},{-86,120},{-86,72}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-110,76},{48,-76}},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={127,0,0},
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{-178,-196},{-130,-122}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{-190,-20},{-160,24}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0})}),
            Documentation(info="<html>
<p>Basic model of a belt driven alternator. The output voltage is generated when torque is applied to the shaft. The voltage is limited by the maximum torque parameter. </p>
</html>"));
        end Alternator;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Alternator
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Simple_Dyno
                                       simple_Dyno(
              Ti=0.1,
              k=10,
              controllerType=Modelica.Blocks.Types.SimpleController.P,
              use_inertia=true,
              max_res_trq=100,
              trq_start=10,
              J=0.1)                                                    annotation (
                Placement(transformation(
                  extent={{20,-30},{-20,30}},
                  rotation=0,
                  origin={-60,-2})));
            Modelica.Blocks.Sources.Constant const(k=100)
              annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{36,-64},{56,-44}})));
            Modelica.Blocks.Sources.Constant const2(k=1)
              annotation (Placement(transformation(extent={{60,-90},{40,-70}})));
            Modelica.Electrical.Analog.Basic.VariableResistor
                                                      resistor annotation (Placement(
                  transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=0,
                  origin={0,-40})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                 env
              annotation (Placement(transformation(extent={{60,80},{80,100}})));
            Alternator alternator(v_nom=28, pow_max=1000)
              annotation (Placement(transformation(extent={{-14,-32},{26,28}})));
            Starting_Systems.Lead_Acid_Battery lead_Acid_Battery(
              soc_init=0.8,
              q_max=100,
              v_nom=24,
              e_max=24.2)
              annotation (Placement(transformation(extent={{72,-18},{100,24}})));

            Modelica.Blocks.Sources.Constant const3(k=100)
              annotation (Placement(transformation(extent={{140,-88},{120,-68}})));
            Modelica.Blocks.Logical.Hysteresis hysteresis(
              pre_y_start=false,
              uLow=0.1,
              uHigh=0.8)
              annotation (Placement(transformation(extent={{78,50},{58,70}})));
            Modelica.Blocks.Math.BooleanToReal booleanToReal(realTrue=0, realFalse=-1)
              annotation (Placement(transformation(extent={{42,50},{22,70}})));
          equation
            connect(const.y, simple_Dyno.request_speed) annotation (Line(
                points={{-79,50},{-60,50},{-60,31}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ground.p, resistor.n) annotation (Line(
                points={{46,-44},{28,-44},{28,-40},{10,-40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(const2.y, resistor.R) annotation (Line(
                points={{39,-80},{0,-80},{0,-51}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(alternator.pin_n, ground.p) annotation (Line(
                points={{26,16},{46,16},{46,-44}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(lead_Acid_Battery.pin_p, resistor.p) annotation (Line(
                points={{58,28.2},{58,-58},{-10,-58},{-10,-40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(hysteresis.y, booleanToReal.u) annotation (Line(
                points={{57,60},{44,60}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(alternator.pin_p, resistor.p) annotation (Line(
                points={{-14,16},{-30,16},{-30,-40},{-10,-40}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(booleanToReal.y, alternator.demand) annotation (Line(
                points={{21,60},{2,60},{2,28.9}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(lead_Acid_Battery.pin_n, alternator.pin_n) annotation (Line(
                points={{114,28.2},{114,40},{26,40},{26,16}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(lead_Acid_Battery.soc, hysteresis.u) annotation (Line(
                points={{91.6,46.26},{91.6,60},{80,60}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(alternator.brg_01, simple_Dyno.flange_a) annotation (Line(
                points={{-14,-2},{-40,-2}},
                color={0,0,0},
                smooth=Smooth.None));
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                      100,100}}),
                      graphics),
              experiment(StopTime=1000),
              __Dymola_experimentSetupOutput(events=false));
          end Test_Alternator;
        end Tests;
      end Charging_Systems;

      package Circuit_Systems
        extends Modelica.Icons.Package;

        model Circuit_Breaker
          "Provides resettable overcurrent protection in an electrical circuit"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Current i_max=100 "Maximum current" annotation (Dialog(tab="Electrical Model"));
          parameter SI.Area heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Blocks.Interfaces.BooleanInput reset
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,204})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
                heat_transfer_area)
            annotation (Placement(transformation(extent={{82,222},{110,238}})));
          Modelica.Thermal.HeatTransfer.Components.Convection convection
            annotation (Placement(transformation(extent={{110,204},{122,216}})));
           outer MSL_Extend.Environments.C2M2L_Environment
                                                      env
            annotation (Placement(transformation(extent={{130,220},{150,240}})));
          MSL_Extend.Electrical.Circuit_Devices.Circuit_Breaker curcuit_Breaker(
              use_heat_port=true, i_max=i_max)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation
          connect(env.heat_port, convection.fluid) annotation (Line(
              points={{132,219.8},{132,210},{122,210}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(realExpression.y, convection.Gc) annotation (Line(
              points={{111.4,230},{116,230},{116,216}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(curcuit_Breaker.pos_in, pin_p) annotation (Line(
              points={{-10,0},{-100,0},{-100,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(curcuit_Breaker.pos_out, pin_n) annotation (Line(
              points={{10,0},{100,0},{100,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(curcuit_Breaker.reset, reset) annotation (Line(
              points={{-10,8},{-40,8},{-40,120},{0,120},{0,204}},
              color={255,0,255},
              smooth=Smooth.None));
          connect(convection.solid, curcuit_Breaker.heatPort) annotation (Line(
              points={{110,210},{60,210},{60,-40},{0,-40},{0,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),      graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-200,-320},{200,280}}), graphics={
                Rectangle(extent={{-64,130},{58,-100}}, lineColor={0,0,255}),
                Polygon(
                  points={{-64,130},{-30,94},{92,94},{58,130},{-64,130}},
                  smooth=Smooth.None,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-64,130},{-30,94},{-30,-136},{-64,-100},{-64,130},{-64,130}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,94},{92,-136}},
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Line(
                  points={{-64,-100},{-30,-136},{-30,-136}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-64,130},{-30,94},{-30,94}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{58,130},{92,94},{92,94}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-64,-100},{-64,130},{58,130},{58,130}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None),
                Rectangle(
                  extent={{18,32},{50,-70}},
                  pattern=LinePattern.None,
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{18,-18},{50,-70}},
                  pattern=LinePattern.None,
                  lineColor={0,0,255},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-190,120},{-146,120},{-146,164},{-40,164},{-40,130},{-40,
                      130}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{190,120},{146,120},{146,164},{40,164},{40,130},{40,130}},
                  color={0,0,255},
                  smooth=Smooth.None)}));
        end Circuit_Breaker;

        model Fuse "Provides overcurrent protection in an electrical circuit"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Current i_max=100 "Maximum current" annotation (Dialog(tab="Electrical Model"));
          parameter SI.Area heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
           outer MSL_Extend.Environments.C2M2L_Environment
                                                      env
            annotation (Placement(transformation(extent={{130,220},{150,240}})));
          Modelica.Thermal.HeatTransfer.Components.Convection convection
            annotation (Placement(transformation(extent={{110,204},{122,216}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
                heat_transfer_area)
            annotation (Placement(transformation(extent={{82,222},{110,238}})));
          MSL_Extend.Electrical.Circuit_Devices.Fuse fuse(use_heat_port=true, i_max=
                i_max)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation
          connect(fuse.heatPort, convection.solid) annotation (Line(
              points={{0,-10},{0,-40},{60,-40},{60,210},{110,210}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(realExpression.y, convection.Gc) annotation (Line(
              points={{111.4,230},{116,230},{116,216}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(env.heat_port, convection.fluid) annotation (Line(
              points={{132,219.8},{132,210},{122,210}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(fuse.pos_in, pin_p) annotation (Line(
              points={{-10,0},{-100,0},{-100,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(fuse.pos_out, pin_n) annotation (Line(
              points={{10,0},{100,0},{100,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}), graphics={
                Rectangle(
                  extent={{-130,132},{134,-34}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-82,8},{-50,8},{-22,56},{-4,60},{16,58},{40,14},{84,12},{
                      88,10},{88,10}},
                  color={175,175,175},
                  thickness=1,
                  smooth=Smooth.Bezier),
                Line(
                  points={{-82,10},{-50,10},{-22,58},{-4,62},{16,60},{40,16},{84,14},
                      {88,12},{88,12}},
                  color={175,175,175},
                  thickness=1,
                  smooth=Smooth.Bezier),
                Line(
                  points={{-82,12},{-50,12},{-22,60},{-4,64},{16,62},{40,18},{84,16},
                      {88,14},{88,14}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-82,6},{-50,6},{-22,54},{-4,58},{16,56},{40,12},{84,10},{
                      88,8},{88,8}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-110,130},{-110,-96},{-100,-124},{-36,-124},{-36,-80},{-60,
                      -58},{-60,-22},{-72,-8},{-72,78},{-88,78},{-88,130},{-110,130}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{114,130},{114,-96},{104,-124},{40,-124},{40,-80},{64,-58},
                      {64,-22},{76,-8},{76,78},{92,78},{92,130},{114,130}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-130,132},{134,88}},
                  lineColor={0,0,0},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-200,196},{200,136}},
                  lineColor={0,0,255},
                  textString="%i_max A")}));
        end Fuse;

        model Relay
          "An electrical switch controlled by a low power electrical signal"
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Voltage v_enable=0.5 "Relay enable voltage"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Current i_max=100 "Maximum current"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Area heat_transfer_area=1.0
            "Area available for heat to transfer through case"
            annotation (Dialog(tab="Thermal Model"));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin control
            annotation (Placement(transformation(extent={{-10,190},{10,210}})));
           outer MSL_Extend.Environments.C2M2L_Environment
                                                      env
            annotation (Placement(transformation(extent={{130,220},{150,240}})));
          Modelica.Thermal.HeatTransfer.Components.Convection convection
            annotation (Placement(transformation(extent={{110,204},{122,216}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=env.htc*
                heat_transfer_area)
            annotation (Placement(transformation(extent={{82,222},{110,238}})));
          MSL_Extend.Electrical.Circuit_Devices.Relay relay(use_heat_port=true,
            i_max=i_max,
            v_enable=v_enable)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation
          connect(convection.fluid, env.heat_port) annotation (Line(
              points={{122,210},{132,210},{132,219.8}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(realExpression.y, convection.Gc) annotation (Line(
              points={{111.4,230},{116,230},{116,216}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(relay.pos_in, pin_p) annotation (Line(
              points={{-10,0},{-100,0},{-100,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(relay.pos_out, pin_n) annotation (Line(
              points={{10,0},{100,0},{100,120},{200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(relay.heatPort, convection.solid) annotation (Line(
              points={{0,-10},{0,-40},{60,-40},{60,210},{110,210}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(relay.control, control) annotation (Line(
              points={{-10,8},{-40,8},{-40,120},{0,120},{0,200}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}), graphics={
                Rectangle(extent={{-138,100},{140,-150}}, lineColor={0,0,0}),
                Line(
                  points={{-188,118},{-118,118},{-114,70},{-112,44},{-88,56},{-98,82},
                      {-100,50},{-80,48},{-68,54},{-74,82},{-80,50},{-50,48},{-40,58},
                      {-50,84},{-50,44},{-16,46},{-10,58},{-18,82},{-24,46},{4,46},{
                      14,62},{4,82},{-4,48},{30,44},{52,52},{38,86},{34,44},{58,46},{
                      74,62},{66,84},{58,46},{92,44},{106,50},{110,64},{114,108},{130,
                      118},{190,120},{192,120}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-168,12},{14,12},{92,12}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-178,-102},{4,-102},{94,-102}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,192},{0,150},{170,150},{170,-44},{-26,-44},{-26,-44}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-24,-40},{-36,-50}},
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid)}));
        end Relay;

        package Tests
          extends Modelica.Icons.Package;
          model Test_Circuit_Breaker
              extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{14,-92},{26,-80}})));
            Hybrid_Drive_Systems.High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-40,-72},{0,-32}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-48,-16},{-28,4}})));
            Circuit_Breaker circuit_Breaker annotation (Placement(transformation(
                  extent={{-20,-30},{20,30}},
                  rotation=0,
                  origin={-20,18})));
            Modelica.Blocks.Math.Add add1
              annotation (Placement(transformation(extent={{76,44},{82,50}})));
            Modelica.Electrical.Analog.Basic.VariableResistor load_resistor
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=90,
                  origin={40,-18})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                 env
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            Modelica.Blocks.Math.Add add2
              annotation (Placement(transformation(extent={{46,42},{52,48}})));
            Modelica.Blocks.Sources.BooleanTable booleanTable1(
                                                              table={300,546,650})
              annotation (Placement(transformation(extent={{-88,36},{-68,56}})));
            Modelica.Blocks.Sources.Ramp ramp3(
              duration=100,
              offset=0,
              startTime=290,
              height=1000)
              annotation (Placement(transformation(extent={{6,56},{26,76}})));
            Modelica.Blocks.Sources.Ramp ramp4(
              offset=1000,
              duration=100,
              height=-997)
              annotation (Placement(transformation(extent={{12,82},{32,102}})));
            Modelica.Blocks.Sources.Ramp ramp5(
              duration=100,
              startTime=390,
              offset=0,
              height=-999.9)
              annotation (Placement(transformation(extent={{44,78},{64,98}})));
          equation

            connect(ground.p, high_Voltage_Battery.pin_n) annotation (Line(
                points={{20,-80},{20,-38},{0,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(high_Voltage_Battery.pin_p, circuit_Breaker.pin_p) annotation (Line(
                points={{-40,-38},{-60,-38},{-60,32},{-40,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(add1.y, load_resistor.R)
                                         annotation (Line(
                points={{82.3,47},{88,47},{88,-18},{51,-18}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(circuit_Breaker.pin_n, load_resistor.p) annotation (Line(
                points={{0,32},{40,32},{40,-8}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_resistor.n, high_Voltage_Battery.pin_n) annotation (Line(
                points={{40,-28},{40,-38},{0,-38}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(add2.y, add1.u2) annotation (Line(
                points={{52.3,45},{58.15,45},{58.15,45.2},{75.4,45.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp3.y, add2.u2) annotation (Line(
                points={{27,66},{30,66},{30,43.2},{45.4,43.2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp4.y, add2.u1) annotation (Line(
                points={{33,92},{40,92},{40,46.8},{45.4,46.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp5.y, add1.u1) annotation (Line(
                points={{65,88},{70,88},{70,48.8},{75.4,48.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(booleanTable1.y, circuit_Breaker.reset) annotation (Line(
                points={{-67,46},{-20,46},{-20,40.4}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-44,-16},{-42,-16},{-42,-32},{-40,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.return_port, high_Voltage_Battery.fluid_out)
              annotation (Line(
                points={{-32,-16},{-32,-32},{-34,-32}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/DC_DC_Converter_Liquid_Cooled_plot_script.mos"));
          end Test_Circuit_Breaker;

          model Test_Fuse
              extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{14,-74},{26,-62}})));
            Hybrid_Drive_Systems.High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-40,-54},{0,-14}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-46,-4},{-26,16}})));
            Modelica.Blocks.Sources.Ramp ramp(
              offset=1000,
              duration=100,
              height=-997)
              annotation (Placement(transformation(extent={{28,68},{48,88}})));
            Modelica.Electrical.Analog.Basic.VariableResistor load_resistor
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=90,
                  origin={40,0})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                 env
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            Fuse fuse annotation (Placement(transformation(extent={{-40,4},{0,64}})));
            Modelica.Blocks.Sources.Ramp ramp1(
              duration=100,
              height=1000,
              offset=0,
              startTime=150)
              annotation (Placement(transformation(extent={{38,-56},{58,-36}})));
            Modelica.Blocks.Math.Add add1
              annotation (Placement(transformation(extent={{74,-4},{66,4}})));
          equation

            connect(ground.p, high_Voltage_Battery.pin_n) annotation (Line(
                points={{20,-62},{20,-20},{0,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_resistor.n, high_Voltage_Battery.pin_n) annotation (Line(
                points={{40,-10},{40,-20},{0,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fuse.pin_p, high_Voltage_Battery.pin_p) annotation (Line(
                points={{-40,48},{-60,48},{-60,-20},{-40,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fuse.pin_n, load_resistor.p) annotation (Line(
                points={{0,48},{40,48},{40,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.return_port, high_Voltage_Battery.fluid_out)
              annotation (Line(
                points={{-30,-4},{-34,-4},{-34,-14}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-42,-4},{-42,-14},{-40,-14}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(ramp1.y, add1.u2) annotation (Line(
                points={{59,-46},{80,-46},{80,-2.4},{74.8,-2.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, add1.u1) annotation (Line(
                points={{49,78},{80,78},{80,2.4},{74.8,2.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add1.y, load_resistor.R) annotation (Line(
                points={{65.6,0},{51,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=250),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/DC_DC_Converter_Liquid_Cooled_plot_script.mos"));
          end Test_Fuse;

          model Test_Relay
              extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{14,-74},{26,-62}})));
            Hybrid_Drive_Systems.High_Voltage_Battery high_Voltage_Battery
              annotation (Placement(transformation(extent={{-40,-54},{0,-14}})));
            MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                             fluid_Source_Sink1(medium=
                  Modelica.Thermal.FluidHeatFlow.Media.Water(), T=323.15)
              annotation (Placement(transformation(extent={{-50,-2},{-30,18}})));
            Modelica.Blocks.Sources.Ramp ramp(
              offset=1000,
              duration=100,
              height=-999.9999)
              annotation (Placement(transformation(extent={{28,68},{48,88}})));
            Modelica.Electrical.Analog.Basic.VariableResistor load_resistor
                                                               annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=90,
                  origin={40,0})));
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                                 env
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            Relay relay annotation (Placement(transformation(extent={{-42,6},{-2,66}})));
            Modelica.Electrical.Analog.Sources.PulseVoltage    constantVoltage(V=5,
              width=60,
              period=120,
              startTime=15)
              annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-80,56})));
            Modelica.Electrical.Analog.Basic.Ground ground1
              annotation (Placement(transformation(extent={{-90,18},{-70,38}})));
            Modelica.Blocks.Sources.Ramp ramp1(
              duration=100,
              height=1000,
              offset=0,
              startTime=150)
              annotation (Placement(transformation(extent={{38,-56},{58,-36}})));
            Modelica.Blocks.Math.Add add1
              annotation (Placement(transformation(extent={{70,-4},{62,4}})));
          equation

            connect(ground.p, high_Voltage_Battery.pin_n) annotation (Line(
                points={{20,-62},{20,-20},{0,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(load_resistor.n, high_Voltage_Battery.pin_n) annotation (Line(
                points={{40,-10},{40,-20},{0,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(relay.pin_p, high_Voltage_Battery.pin_p) annotation (Line(
                points={{-42,50},{-60,50},{-60,-20},{-40,-20}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(relay.pin_n, load_resistor.p) annotation (Line(
                points={{-2,50},{40,50},{40,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(ground1.p,constantVoltage. n) annotation (Line(
                points={{-80,38},{-80,46}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(constantVoltage.p, relay.control) annotation (Line(
                points={{-80,66},{-80,80},{-22,80},{-22,58}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.return_port, high_Voltage_Battery.fluid_out)
              annotation (Line(
                points={{-34,-2},{-34,-14}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(fluid_Source_Sink1.supply_port, high_Voltage_Battery.fluid_in)
              annotation (Line(
                points={{-46,-2},{-44,-2},{-44,-14},{-40,-14}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(ramp.y, add1.u1) annotation (Line(
                points={{49,78},{80,78},{80,2.4},{70.8,2.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp1.y, add1.u2) annotation (Line(
                points={{59,-46},{80,-46},{80,-2.4},{70.8,-2.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add1.y, load_resistor.R) annotation (Line(
                points={{61.6,0},{51,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=250),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/DC_DC_Converter_Liquid_Cooled_plot_script.mos"));
          end Test_Relay;
        end Tests;
      end Circuit_Systems;
    end Electrical_System;

    package Suspension
    extends Modelica.Icons.Package;

      package Component_Test_Cases
        extends C2M2L_OM.MSL_Extend.Icons.Package_For_Simple_Test_Cases;
        model Torsion_Bar_Translational_Damper_Arm_Test
          "Simple motion test of suspension module, using damper with max-min ranges"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner MSL_Extend.Mechanics.Planar.World  world(g=9.81)
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.TrackSusp_SubAssembly_Torsion_Trans_Damper_Range
            suspension
            annotation (Placement(transformation(extent={{0,40},{40,80}})));
          Modelica.Blocks.Sources.Sine sine(
            startTime=1,
            amplitude=10000,
            freqHz=0.5)
            annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
          MSL_Extend.Mechanics.Planar.Forces.Force       force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,-60})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{10,-40},{30,-20}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
            road_Wheel_Bearing_Flange
            annotation (Placement(transformation(extent={{0,-10},{40,30}})));
          inner
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground(p_act=[-1,-1; 1,-1], road=[-1,-1; 1,-1])
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
        equation
          connect(world.frame_b, suspension.hull) annotation (Line(
              points={{-80,90},{20,90},{20,80.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(force.frame_b, flange.bearingFrame) annotation (Line(
              points={{20,-50},{20,-30}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension.wheel, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{20,39.6},{20,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{20,-30},{20,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(sine.y, force.f[2]) annotation (Line(
              points={{-59,-40},{-28,-40},{-28,-80},{19,-80},{19,-72}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(const.y, force.f[1]) annotation (Line(
              points={{-59,-80},{21,-80},{21,-72}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Torsion_Bar_Translational_Damper_Arm_Test;

        model Hydropneumatic_Arm_Test
          "Simple motion test of suspension module, using hydropneumatic suspension arm"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner C2M2L_OM.MSL_Extend.Mechanics.Planar.World world(g=9.81)
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.TrackSusp_SubAssembly_Hydropneumatic
            suspension(spring_scale=1)
            annotation (Placement(transformation(extent={{0,40},{40,80}})));
          Modelica.Blocks.Sources.Ramp sine(
            height=10000,
            duration=1,
            startTime=0)
            annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Forces.Force force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,-60})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{10,-40},{30,-20}})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
            road_Wheel_Bearing_Flange(
            D_wheel=1.0,
            W_wheel=0.2,
            Z_offset=0,
            c_tire=1000000,
            d_tire=1000,
            m_wheel=50,
            I_xx_wheel=1e-3,
            I_yy_wheel=1e-3,
            I_zz_wheel=1e-3,
            fix_wheel_brg_phi=true)
            annotation (Placement(transformation(extent={{0,-10},{40,30}})));
          inner
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground(p_act=[-1,-1; 1,-1], road=[-1,-1; 1,-1])
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
          Modelica.Blocks.Sources.Ramp sine1(
            height=-10000,
            duration=0.01,
            startTime=1)
            annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));
        equation
          connect(world.frame_b, suspension.hull) annotation (Line(
              points={{-80,90},{20,90},{20,80.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(force.f[1], const.y) annotation (Line(
              points={{21,-72},{20,-72},{20,-80},{-59,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(suspension.wheel, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{20,39.6},{20,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(road_Wheel_Bearing_Flange.flange, flange) annotation (Line(
              points={{20,10},{20,-30}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange.bearingFrame, force.frame_b) annotation (Line(
              points={{20,-30},{20,-50}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(sine1.y, add.u1) annotation (Line(
              points={{-59,-10},{-50,-10},{-50,-14},{-42,-14}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sine.y, add.u2) annotation (Line(
              points={{-59,-40},{-50,-40},{-50,-26},{-42,-26}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, force.f[2]) annotation (Line(
              points={{-19,-20},{-6,-20},{-6,-80},{19,-80},{19,-72}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}),
                            graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Hydropneumatic_Arm_Test;

        model Rigid_Tensioner_Assembly_Test
          "Simple motion test of suspension module, using damper with max-min ranges"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner MSL_Extend.Mechanics.Planar.World  world(g=9.81)
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          replaceable Rigid_Tensioner_Assembly
            suspension constrainedby
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Rigid_Tensioner_Assembly
            annotation (Placement(transformation(extent={{0,40},{40,80}})));
          Modelica.Blocks.Sources.Sine sine(
            startTime=1,
            amplitude=10000,
            freqHz=0.5)
            annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
          MSL_Extend.Mechanics.Planar.Forces.Force       force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={20,-60})));
          C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
            road_Wheel_Bearing_Flange
            annotation (Placement(transformation(extent={{40,-10},{80,30}})));
          inner
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground(p_act=[-1,-1; 1,-1], road=[-1,-1; 1,-1])
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearingAdaptor adaptor(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{42,-40},{62,-20}})));
        equation
          connect(world.frame_b, suspension.hull) annotation (Line(
              points={{-80,90},{-60,90},{-60,54},{-0.4,54}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension.wheel, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{40.4,46},{60,46},{60,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(const.y, force.f[1]) annotation (Line(
              points={{-59,-80},{21,-80},{21,-72}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sine.y, force.f[2]) annotation (Line(
              points={{-59,-40},{-30,-40},{-30,-80},{19,-80},{19,-72}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(adaptor.flangeAndFrame, road_Wheel_Bearing_Flange.flange) annotation (
             Line(
              points={{42,-30},{38,-30},{38,10},{60,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(adaptor.frame, force.frame_b) annotation (Line(
              points={{52,-40},{36,-40},{36,-50},{20,-50}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Rigid_Tensioner_Assembly_Test;

        model Sprocket_Test
          "Demonstrates how belt connects pulleys, and torque in one pulley rotates the other pulley via the belt"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
                                                                                     pulley_left
            annotation (Placement(transformation(extent={{-100,-20},{-60,20}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Drive_Sprocket_Pulley
            pulley_right
            annotation (Placement(transformation(extent={{100,20},{60,-20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_lower
                 annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_upper
                 annotation (Placement(transformation(extent={{10,20},{-10,40}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation fixedTranslation(r={2,0})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_left(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_right(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          inner C2M2L_OM.MSL_Extend.Mechanics.Planar.World world
            annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_world(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-70,60},{-50,80}})));
          Modelica.Blocks.Sources.Ramp torque(
            startTime=1,
            duration=1,
            height=-100)
            annotation (Placement(transformation(extent={{100,60},{80,80}})));
          Modelica.Mechanics.Rotational.Sources.Torque2 torque2_1
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational mounting1D
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
        equation
          connect(pulley_left.frame_a, belt_upper.flange_b) annotation (Line(
              points={{-66,20},{-40,20},{-40,30},{-10,30}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_a, pulley_left.frame_b) annotation (Line(
              points={{-10,-30},{-66,-30},{-66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pulley_left.flange, flange_left) annotation (Line(
              points={{-80,0},{-30,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_left.bearingFrame, fixedTranslation.frame_a) annotation (Line(
              points={{-30,0},{-10,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, flange_right.bearingFrame) annotation (Line(
              points={{10,0},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_right, pulley_right.flange) annotation (Line(
              points={{30,0},{80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, flange_world.bearingFrame) annotation (Line(
              points={{-80,70},{-60,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_world, pulley_left.flange) annotation (Line(
              points={{-60,70},{-60,50},{-80,50},{-80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.y, torque2_1.tau) annotation (Line(
              points={{79,70},{70,70},{70,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(mounting1D.flange_b, torque2_1.flange_a) annotation (Line(
              points={{40,50},{60,50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(mounting1D.frame_a, flange_right.bearingFrame) annotation (Line(
              points={{30,40},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque2_1.flange_b, flange_right.flange) annotation (Line(
              points={{80,50},{80,36},{30,36},{30,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(belt_upper.flange_a, pulley_right.frame_b) annotation (Line(
              points={{10,30},{40,30},{40,20},{66,20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_b, pulley_right.frame_a) annotation (Line(
              points={{10,-30},{66,-30},{66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(graphics),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Sprocket_Test;

        model Pulley_Test
          "Demonstrates how belt connects pulleys, and torque in one pulley rotates the other pulley via the belt"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
                                                                            pulley_left
            annotation (Placement(transformation(extent={{-100,-20},{-60,20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
            pulley_right
            annotation (Placement(transformation(extent={{100,20},{60,-20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_lower
                 annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_upper
                 annotation (Placement(transformation(extent={{10,20},{-10,40}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation
                                                              fixedTranslation(r={2,0})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                                    flange_left(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                                    flange_right(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          inner C2M2L_OM.MSL_Extend.Mechanics.Planar.World
                                                   world
            annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                                    flange_world(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-70,60},{-50,80}})));
          Modelica.Blocks.Sources.Ramp torque(
            startTime=1,
            duration=1,
            height=-100)
            annotation (Placement(transformation(extent={{100,60},{80,80}})));
          Modelica.Mechanics.Rotational.Sources.Torque2 torque2_1
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational
                                                        mounting1D
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
        equation
          connect(pulley_left.frame_a, belt_upper.flange_b) annotation (Line(
              points={{-66,20},{-40,20},{-40,30},{-10,30}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_a, pulley_left.frame_b) annotation (Line(
              points={{-10,-30},{-66,-30},{-66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pulley_left.flange, flange_left) annotation (Line(
              points={{-80,0},{-30,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_left.bearingFrame, fixedTranslation.frame_a) annotation (Line(
              points={{-30,0},{-10,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, flange_right.bearingFrame) annotation (Line(
              points={{10,0},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_right, pulley_right.flange) annotation (Line(
              points={{30,0},{80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, flange_world.bearingFrame) annotation (Line(
              points={{-80,70},{-60,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_world, pulley_left.flange) annotation (Line(
              points={{-60,70},{-60,50},{-80,50},{-80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.y, torque2_1.tau) annotation (Line(
              points={{79,70},{70,70},{70,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(mounting1D.flange_b, torque2_1.flange_a) annotation (Line(
              points={{40,50},{60,50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(mounting1D.frame_a, flange_right.bearingFrame) annotation (Line(
              points={{30,40},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque2_1.flange_b, flange_right.flange) annotation (Line(
              points={{80,50},{80,36},{30,36},{30,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(belt_upper.flange_a, pulley_right.frame_b) annotation (Line(
              points={{10,30},{40,30},{40,20},{66,20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_b, pulley_right.frame_a) annotation (Line(
              points={{10,-30},{66,-30},{66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Pulley_Test;

        model Belt_Test
          "Demonstrates how belt connects pulleys, and torque in one pulley rotates the other pulley via the belt"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
                                                                                     pulley_left
            annotation (Placement(transformation(extent={{-100,-20},{-60,20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
                                                                                     pulley_right
            annotation (Placement(transformation(extent={{100,20},{60,-20}})));
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_lower
                 annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_upper
                 annotation (Placement(transformation(extent={{10,20},{-10,40}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation fixedTranslation(r={2,0})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_left(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_right(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          inner C2M2L_OM.MSL_Extend.Mechanics.Planar.World world
            annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_world(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-70,60},{-50,80}})));
          Modelica.Blocks.Sources.Ramp torque(
            startTime=1,
            duration=1,
            height=-100)
            annotation (Placement(transformation(extent={{100,60},{80,80}})));
          Modelica.Mechanics.Rotational.Sources.Torque2 torque2_1
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational mounting1D
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
        equation
          connect(pulley_left.frame_a, belt_upper.flange_b) annotation (Line(
              points={{-66,20},{-40,20},{-40,30},{-10,30}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_a, pulley_left.frame_b) annotation (Line(
              points={{-10,-30},{-66,-30},{-66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pulley_left.flange, flange_left) annotation (Line(
              points={{-80,0},{-30,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_left.bearingFrame, fixedTranslation.frame_a) annotation (Line(
              points={{-30,0},{-10,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, flange_right.bearingFrame) annotation (Line(
              points={{10,0},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_right, pulley_right.flange) annotation (Line(
              points={{30,0},{80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, flange_world.bearingFrame) annotation (Line(
              points={{-80,70},{-60,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_world, pulley_left.flange) annotation (Line(
              points={{-60,70},{-60,50},{-80,50},{-80,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.y, torque2_1.tau) annotation (Line(
              points={{79,70},{70,70},{70,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(mounting1D.flange_b, torque2_1.flange_a) annotation (Line(
              points={{40,50},{60,50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(mounting1D.frame_a, flange_right.bearingFrame) annotation (Line(
              points={{30,40},{30,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque2_1.flange_b, flange_right.flange) annotation (Line(
              points={{80,50},{80,36},{30,36},{30,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(belt_upper.flange_a, pulley_right.frame_b) annotation (Line(
              points={{10,30},{40,30},{40,20},{66,20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_lower.flange_b, pulley_right.frame_a) annotation (Line(
              points={{10,-30},{66,-30},{66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(graphics),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Belt_Test;

        model Driving_Road_Wheels_Test
          "Demonstrate the road wheel contact with the ground, applying a torque to generate friction and drive the wheels."

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner MSL_Extend.Mechanics.Planar.World  world
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{50,-30},{70,-10}})));
          MSL_Extend.Mechanics.Planar.Joints.Prismatic  prismatic(v(fixed=true), s(fixed=
                 true))
            annotation (Placement(transformation(extent={{-70,0},{-50,20}})));
          inner
            C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground(p_act=[-10,0.01; 10,0.01])
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
          MSL_Extend.Mechanics.Planar.Parts.Body  body(m=100, J=0.001)
            annotation (Placement(transformation(extent={{-10,20},{-30,40}})));
          MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational
                                                        mounting1D
            annotation (Placement(transformation(extent={{20,10},{40,30}})));
          Modelica.Mechanics.Rotational.Sources.Torque2 torque2_1
            annotation (Placement(transformation(extent={{40,20},{60,40}})));
          Modelica.Blocks.Sources.Ramp torque(
            duration=2,
            startTime=1,
            height=-100)
            annotation (Placement(transformation(extent={{80,40},{60,60}})));
          Road_Wheel_Assembly wheel_1
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-66})));
          replaceable Road_Wheel_Assembly wheel_2 constrainedby
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Road_Wheel_Assembly
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,-66})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
          Belt_Segment
            belt_Segment
            annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                rotation=0,
                origin={-10,-90})));
          Belt_Segment
            belt_Segment1
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={30,-40})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  fixedTranslation(r={1,0})
                    annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  fixedTranslation1(r={1,0})
                    annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
          MSL_Extend.Mechanics.Planar.Joints.Revolute  revolute(w(fixed=true))
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        equation
          connect(world.frame_b, prismatic.frame_a)
                                                 annotation (Line(
              points={{-80,10},{-70,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(mounting1D.frame_a, flange1.bearingFrame)
                                                           annotation (Line(
              points={{30,10},{30,-20},{60,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque2_1.flange_b, flange1.flange)
                                                     annotation (Line(
              points={{60,30},{60,-20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque.y, torque2_1.tau) annotation (Line(
              points={{59,50},{50,50},{50,34}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(flange1, wheel_1.flange)
                                          annotation (Line(
              points={{60,-20},{79.8,-20},{79.8,-66}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange2, wheel_2.flange) annotation (Line(
              points={{-80,-20},{-79.8,-20},{-79.8,-66}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation1.frame_b, flange1.bearingFrame)
                                                                  annotation (Line(
              points={{20,-20},{60,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque2_1.flange_a, mounting1D.flange_b) annotation (Line(
              points={{40,30},{40,20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(fixedTranslation.frame_a, flange2.bearingFrame) annotation (Line(
              points={{-50,-20},{-80,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(body.frame_a, fixedTranslation1.frame_a) annotation (Line(
              points={{-10,30},{-10,-20},{0,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, revolute.frame_a) annotation (Line(
              points={{-50,10},{-40,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(revolute.frame_b, fixedTranslation.frame_b) annotation (Line(
              points={{-20,10},{-10,10},{-10,-20},{-30,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(revolute.frame_b, fixedTranslation1.frame_a) annotation (Line(
              points={{-20,10},{-10,10},{-10,-20},{0,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_Segment.flange_a, wheel_1.frame_b) annotation (Line(
              points={{0,-90},{94,-90},{94,-86}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_Segment.flange_b, wheel_2.frame_a) annotation (Line(
              points={{-20,-90},{-94,-90},{-94,-86}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_Segment1.flange_b, wheel_1.frame_a) annotation (Line(
              points={{40,-40},{94,-40},{94,-46}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(wheel_2.frame_b, belt_Segment1.flange_a) annotation (Line(
              points={{-94,-46},{-94,-46},{-94,-40},{20,-40}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics),
            experiment(StopTime=10, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Driving_Road_Wheels_Test;

        model Test_3_Pulley_System_with_1D_3D_belt_reactions
          "Demonstrates belt connection between pulleys, and how the belt tension acts on the pulleys.  In this case, top pulley is mounted on sprung joint, allowing it to be pulled down"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner C2M2L_OM.MSL_Extend.Mechanics.Planar.World world(g=0)
            annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
            pulley_left
            annotation (Placement(transformation(extent={{-58,-60},{-18,-20}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
            pulley_right                    annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=180,
                origin={80,-40})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_bottom
                                                    annotation (Placement(
                transformation(rotation=0, extent={{20,-80},{40,-60}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Joints.Prismatic       fixedTranslation2(
              useAxisFlange=true, s(start=2))
            annotation (Placement(transformation(extent={{10,-50},{30,-30}})));
          Modelica.Mechanics.Rotational.Components.Fixed fixed
            annotation (Placement(transformation(extent={{-100,100},{-80,80}})));
          Modelica.Mechanics.Rotational.Components.Damper damper(d=5)
            annotation (Placement(transformation(extent={{-90,70},{-70,90}})));
          Modelica.Mechanics.Translational.Sources.Speed speed(s(start=1))
            annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (Placement(transformation(extent={{20,0},{0,20}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Idler_Pulley
            pulley_left1
            annotation (Placement(transformation(extent={{-58,40},{-18,80}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                          belt_left
                                                    annotation (Placement(
                transformation(rotation=270,
                                           extent={{-10,-10},{10,10}},
                origin={-30,10})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Joints.Prismatic fixedTranslation(n={0,1},
              useAxisFlange=true) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-70,10})));
          Modelica.Mechanics.Rotational.Components.Fixed fixed1
            annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
          Modelica.Mechanics.Rotational.Components.Damper damper1(
                                                                 d=0.1)
            annotation (Placement(transformation(extent={{-90,-90},{-70,-70}})));
          Modelica.Mechanics.Translational.Components.SpringDamper springDamper(
            s_rel(fixed=true, start=1),
            c=100,
            d=10,
            s_rel0=1) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-90,14})));
          Modelica.Mechanics.Rotational.Sources.Torque torqueStep
            annotation (Placement(transformation(extent={{30,40},{50,60}})));
          Modelica.Blocks.Sources.Ramp ramp(
            duration=10,
            startTime=1,
            height=20)
            annotation (Placement(transformation(extent={{0,40},{20,60}})));
          replaceable
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Suspension.Belt_Segment
                                                                            belt_top
                                                    annotation (Placement(
                transformation(rotation=180,
                                           extent={{-10,-10},{10,10}},
                origin={50,80})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_left(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_left1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
          C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange_right(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{40,-50},{60,-30}})));
        equation
          connect(belt_bottom.flange_a, pulley_left.frame_b)
                                                         annotation (Line(
              points={{20,-70},{-24,-70},{-24,-60}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_bottom.flange_b, pulley_right.frame_a)
                                                         annotation (Line(
              points={{40,-70},{66,-70},{66,-60}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixed.flange, damper.flange_a) annotation (Line(
              points={{-90,90},{-90,80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(speed.flange, fixedTranslation2.axis) annotation (Line(
              points={{20,-20},{28,-20},{28,-34}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(belt_left.flange_a, pulley_left1.frame_b)
                                                          annotation (Line(
              points={{-30,20},{-30,30},{-24,30},{-24,40}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixed1.flange, damper1.flange_a)
                                                 annotation (Line(
              points={{-90,-90},{-90,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(springDamper.flange_b, fixedTranslation.axis) annotation (Line(
              points={{-90,24},{-76,24},{-76,18}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(springDamper.flange_a, fixedTranslation.support) annotation (Line(
              points={{-90,4},{-76,4},{-76,6}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(const.y, speed.v_ref) annotation (Line(
              points={{-1,10},{-6,10},{-6,-20},{-2,-20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ramp.y, torqueStep.tau) annotation (Line(
              points={{21,50},{28,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(belt_top.flange_b, pulley_left1.frame_a)
                                                          annotation (Line(
              points={{40,80},{-24,80}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(belt_top.flange_a, pulley_right.frame_b)
                                                          annotation (Line(
              points={{60,80},{66,80},{66,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, flange_left.bearingFrame) annotation (Line(
              points={{-100,-40},{-70,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(damper1.flange_b, flange_left.flange) annotation (Line(
              points={{-70,-80},{-70,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(flange_left, pulley_left.flange) annotation (Line(
              points={{-70,-40},{-38,-40}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, flange_left1.bearingFrame) annotation (Line(
              points={{-70,20},{-70,60}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_left1, pulley_left1.flange) annotation (Line(
              points={{-70,60},{-38,60}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_a, flange_left.bearingFrame) annotation (Line(
              points={{-70,0},{-70,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange_right, pulley_right.flange) annotation (Line(
              points={{50,-40},{80,-40}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation2.frame_b, flange_right.bearingFrame) annotation (
              Line(
              points={{30,-40},{50,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torqueStep.flange, flange_right.flange) annotation (Line(
              points={{50,50},{50,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(damper.flange_b, flange_left1.flange) annotation (Line(
              points={{-70,80},{-70,60}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(belt_left.flange_b, pulley_left.frame_a) annotation (Line(
              points={{-30,0},{-30,-10},{-24,-10},{-24,-20}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation2.frame_a, flange_left.bearingFrame) annotation (
              Line(
              points={{10,-40},{-70,-40}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                  preserveAspectRatio=true), graphics), Icon(coordinateSystem(extent={{-100,
                    -100},{100,100}}, preserveAspectRatio=true)),
            experiment(StopTime=10),
            __Dymola_experimentSetupOutput);
        end Test_3_Pulley_System_with_1D_3D_belt_reactions;

        model Wheels_Test

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner MSL_Extend.Mechanics.Planar.World world
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));

          MSL_Extend.Mechanics.Planar.Parts.Body body(
            m=200,
            J=20,
            s(start={-2,0.7}, fixed=true),
            v(start={5,0}, fixed=true))
            annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
          replaceable
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
                                    road_Wheel_Bearing_Flange
            annotation (Placement(transformation(extent={{50,-100},{90,-60}})));
          Modelica.Mechanics.Rotational.Sources.Torque2 torque
            annotation (Placement(transformation(extent={{20,60},{40,80}})));
          Modelica.Blocks.Sources.Trapezoid ramp(
            nperiod=1,
            startTime=1,
            falling=0,
            period=100,
            width=80,
            rising=0.1,
            amplitude=-150)
                        annotation (Placement(transformation(extent={{0,80},{20,100}})));
          replaceable
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
                                    road_Wheel_Bearing_Flange1
            annotation (Placement(transformation(extent={{-40,-100},{0,-60}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation fixedTranslation1(r={1,0})
                    annotation (Placement(transformation(extent={{50,50},{70,70}})));
          MSL_Extend.Mechanics.Planar.Parts.FixedTranslation fixedTranslation2(r={1,0})
                    annotation (Placement(transformation(extent={{-20,0},{-40,20}})));
          MSL_Extend.Mechanics.Planar.Parts.Mounting_1D_Rotational mounting1D1
            annotation (Placement(transformation(extent={{0,20},{20,40}})));
          MSL_Extend.Mechanics.Planar.Joints.Prismatic susp_2(
            useAxisFlange=true, n={0,-1})
                        annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-20,-30})));
          Modelica.Mechanics.Translational.Components.SpringDamper springDamper_2(
            stateSelect=StateSelect.always,
            s_rel0=0.2,
            s_rel(start=0.2),
            c=20000,
            d=1000)   annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={10,-30})));
          MSL_Extend.Mechanics.Planar.Joints.Prismatic susp_1(
            useAxisFlange=true, n={0,-1})
                        annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={70,-30})));
          Modelica.Mechanics.Translational.Components.SpringDamper springDamper_1(
            stateSelect=StateSelect.always,
            s_rel0=0.2,
            s_rel(start=0.2),
            c=20000,
            d=1000)   annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={100,-30})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-30,-60},{-10,-40}})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
          inner
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Flat_Road
            ground
            annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
          MSL_Extend.Mechanics.Planar.Joints.Planar planar
            annotation (Placement(transformation(extent={{-74,80},{-54,100}})));
        equation

          connect(fixedTranslation2.frame_b, body.frame_a) annotation (Line(
              points={{-40,10},{-50,10},{-50,70},{-40,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation1.frame_a, body.frame_a) annotation (Line(
              points={{50,60},{-50,60},{-50,70},{-40,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(mounting1D1.frame_a, fixedTranslation2.frame_a) annotation (Line(
              points={{10,20},{10,10},{-20,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(mounting1D1.flange_b, torque.flange_a) annotation (Line(
              points={{20,30},{20,70}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(ramp.y, torque.tau) annotation (Line(
              points={{21,90},{30,90},{30,74}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(susp_2.frame_a, fixedTranslation2.frame_a) annotation (Line(
              points={{-20,-20},{-20,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(susp_2.axis, springDamper_2.flange_b) annotation (Line(
              points={{-14,-38},{-14,-40},{10,-40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(susp_2.support, springDamper_2.flange_a) annotation (Line(
              points={{-14,-26},{-14,-20},{10,-20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(susp_1.frame_a, fixedTranslation1.frame_b) annotation (Line(
              points={{70,-20},{70,60}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(susp_1.axis, springDamper_1.flange_b) annotation (Line(
              points={{76,-38},{76,-40},{100,-40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(susp_1.support, springDamper_1.flange_a) annotation (Line(
              points={{76,-26},{76,-20},{100,-20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(road_Wheel_Bearing_Flange1.flange, flange) annotation (Line(
              points={{-20,-80},{-20,-50}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(susp_1.frame_b, flange1.bearingFrame) annotation (Line(
              points={{70,-40},{70,-50}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange_b, flange.flange) annotation (Line(
              points={{40,70},{40,-50},{-20,-50}},
              color={0,0,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange1, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{70,-50},{70,-80}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(susp_2.frame_b, flange.bearingFrame) annotation (Line(
              points={{-20,-40},{-20,-50}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, planar.frame_a) annotation (Line(
              points={{-80,90},{-74,90}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(planar.frame_b, body.frame_a) annotation (Line(
              points={{-54,90},{-48,90},{-48,70},{-40,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            experiment(StopTime=10, NumberOfIntervals=5000),
            __Dymola_experimentSetupOutput,
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}),
                    graphics));
        end Wheels_Test;

        model Rolling_Wheel_Test
          "Demonstrates the road wheel contact with the ground.  Wheel with mass attached rolls down a sloped road surface"

          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

          inner MSL_Extend.Mechanics.Planar.World world
            annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
          MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
          replaceable
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
            road_Wheel_Bearing_Flange
            annotation (Placement(transformation(extent={{20,-60},{60,-20}})));
          MSL_Extend.Mechanics.Planar.Joints.Planar  planar
            annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
          inner
            C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground(p_act=[-10,-1; -8,-2.5; -6,-2.5; -4,-1; 2,0.25], road=[-10,-1; -8,-2.5;
                -6,-2.5; -4,-1; 2,0.25]) "[-6.1, 1; -6, -0.5; -4, -1; 2, 0.25]"
            annotation (Placement(transformation(extent={{60,80},{80,100}})));
          MSL_Extend.Mechanics.Planar.Parts.Body body(m=100, J=0.001)
            annotation (Placement(transformation(extent={{-20,0},{-40,20}})));
        equation
          connect(world.frame_b, planar.frame_a) annotation (Line(
              points={{-80,-10},{-60,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(planar.frame_b, flange.bearingFrame) annotation (Line(
              points={{-40,-10},{-10,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, road_Wheel_Bearing_Flange.flange) annotation (Line(
              points={{-10,-10},{40,-10},{40,-40}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(body.frame_a, flange.bearingFrame) annotation (Line(
              points={{-20,10},{-10,10},{-10,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(graphics),
            experiment(StopTime=10, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Rolling_Wheel_Test;
      end Component_Test_Cases;

      model Belt_Segment

      //   extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        parameter Modelica.SIunits.TranslationalSpringConstant c=1000
          "Spring constant ";

        parameter Modelica.SIunits.TranslationalDampingConstant d=10
          "Damping constant";

        parameter Modelica.SIunits.Length belt_width= 0.05
          "Width of belt visualizer";

        parameter Modelica.SIunits.Length L=1 "initial_length";

        MSL_Extend.Mechanics.Planar.Joints.Prismatic_Dynamic_Color   prismatic1(
          useAxisFlange=true,
          alt_color={0,0,0},
          color_thresh=1e-2,
          s(start=100),
          stateSelect=StateSelect.prefer,
          boxColor={100,64,128},
          specularCoefficient=0,
          boxWidth=0.15,
          boxHeight=belt_width,
          n={1,0})   annotation (Placement(transformation(extent={{-12,70},{8,50}})));
        C2M2L_Component_Building_Blocks.Suspension.Submodels.Elasto_Gap_Belt_Tension
                                                                                     spring_3D_1D(
          c=c,
          d=d,
          s_rel(start=1))   annotation (Placement(transformation(extent={{-12,-10},{8,10}})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                 flange_a(
            includeBearingConnector=true)
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                 flange_b(
            includeBearingConnector=true)
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Mechanics.Translational.Sensors.ForceSensor forceSensor
          annotation (Placement(transformation(extent={{30,10},{50,-10}})));
        Modelica.Mechanics.Translational.Components.Mass rod(
                                                            L=L, m=10)
          annotation (Placement(transformation(extent={{80,-10},{60,10}})));

      equation
        connect(forceSensor.f, prismatic1.u) annotation (Line(
            points={{32,11},{32,78},{-2,78},{-2,71.9}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(spring_3D_1D.flange_b, forceSensor.flange_a) annotation (Line(
            points={{8,0},{30,0}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(rod.flange_a, flange_b.flange) annotation (Line(
            points={{80,0},{100,0}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(rod.flange_b, forceSensor.flange_b) annotation (Line(
            points={{60,0},{50,0}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(spring_3D_1D.flange_a, flange_a.flange) annotation (Line(
            points={{-12,0},{-100,0}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(spring_3D_1D.flange_3D_a, prismatic1.support) annotation (Line(
            points={{-10,10},{-8,10},{-8,54},{-6,54}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(spring_3D_1D.flange_3D_b, prismatic1.axis) annotation (Line(
            points={{6,10},{6,54}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(prismatic1.frame_a, flange_a.bearingFrame) annotation (Line(
            points={{-12,60},{-100,60},{-100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(prismatic1.frame_b, flange_b.bearingFrame) annotation (Line(
            points={{8,60},{100,60},{100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
                preserveAspectRatio=true), graphics), Icon(coordinateSystem(extent={{-100,
                  -100},{100,100}}, preserveAspectRatio=true), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),                          Rectangle(
                extent={{0,20},{80,-20}},
                lineColor={0,0,255},
                fillColor={200,128,255},
                fillPattern=FillPattern.Solid), Rectangle(
                extent={{-80,20},{0,-20}},
                lineColor={0,0,255},
                fillColor={213,170,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-100,60},{100,100}},
                textString="%name",
                lineColor={0,0,255},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255}),
              Text(
                extent={{-100,64},{-60,34}},
                lineColor={0,0,0},
                textString="a"),
              Text(
                extent={{60,64},{100,34}},
                lineColor={0,0,0},
                textString="b")}),
          Documentation(info="<html>
<p>Represents a segment of belt (track) between two wheels/pulleys. Transmits the torque from the sprocket to the road wheels, allowing the vehicle to drive and brake. The belt segment also has longitudinal stiffness and damping properties to handle tension. Stiffness and damping constants are <b>c</b> and <b>d</b>, respectively. The initial length, <b>L</b>, is used to set the initial tension in the belt. Setting this parameter to be shorter than the static distance between attachment points (wheels, pulleys) will result in an intial tension force.  Setting it equal or longer will result in no initial tension force.</p>
<p>Dimensional parameters are explained via the image below.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Belt_Segment.png\"/></p>
</html>"));
      end Belt_Segment;

      model Guide_Wheel_Pulley
      //   extends C2M2L_Ext.Interfaces.Delivered_C2M2L;
        extends C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Base_Pulley(
            final use_mass_and_viz=true, final stateSelect=StateSelect.prefer);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},
                  {200,200}}), graphics),
                                      Diagram(coordinateSystem(preserveAspectRatio=
                  true, extent={{-200,-200},{200,200}})),
          Documentation(info="<html>
<p>The guide wheel (aka support roller) attaches to the vehicle hull (or bracket off of the hull). Dimensional parameters are explained via the images below.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Guide_Wheel_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Guide_Wheel_2.png\"/></p>
</html>"));
      end Guide_Wheel_Pulley;

      model Drive_Sprocket_Pulley
        extends C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Base_Pulley(
          final use_mass_and_viz=true,
          final stateSelect=StateSelect.prefer,
          wheel_hub(extra=10));
      //  extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        //parameter Real N_teeth "Number of teeth on the sprocket"

        C2M2L_OM.MSL_Extend.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_sprocket_torque(nu=1)
          annotation (Placement(transformation(extent={{140,80},{160,100}})));
        Modelica.Mechanics.Rotational.Sensors.TorqueSensor torqueSensor
          annotation (Placement(transformation(extent={{-10,10},{10,-10}},
              rotation=0,
              origin={90,30})));
      equation
        connect(torqueSensor.flange_a, wheel_brg.support) annotation (Line(
            points={{80,30},{64,30},{64,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(torqueSensor.flange_b, wheel_brg.axis) annotation (Line(
            points={{100,30},{100,10},{70,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(torqueSensor.tau, max_sprocket_torque.u[1]) annotation (Line(
            points={{82,41},{82,90},{140,90}},
            color={0,0,127},
            smooth=Smooth.None));
          annotation (Dialog(group="Pulley Details"),
                    Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),
                               graphics),
                                      Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-200},{200,200}})),
          Documentation(info="<html>
<p>A sprocket-carrier assembly. The assembly consists of a carrier (blue) and a pair of toothed sprockets (grey) that are bolted together. The carrier accepts the torque output from the final drive, transferring the torque through the sprocket teeth and into the track. Dimensional parameters are explained via the images below. <b>D_wheel</b> measures the pitch diameter of the sprocket-carrier assembly. <b>W_wheel</b> is the width between the teeth, measured at the center of the teeth.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Sprocket_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Sprocket_2.png\"/></p>
</html>"));
      end Drive_Sprocket_Pulley;

      model Idler_Pulley
      //   extends C2M2L_Ext.Interfaces.Delivered_C2M2L;
        extends C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Base_Pulley(
          final use_mass_and_viz=true,
          final stateSelect=StateSelect.prefer,
          flange(includeBearingConnector=true),
          frame_a(includeBearingConnector=true),
          frame_b(includeBearingConnector=true));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}})), Diagram(coordinateSystem(preserveAspectRatio=true,
                        extent={{-200,-200},{200,200}}), graphics),
          Documentation(info="<html>
<p>The idler wheel attaches to the idler arm on the tensioner assembly. Dimensional parameters are explained via the images below.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Idler_Wheel_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Idler_Wheel_2.png\"/></p>
</html>"));
      end Idler_Pulley;

      model Rigid_Tensioner_Assembly
        "Tensioner assembly consisting of ider arm and rigid (fixed length) tensioner"
      //   extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                        wheel(includeBearingConnector=
             true)                                              annotation (Placement(
              transformation(
              extent={{-16,-16},{16,16}},
              rotation=180,
              origin={2,-20}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=180,
              origin={204,-140})));
        C2M2L_OM.MSL_Extend.Mechanics.Planar.Interfaces.Frame_a hull    annotation (
            Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={-100,122}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=180,
              origin={-204,-60})));
        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Running_Gear_Components.Idler_Arm
                                                             idler_Arm(
          lever_arm_wheel=lever_arm_wheel,
          offset_wheel=offset_wheel,
          lever_arm_tensioner=lever_arm_tensioner,
          bracket_height_tensioner=bracket_height_tensioner,
          m_arm=m_arm,
          I_xx_arm=I_xx_arm,
          I_yy_arm=I_yy_arm,
          I_zz_arm=I_zz_arm,
          lever_arm_CG_idler=lever_arm_CG_idler,
          bracket_height_CG_idler=bracket_height_CG_idler,
          offset_CG_idler=offset_CG_idler,
          initial_angle=initial_angle,
          offset_tensioner=tensioner_hull_attach_z)
          annotation (Placement(transformation(extent={{-80,0},{-40,40}})));
        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Running_Gear_Components.Rigid_Tensioner
                                                                   tensioner(
          ideal_length=ideal_length,
          m_tensioner=m_tensioner,
          I_xx_tensioner=I_xx_tensioner,
          I_yy_tensioner=I_yy_tensioner,
          I_zz_tensioner=I_zz_tensioner,
          lever_arm_CG_tensioner=lever_arm_CG_tensioner,
          bracket_height_CG_tensioner=bracket_height_CG_tensioner,
          offset_CG_tensioner=offset_CG_tensioner)
          annotation (Placement(transformation(extent={{20,20},{60,60}})));
        C2M2L_OM.MSL_Extend.Mechanics.Planar.Parts.FixedTranslation tensioner_hull_attach(
            animation=false, r={tensioner_hull_attach_x,tensioner_hull_attach_y})
          "Attachment point of the tensioner to the hull, measured from the idler arm hull bearing"
          annotation (Placement(transformation(extent={{-20,70},{0,90}})));

      // IDLER ARM PROPERTIES
        parameter Modelica.SIunits.Length lever_arm_wheel=0.15
          "Distance from center of hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Wheel", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Length offset_wheel=0.30
          "Lateral offset of wheel center from hull bearing"
          annotation (Dialog(group="Lever Arm - Wheel", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg initial_angle=60
          "Estimated initial angle of idler arm (measured in World frame)"
          annotation (Dialog(group="Lever Arm - Wheel", tab="Idler Arm Properties"));

        parameter Modelica.SIunits.Length lever_arm_tensioner=0.14
          "Distance from center of hull bearing to tensioner attachment (projected in side view)"
          annotation (Dialog(group="Lever Arm - Tensioner", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Length bracket_height_tensioner=0
          "Distance of tensioner attachment above or below the line from hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Tensioner", tab="Idler Arm Properties"));

        parameter Modelica.SIunits.Length lever_arm_CG_idler=0.07
          "Distance from center of hull bearing to arm CG location (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Length bracket_height_CG_idler=0
          "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Length offset_CG_idler=0
          "Lateral offset of arm CG location from hull bearing"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Idler Arm Properties"));

        parameter Modelica.SIunits.Mass m_arm=25 "Mass of arm"
          annotation (Dialog(group="Mass Properties", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Inertia I_xx_arm=0.1
          "(1,1) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Inertia I_yy_arm=0.1
          "(2,2) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Idler Arm Properties"));
        parameter Modelica.SIunits.Inertia I_zz_arm=0.1
          "(3,3) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Idler Arm Properties"));

      // TENSIONER PROPERTIES
        parameter Modelica.SIunits.Length tensioner_hull_attach_x=0.45
          "Distance from center of idler arm hull bearing to tensioner hull attachment (X-direction)"
          annotation (Dialog(group="Top Mount - Tensioner"));
        parameter Modelica.SIunits.Length tensioner_hull_attach_y=0.10
          "Distance from center of idler arm hull bearing to tensioner hull attachment (Y-direction)"
          annotation (Dialog(group="Top Mount - Tensioner"));
        parameter Modelica.SIunits.Length tensioner_hull_attach_z=-0.15
          "Distance from center of idler arm hull bearing to tensioner hull attachment (Z-direction)"
          annotation (Dialog(group="Top Mount - Tensioner"));

        parameter Modelica.SIunits.Length ideal_length=0.40
          "Ideal distance from hull attachment to idler arm attachment (projected in side view)"
          annotation (Dialog(group="Dimensions", tab="Tensioner Properties"));

        parameter Modelica.SIunits.Length lever_arm_CG_tensioner=0.20
          "Distance from center of hull attachment to arm CG location (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Tensioner Properties"));
        parameter Modelica.SIunits.Length bracket_height_CG_tensioner=0
          "Distance of CG above or below the line from hull attachment to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Tensioner Properties"));
        parameter Modelica.SIunits.Length offset_CG_tensioner=0
          "Lateral offset of arm CG location from hull attachment"
          annotation (Dialog(group="Lever Arm - Center of Gravity", tab="Tensioner Properties"));

        parameter Modelica.SIunits.Mass m_tensioner=80 "Mass of tensioner"
          annotation (Dialog(group="Mass Properties", tab="Tensioner Properties"));
        parameter Modelica.SIunits.Inertia I_xx_tensioner=0.1
          "(1,1) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Tensioner Properties"));
        parameter Modelica.SIunits.Inertia I_yy_tensioner=0.1
          "(2,2) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Tensioner Properties"));
        parameter Modelica.SIunits.Inertia I_zz_tensioner=0.1
          "(3,3) element of inertia tensor"
          annotation (Dialog(group="Mass Properties", tab="Tensioner Properties"));

      equation
        connect(tensioner_hull_attach.frame_b, tensioner.hull) annotation (Line(
            points={{0,80},{80,80},{80,32.6},{60.4,32.6}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tensioner_hull_attach.frame_a, hull) annotation (Line(
            points={{-20,80},{-100,80},{-100,122}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(idler_Arm.tensioner, tensioner.idler_arm) annotation (Line(
            points={{-39.6,38},{19.6,38}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(idler_Arm.hull, hull) annotation (Line(
            points={{-80.4,14},{-100,14},{-100,122}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(idler_Arm.wheel, wheel) annotation (Line(
            points={{-39.6,20},{-20,20},{-20,-20},{2,-20}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),
                            graphics),
          experiment(StopTime=10, Interval=0.001),
          __Dymola_experimentSetupOutput,
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}}),
                          graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,30},{80,-30}},
                lineColor={0,0,255},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={88,54},
                rotation=170),
              Rectangle(
                extent={{-80,45},{80,-45}},
                lineColor={0,0,255},
                fillColor={217,217,172},
                fillPattern=FillPattern.Solid,
                origin={-70,0},
                rotation=45),
              Ellipse(
                extent={{-65,-65},{65,65}},
                lineColor={0,0,255},
                origin={0,70},
                rotation=360,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={0,120},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-44,95},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-44,45},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={0,20},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={44,45},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={44,95},
                rotation=360,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-55,-55},{55,55}},
                lineColor={0,0,255},
                origin={-126,-56},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-20,-20},{20,20}},
                lineColor={0,0,255},
                origin={178,38},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>Similar to a trailing arm suspension assembly that attaches to the vehicle hull. Assembly includes a rigid idler arm and a rigid (fixed length) tensioner. While both the idler arm and tensioner will have attachments to the vehicle hull, the tensioner attachment point is dimensioned from the idler arm hull attachment inside the assembly.</p>
<p>Dimensional parameters are explained via the images below. Dimensions in the first two images are measured in the local coordinate system of the arm (in red). Images shown represent a tensioner assembly at the rear of the vehicle on the right hand side. The parameter <b>initial_angle</b> only needs to be a guess. It is used to determine if the idler arm sits above the horizontal (as shown in the images) or below the horizontal. The blue dot represents the center of the tensioner attachment to the idler arm.</p>
<p>The idler arm is the tan component, while the dark gray component is the tensioner. The parameter <b>bracket_height_tensioner</b> is positive if it is above the <b>lever_arm_wheel</b> line (+y) and negative if below the line (-y).</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Tensioner_Dimensions_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Tensioner_Dimensions_2.png\"/></p>
<p>The image below details how the tensioner hull attachment is dimensioned. Dimensions are measured in the World coordinate system from the idler arm hull attachment point (origin of red coordinate system).</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Tensioner_Dimensions_3.png\"/></p>
</html>"));
      end Rigid_Tensioner_Assembly;

      model Road_Wheel_Assembly
        "Assembly consists of \"Pulley\" model (belt interactions only) and \"Road Wheel\" model (normal and friction forces only)"
      //  extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

      //Pulley Details
        parameter Modelica.SIunits.Length D_wheel(min=0)=0.6
          "Road wheel diameter"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Length W_wheel(min=0)=0.2
          "Road wheel width (for pair of road wheels)"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Length Z_offset(min=0)=0
          "Thickness of single road wheel flange"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Angle phi=0 "guess_angle"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Length L_wrap=1
          "Length of belt around pulley"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Mass m_wheel(min=0)=50 "Mass of wheel"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_xx_wheel(min=0)=10
          "I_xx inertia of road wheel"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_yy_wheel(min=0)=10
          "I_yy inertia of road wheel"
          annotation (Dialog(group="Pulley Details"));
        parameter Modelica.SIunits.Inertia I_zz_wheel(min=0)=10
          "I_zz inertia of road wheel"
          annotation (Dialog(group="Pulley Details"));

      //Road Wheel Details
        parameter Modelica.SIunits.TranslationalSpringConstant c_tire(final min=0, start=1)=100000
          "Tire spring constant"
          annotation (Dialog(group="Road Wheel Details"));
        parameter Modelica.SIunits.TranslationalDampingConstant d_tire(final min=0, start=1)=1000
          "Tire damping constant"
          annotation (Dialog(group="Road Wheel Details"));
        parameter Real crr=0.01 "Rolling resistance coefficient for the tire"
          annotation (Dialog(group="Road Wheel Details"));
        parameter Real mu_static=0.7 "Static coefficient of friction"
          annotation (Dialog(group="Road Wheel Details"));
        parameter Real mu_dynamic=0.35 "Dynamic coefficient of friction"
          annotation (Dialog(group="Road Wheel Details"));

        parameter Boolean fix_wheel_brg_phi=false
          "=true if angular position of wheel should be zero";
        parameter Boolean fix_wheel_brg_w=false
          "=true if angular velocity of wheel should be zero";
        parameter Boolean fix_wheel_brg_a=false
          "=true if angular accel of wheel should be zero";
        parameter StateSelect stateSelect=StateSelect.prefer
          "Priority to use joint angle phi and w=der(phi) as states";

        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Road_Wheel_Bearing_Flange
          road_Wheel(
          D_wheel=D_wheel,
          c_tire=c_tire,
          d_tire=d_tire,
          Z_offset=Z_offset,
          W_wheel=W_wheel,
          m_wheel=m_wheel,
          I_xx_wheel=I_xx_wheel,
          I_yy_wheel=I_yy_wheel,
          I_zz_wheel=I_zz_wheel,
          fix_wheel_brg_phi=fix_wheel_brg_phi,
          fix_wheel_brg_w=fix_wheel_brg_w,
          fix_wheel_brg_a=fix_wheel_brg_a,
          mue_sliding=mu_dynamic,
          mue_locked=mu_static,
          n_tire=1,
          crr=crr)
          annotation (Placement(transformation(extent={{-40,-160},{40,-80}})));
        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Base_Pulley pulley(
          D_wheel=D_wheel,
          phi=phi,
          W_wheel=0.1,
          stateSelect=stateSelect,
          use_mass_and_viz=false)
                      annotation (Placement(transformation(
              extent={{-40,40},{40,-40}},
              rotation=90,
              origin={0,112})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                   frame_a(
            includeBearingConnector=true)                       annotation (Placement(
              transformation(rotation=0, extent={{180,-160},{220,-120}}),
              iconTransformation(extent={{180,-160},{220,-120}})));
        MSL_Extend.Mechanics.Planar.Interfaces.Flange_With_Bearing_Translational
                                                                                   frame_b(
            includeBearingConnector=true)                       annotation (Placement(
              transformation(rotation=0, extent={{-220,-160},{-180,-120}}),
              iconTransformation(extent={{-220,-160},{-180,-120}})));
        MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing  flange(
            includeBearingConnector=true)
          annotation (Placement(transformation(extent={{-10,-8},{10,12}})));

      equation
        connect(frame_b, pulley.frame_b) annotation (Line(
            points={{-200,-140},{-120,-140},{-120,140},{-40,140}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(pulley.frame_a, frame_a) annotation (Line(
            points={{40,140},{120,140},{120,-140},{200,-140}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(pulley.flange, flange) annotation (Line(
            points={{0,112},{0,2}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(flange, road_Wheel.flange) annotation (Line(
            points={{0,2},{0,-120}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(extent={{-200,-200},{200,200}},
                preserveAspectRatio=true),
                            graphics), Icon(coordinateSystem(extent={{-200,-200},{200,
                  200}},     preserveAspectRatio=true), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),                   Ellipse(
                extent={{-160,-160},{160,160}},
                lineColor={0,0,255},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-120,-120},{120,120}},
                lineColor={0,0,255},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360),
              Text(
                extent={{190,-82},{250,-112}},
                lineColor={0,0,0},
                textString="a"),
              Text(
                extent={{-248,-84},{-188,-114}},
                lineColor={0,0,0},
                textString="b"),
              Line(
                points={{-178,-142},{-2,-162}},
                color={200,128,255},
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{-2,-162},{180,-140}},
                color={213,170,255},
                thickness=0.5,
                smooth=Smooth.None)}),
          Documentation(info="<html>
<p>A road wheel attaches to the end of the suspension arm. Road wheels are attached in pairs, so the width measurement is for the assembled pair. The parameter <b>Z_offset</b> is equal to the thickness of one roadwheel flange. The true center of the assembly is where the two wheel flanges meet. This center is offset from the flange on the suspension arm by the thickness of one wheel flange.</p>
<p>The road wheel transfers force from the ground to the suspension arm, but also has its own stiffness and damping properties, controlled by the parameters <b>c_tire</b> and <b>d_tire</b>.</p>
<p>Dimensional parameters are explained via the images below.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Road_Wheel_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Road_Wheel_2.png\"/></p>
</html>"));
      end Road_Wheel_Assembly;

      model TrackSusp_SubAssembly_Torsion_Trans_Damper_Range
        "Single suspension set for attaching to hull - parameterized road arm with damper.  Damper has max-min force ranges"
          //extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        MSL_Extend.Mechanics.Planar.Interfaces.Frame_a  hull    annotation (
            Placement(transformation(extent={{-16,-16},{16,16}},
              rotation=90,
              origin={-24,122}),
              iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,204})));
        C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Road_Arm_With_Torsion_Bar_Trans_Damper
                                               road_arm(
          lever_arm_wheel=lever_arm_wheel,
          offset_wheel=offset_wheel,
          lever_arm_damper=lever_arm_damper,
          bracket_height_damper=bracket_height_damper,
          offset_damper=offset_damper,
          lever_arm_CG=lever_arm_CG,
          bracket_height_CG=bracket_height_CG,
          offset_CG=offset_CG,
          torsion_bar_install_angle=torsion_bar_install_angle,
          m_arm=m_arm,
          m_bar=m_bar,
          I_xx_arm=I_xx_arm,
          I_yy_arm=I_yy_arm,
          I_zz_arm=I_zz_arm,
          c_bar=c_bar)
          annotation (Placement(transformation(extent={{-48,-24},{0,24}})));
        MSL_Extend.Mechanics.Planar.Parts.FixedTranslation  damper_mount_upper(
                                                                         animation=
              false, r={damper_top_mount_x,damper_top_mount_y}) if
                         use_damper
          annotation (Placement(transformation(extent={{0,50},{20,70}})));
        C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Damper_From_Table_With_Range
          damper_from_table(
          tableOnFile=false,
          m_damper=m_damper,
          L_max=L_max,
          L_min=L_min,
          compression_scale=compression_scale,
          rebound_scale=rebound_scale,
          max_table=f_v_table_max,
          min_table=f_v_table_min,
          specularCoefficient=0.1,
          length_a=0.3,
          diameter_a=0.12,
          diameter_b=0.2) if          use_damper
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={30,30})));

        MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                        wheel(includeBearingConnector=
             true)                                              annotation (Placement(
              transformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={-24,-60}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,-204})));

        parameter Modelica.SIunits.Length lever_arm_wheel=0.5
          "Distance from center of hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Wheel"));
        parameter Modelica.SIunits.Length offset_wheel=0.1
          "Lateral offset of wheel center from hull bearing"
          annotation (Dialog(group="Lever Arm - Wheel"));
        parameter Modelica.SIunits.Length lever_arm_damper=0.15
          "Distance from center of hull bearing to damper attachment (projected in side view)"
          annotation (Dialog(group="Lever Arm - Damper"));
        parameter Modelica.SIunits.Length bracket_height_damper=0.2
          "Distance of damper attachment above or below the line from hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Damper"));
        parameter Modelica.SIunits.Length offset_damper=-0.1
          "Lateral offset of damper attachment from hull bearing"
          annotation (Dialog(group="Lever Arm - Damper"));

        parameter Modelica.SIunits.Length lever_arm_CG=0.25
          "Distance from center of hull bearing to arm CG location (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));
        parameter Modelica.SIunits.Length bracket_height_CG=0
          "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));
        parameter Modelica.SIunits.Length offset_CG=0.1
          "Lateral offset of arm CG location from hull bearing"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));

        parameter Modelica.SIunits.Mass m_arm=38 "Mass of arm" annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_xx_arm=10
          "(1,1) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_yy_arm=10
          "(2,2) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_zz_arm=10
          "(3,3) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));

        parameter Modelica.SIunits.Mass m_bar=0 "Mass of torsion bar"
          annotation (Dialog(tab="Damper and Torsion Bar", group="Torsion Bar"));
        parameter Real c_bar(unit="N.m/deg")=300 "Torsion bar spring constant"
          annotation (Dialog(tab="Damper and Torsion Bar", group="Torsion Bar"));
        parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg torsion_bar_install_angle=30
          "Unstretched spring angle (aka installation angle of torsion bar)"
          annotation (Dialog(tab="Damper and Torsion Bar", group="Torsion Bar"));
        parameter Boolean use_damper=true
          "= true, if damper is used; = false, if damper is not used"
          annotation (Dialog(tab="Damper and Torsion Bar", group="Parameters"));
        parameter Real f_v_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Real f_v_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Real compression_scale(min=0, max=1) = 0.0
          "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Real rebound_scale(min=0, max=1) = 0.0
          "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));

        parameter Modelica.SIunits.Mass m_damper=1 "Mass of damper"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Modelica.SIunits.Length L_max=1.0
          "Maximum extended length of damper"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Modelica.SIunits.Length L_min=0.5
          "Minimum compressed length of damper"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Damper_Properties"));
        parameter Modelica.SIunits.Length damper_top_mount_x=-0.5
          "Distance from center of trailing arm hull bearing to damper hull attachment (X-direction)"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Top Mount - Damper"));
        parameter Modelica.SIunits.Length damper_top_mount_y=0.3
          "Distance from center of trailing arm hull bearing to damper hull attachment (Y-direction)"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Top Mount - Damper"));
        parameter Modelica.SIunits.Length damper_top_mount_z=-0.1
          "Distance from center of trailing arm hull bearing to damper hull attachment (Z-direction)"
          annotation (Dialog(enable=use_damper, tab="Damper and Torsion Bar", group="Top Mount - Damper"));

      protected
        parameter Modelica.SIunits.RotationalSpringConstant c=c_bar*pi/180
          "Torsion bar spring constant";
      public
        C2M2L_OM.MSL_Extend.Blocks.Metrics.Empty_Metrics.Record arm_angle(nu=1)
          annotation (Placement(transformation(extent={{120,-22},{140,-2}})));
      equation
        connect(damper_mount_upper.frame_b, damper_from_table.frame_b)
                                                                     annotation (Line(
            points={{20,60},{30,60},{30,40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(road_arm.damper, damper_from_table.frame_a) annotation (Line(
            points={{0.4,-4},{30,-4},{30,20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(hull, road_arm.hull)    annotation (Line(
            points={{-24,122},{-24,24.4}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(damper_mount_upper.frame_a, hull)    annotation (Line(
            points={{0,60},{-24,60},{-24,122}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(road_arm.wheel, wheel) annotation (Line(
            points={{-24,-24.4},{-24,-60}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(road_arm.angle, arm_angle.u[1]) annotation (Line(
            points={{1,-12},{120,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),
                            graphics),
          experiment(StopTime=10, Interval=0.001),
          __Dymola_experimentSetupOutput,
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                  200}}), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-54,74},{46,-26},{66,-6},{-34,94},{-54,74}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-110,110},{-50,50},{-10,90},{-70,150},{-110,110}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{68,28},{110,-44},{90,-70},{-12,-52},{68,28}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={217,217,172},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-120,-80},{120,160},{160,120},{-80,-120},{-120,-80}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={217,217,172}),
              Ellipse(
                extent={{-56,-56},{56,56}},
                lineColor={0,0,255},
                origin={-120,-120},
                rotation=360,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-40,-40},{40,40}},
                lineColor={0,0,255},
                origin={150,150},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-20,-20},{20,20}},
                lineColor={0,0,255},
                origin={90,-50},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-20,-20},{20,20}},
                lineColor={0,0,255},
                origin={-100,140},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-164,-120},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-76,-120},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-120,-76},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-120,-164},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-150,-90},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-90,-90},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-90,-150},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                origin={-150,-150},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-30},{30,30}},
                lineColor={0,0,0},
                origin={-120,-120},
                rotation=360,
                fillColor={200,200,200},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{140,-26},{220,-54}},
                lineColor={0,0,0},
                fontName="Symbol",
                textString="q")}),
          Documentation(info="<html>
<p>A trailing arm suspension assembly that attaches to the vehicle hull. Assembly includes a rigid trailing arm, torsion bar acting across the revolute joint used to connect the arm to the hull, and a provision for attaching a translational damper. The damper can be turned on or off with the parameter <b>use_damper</b>. Even without the damper installed, there is still an attachment provision on the arm for the damper (in some current vehicles, not every arm has a damper attached, but often the same arm is used throughout for commonality). While both the trailing arm and damper (if used) will have attachments to the vehicle hull, the damper attachment point is dimensioned from the trailing arm hull attachment inside the assembly. </p>
<p>The damper behavior is described by four parameters: <b>f_v_table_max</b>, <b>f_v_table_min</b>, <b>compression_scale</b>, and <b>rebound_scale</b>.&nbsp; The parameters <b>f_v_table_max </b>and<b> f_v_table_min</b> described the maximum and minimum damping force curves.&nbsp; The parameters <b>compression_scale</b> and <b>rebound_scale</b> are used to pick a damping curve between the maximum and minimum curves.&nbsp; If a scale value of 0 is used, the minimum curve will be used, while a value of 1 will select the maximum curve. </p>
<p>&nbsp;The f_v inputs should be tables with velocity in the left column (m/s) and force in the right column (N). Positive damper velocity represents rebound damping, while negative damper velocity represents compression damping.&nbsp; The tables must be in an increasing order, from negative velocity to positive velocity. </p>
<p>Dimensional parameters are explained via the images below. Dimensions in the first two images are measured in the local coordinate system of the arm (in red). The local coordinate system in the images represents a trailing arm on the left hand side of the vehicle. </p>
<p>The parameter <b>bracket_height_damper</b> is positive if it is above the <b>lever_arm_wheel</b> line (+y) and negative if below the line (-y). </p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Susp_Dimensions_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Susp_Dimensions_2.png\"/></p>
<p>The image below details how the damper top mount (attached to vehicle hull) is dimensioned. Dimensions are measured in the World coordinate system, from the trailing arm hull attachment point.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Susp_Dimensions_3.png\"/></p>
</html>"));
      end TrackSusp_SubAssembly_Torsion_Trans_Damper_Range;

      model TrackSusp_SubAssembly_Hydropneumatic
        "Single suspension set for attaching to hull - parameterized road arm with hydropneumatic spring and damper"
          //extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        parameter Modelica.SIunits.Length lever_arm_wheel=0.5
          "Distance from center of hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Wheel"));
        parameter Modelica.SIunits.Length offset_wheel=0.1
          "Lateral offset of wheel center from hull bearing"
          annotation (Dialog(group="Lever Arm - Wheel"));
        parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg arm_install_angle=30
          "Installation angle of arm"
          annotation (Dialog(group="Lever Arm - Wheel"));
        parameter Modelica.SIunits.Length lever_arm_CG=0.25
          "Distance from center of hull bearing to arm CG location (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));
        parameter Modelica.SIunits.Length bracket_height_CG=0
          "Distance of CG above or below the line from hull bearing to wheel bearing (projected in side view)"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));
        parameter Modelica.SIunits.Length offset_CG=0.1
          "Lateral offset of arm CG location from hull bearing"
          annotation (Dialog(group="Lever Arm - Center of Gravity"));
        parameter Modelica.SIunits.Mass m_arm=38 "Mass of arm" annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_xx_arm=10
          "(1,1) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_yy_arm=10
          "(2,2) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));
        parameter Modelica.SIunits.Inertia I_zz_arm=10
          "(3,3) element of inertia tensor"                                              annotation (Dialog(group="Mass Properties"));

        parameter Real t_phi_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "N.m/deg - Torque versus rotational displacement ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N.m).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(tab="Damper and Spring",group="Spring Properties"));
        parameter Real t_phi_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "N.m/deg - Torque versus rotational displacement ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg give a torque of 16N.m).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(tab="Damper and Spring",group="Spring Properties"));
        parameter Real spring_scale(min=0, max=1) = 0.0
          "Spring scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(tab="Damper and Spring",group="Spring Properties"));

        parameter Real t_w_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "N.m.s/deg - Torque versus rotational velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(tab="Damper and Spring",group="Damper Properties"));
        parameter Real t_w_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "N.m.s/deg - Torque versus rotational velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4deg/s give a torque of 16N.m).  ***** MUST PROVIDE IN ASCENDING ORDER *****"
          annotation (Dialog(tab="Damper and Spring",group="Damper Properties"));
        parameter Real compression_scale(min=0, max=1) = 0.0
          "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(tab="Damper and Spring",group="Damper Properties"));
        parameter Real rebound_scale(min=0, max=1) = 0.0
          "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(tab="Damper and Spring",group="Damper Properties"));

        C2M2L_OM.C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Hydropneumatic_Road_Arm
          road_arm(
          lever_arm_wheel=lever_arm_wheel,
          offset_wheel=offset_wheel,
          lever_arm_CG=lever_arm_CG,
          bracket_height_CG=bracket_height_CG,
          offset_CG=offset_CG,
          m_arm=m_arm,
          I_xx_arm=I_xx_arm,
          I_yy_arm=I_yy_arm,
          I_zz_arm=I_zz_arm,
          arm_install_angle=arm_install_angle,
          t_phi_table_max=t_phi_table_max,
          t_phi_table_min=t_phi_table_min,
          spring_scale=spring_scale,
          t_w_table_max=t_w_table_max,
          t_w_table_min=t_w_table_min,
          compression_scale=compression_scale,
          rebound_scale=rebound_scale)
          annotation (Placement(transformation(extent={{-48,-24},{0,24}})));
          MSL_Extend.Mechanics.Planar.Interfaces.Frame_a hull    annotation (
            Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={-24,122}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,204})));
        MSL_Extend.Mechanics.Planar.Interfaces.FlangeWithBearing
                                                        wheel(includeBearingConnector=
             true)                                              annotation (Placement(
              transformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={-24,-60}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,-204})));

        C2M2L_OM.MSL_Extend.Blocks.Metrics.Empty_Metrics.Record arm_angle(nu=1)
          annotation (Placement(transformation(extent={{120,-22},{140,-2}})));
      equation
        connect(hull, road_arm.hull) annotation (Line(
            points={{-24,122},{-24,24.4}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(road_arm.wheel, wheel) annotation (Line(
            points={{-24,-24.4},{-24,-60}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(road_arm.angle, arm_angle.u[1]) annotation (Line(
            points={{1,-12},{120,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),
                            graphics),
          experiment(StopTime=10, Interval=0.001),
          __Dymola_experimentSetupOutput,
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                  200}}), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-90,-90},{90,90}},
                lineColor={0,0,0},
                origin={100,100},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-200,65},{150,-65}},
                lineColor={0,0,0},
                fillColor={217,217,172},
                fillPattern=FillPattern.Solid,
                origin={-6,-6},
                rotation=45),
              Ellipse(
                extent={{-56,-56},{56,56}},
                lineColor={0,0,0},
                origin={-104,-104},
                rotation=360,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,-80},{80,80}},
                lineColor={0,0,0},
                origin={100,100},
                rotation=360,
                fillColor={217,217,172},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-148,-104},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-60,-104},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-104,-60},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-104,-148},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-134,-74},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-74,-74},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-74,-134},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,0},
                origin={-134,-134},
                rotation=360,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-30},{30,30}},
                lineColor={0,0,0},
                origin={-104,-104},
                rotation=360,
                fillColor={200,200,200},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{140,-26},{220,-54}},
                lineColor={0,0,0},
                fontName="Symbol",
                textString="q")}),
          Documentation(info="<html>
<p>A trailing arm suspension assembly that attaches to the vehicle hull. Assembly includes a rigid trailing arm that contains a hydropneumatic unit.&nbsp; The hydropneumatic unit controls both springing and damping.&nbsp; Since everything is based on the rotation of the arm, springing and damping will be in terms of torque, rather than force. </p>
<p>The damper behavior is described by four parameters:<b> t_w_table_max</b>,<b> t_w_table_min</b>,<b> compression_scale</b>, and<b> rebound_scale</b>.&nbsp; The parameters <b>t_w_table_max</b> and <b>t_w_table_min</b> describe the maximum and minimum damping torque curves.&nbsp; The parameters <b>compression_scale</b> and <b>rebound_scale</b> are used to pick a damping curve between the maximum and minimum curves.&nbsp; If a scale value of 0 is used, the minimum curve will be used, while a value of 1 will select the maximum curve. </p>
<p>The spring behavior is described by three parameters: <b>t_phi_table_max</b>, <b>t_phi_table_min</b>, and <b>spring_scale</b>.&nbsp; Similar to the damper, <b>t_phi_table_max</b> and <b>t_phi_table_min</b> describe the maximum and minimum torque curves for the spring.&nbsp; The parameter <b>spring_scale</b> picks a spring curve between the maximum and minimum curves.&nbsp; Just like the dampers, a scale value of 0 will use the minimum curve, while a value of 1 will use the maximum curve. </p>
<p>&nbsp;The t_w inputs should be tables with rotational velocity in the left column (deg/s) and torque in the right column (N-m). Positive damper velocity represents rebound damping, while negative damper velocity represents compression damping.&nbsp; The tables must be in an increasing order, from negative velocity to positive velocity. </p>
<p>The t_phi inputs should also be tables, with rotation in the left column (deg) and torque in the right column (N-m).&nbsp; Tables must be in an increasing order, from negative to positive rotation. </p>
<p>Dimensional parameters are explained via the images below. Dimensions are measured in the local coordinate system of the arm (in red). The local coordinate system in the images represents a trailing arm on the left hand side of the vehicle.</p>
<p><img src=\"modelica://C2M2L_OM/Resources/Small_Hydro_Susp_Dimensions_1.png\"/><img src=\"modelica://C2M2L_OM/Resources/Small_Hydro_Susp_Dimensions_2.png\"/></p>
</html>"));
      end TrackSusp_SubAssembly_Hydropneumatic;
    end Suspension;

    package Amphibious
        extends Modelica.Icons.Package;

      package Bilge_Pump
        extends Modelica.Icons.Package;

        model Bilge_Pump_Electrical
          "Standalone bilge pump used. Electrical motor drive"

          extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice(
            rotating_inertia=0.01,
            flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
            efficiency_characteristic=[0,0.7],
            flow_device(check_valve=true));

        //eMotor
          parameter SI.Voltage v_nom=24
            "Nominal voltage that device is intended to operate at"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Inertia rotating_inertia_eMotor = 0.01
            "Moment of inertia of device around its axis of rotation"
                                                                     annotation (Dialog(tab="Electrical Model"));
          parameter SI.Voltage v_cutoff=v_nom*0.1
            "Supply voltage below which power limit cannot be reached"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Power pow_max=100000 "Maximum input power at v_nom"
          annotation (Dialog(tab="Electrical Model"));
          parameter SI.Torque trq_max=100 "Maximum output torque"
          annotation (Dialog(tab="Electrical Model"));
          parameter Real efficiency=0.95
            "Efficiency of electrical to mechanical conversion"
            annotation (Dialog(tab="Electrical Model"));
          parameter SI.Pressure On_Trigger_Pressure = 101500
            "Pressure (max) that triggers pump on";
          parameter SI.Pressure Off_Trigger_Pressure = 100800
            "Pressure (min) that triggers pump off";

          Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor
                                          pump_inlet_pressure_sensor(medium=medium)
            "Records pressure so it can be checked to see if the pump would have cavitated"
            annotation (Placement(transformation(extent={{-30,70},{-50,90}})));
          MSL_Extend.Electrical.Electric_Machines.Electric_Motor
                                                      electric_Motor(
            v_nom=v_nom,
            v_cutoff=v_cutoff,
            pow_max=pow_max,
            trq_max=trq_max,
            efficiency=efficiency) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-130,-14})));
          MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
            annotation (Placement(transformation(extent={{-198,180},{-178,200}})));
          Tests.Switch_Electric_Demand
            switch_Electric_Demand(On_Trigger_Pressure=On_Trigger_Pressure,
              Off_Trigger_Pressure=Off_Trigger_Pressure)
            annotation (Placement(transformation(extent={{-70,70},{-90,90}})));
          Modelica.Electrical.Analog.Interfaces.PositivePin pin_p
            annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
          Modelica.Electrical.Analog.Interfaces.NegativePin pin_n
            annotation (Placement(transformation(extent={{190,110},{210,130}})));
        equation
          connect(thermal_To_Environment_Thru_Area.solid, electric_Motor.heatPort)
            annotation (Line(
              points={{-198,190},{-198,-26},{-138,-26},{-138,-22}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(electric_Motor.demand, switch_Electric_Demand.demand) annotation (
              Line(
              points={{-119.4,-11},{-112,-11},{-112,80},{-90.6,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(electric_Motor.support, internalSupport) annotation (Line(
              points={{-140,-14},{-152,-14},{-152,-120},{0,-120},{0,-140}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(pin_n, electric_Motor.n) annotation (Line(
              points={{200,120},{140,120},{140,-98},{-130,-98},{-130,-22}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(electric_Motor.p, pin_p) annotation (Line(
              points={{-130,-6},{-130,120},{-200,120}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(pump_inlet_pressure_sensor.y, switch_Electric_Demand.pressure_in)
            annotation (Line(
              points={{-51,80},{-70,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(pump_inlet_pressure_sensor.flowPort, flow_device.flowPort_a)
            annotation (Line(
              points={{-30,80},{-20,80},{-20,90},{-10,90}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(flow_device.flange, electric_Motor.flange) annotation (Line(
              points={{0,80},{0,-14},{-120,-14}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}),
                                                 graphics={
                Polygon(
                  points={{-87,146},{-58,146},{-58,186},{-68,186},{-48,206},{-28,186},{
                      -38,186},{-38,126},{-87,126},{-87,146}},
                  lineColor={0,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{96,-60},{148,-60},{148,-80},{198,-80}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Line(
                  points={{-196,-80},{-152,-80},{-152,-60},{-98,-60},{-98,-62}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,11},{40,-11}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95},
                  origin={-1,60},
                  rotation=90),
                Polygon(
                  points={{-120,-200},{118,-200},{60,-102},{-60,-102},{-120,-200}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-102,40},{100,-160}},
                  lineColor={0,128,255},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-63,-40},{-63,-80},{-103,-60},{-63,-40}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{20,20},{20,-20},{-20,0},{20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={81,-60},
                  rotation=180),
                Rectangle(
                  extent={{-50,49},{50,-49}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,128,255},
                  origin={1,130},
                  rotation=90),
                Polygon(
                  points={{4,166},{18,158},{6,126},{0,134},{-14,96},{-4,148},{2,142},{4,
                      166}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-190,120},{-48,120}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{50,120},{192,120}},
                  color={0,0,255},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Electric bilge pump uses electrical inputs to power pump</li>
<li>user must provide the operating parameters for bith the electrical and fluid pump components</li>
</ul></p>
</html>"));
        end Bilge_Pump_Electrical;

        model Bilge_Pump_Hydraulic
          "Standalone bilge pump used. Hydraulic driven"

          extends
            C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice_PumpBase(
                                                                      rotating_inertia=0.01,
            flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
            efficiency_characteristic=[0,0.7],
            pump(check_valve=true),
            isolatedPipe(m=0));

        //motor parameters
         parameter SI.Volume vol_per_radian_motor = 1
            "Volume of hydraulic fluid moved for 1 radian of shaft rotation" annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter SI.Volume Nm_per_pascal_motor = 1
            "Pressure rise for 1 Nm of torque input"
                                                    annotation(Dialog(group="Hydraulic",tab="Motor"));
         parameter Real lossTable_motor[:, 5]=[0, 1, 1, 0, 0]
            "Array for mechanical efficiencies and bearing friction depending on speed"
                                                                                        annotation(Dialog(group="Mechanical",tab="Motor"));
         parameter SI.Inertia J_motor(
            min=0,
            start=1)=0.001 "Moment of inertia"
                                             annotation(Dialog(group="Inertia",tab="Motor"));
         parameter Real leakage_motor=0.001 "Leakage loss factor"
                                                                 annotation(Dialog(group="Hydraulic",tab="Motor"));
          parameter SI.Pressure On_Trigger_Pressure = 101500
            "Pressure (max) that triggers pump on";
          parameter SI.Pressure Off_Trigger_Pressure = 100800
            "Pressure (min) that triggers pump off";
          MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Lossy
            hydraulic_Mechanical_Conversion_Lossy(
            useSupport=true,
            vol_per_radian=vol_per_radian_motor,
            Nm_per_pascal=Nm_per_pascal_motor,
            lossTable=lossTable_motor,
            J=J_motor,
            leakage=leakage_motor,
            useHeatPort=true,
            useInertia=false)  annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-110,-110})));
          MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                            hyd_a
            annotation (Placement(transformation(extent={{-210,110},{-190,130}}),
                iconTransformation(extent={{-210,110},{-190,130}})));
          MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                            hyd_b
            annotation (Placement(transformation(extent={{190,110},{210,130}}),
                iconTransformation(extent={{190,110},{210,130}})));
          MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
            thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
            annotation (Placement(transformation(extent={{-200,180},{-180,200}})));
          Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor
                                          pump_inlet_pressure_sensor(medium=medium)
            "Records pressure so it can be checked to see if the pump would have cavitated"
            annotation (Placement(transformation(extent={{-23,114},{-43,134}})));
          Tests.Switch_Hydraulic_Demand
            switch_Hydraulic_Demand(On_Trigger_Pressure=On_Trigger_Pressure,
              Off_Trigger_Pressure=Off_Trigger_Pressure)
            annotation (Placement(transformation(extent={{-72,114},{-92,134}})));
          MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch
            hydraulic_On_Off_Switch(
            k_off=0,
            f_crit=0.2,
            k_on=0.0001)            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-102,184})));
          Modelica.Blocks.Logical.Not not1 annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-104,154})));
          MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_On_Off_Switch
            hydraulic_On_Off_Switch1(
            k_off=0,
            f_crit=0.2,
            k_on=0.0001)            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=270,
                origin={-148,124})));
          MSL_Extend.Hydraulics_Simple.Components.Switches.Hydraulic_One_Way
                                                                     hydraulic_One_Way
            annotation (Placement(transformation(extent={{-168,174},{-148,194}})));
        equation
          connect(hydraulic_Mechanical_Conversion_Lossy.hyd_b, hyd_b) annotation (Line(
              points={{-100,-110},{160,-110},{160,120},{200,120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(thermal_To_Environment_Thru_Area.solid,
            hydraulic_Mechanical_Conversion_Lossy.heatPort) annotation (Line(
              points={{-200,190},{-200,-118},{-120,-118},{-120,-120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_a, hydraulic_Mechanical_Conversion_Lossy.flange)
            annotation (Line(
              points={{-28,12},{-70,12},{-70,-100},{-110,-100}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(internalSupport, hydraulic_Mechanical_Conversion_Lossy.support)
            annotation (Line(
              points={{0,-140},{0,-120},{-110,-120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(pump_inlet_pressure_sensor.y, switch_Hydraulic_Demand.pressure_in)
            annotation (Line(
              points={{-44,124},{-72,124}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(not1.y,hydraulic_On_Off_Switch. u) annotation (Line(
              points={{-104,165},{-104,172},{-102,172}},
              color={255,0,255},
              smooth=Smooth.None));
          connect(not1.u,switch_Hydraulic_Demand. y) annotation (Line(
              points={{-104,142},{-104,124},{-92,124}},
              color={255,0,255},
              smooth=Smooth.None));
          connect(hydraulic_On_Off_Switch1.hyd_a, hydraulic_Mechanical_Conversion_Lossy.hyd_a)
            annotation (Line(
              points={{-148,114},{-148,-110},{-120,-110}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_On_Off_Switch1.u,switch_Hydraulic_Demand. y) annotation (
              Line(
              points={{-136,124},{-92,124}},
              color={255,0,255},
              smooth=Smooth.None));
          connect(hydraulic_One_Way.hyd_b,hydraulic_On_Off_Switch. hyd_a) annotation (
              Line(
              points={{-148,184},{-112,184}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_One_Way.hyd_b,hydraulic_On_Off_Switch1. hyd_b) annotation (
              Line(
              points={{-148,184},{-148,134}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_One_Way.hyd_a, hyd_a) annotation (Line(
              points={{-168,184},{-180,184},{-180,120},{-200,120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_On_Off_Switch.hyd_b, hyd_b) annotation (Line(
              points={{-92,184},{56,184},{56,120},{200,120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(pump_inlet_pressure_sensor.flowPort, pump.flowPort_a) annotation (
              Line(
              points={{-23,124},{-10,124},{-10,90}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                                 graphics), Icon(coordinateSystem(preserveAspectRatio=
                    true, extent={{-200,-320},{200,280}}),
                                                 graphics={
                Polygon(
                  points={{-79,148},{-50,148},{-50,188},{-60,188},{-40,208},{-20,188},{
                      -30,188},{-30,128},{-79,128},{-79,148}},
                  lineColor={0,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{96,-60},{148,-60},{148,-80},{198,-80}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Line(
                  points={{-196,-80},{-152,-80},{-152,-60},{-98,-60},{-98,-62}},
                  color={0,128,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,11},{40,-11}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={95,95,95},
                  origin={-1,60},
                  rotation=90),
                Polygon(
                  points={{-120,-200},{118,-200},{60,-102},{-60,-102},{-120,-200}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-102,40},{100,-160}},
                  lineColor={0,128,255},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{20,20},{20,-20},{-20,0},{20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={81,-60},
                  rotation=180),
                Polygon(
                  points={{-62,-40},{-62,-80},{-102,-60},{-62,-40}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-60,180},{60,60}},
                  lineColor={255,0,128},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,20},{-20,-20},{20,0},{-20,20}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  origin={46,120},
                  rotation=180),
                Polygon(
                  points={{-66,140},{-66,100},{-26,120},{-66,140}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-200,120},{-66,120}},
                  color={255,0,128},
                  smooth=Smooth.None),
                Line(
                  points={{66,120},{200,120}},
                  color={255,0,128},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Hydraulic bilge pump uses hydraulic motor to power pump</li>
<li>user must provide the operating parameters for bith the hydraulic motor and fluid pump components</li>
</ul></p>
</html>"));
        end Bilge_Pump_Hydraulic;

        package Tests
          extends Modelica.Icons.Package;

          model Test_Simple_Hydraulic
            extends MSL_Extend.Icons.Simple_Test_Case;
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                        env
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Modelica.Blocks.Sources.Ramp     const1(
              duration=10,
              startTime=5,
              height=75)
              annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
            Modelica.Mechanics.Rotational.Sources.Speed speed(exact=true)
              annotation (Placement(transformation(extent={{-70,60},{-50,80}})));
            MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Lossy
              test_hydraulic_pump(
              vol_per_radian=1e-5,
              Nm_per_pascal=1e-5,
              leakage=1e-9)
              annotation (Placement(transformation(extent={{10,30},{-10,50}})));
            MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                            pressure_Source(P_constant=10000000)
              annotation (Placement(transformation(extent={{-56,30},{-36,50}})));
            Bilge_Pump_Hydraulic bilge_Pump_Hydraulic(
              rotating_inertia=0.01,
              flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
              efficiency_characteristic=[0,0.7],
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              vol_per_radian_motor=1e-6,
              Nm_per_pascal_motor=1e-6,
              leakage_motor=1e-9)
              annotation (Placement(transformation(extent={{-20,-40},{20,20}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Out_Pressure_Source(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientPressure=118000,
              constantAmbientTemperature=293.15)
              annotation (Placement(transformation(extent={{34,-18},{54,2}})));
            Modelica.Blocks.Sources.TimeTable
                                         ramp2(          table=[0,0; 5,0; 10,2490.8892;
                  15,2490.8892; 20,498.17781; 25,498.17781; 30,2490.8892; 35,2490.8892], offset=
                  100000)
              annotation (Placement(transformation(extent={{-94,-8},{-74,12}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient In_Pressure_Source(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              usePressureInput=true,
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-38,-6})));
          equation

            connect(const1.y, speed.w_ref) annotation (Line(
                points={{-79,70},{-72,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_a, bilge_Pump_Hydraulic.hyd_b) annotation (
                Line(
                points={{10,40},{26,40},{26,4},{20,4}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_b, pressure_Source.hydraulic_port)
              annotation (Line(
                points={{-10,40},{-36,40}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(test_hydraulic_pump.hyd_b, bilge_Pump_Hydraulic.hyd_a) annotation (
                Line(
                points={{-10,40},{-26,40},{-26,4},{-20,4}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(speed.flange, test_hydraulic_pump.flange) annotation (Line(
                points={{-50,70},{0,70},{0,50}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(Out_Pressure_Source.flowPort, bilge_Pump_Hydraulic.flowPort_b)
                                                                       annotation (
                Line(
                points={{34,-8},{28,-8},{28,-16},{20,-16}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(In_Pressure_Source.ambientPressure,ramp2. y)
                                                       annotation (Line(
                points={{-48,-13},{-58,-13},{-58,2},{-73,2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(bilge_Pump_Hydraulic.flowPort_a, In_Pressure_Source.flowPort)
              annotation (Line(
                points={{-20,-16},{-24,-16},{-24,-6},{-28,-6}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=100, Interval=0.01),
              __Dymola_experimentSetupOutput);
          end Test_Simple_Hydraulic;

          model Switch_Hydraulic_Demand "activate switch at on/off pressure"

            Modelica.Blocks.Interfaces.RealInput pressure_in annotation (Placement(
                  transformation(extent={{-120,-20},{-80,20}}), iconTransformation(extent=
                     {{-120,-20},{-80,20}})));
            Modelica.Blocks.Logical.Hysteresis trigger(
              pre_y_start=false,
              uLow=Off_Trigger_Pressure,
              uHigh=On_Trigger_Pressure)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            Modelica.Blocks.Interfaces.BooleanOutput y
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));

            parameter SI.Pressure On_Trigger_Pressure = 2490.8891
              "Pressure (max) that triggers pump on";
            parameter SI.Pressure Off_Trigger_Pressure = 498.17782
              "Pressure (min) that triggers pump off";

          equation
          //        if pressure_in >= On_Trigger_Pressure then
          //          switch_out =1;
          //        elseif (pressure_in > Off_Trigger_Pressure and pre(switch_out) > 0) then
          //          switch_out =1;
          //        elseif pressure_in <= Off_Trigger_Pressure then
          //          switch_out =0;
          //        end if;

            connect(pressure_in, trigger.u)    annotation (Line(
                points={{-100,0},{-12,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trigger.y, y) annotation (Line(
                points={{11,0},{100,0}},
                color={255,0,255},
                smooth=Smooth.None));
            annotation (Diagram(graphics), Icon(graphics={
                  Line(points={{-76,20},{-68,46},{-50,78},{-24,92},{-2,94},{16,88},{32,80},
                        {48,64},{58,46},{68,24}},      color={0,0,255}),
                  Line(points={{-78,64},{-6,82},{82,52}},color={0,0,0}),
                  Line(points={{-78,50},{-6,70},{82,40}},  color={255,0,0}),
                  Line(points={{-78,36},{-6,56},{82,26}},  color={0,0,0}),
                  Line(points={{-82,34},{-56,34},{-56,12},{64,12},{64,32},{90,32}},
                      color={255,0,255}),
                  Text(
                    extent={{-100,-40},{100,-60}},
                    lineColor={255,0,0},
                    textString="high / low")}));
          end Switch_Hydraulic_Demand;

          model Test_Simple_Bilge_Electrical
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC
                                                        env
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Bilge_Pump_Electrical
              bilge_Pump(
              rotating_inertia=0.01,
              flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
              pow_max=5000,
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              efficiency_characteristic=[0,0.7; 2,0.7])
              annotation (Placement(transformation(extent={{-20,-34},{20,26}})));
            Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=12)
              annotation (Placement(transformation(
                  extent={{-10,10},{10,-10}},
                  rotation=0,
                  origin={0,46})));
            Modelica.Electrical.Analog.Basic.Ground ground
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={38,32})));
            Modelica.Blocks.Sources.TimeTable
                                         ramp1(          table=[0,0; 5,0; 10,2490.8892;
                  15,2490.8892; 20,498.17781; 25,498.17781; 30,2490.8892; 35,2490.8892], offset=
                  100000)
              annotation (Placement(transformation(extent={{-100,-12},{-80,8}})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient In_Pressure_Source(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              usePressureInput=true,
              constantAmbientPressure=100000,
              constantAmbientTemperature=293.15) annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=180,
                  origin={-44,-10})));
            Modelica.Thermal.FluidHeatFlow.Sources.Ambient Out_Pressure_Source(
              medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
              constantAmbientTemperature(displayUnit="degC") = 293.15,
              constantAmbientPressure=118000)
              annotation (Placement(transformation(extent={{42,-20},{62,0}})));
          equation

            connect(constantVoltage.n, ground.p) annotation (Line(
                points={{10,46},{28,46},{28,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(bilge_Pump.pin_n, ground.p) annotation (Line(
                points={{20,10},{28,10},{28,32}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(constantVoltage.p, bilge_Pump.pin_p) annotation (Line(
                points={{-10,46},{-26,46},{-26,10},{-20,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(bilge_Pump.flowPort_a, In_Pressure_Source.flowPort)
                                                              annotation (Line(
                points={{-20,-10},{-34,-10}},
                color={255,0,0},
                smooth=Smooth.None));
            connect(In_Pressure_Source.ambientPressure, ramp1.y)
                                                       annotation (Line(
                points={{-54,-17},{-64,-17},{-64,-2},{-79,-2}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(Out_Pressure_Source.flowPort, bilge_Pump.flowPort_b)
                                                             annotation (Line(
                points={{42,-10},{20,-10}},
                color={255,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=100),
              __Dymola_experimentSetupOutput);
          end Test_Simple_Bilge_Electrical;

          model Switch_Electric_Demand "activate switch at on/off pressure"

            Modelica.Blocks.Interfaces.RealInput pressure_in annotation (Placement(
                  transformation(extent={{-120,-20},{-80,20}}), iconTransformation(extent=
                     {{-120,-20},{-80,20}})));
            Modelica.Blocks.Logical.Hysteresis trigger(uLow=Off_Trigger_Pressure, uHigh=
                  On_Trigger_Pressure)
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Modelica.Blocks.Logical.Switch demand_switch
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            Modelica.Blocks.Sources.Constant true_signal(k=1)
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            Modelica.Blocks.Sources.Constant false_signal(k=0)
              annotation (Placement(transformation(extent={{-20,-30},{0,-10}})));

            parameter SI.Pressure On_Trigger_Pressure = 2490.8891
              "Pressure (max) that triggers pump on";
            parameter SI.Pressure Off_Trigger_Pressure = 498.17782
              "Pressure (min) that triggers pump off";

            Modelica.Blocks.Interfaces.RealOutput demand
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{96,-10},{116,10}})));
          equation
          //        if pressure_in >= On_Trigger_Pressure then
          //          switch_out =1;
          //        elseif (pressure_in > Off_Trigger_Pressure and pre(switch_out) > 0) then
          //          switch_out =1;
          //        elseif pressure_in <= Off_Trigger_Pressure then
          //          switch_out =0;
          //        end if;

            connect(pressure_in, trigger.u)    annotation (Line(
                points={{-100,0},{-62,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trigger.y, demand_switch.u2) annotation (Line(
                points={{-39,0},{18,0}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(true_signal.y, demand_switch.u1) annotation (Line(
                points={{1,20},{10,20},{10,8},{18,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(false_signal.y, demand_switch.u3) annotation (Line(
                points={{1,-20},{8,-20},{8,-8},{18,-8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(demand_switch.y, demand) annotation (Line(
                points={{41,0},{106,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}}),
                                graphics), Icon(graphics={
                  Line(points={{-76,20},{-68,46},{-50,78},{-24,92},{-2,94},{16,88},{32,80},
                        {48,64},{58,46},{68,24}},      color={0,0,255}),
                  Line(points={{-78,64},{-6,82},{82,52}},color={0,0,0}),
                  Line(points={{-78,50},{-6,70},{82,40}},  color={255,0,0}),
                  Line(points={{-78,36},{-6,56},{82,26}},  color={0,0,0}),
                  Line(points={{-82,34},{-56,34},{-56,12},{64,12},{64,32},{90,32}},
                      color={255,0,255}),
                  Text(
                    extent={{-100,-40},{100,-60}},
                    lineColor={255,0,0},
                    textString="high / low")}));
          end Switch_Electric_Demand;
        end Tests;
      end Bilge_Pump;

      package Waterjet "waterjet package"
          extends Modelica.Icons.Package;

        model Waterjet "water jet model with world force purpolsion"

        //parameters from instance sheet
         parameter SI.MomentOfInertia MOI_rotation = 1.22
            "rotational moment of inertia";
         parameter SI.Force max_thrust_forward_max_knots = 1000
            "max thrust whilst vehicle is moving";
         parameter SI.Force max_thrust_forward_zero_knots = 2000
            "max thrust whilst vehicle is stationary";
         parameter SI.Power max_power = 100000 "max operating power";
         parameter SI.Torque max_torque = 1000 "max operating torque";
         parameter Real reverse_thrust_factor = 0.43
            "Percentage of forward thrust when in reverse";
         parameter Integer steer_port_only = 0
            "Waterjet steers to port side only";
         parameter Integer steer_starboard_only = 0
            "Waterjet steers to starboard side only";
         parameter Integer steer_port_and_starboard = 1
            "Waterjet can steer to port or starboard side";
         parameter Real max_steer_angle = 45
            "Maximum steer angle for waterjet [deg]";

          Waterjet_base_thrust_control waterjet_base_thrust_control(
            MOI_rotation=MOI_rotation,
            max_thrust_forward_max_knots=max_thrust_forward_max_knots,
            max_thrust_forward_zero_knots=max_thrust_forward_zero_knots,
            max_power=max_power,
            max_torque=max_torque,
            reverse_thrust_factor=reverse_thrust_factor,
            steer_port_only=steer_port_only,
            steer_starboard_only=steer_starboard_only,
            steer_port_and_starboard=steer_port_and_starboard,
            max_steer_angle=max_steer_angle,
            useSupport=false)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={88,0})));
          Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a
            annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
          Modelica.Mechanics.Translational.Sources.Force force annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={50,0})));

         parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          Modelica.Mechanics.Translational.Interfaces.Support
                  support if useSupport "Support/housing of component"
            annotation (Placement(transformation(extent={{-10,-330},{10,-310}})));
        protected
          Modelica.Mechanics.Translational.Interfaces.Support
                  internalSupport
            "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
            annotation (Placement(transformation(extent={{-3,-303},{3,-297}})));
          Modelica.Mechanics.Translational.Components.Fixed
                           fixed if not useSupport
            "Fixed support/housing, if not useSupport"
            annotation (Placement(transformation(extent={{10,-314},{30,-294}})));
        public
          Modelica.Blocks.Interfaces.RealInput thrust_demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={88,288})));
          Modelica.Blocks.Interfaces.RealInput reverse_command
                                                             annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={44,288})));
          Modelica.Blocks.Interfaces.RealInput steer_command annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={126,288})));
          Modelica.Blocks.Interfaces.RealInput vehicle_speed annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={4,288})));
        equation
          connect(waterjet_base_thrust_control.thrust_out, force.f) annotation (Line(
              points={{78.6,0},{62,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(waterjet_base_thrust_control.flange, flange_a) annotation (Line(
              points={{98,0},{120,0},{120,20},{-100,20},{-100,0},{-200,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(fixed.flange, internalSupport) annotation (Line(
              points={{20,-304},{20,-300},{0,-300}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(force.flange, internalSupport) annotation (Line(
              points={{40,1.33227e-015},{0,1.33227e-015},{0,-300}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(support, internalSupport) annotation (Line(
              points={{0,-320},{0,-300}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(waterjet_base_thrust_control.thrust_demand, thrust_demand)
            annotation (Line(
              points={{88,10.8},{88,288}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(waterjet_base_thrust_control.steer_command, steer_command)
            annotation (Line(
              points={{92.2,10.8},{92.2,180.4},{126,180.4},{126,288}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(reverse_command, waterjet_base_thrust_control.reverse_command)
            annotation (Line(
              points={{44,288},{44,180},{84,180},{84,10.8}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(waterjet_base_thrust_control.vehicle_speed, vehicle_speed)
            annotation (Line(
              points={{80,10.8},{80,176},{4,176},{4,288}},
              color={0,0,127},
              smooth=Smooth.None));
            annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)),
                      Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                    -320},{200,280}}),
                              graphics={         Text(
                  extent={{23,-315},{63,-316}},
                  lineColor={95,95,95},
                  textString="(if not useSupport)"),
                                       Text(
                  extent={{-38,-324},{-6,-322}},
                  lineColor={95,95,95},
                  textString="(if useSupport)")}),
                                         Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}),
                                              graphics={
                Line(
                  points={{-132,-48},{-26,50},{-2,64},{24,68},{124,68},{142,58},{142,
                      -44},{128,-54},{32,-54},{20,-54},{12,-60},{-132,-60},{-132,-46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-112,16},{152,4}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{24,68},{22,-54}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{94,68},{100,-54}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Rectangle(
                  extent={{110,68},{116,-54}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Rectangle(
                  extent={{130,62},{134,-50}},
                  lineColor={0,0,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Rectangle(
                  extent={{80,-6},{142,26}},
                  lineColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  fillColor={0,0,255}),
                Text(
                  extent={{-200,150},{200,102}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name")}),
            Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Waterjet outputs directional force based on input shaft power and steeing/reverse signal</li>
<li>user must defin (by 0 or 1 input) if waterjet steers to port sode only, starboard side only or both.</li>
<li>user must define max steering input angle. A steering signal input of 1 will steer to that maximum angle.</li>
<li>if a reverse signal is recived, a thrust reduction factor will be applied to the forward thrust ans the direction will be reversed</li>
</ul></p>
</html>"));
        end Waterjet;

        model Waterjet_base_thrust_control
          "water jet model with world force purpolsion. thrust request form driver"
          extends
            Modelica.Mechanics.Rotational.Interfaces.PartialOneFlangeAndSupport;

        //parameters from instance sheet
         parameter SI.MomentOfInertia MOI_rotation = 1.22
            "rotational moment of inertia";
         parameter SI.Force max_thrust_forward_max_knots = 1000
            "max thrust whilst vehicle is moving";
         parameter SI.Force max_thrust_forward_zero_knots = 2000
            "max thrust whilst vehicle is stationary";
         parameter SI.Power max_power = 100000 "max operating power";
         //parameter SI.AngularVelocity max_speed = 800 "max operating speed";
         parameter SI.Torque max_torque = 1000 "max operating torque";
         parameter Real reverse_thrust_factor = 0.43
            "Percentage of forward thrust when in reverse";
         parameter Integer steer_port_only = 0
            "Waterjet steers to port side only";
         parameter Integer steer_starboard_only = 0
            "Waterjet steers to starboard side only";
         parameter Integer steer_port_and_starboard = 1
            "Waterjet can steer to port or starboard side";
         parameter Real max_steer_angle = 45
            "Maximum steer angle for waterjet [deg]";
         parameter SI.Length unit_length = 1
            "length parameter needed for torque reaction calc";

        //calculation variables
          SI.Power input_power "input power to waterjet";
          SI.Force max_thrust "maximum thrustage moving/stationary";
          SI.Force thrust "thrust";
          Real steer_angle "steering input angle. 1 to port, -1 to starboard";

          Modelica.Blocks.Interfaces.RealOutput thrust_out
            annotation (Placement(transformation(extent={{-104,-10},{-84,10}})));
          Modelica.Mechanics.Rotational.Components.Inertia waterjet_inertia(J=
                MOI_rotation)
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          Modelica.Mechanics.Rotational.Components.Clutch clutch_Simple_Friction(fn_max=
                max_torque/unit_length, stateSelect=StateSelect.avoid)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Modelica.Blocks.Interfaces.RealInput thrust_demand annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,108})));
          Modelica.Blocks.Interfaces.RealInput steer_command annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={42,108})));
          Modelica.Blocks.Interfaces.RealInput reverse_command
                                                             annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,108})));
          Modelica.Blocks.Interfaces.RealInput vehicle_speed annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-80,108})));
        equation
        //Input torque to thrust
          input_power = abs(waterjet_inertia.flange_a.tau*der(waterjet_inertia.flange_a.phi));
          if abs(vehicle_speed) > 0 then
            max_thrust = max_thrust_forward_max_knots;
          else
             max_thrust = max_thrust_forward_zero_knots;
          end if;
          if input_power > max_power then
            thrust = max_thrust;
          else
            thrust = (input_power/max_power)*max_thrust;
          end if;

        //steering thrust
          if steer_port_and_starboard > 0 then
            steer_angle = steer_command*max_steer_angle;
          elseif steer_port_only > 0 then
            if steer_command > 0 then
              steer_angle = steer_command*max_steer_angle;
            else
              steer_angle = 0;
            end if;
          elseif steer_starboard_only > 0 then
            if steer_command < 0 then
              steer_angle = steer_command*max_steer_angle;
            else
              steer_angle = 0;
            end if;
          end if;

        //thrust out forward and reverse
          if reverse_command > 0 then
            thrust_out = reverse_thrust_factor*thrust;
          else
            thrust_out = -thrust;
          end if;
          connect(clutch_Simple_Friction.flange_b, waterjet_inertia.flange_a)
                                                             annotation (Line(
              points={{10,0},{40,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(waterjet_inertia.flange_b, flange) annotation (Line(
              points={{60,0},{100,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(clutch_Simple_Friction.f_normalized, thrust_demand)
                                                     annotation (Line(
              points={{0,11},{0,108}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(clutch_Simple_Friction.flange_a, internalSupport) annotation (Line(
              points={{-10,0},{-26,0},{-26,-68},{0,-68},{0,-80}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                    {100,100}}),
                              graphics), Icon(coordinateSystem(extent={{-100,-100},{100,
                    100}}, preserveAspectRatio=true),
                                              graphics={Text(
                  extent={{-90,80},{90,40}},
                  lineColor={0,0,255},
                  textString="%name"),
                Polygon(
                  points={{74,10},{-32,10},{-32,31},{-76,0},{-32,-31},{-32,-10},{74,-10},
                      {74,10}},
                  lineColor={0,0,0},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.CrossDiag),
                Line(points={{-58,-72},{-42,-58},{-20,-46},{0,-44},{18,-46},{34,-52},{
                      44,-62},{54,-72},{60,-84}},  color={0,0,0}),
                Polygon(
                  points={{-65,-88},{-46,-70},{-58,-62},{-65,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}));
        end Waterjet_base_thrust_control;

        package Tests
            extends Modelica.Icons.Package;

          model Test_container_waterjet
            extends MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Mechanics.Rotational.Sources.ConstantTorque constantTorque(
                tau_constant=100)
              annotation (Placement(transformation(extent={{-72,0},{-52,20}})));
            Waterjet waterjet
              annotation (Placement(transformation(extent={{-4,-40},{36,20}})));
            Test_Driver test_Driver
              annotation (Placement(transformation(extent={{-20,60},{0,80}})));
          equation

            connect(waterjet.flange_a, constantTorque.flange) annotation (Line(
                points={{-4,-8},{-28,-8},{-28,10},{-52,10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver.thrust_demand_out, waterjet.thrust_demand)
              annotation (Line(
                points={{0.6,74},{24.8,74},{24.8,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.reverse_command_out, waterjet.reverse_command)
              annotation (Line(
                points={{0.6,78},{20.4,78},{20.4,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.steer_command_out, waterjet.steer_command)
              annotation (Line(
                points={{0.6,70},{28.6,70},{28.6,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.vehicle_speed_out, waterjet.vehicle_speed)
              annotation (Line(
                points={{0.6,66},{16.4,66},{16.4,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=30, Interval=0.01),
              __Dymola_experimentSetupOutput);
          end Test_container_waterjet;

          model Test_Aquatic_Vehicle_2D
            extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
            Waterjet
              waterjet_starboard(
              steer_port_and_starboard=0,
              steer_starboard_only=1,
              max_thrust_forward_max_knots=4500,
              max_thrust_forward_zero_knots=5000)                   annotation (Placement(
                  transformation(
                  extent={{20,-30},{-20,30}},
                  rotation=180,
                  origin={62,-62})));
            Waterjet
              waterjet_port(
              steer_port_and_starboard=0,
              steer_port_only=1,
              max_thrust_forward_max_knots=4500,
              max_thrust_forward_zero_knots=5000)              annotation (Placement(
                  transformation(
                  extent={{20,30},{-20,-30}},
                  rotation=180,
                  origin={62,22})));
            Modelica.Mechanics.Rotational.Sources.Speed input_port
              annotation (Placement(transformation(extent={{-40,10},{-20,30}})));
            Modelica.Mechanics.Rotational.Sources.Speed input_starboard
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
            Modelica.Blocks.Sources.Constant const(k=250)
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
            Test_Driver
              test_Driver
              annotation (Placement(transformation(rotation=0, extent={{0,70},{20,90}})));
          equation
            connect(const.y, input_port.w_ref) annotation (Line(
                points={{-59,-20},{-52,-20},{-52,20},{-42,20}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(const.y, input_starboard.w_ref) annotation (Line(
                points={{-59,-20},{-52,-20},{-52,-60},{-42,-60}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(waterjet_starboard.flange_a, input_starboard.flange) annotation (Line(
                points={{42,-60},{-20,-60}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(waterjet_port.flange_a, input_port.flange) annotation (Line(
                points={{42,20},{-20,20}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver.thrust_demand_out, waterjet_port.thrust_demand)
              annotation (Line(
                points={{20.6,84},{70.8,84},{70.8,48.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.thrust_demand_out, waterjet_starboard.thrust_demand)
              annotation (Line(
                points={{20.6,84},{88,84},{88,-96},{70.8,-96},{70.8,-88.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.vehicle_speed_out, waterjet_port.vehicle_speed)
              annotation (Line(
                points={{20.6,76},{62.4,76},{62.4,48.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.vehicle_speed_out, waterjet_starboard.vehicle_speed)
              annotation (Line(
                points={{20.6,76},{52,76},{52,-88.8},{62.4,-88.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.steer_command_out, waterjet_port.steer_command)
              annotation (Line(
                points={{20.6,80},{74.6,80},{74.6,48.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.steer_command_out, waterjet_starboard.steer_command)
              annotation (Line(
                points={{20.6,80},{86,80},{86,-88.8},{74.6,-88.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.reverse_command_out, waterjet_port.reverse_command)
              annotation (Line(
                points={{20.6,88},{66.4,88},{66.4,48.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.reverse_command_out, waterjet_starboard.reverse_command)
              annotation (Line(
                points={{20.6,88},{48,88},{48,-96},{66.4,-96},{66.4,-88.8}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=60, Interval=0.01),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Watejet_2D_test.mos" "Watejet_2D_test"));
          end Test_Aquatic_Vehicle_2D;

          model Test_Bench_Waterjet
            extends MSL_Extend.Icons.Simple_Test_Case;
            Modelica.Mechanics.Rotational.Sources.ConstantSpeed constantSpeed(w_fixed=500)
              annotation (Placement(transformation(extent={{-72,0},{-52,20}})));
            Waterjet                                                   waterjet
              annotation (Placement(transformation(extent={{-4,-40},{36,20}})));
            Test_Driver test_Driver
              annotation (Placement(transformation(extent={{-20,60},{0,80}})));
          equation

            connect(waterjet.flange_a, constantSpeed.flange) annotation (Line(
                points={{-4,-8},{-28,-8},{-28,10},{-52,10}},
                color={0,0,0},
                smooth=Smooth.None));
            connect(test_Driver.thrust_demand_out, waterjet.thrust_demand)
              annotation (Line(
                points={{0.6,74},{24.8,74},{24.8,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.steer_command_out, waterjet.steer_command)
              annotation (Line(
                points={{0.6,70},{28.6,70},{28.6,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.vehicle_speed_out, waterjet.vehicle_speed)
              annotation (Line(
                points={{0.6,66},{16.4,66},{16.4,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(test_Driver.reverse_command_out, waterjet.reverse_command)
              annotation (Line(
                points={{0.6,78},{20.4,78},{20.4,20.8}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics),
              experiment(StopTime=30, Interval=0.01),
              __Dymola_experimentSetupOutput,
              Commands(file="Scripts/Waterjet_Instance_Test.mos"
                  "Waterjet_Instance_Test"));
          end Test_Bench_Waterjet;

          model Test_Driver
            extends C2M2L_OM.MSL_Extend.Icons.Test_Driver;

            Modelica.Blocks.Sources.Ramp vehicle_speed(
              height=10,
              duration=3,
              startTime=0.25)
              annotation (Placement(transformation(extent={{-100,70},{-80,90}})));
            Modelica.Blocks.Sources.TimeTable steer_command(startTime=0, table=[0,0])
              annotation (Placement(transformation(extent={{-72,70},{-52,90}})));
            Modelica.Blocks.Sources.Ramp reverse_command(
              duration=1,
              height=1,
              startTime=3500)
              annotation (Placement(transformation(extent={{-16,70},{4,90}})));
            Modelica.Blocks.Sources.Ramp thrust_demand(duration=2, height=0.5)
              annotation (Placement(transformation(extent={{-44,70},{-24,90}})));
            Modelica.Blocks.Interfaces.RealOutput reverse_command_out
              annotation (Placement(transformation(extent={{96,70},{116,90}})));
            Modelica.Blocks.Interfaces.RealOutput thrust_demand_out
              annotation (Placement(transformation(extent={{96,30},{116,50}})));
            Modelica.Blocks.Interfaces.RealOutput steer_command_out
              annotation (Placement(transformation(extent={{96,-10},{116,10}})));
            Modelica.Blocks.Interfaces.RealOutput vehicle_speed_out
              annotation (Placement(transformation(extent={{96,-50},{116,-30}})));
          equation
            connect(reverse_command.y, reverse_command_out) annotation (Line(
                points={{5,80},{106,80}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(thrust_demand.y, thrust_demand_out) annotation (Line(
                points={{-23,80},{-20,80},{-20,40},{106,40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(steer_command.y, steer_command_out) annotation (Line(
                points={{-51,80},{-46,80},{-46,0},{106,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(vehicle_speed.y, vehicle_speed_out) annotation (Line(
                points={{-79,80},{-72,80},{-72,-40},{106,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics));
          end Test_Driver;
        end Tests;
      end Waterjet;
    end Amphibious;

    package Hydraulic
      extends Modelica.Icons.Package;

      package Interfaces
        extends Modelica.Icons.Package;

        partial model Hydraulic_Manifold_P_T_A_B
          "Base class for manifolds with a Pressure, Tank, A and B connectors"

          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port P
            annotation (Placement(transformation(extent={{-220,110},{-200,130}}),
                iconTransformation(extent={{-220,110},{-200,130}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A
            annotation (Placement(transformation(extent={{200,110},{220,130}}),
                iconTransformation(extent={{200,110},{220,130}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B
            annotation (Placement(transformation(extent={{200,-130},{220,-110}}),
                iconTransformation(extent={{200,-130},{220,-110}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port T
            annotation (Placement(transformation(extent={{-220,-130},{-200,-110}}),
                iconTransformation(extent={{-220,-130},{-200,-110}})));

          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                    -320},{200,280}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}), graphics={
                Text(
                  extent={{-260,180},{-200,120}},
                  lineColor={0,0,0},
                  textString="P"),
                Text(
                  extent={{-260,-120},{-200,-180}},
                  lineColor={0,0,0},
                  textString="T"),
                Text(
                  extent={{200,180},{260,120}},
                  lineColor={0,0,0},
                  textString="A"),
                Text(
                  extent={{200,-120},{260,-180}},
                  lineColor={0,0,0},
                  textString="B")}));
        end Hydraulic_Manifold_P_T_A_B;

        partial model Hydraulic_P_T_5A_5B
          "Base class for manifolds with a Pressure, Tank, 5*A and 5*B connectors.  The A and B connectors can be disabled with parameter settings."

          parameter Integer num_valves(min=1, max=5) = 5
            "Number of A and B ports to use";

          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_5 if num_valves > 4
            annotation (Placement(transformation(extent={{-220,210},{-200,230}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_5 if num_valves > 4
            annotation (Placement(transformation(extent={{200,210},{220,230}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port T
            annotation (Placement(transformation(extent={{200,-290},{220,-270}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port P
            annotation (Placement(transformation(extent={{-220,-290},{-200,-270}})));

          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_4 if num_valves > 3
            annotation (Placement(transformation(extent={{-220,110},{-200,130}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_3 if num_valves > 2
            annotation (Placement(transformation(extent={{-220,10},{-200,30}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_2 if num_valves > 1
            annotation (Placement(transformation(extent={{-220,-90},{-200,-70}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_1
            annotation (Placement(transformation(extent={{-220,-190},{-200,-170}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_4 if num_valves > 3
            annotation (Placement(transformation(extent={{200,110},{220,130}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_3 if num_valves > 2
            annotation (Placement(transformation(extent={{200,10},{220,30}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_2 if num_valves > 1
            annotation (Placement(transformation(extent={{198,-90},{218,-70}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_1
            annotation (Placement(transformation(extent={{198,-190},{218,-170}})));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-320},
                    {200,280}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-320},{200,280}}), graphics={
                Text(
                  extent={{-318,208},{-238,128}},
                  lineColor={0,0,0},
                  textString="A"),
                Text(
                  extent={{-270,-284},{-190,-364}},
                  lineColor={0,0,0},
                  textString="P"),
                Text(
                  extent={{236,210},{316,130}},
                  lineColor={0,0,0},
                  textString="B"),
                Text(
                  extent={{188,-284},{268,-364}},
                  lineColor={0,0,0},
                  textString="T"),
                Line(
                  points={{-220,260},{-240,260},{-240,-222},{-220,-222}},
                  color={128,128,128},
                  smooth=Smooth.None),
                Line(
                  points={{220,260},{240,260},{240,-220},{220,-220}},
                  color={128,128,128},
                  smooth=Smooth.None)}));
        end Hydraulic_P_T_5A_5B;

        partial model Base

          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                hyd_in
            "Port that nominally flows hydraulic fluid in"
            annotation (Placement(transformation(extent={{-210,70},{-190,90}})));
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                hyd_out
            "Port that nominally flows hydraulic fluid out"
            annotation (Placement(transformation(extent={{190,70},{210,90}})));
        end Base;

        partial model BaseWithSupport
          extends
            C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.Base;
          parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          Modelica.Mechanics.Rotational.Interfaces.Support support if useSupport
            "Support/housing of component"
            annotation (Placement(transformation(extent={{-10,-170},{10,-150}})));
        protected
          Modelica.Mechanics.Rotational.Interfaces.Support internalSupport
            "Internal support/housing of component (either connected to support, if useSupport=true, or connected to fixed, if useSupport=false)"
            annotation (Placement(transformation(extent={{-3,-143},{3,-137}})));
          Modelica.Mechanics.Rotational.Components.Fixed fixed if not useSupport
            "Fixed support/housing, if not useSupport"
            annotation (Placement(transformation(extent={{10,-157},{30,-137}})));
        equation
          connect(support, internalSupport) annotation (Line(
              points={{0,-160},{0,-155},{4.4409e-016,-155},{4.4409e-016,-150},{0,-150},
                  {0,-140}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(internalSupport, fixed.flange) annotation (Line(
              points={{0,-140},{20,-140},{20,-147}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics));
        end BaseWithSupport;
      end Interfaces;

      package Manifold_Open_Center
        "Contains manifold that have an open center position"
      extends Modelica.Icons.Package;
        package Tests
        extends MSL_Extend.Icons.Package_For_Simple_Test_Cases;
          model Test_Hydraulic_Manifold_Open_Center_5
            "Observe that only the lowest number ram will actuate if multiple are commanded"
          extends C2M2L_Ext.Icons.Simple_Test_Case;
            Hydraulic_Manifold_Open_Center_5 hydraulic_manifold(p_max=
                  10000000)
              annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
            Modelica.Mechanics.Translational.Components.Mass mass(
              L=0.01,
              m=100)
              annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
                P_constant=200000)
              annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                  rotation=90,
                  origin={-40.5,-10})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
                P_constant=100000)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-10,-10})));
            Modelica.Mechanics.Translational.Components.Mass mass1(
              L=0.01, m=200)
              annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
            Modelica.Mechanics.Translational.Components.Mass mass2(
              L=0.01, m=300)
              annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
            Modelica.Mechanics.Translational.Components.Mass mass3(
              L=0.01, m=400)
              annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational3(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
            Modelica.Mechanics.Translational.Components.Mass mass4(
              L=0.01, m=500)
              annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational4(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
            Modelica.Blocks.Sources.Trapezoid trapezoid[5](
              period={60,80,100,120,140},
              amplitude={1,1,1,1,1},
              rising={2,2,2,2,2},
              falling={2,2,2,2,2},
              width={20,20,20,20,20})
              annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
          equation

            connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
              annotation (Line(
                points={{-30,-170},{60,-170}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
              annotation (Line(
                points={{-30,-140},{60,-140}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
              annotation (Line(
                points={{-30,-110},{60,-110}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational3.flange, mass3.flange_a)
              annotation (Line(
                points={{-30,-80},{60,-80}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational4.flange, mass4.flange_a)
              annotation (Line(
                points={{-30,-50},{60,-50}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
              annotation (Line(
                points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
              annotation (Line(
                points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
                points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
                points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
                points={{-49.15,55.6667},{-80,55.6667},{-80,-120},{-40,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
                points={{-0.85,55.6667},{28,55.6667},{28,-120},{-20,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_4,
              hydraulic_Mechanical_Conversion_Translational3.hyd_a) annotation (Line(
                points={{-49.15,67.3333},{-70,67.3333},{-70,-90},{-40,-90}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_4,
              hydraulic_Mechanical_Conversion_Translational3.hyd_b) annotation (Line(
                points={{-0.85,67.3333},{20,67.3333},{20,-90},{-20,-90}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_5,
              hydraulic_Mechanical_Conversion_Translational4.hyd_a) annotation (Line(
                points={{-49.15,79},{-60,79},{-60,-60},{-40,-60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_5,
              hydraulic_Mechanical_Conversion_Translational4.hyd_b) annotation (Line(
                points={{-0.85,79},{10,79},{10,-60},{-20,-60}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
                Line(
                points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
                Line(
                points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
                points={{-79,130},{-43.4,130},{-43.4,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
                points={{-79,130},{-34.2,130},{-34.2,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
                points={{-79,130},{-25,130},{-25,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
                points={{-79,130},{-15.8,130},{-15.8,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
                points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                    preserveAspectRatio=false),
                                graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                      160}}),                   graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Hydraulic_Manifold_Open_Center_5;

          model Test_Hydraulic_Manifold_Open_Center_4
            "Observe that only the lowest number ram will actuate if multiple are commanded"
          extends C2M2L_Ext.Icons.Simple_Test_Case;
             Hydraulic_Manifold_Open_Center_4 hydraulic_manifold(p_max=
                  10000000)
              annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
            Modelica.Mechanics.Translational.Components.Mass mass(
              L=0.01,
              m=100)
              annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
                P_constant=200000)
              annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                  rotation=90,
                  origin={-40.5,-10})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
                P_constant=100000)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-10,-10})));
            Modelica.Mechanics.Translational.Components.Mass mass1(
              L=0.01, m=200)
              annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
            Modelica.Mechanics.Translational.Components.Mass mass2(
              L=0.01, m=300)
              annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
            Modelica.Mechanics.Translational.Components.Mass mass3(
              L=0.01, m=400)
              annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational3(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
            Modelica.Blocks.Sources.Trapezoid trapezoid[5](
              period={60,80,100,120,140},
              amplitude={1,1,1,1,1},
              rising={2,2,2,2,2},
              falling={2,2,2,2,2},
              width={20,20,20,20,20})
              annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
          equation

            connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
              annotation (Line(
                points={{-30,-170},{60,-170}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
              annotation (Line(
                points={{-30,-140},{60,-140}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
              annotation (Line(
                points={{-30,-110},{60,-110}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational3.flange, mass3.flange_a)
              annotation (Line(
                points={{-30,-80},{60,-80}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
              annotation (Line(
                points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
              annotation (Line(
                points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
                points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
                points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
                points={{-49.15,55.6667},{-80,55.6667},{-80,-120},{-40,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
                points={{-0.85,55.6667},{28,55.6667},{28,-120},{-20,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_4,
              hydraulic_Mechanical_Conversion_Translational3.hyd_a) annotation (Line(
                points={{-49.15,67.3333},{-70,67.3333},{-70,-90},{-40,-90}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_4,
              hydraulic_Mechanical_Conversion_Translational3.hyd_b) annotation (Line(
                points={{-0.85,67.3333},{20,67.3333},{20,-90},{-20,-90}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
                Line(
                points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
                Line(
                points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
                points={{-79,130},{-43.4,130},{-43.4,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
                points={{-79,130},{-34.2,130},{-34.2,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
                points={{-79,130},{-25,130},{-25,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
                points={{-79,130},{-15.8,130},{-15.8,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
                points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                    preserveAspectRatio=true),
                                graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                      160}}),                   graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Hydraulic_Manifold_Open_Center_4;

          model Test_Hydraulic_Manifold_Open_Center_3
            "Observe that only the lowest number ram will actuate if multiple are commanded"
          extends C2M2L_Ext.Icons.Simple_Test_Case;
            Hydraulic_Manifold_Open_Center_3 hydraulic_manifold(p_max=
                  10000000)
              annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
            Modelica.Mechanics.Translational.Components.Mass mass(
              L=0.01,
              m=100)
              annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
                P_constant=200000)
              annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                  rotation=90,
                  origin={-40.5,-10})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
                P_constant=100000)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-10,-10})));
            Modelica.Mechanics.Translational.Components.Mass mass1(
              L=0.01, m=200)
              annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
            Modelica.Mechanics.Translational.Components.Mass mass2(
              L=0.01, m=300)
              annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
            Modelica.Blocks.Sources.Trapezoid trapezoid[5](
              period={60,80,100,120,140},
              amplitude={1,1,1,1,1},
              rising={2,2,2,2,2},
              falling={2,2,2,2,2},
              width={20,20,20,20,20})
              annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
          equation

            connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
              annotation (Line(
                points={{-30,-170},{60,-170}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
              annotation (Line(
                points={{-30,-140},{60,-140}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
              annotation (Line(
                points={{-30,-110},{60,-110}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
              annotation (Line(
                points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
              annotation (Line(
                points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
                points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
                points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
                points={{-49.15,55.6667},{-80,55.6667},{-80,-120},{-40,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_3,
              hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
                points={{-0.85,55.6667},{28,55.6667},{28,-120},{-20,-120}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
                Line(
                points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
                Line(
                points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
                points={{-79,130},{-43.4,130},{-43.4,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
                points={{-79,130},{-34.2,130},{-34.2,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
                points={{-79,130},{-25,130},{-25,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
                points={{-79,130},{-15.8,130},{-15.8,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
                points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                    preserveAspectRatio=true),
                                graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                      160}}),                   graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Hydraulic_Manifold_Open_Center_3;

          model Test_Hydraulic_Manifold_Open_Center_2
            "Observe that only the lowest number ram will actuate if multiple are commanded"
          extends C2M2L_Ext.Icons.Simple_Test_Case;
            Hydraulic_Manifold_Open_Center_2 hydraulic_manifold(p_max=
                  10000000)
              annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
            Modelica.Mechanics.Translational.Components.Mass mass(
              L=0.01,
              m=100)
              annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
                P_constant=200000)
              annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                  rotation=90,
                  origin={-40.5,-10})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
                P_constant=100000)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-10,-10})));
            Modelica.Mechanics.Translational.Components.Mass mass1(
              L=0.01, m=200)
              annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
            Modelica.Blocks.Sources.Trapezoid trapezoid[5](
              period={60,80,100,120,140},
              amplitude={1,1,1,1,1},
              rising={2,2,2,2,2},
              falling={2,2,2,2,2},
              width={20,20,20,20,20})
              annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
          equation

            connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
              annotation (Line(
                points={{-30,-170},{60,-170}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
              annotation (Line(
                points={{-30,-140},{60,-140}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
              annotation (Line(
                points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
              annotation (Line(
                points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
                points={{-49.15,44},{-90,44},{-90,-150},{-40,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_2,
              hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
                points={{-1.08,44},{40,44},{40,-150},{-20,-150}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
                Line(
                points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
                Line(
                points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
                points={{-79,130},{-43.4,130},{-43.4,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
                points={{-79,130},{-34.2,130},{-34.2,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
                points={{-79,130},{-25,130},{-25,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
                points={{-79,130},{-15.8,130},{-15.8,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
                points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                    preserveAspectRatio=true),
                                graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                      160}}),                   graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Hydraulic_Manifold_Open_Center_2;

          model Test_Hydraulic_Manifold_Open_Center_1
            "Observe that only the lowest number ram will actuate if multiple are commanded"
          extends C2M2L_Ext.Icons.Simple_Test_Case;
            Hydraulic_Manifold_Open_Center_1 hydraulic_manifold(p_max=
                  10000000)
              annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
            Modelica.Mechanics.Translational.Components.Mass mass(
              L=0.01,
              m=100)
              annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Mechanical.Hydraulic_Mechanical_Conversion_Translational
              hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
              annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source2(
                P_constant=200000)
              annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                  rotation=90,
                  origin={-40.5,-10})));
            C2M2L_Ext.Fluid.Hydraulics_Simple.Sources.Pressure_Source pressure_Source3(
                P_constant=100000)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-10,-10})));
            Modelica.Blocks.Sources.Trapezoid trapezoid[5](
              period={60,80,100,120,140},
              amplitude={1,1,1,1,1},
              rising={2,2,2,2,2},
              falling={2,2,2,2,2},
              width={20,20,20,20,20})
              annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
          equation

            connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
              annotation (Line(
                points={{-30,-170},{60,-170}},
                color={0,127,0},
                smooth=Smooth.None));
            connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
              annotation (Line(
                points={{-49.15,32.3333},{-100,32.3333},{-100,-180},{-40,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
              annotation (Line(
                points={{-1.08,32.3333},{50,32.3333},{50,-180},{-20,-180}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
                Line(
                points={{-40.5,0},{-40.5,32},{-49.15,32},{-49.15,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
                Line(
                points={{-10,0},{-10,34},{-0.85,34},{-0.85,20.6667}},
                color={255,0,128},
                smooth=Smooth.None));
            connect(trapezoid[1].y, hydraulic_manifold.u_1) annotation (Line(
                points={{-79,130},{-43.4,130},{-43.4,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[2].y, hydraulic_manifold.u_2) annotation (Line(
                points={{-79,130},{-34.2,130},{-34.2,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[3].y, hydraulic_manifold.u_3) annotation (Line(
                points={{-79,130},{-25,130},{-25,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[4].y, hydraulic_manifold.u_4) annotation (Line(
                points={{-79,130},{-15.8,130},{-15.8,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(trapezoid[5].y, hydraulic_manifold.u_5) annotation (Line(
                points={{-79,130},{-6,130},{-6,88.3333},{-6.6,88.3333}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(extent={{-120,-200},{100,160}},
                    preserveAspectRatio=true),
                                graphics), Icon(coordinateSystem(extent={{-120,-200},{100,
                      160}}),                   graphics),
              experiment(StopTime=500),
              __Dymola_experimentSetupOutput);
          end Test_Hydraulic_Manifold_Open_Center_1;
        end Tests;

        model Hydraulic_Manifold_Open_Center_5
          "Manifold with open center and 5 valves"
          extends
            C2M2L_Component_Building_Blocks.Hydraulics.Hydraulic_Manifold_Open_Center(final num_valves=5);

        end Hydraulic_Manifold_Open_Center_5;

        model Hydraulic_Manifold_Open_Center_4
          "Manifold with open center and 4 valves"
          extends
            C2M2L_Component_Building_Blocks.Hydraulics.Hydraulic_Manifold_Open_Center(final num_valves=4);

        end Hydraulic_Manifold_Open_Center_4;

        model Hydraulic_Manifold_Open_Center_3
          "Manifold with open center and 3 valves"
          extends
            C2M2L_Component_Building_Blocks.Hydraulics.Hydraulic_Manifold_Open_Center(final num_valves=3);

        end Hydraulic_Manifold_Open_Center_3;

        model Hydraulic_Manifold_Open_Center_2
          "Manifold with open center and 2 valves"
          extends
            C2M2L_Component_Building_Blocks.Hydraulics.Hydraulic_Manifold_Open_Center(final num_valves=2);

        end Hydraulic_Manifold_Open_Center_2;

        model Hydraulic_Manifold_Open_Center_1
          "Manifold with open center and 1 valves"
          extends
            C2M2L_Component_Building_Blocks.Hydraulics.Hydraulic_Manifold_Open_Center(final num_valves=1);

        end Hydraulic_Manifold_Open_Center_1;
      end Manifold_Open_Center;

      model Pump_Hydraulic "Standalone hydraulic pump"
        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.BaseWithSupport;
        MSL_Extend.Hydraulics_Simple.Components.Pumps.Hydraulic_Mechanical_Conversion_Lossy
          hydraulic_Mechanical_Conversion_Lossy(use_environment_heat_port=true,
            useSupport=true,
          vol_per_radian=vol_per_radian,
          Nm_per_pascal=vol_per_radian,
          lossTable=[0,fixed_efficiency,fixed_efficiency,0,0],
          useInertia=true,
          J=J,
          leakage=1e-6)      annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={0,80})));
        parameter SI.Inertia J=0.001 "Rotational moment of inertia";
        parameter Real cc_per_rev = 10;
        parameter Real fixed_efficiency = 0.7;

      protected
        parameter SI.Volume vol_per_radian=(cc_per_rev / 1e6) / 2 * pi;

      public
        Modelica.Mechanics.Rotational.Interfaces.Flange_a brg_01
          annotation (Placement(transformation(extent={{-210,-10},{-190,10}})));
        MSL_Extend.Hydraulics_Simple.Components.Valves.Pressure_Relief_Valve
          pressure_Relief_Valve1(
          p_error_frac=0.1,
          k_on=0.00001,
          min_opening=0.001,
          p_max=200000000)                     annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=0,
              origin={110,74})));
      equation

        connect(brg_01, hydraulic_Mechanical_Conversion_Lossy.flange) annotation (
            Line(
            points={{-200,0},{-76,0},{-76,148},{0,148},{0,90}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Lossy.hyd_b, hyd_in)
          annotation (Line(
            points={{-10,80},{-200,80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hydraulic_Mechanical_Conversion_Lossy.support, internalSupport)
          annotation (Line(
            points={{-1.33227e-015,70},{0,70},{0,-140}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(hyd_out, pressure_Relief_Valve1.P) annotation (Line(
            points={{200,80},{120,80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve1.A, hydraulic_Mechanical_Conversion_Lossy.hyd_a)
          annotation (Line(
            points={{100,80},{10,80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(pressure_Relief_Valve1.T, hydraulic_Mechanical_Conversion_Lossy.hyd_b)
          annotation (Line(
            points={{110,64.1},{110,34},{-24,34},{-24,80},{-10,80}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                  {200,280}}),       graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-320},{200,280}}), graphics={
              Rectangle(
                extent={{-40,11},{40,-11}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={95,95,95},
                origin={-1,72},
                rotation=90),
              Ellipse(
                extent={{-62,166},{58,46}},
                lineColor={255,0,128},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(
                points={{70,106},{108,106},{108,80},{200,80}},
                color={255,0,128},
                smooth=Smooth.None),
              Polygon(
                points={{-20,20},{-20,-20},{20,0},{-20,20}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-56,106},
                rotation=180),
              Polygon(
                points={{30,126},{30,86},{70,106},{30,126}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-188,0},{0,0},{0,36}},
                color={95,95,95},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{-70,106},{-108,106},{-108,80},{-200,80}},
                color={255,0,128},
                smooth=Smooth.None)}));
      end Pump_Hydraulic;

      model Hydraulic_Line "LAMINAR flow loss in a pipe"
        extends
          C2M2L_OM.MSL_Extend.Hydraulics_Simple.Components.Templates.Partial_Two_Port_Transport;

        parameter SI.Diameter diameter=0.01 "Circular hose diameter";
        parameter SI.Length length=1 "Length of hose";
        parameter SI.DynamicViscosity visc=1e-5;
        Real vel;
      protected
        parameter SI.Area flow_area=pi*diameter^2/4;
      equation
        vel = V/flow_area;
        dP = 64/(diameter/visc)*length/diameter*vel/2;
        annotation (Diagram(coordinateSystem(extent={{-100,-60},{100,60}},
                preserveAspectRatio=true), graphics), Icon(coordinateSystem(extent={{-100,
                  -60},{100,60}}, preserveAspectRatio=true), graphics={
              Ellipse(
                extent={{40,40},{100,-20}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={255,170,213}),
              Polygon(
                points={{-70,20},{-20,20},{20,40},{70,40},{70,40},{70,-20},{70,-20},{20,
                    -20},{-20,-40},{-70,-40},{-70,-40},{-70,20},{-70,20}},
                smooth=Smooth.Bezier,
                fillColor={255,170,213},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-70,20},{-20,20},{20,40},{70,40}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(
                points={{-70,-40},{-20,-40},{20,-20},{70,-20}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Ellipse(
                extent={{-100,20},{-40,-40}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}));
      end Hydraulic_Line;

      model Hydraulic_Accumulator
        "Increases in pressure as more fluid is forced in"

        MSL_Extend.Hydraulics_Simple.Components.Volumes.Hydraulic_Accumulator
          hydraulic_Accumulator(
          total_volume=total_volume,
          empty_pressure=empty_pressure,
          hydraulic_fluid_accumulated_start=hydraulic_fluid_accumulated_start)
          annotation (Placement(transformation(extent={{-38,-18},{36,66}})));
        parameter SI.Volume total_volume=10 "total volume of the accumulator";
        parameter SI.Pressure empty_pressure=20e5
          "fluid pressure when accumulator is empty";
        parameter SI.Volume hydraulic_fluid_accumulated_start = total_volume/2
          "initial volume of hydraulic fluid in the accumulator";
        MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Linear
                                                       loss_Linear(k=k) annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=-90,
              origin={-6,-100})));
        parameter Real k=1e-9 "Loss factor";
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                          hyd1
          annotation (Placement(transformation(extent={{-88,-230},{-68,-210}})));
      equation
        connect(loss_Linear.hyd_a, hydraulic_Accumulator.hydraulic_Port) annotation (
            Line(
            points={{-6,-90},{-4,-90},{-4,-18},{-1,-18}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hyd1, loss_Linear.hyd_b) annotation (Line(
            points={{-78,-220},{-6,-220},{-6,-110}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                  {200,280}}), graphics), Icon(graphics={
              Rectangle(
                extent={{-58,76},{62,-44}},
                lineColor={0,0,0},
                radius=20,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-58,16},{62,-44}},
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                radius=20),
              Rectangle(
                extent={{-58,16},{62,-24}},
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                radius=0),
              Line(
                points={{-78,-220},{-78,-98},{2,-98},{2,-34}},
                smooth=Smooth.None,
                color={255,0,128}),
              Rectangle(
                extent={{-58,76},{62,-44}},
                lineColor={0,0,0},
                radius=20),
              Line(
                points={{42,36},{42,16}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{36,26},{42,16},{48,26}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-38,36},{-38,16}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-44,26},{-38,16},{-32,26}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{2,36},{2,16}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-4,26},{2,16},{8,26}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-58,16},{62,16}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5)}));
      end Hydraulic_Accumulator;

      model Hydraulic_Attentuator
        "Same as accumulator but with 2 connection ports and internal losses"
        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.Base;

        MSL_Extend.Hydraulics_Simple.Components.Volumes.Hydraulic_Accumulator
          hydraulic_Accumulator(total_volume=total_volume, empty_pressure=
              empty_pressure,
          hydraulic_fluid_accumulated(fixed=true, start=
                hydraulic_fluid_in_attenuator_start))
          annotation (Placement(transformation(extent={{-20,120},{20,160}})));
        parameter SI.Volume total_volume=10 "total volume of the attentuator";
        parameter SI.Pressure empty_pressure=20e5
          "gas pressure when attentuator has no hydraulic fluid";

        parameter Real k=1 "Loss factor";
        parameter SI.Volume hydraulic_fluid_in_attenuator_start
          "initial_hydraulic fluid inside the attentuator";

      equation
        connect(hyd_out, hydraulic_Accumulator.hydraulic_Port) annotation (Line(
            points={{200,80},{0,80},{0,120}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(hyd_in, hydraulic_Accumulator.hydraulic_Port) annotation (Line(
            points={{-200,80},{0,80},{0,120}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-320},
                  {200,280}}),
                         graphics={
              Rectangle(
                extent={{-60,60},{60,0}},
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                radius=20),
              Rectangle(
                extent={{-60,60},{60,20}},
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                radius=0),
              Line(
                points={{0,-20},{0,10}},
                smooth=Smooth.None,
                color={255,0,128}),
              Rectangle(
                extent={{-60,120},{60,0}},
                lineColor={0,0,0},
                radius=20),
              Line(
                points={{40,80},{40,60}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{34,70},{40,60},{46,70}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-40,80},{-40,60}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-46,70},{-40,60},{-34,70}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{0,80},{0,60}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-6,70},{0,60},{6,70}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-60,60},{60,60}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-4,-12},{0,-18},{4,-12}},
                color={255,0,128},
                smooth=Smooth.None),
              Line(
                points={{-4,3},{0,-3},{4,3}},
                color={255,0,128},
                smooth=Smooth.None,
                origin={0,-3},
                rotation=180),
              Line(
                points={{-198,80},{-80,80},{-80,-20},{80,-20},{80,80},{200,80}},
                color={255,0,128},
                smooth=Smooth.None)}),
                                    Diagram(coordinateSystem(preserveAspectRatio=false,
                extent={{-200,-320},{200,280}}), graphics));
      end Hydraulic_Attentuator;

      model Hydraulic_Reservoir "Holds hydraulic fluid"

        MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Linear
                               loss_Linear(k=1e-6)
          annotation (Placement(transformation(extent={{-48,-96},{-28,-76}})));
        parameter SI.Volume total_volume=10 "total volume of reservoir";
        parameter SI.Pressure atmospheric_pressure=1.1e5 "atmospheric pressure";
        parameter SI.Volume hydraulic_fluid_accumulated_start=total_volume/2
          "initial hydraulic fluid volume in reservoir";
        MSL_Extend.Hydraulics_Simple.Components.Volumes.Hydraulic_Reservoir
                                                               hydraulic_Reservoir(
          total_volume=total_volume,
          atmospheric_pressure=atmospheric_pressure,
          hydraulic_fluid_accumulated(fixed=true, start=
                hydraulic_fluid_accumulated_start))
          annotation (Placement(transformation(extent={{-10,-28},{86,66}})));
        C2M2L_OM.MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                          hyd1
          annotation (Placement(transformation(extent={{-88,-230},{-68,-210}})));
      equation
        connect(hyd1, loss_Linear.hyd_a) annotation (Line(
            points={{-78,-220},{-62,-220},{-62,-86},{-48,-86}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(loss_Linear.hyd_b, hydraulic_Reservoir.hydraulic_Port) annotation (
            Line(
            points={{-28,-86},{38,-86},{38,-28.94}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                  {200,280}}), graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-320},{200,280}}), graphics={
              Rectangle(
                extent={{-102,4},{98,-36}},
                lineColor={0,0,0},
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,44},{-102,-36},{98,-36},{98,44}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-2,-36},{-2,-126},{-78,-126},{-78,-218}},
                color={255,0,128},
                smooth=Smooth.None),
              Line(
                points={{-62,24},{-62,4}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-68,14},{-62,4},{-56,14}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-22,24},{-22,4}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{-28,14},{-22,4},{-16,14}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{18,24},{18,4}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{12,14},{18,4},{24,14}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{58,24},{58,4}},
                color={95,95,95},
                smooth=Smooth.None),
              Line(
                points={{52,14},{58,4},{64,14}},
                color={95,95,95},
                smooth=Smooth.None)}));
      end Hydraulic_Reservoir;

      model Hydraulic_Filter "Modelled as a simple linear restriction to flow"

        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Hydraulic.Interfaces.Base;

        MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Linear
                                                       loss_Linear(k=loss_factor)
          annotation (Placement(transformation(extent={{-18,8},{50,64}})));
        parameter Real loss_factor=1 "Loss factor of the filter";
      equation
        connect(hyd_in, loss_Linear.hyd_a) annotation (Line(
            points={{-200,80},{-130,80},{-130,82},{-58,82},{-58,36},{-18,36}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(loss_Linear.hyd_b, hyd_out) annotation (Line(
            points={{50,36},{86,36},{86,20},{200,20},{200,80}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                  -320},{200,280}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-320},{200,280}}), graphics={
              Ellipse(extent={{-162,126},{-82,-74}}, lineColor={0,0,255}),
              Ellipse(extent={{-142,76},{-102,-24}},lineColor={0,0,255}),
              Line(
                points={{-122,126},{98,126}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-118,-74},{102,-74}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-82,26},{138,26}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-90,86},{130,86}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-90,-34},{130,-34}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{100,124},{132,84},{140,24},{132,-36},{100,-76}},
                color={0,0,255},
                smooth=Smooth.Bezier),
              Ellipse(extent={{-154,106},{-90,-54}},
                                                   lineColor={0,0,255}),
              Line(
                points={{-198,26},{-124,26}},
                color={255,0,128},
                smooth=Smooth.Bezier),
              Line(
                points={{142,24},{200,24}},
                color={255,0,128},
                smooth=Smooth.Bezier),
              Polygon(
                points={{-200,-98},{-200,-118},{-134,-118},{-134,-130},{-106,-108},{
                    -134,-86},{-134,-98},{-200,-98}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-198,26},{-198,72}},
                color={255,0,128},
                smooth=Smooth.None),
              Line(
                points={{200,70},{200,24}},
                color={255,0,128},
                smooth=Smooth.None),
              Polygon(
                points={{106,-94},{106,-114},{172,-114},{172,-126},{200,-104},{172,
                    -82},{172,-94},{106,-94}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={255,0,128},
                fillPattern=FillPattern.Solid)}));
      end Hydraulic_Filter;

      model Fitting_Generic "Models a generic fitting"

        MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Quadratic
                                                          loss_Quadratic(final k=k)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        parameter Real loss_coeff = 0.4
          "Minor loss coefficient - see http://www.engineeringtoolbox.com/minor-loss-coefficients-pipes-d_626.html for examples";
        parameter SI.Area flow_area;
      protected
        parameter Real k=flow_area * sqrt(2 / (rho * loss_coeff)) "Loss factor";
        parameter SI.Density rho = 1000 "Fluid density";
      public
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                              hyd_in
          "Port that nominally flows hydraulic fluid in"
          annotation (Placement(transformation(extent={{-210,70},{-190,90}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                              hyd_out
          "Port that nominally flows hydraulic fluid out"
          annotation (Placement(transformation(extent={{190,70},{210,90}})));
      equation
        connect(loss_Quadratic.hyd_a, hyd_in) annotation (Line(
            points={{-10,0},{-102,0},{-102,80},{-200,80}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(loss_Quadratic.hyd_b, hyd_out) annotation (Line(
            points={{10,0},{106,0},{106,80},{200,80}},
            color={255,0,128},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                  -320},{200,280}}),
                            graphics), Icon(graphics={Text(
                extent={{-60,60},{60,-60}},
                lineColor={0,0,0},
                textString="?"), Line(
                points={{-100,0},{102,0}},
                color={255,0,128},
                smooth=Smooth.None)}));
      end Fitting_Generic;

      model Hydraulic_Manifold
        MSL_Extend.Hydraulics_Simple.Components.Valves.Crossover
                                                     crossover(
          k_on=k_on,
          k_off=k_off,
          f_crit=f_crit)    annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-74,10})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port P
                                                 annotation (Placement(transformation(
                extent={{-26,-118},{-6,-98}}), iconTransformation(extent={{-26,-118},
                  {-6,-98}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port T
                                                  annotation (Placement(
              transformation(extent={{30,-118},{50,-98}}), iconTransformation(extent=
                  {{30,-118},{50,-98}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port
                                                          A_1
          annotation (Placement(transformation(extent={{-106,74},{-86,94}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_1
          annotation (Placement(transformation(extent={{86,74},{106,94}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_2
          annotation (Placement(transformation(extent={{-106,34},{-86,54}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_2
          annotation (Placement(transformation(extent={{86,34},{106,54}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_3
          annotation (Placement(transformation(extent={{-106,-6},{-86,14}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_3
          annotation (Placement(transformation(extent={{86,-6},{106,14}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_4
          annotation (Placement(transformation(extent={{-106,-46},{-86,-26}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_4
          annotation (Placement(transformation(extent={{86,-46},{106,-26}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port A_5
          annotation (Placement(transformation(extent={{-106,-86},{-86,-66}})));
        MSL_Extend.Hydraulics_Simple.Interfaces.Hydraulic_Port B_5
          annotation (Placement(transformation(extent={{86,-86},{106,-66}})));
        Modelica.Blocks.Interfaces.IntegerInput u annotation (Placement(
              transformation(
              extent={{-14,-14},{14,14}},
              rotation=-90,
              origin={-60,114})));
        Modelica.Blocks.Interfaces.IntegerInput u1 annotation (Placement(
              transformation(
              extent={{-14,-14},{14,14}},
              rotation=-90,
              origin={-20,114})));
        Modelica.Blocks.Interfaces.IntegerInput u2 annotation (Placement(
              transformation(
              extent={{-14,-14},{14,14}},
              rotation=-90,
              origin={20,114})));
        Modelica.Blocks.Interfaces.IntegerInput u3 annotation (Placement(
              transformation(
              extent={{-14,-14},{14,14}},
              rotation=-90,
              origin={60,114})));
        Modelica.Blocks.Interfaces.IntegerInput u4 annotation (Placement(
              transformation(
              extent={{-14,-14},{14,14}},
              rotation=-90,
              origin={100,114})));
        MSL_Extend.Hydraulics_Simple.Components.Valves.Crossover
                                                     crossover1(
          k_on=k_on,
          k_off=k_off,
          f_crit=f_crit)     annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-34,10})));
        MSL_Extend.Hydraulics_Simple.Components.Valves.Crossover
                                                     crossover2(
          k_on=k_on,
          k_off=k_off,
          f_crit=f_crit)     annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={6,10})));
        MSL_Extend.Hydraulics_Simple.Components.Valves.Crossover
                                                     crossover3(
          k_on=k_on,
          k_off=k_off,
          f_crit=f_crit)     annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={46,10})));
        MSL_Extend.Hydraulics_Simple.Components.Valves.Crossover
                                                     crossover4(
          k_on=k_on,
          k_off=k_off,
          f_crit=f_crit)     annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={86,10})));
        parameter Real k_on=0.0001 "loss factor (>0) when on";
        parameter Real k_off=0.000001 "loss factor (>=0) when off";
        parameter SI.Frequency f_crit=50
          "if exact=false, critical frequency of filter to filter input signal";
      equation
        connect(P, crossover.P)              annotation (Line(
            points={{-16,-108},{-80,-108},{-80,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(P, crossover1.P)              annotation (Line(
            points={{-16,-108},{-16,-48},{-40,-48},{-40,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(P, crossover2.P)              annotation (Line(
            points={{-16,-108},{-8.88178e-016,-108},{-8.88178e-016,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(P, crossover3.P)              annotation (Line(
            points={{-16,-108},{30,-108},{30,-40},{40,-40},{40,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(P, crossover4.P)              annotation (Line(
            points={{-16,-108},{0,-108},{0,-20},{80,-20},{80,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(T, crossover.T)               annotation (Line(
            points={{40,-108},{40,-80},{-67.9,-80},{-67.9,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(T, crossover1.T)               annotation (Line(
            points={{40,-108},{40,-60},{-27.9,-60},{-27.9,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(T, crossover2.T)               annotation (Line(
            points={{40,-108},{40,-40},{12.1,-40},{12.1,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(T, crossover3.T)               annotation (Line(
            points={{40,-108},{40,-40},{52.1,-40},{52.1,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(T, crossover4.T)               annotation (Line(
            points={{40,-108},{92.1,-108},{92.1,0}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover.A, A_1)             annotation (Line(
            points={{-80,20},{-80,84},{-96,84}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover.B, B_1)             annotation (Line(
            points={{-67.9,20},{-67.9,84},{96,84}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover1.A, A_2)             annotation (Line(
            points={{-40,20},{-40,44},{-96,44}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover1.B, B_2)             annotation (Line(
            points={{-27.9,20},{-27.9,44},{96,44}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover2.A, A_3)             annotation (Line(
            points={{8.88178e-016,20},{8.88178e-016,4},{-96,4}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover2.B, B_3)             annotation (Line(
            points={{12.1,20},{12.1,4},{96,4}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover3.A, A_4)             annotation (Line(
            points={{40,20},{40,32},{20,32},{20,-36},{-96,-36}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover3.B, B_4)             annotation (Line(
            points={{52.1,20},{52.1,32},{68,32},{68,-36},{96,-36}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover4.A, A_5)              annotation (Line(
            points={{80,20},{80,34},{58,34},{58,-76},{-96,-76}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover4.B, B_5)              annotation (Line(
            points={{92.1,20},{92.1,36},{116,36},{116,-76},{96,-76}},
            color={255,0,128},
            smooth=Smooth.None));
        connect(crossover.u, u) annotation (Line(
            points={{-85.2,10},{-120,10},{-120,114},{-60,114}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(crossover1.u, u1) annotation (Line(
            points={{-45.2,10},{-54,10},{-54,114},{-20,114}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(crossover2.u, u2) annotation (Line(
            points={{-5.2,10},{-6,10},{-6,114},{20,114}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(crossover3.u, u3) annotation (Line(
            points={{34.8,10},{30,10},{30,114},{60,114}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(crossover4.u, u4) annotation (Line(
            points={{74.8,10},{70,10},{70,114},{100,114}},
            color={255,127,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -320},{200,280}}),
                            graphics), Icon(graphics={
              Rectangle(
                extent={{-131,108},{133,-142}},
                lineColor={255,0,0},
                lineThickness=0.5,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-84,100},{-30,66}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="A_1"),
              Text(
                extent={{-84,62},{-30,28}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="A_2"),
              Text(
                extent={{-84,21},{-30,-13}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="A_3"),
              Text(
                extent={{-84,-19},{-30,-53}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="A_4"),
              Text(
                extent={{-84,-59},{-30,-93}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="A_5"),
              Text(
                extent={{24,100},{78,66}},
                lineColor={0,127,0},
                textString="B_1"),
              Text(
                extent={{24,60},{78,26}},
                lineColor={0,127,0},
                textString="B_2"),
              Text(
                extent={{24,18},{78,-16}},
                lineColor={0,127,0},
                textString="B_3"),
              Text(
                extent={{24,-20},{78,-54}},
                lineColor={0,127,0},
                textString="B_4"),
              Text(
                extent={{24,-58},{78,-92}},
                lineColor={0,127,0},
                textString="B_5"),
              Text(
                extent={{-72,-111},{-18,-145}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="P"),
              Text(
                extent={{48,-111},{102,-145}},
                lineColor={0,127,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5,
                textString="T")}));
      end Hydraulic_Manifold;

      package Tests
        extends Modelica.Icons.Package;

        model Test_Accumulator
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Hydraulic_Accumulator hydraulic_Accumulator
            annotation (Placement(transformation(extent={{-16,4},{16,36}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                                          pressure_Source(P_constant=3000000)
            annotation (Placement(transformation(extent={{-86,-12},{-66,8}})));
        equation
          connect(hydraulic_Accumulator.hyd1, pressure_Source.hydraulic_port)
            annotation (Line(
              points={{-12.48,-15.2},{-42,-15.2},{-42,-2},{-66,-2}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics));
        end Test_Accumulator;

        model Test_Attenuator
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                                          pressure_Source(P_constant=3000000)
            annotation (Placement(transformation(extent={{-98,18},{-78,38}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                                          pressure_Source1(P_constant=3000000)
            annotation (Placement(transformation(extent={{80,18},{60,38}})));
          MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Linear
                                                         loss_Linear(k=1e-5)
            annotation (Placement(transformation(extent={{-50,18},{-30,38}})));
          MSL_Extend.Hydraulics_Simple.Components.Orifices.Loss_Linear
                                                         loss_Linear1(k=1e-5)
            annotation (Placement(transformation(extent={{30,18},{50,38}})));
          Hydraulic_Attentuator hydraulic_Attentuator(
            total_volume=30,
            hydraulic_fluid_in_attenuator_start=5,
            k=1e-5,
            empty_pressure=1000000)
                    annotation (Placement(transformation(extent={{-24,-4},{16,56}})));
        equation
          connect(pressure_Source.hydraulic_port, loss_Linear.hyd_a) annotation (Line(
              points={{-78,28},{-50,28}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(loss_Linear1.hyd_b, pressure_Source1.hydraulic_port) annotation (Line(
              points={{50,28},{60,28}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(loss_Linear.hyd_b, hydraulic_Attentuator.hyd_in) annotation (Line(
              points={{-30,28},{-28,28},{-28,36},{-24,36}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Attentuator.hyd_out, loss_Linear1.hyd_a) annotation (Line(
              points={{16,36},{24,36},{24,28},{30,28}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(graphics));
        end Test_Attenuator;

        model Test_Reservoir
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Hydraulic_Reservoir hydraulic_Reservoir
            annotation (Placement(transformation(extent={{-16,-48},{24,12}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                  pressure_Source(P_constant=200000)
            annotation (Placement(transformation(extent={{-90,0},{-70,20}})));
        equation

          connect(hydraulic_Reservoir.hyd1, pressure_Source.hydraulic_port)
            annotation (Line(
              points={{-3.8,-38},{-40,-38},{-40,10},{-70,10}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent=
                    {{-100,-100},{100,100}}),
                              graphics));
        end Test_Reservoir;

        model Test_Hydraulic_Line
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                                          pressure_Source1(
              P_constant=3000000)
            annotation (Placement(transformation(extent={{40,20},{20,40}})));
          Hydraulic_Line hydraulic_Line
            annotation (Placement(transformation(extent={{-16,24},{4,36}})));
          MSL_Extend.Hydraulics_Simple.Sources.Flow_Source_Actuated
                                                               pressure_Source_Actuated
            annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
          Modelica.Blocks.Sources.Sine sine(freqHz=1, amplitude=0.001)
            annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
        equation
          connect(hydraulic_Line.hyd_b, pressure_Source1.hydraulic_port) annotation (
              Line(
              points={{4,30},{20,30}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(pressure_Source_Actuated.hydraulic_port, hydraulic_Line.hyd_a)
            annotation (Line(
              points={{-40,30},{-16,30}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(sine.y, pressure_Source_Actuated.V_in) annotation (Line(
              points={{-79,30},{-62,30}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(graphics));
        end Test_Hydraulic_Line;

        model Test_Hydraulic_Filter
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Hydraulic_Filter hydraulic_Filter(loss_factor=1e-4)
            annotation (Placement(transformation(extent={{-28,-8},{12,52}})));
          MSL_Extend.Hydraulics_Simple.Sources.Flow_Source pressure_Source(
                                                                          V_constant=-1)
            annotation (Placement(transformation(extent={{-80,22},{-60,42}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                                                          pressure_Source1(P_constant=
                1000000)
            annotation (Placement(transformation(extent={{80,22},{60,42}})));
        equation

          connect(pressure_Source.hydraulic_port, hydraulic_Filter.hyd_in) annotation (
              Line(
              points={{-60,32},{-28,32}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Filter.hyd_out, pressure_Source1.hydraulic_port)
            annotation (Line(
              points={{12,32},{60,32}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(graphics));
        end Test_Hydraulic_Filter;

        model Test_Hydraulic_Manifold
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Hydraulic_Manifold
            hydraulic_manifold(f_crit=5)
            annotation (Placement(transformation(extent={{-48,16},{-2,86}})));
          Modelica.Mechanics.Translational.Components.Mass mass(
            L=0.01,
            m=100)
            annotation (Placement(transformation(extent={{60,-180},{80,-160}})));
          MSL_Extend.Hydraulics_Simple.Components.Cylinders.Hydraulic_Mechanical_Conversion_Translational
            hydraulic_Mechanical_Conversion_Translational(piston_area=pi*0.05^2/4)
            annotation (Placement(transformation(extent={{-40,-190},{-20,-170}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source      pressure_Source2(
              P_constant=2000000)
            annotation (Placement(transformation(extent={{-10,-10.5},{10,10.5}},
                rotation=90,
                origin={-40.5,-10})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source      pressure_Source3(
              P_constant=100000)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-10,-10})));
          Modelica.Blocks.Sources.IntegerStep integerConstant1(
            offset=-1,
            startTime=0.5,
            height=1)
            annotation (Placement(transformation(extent={{-94,84},{-80,98}})));
          Modelica.Mechanics.Translational.Components.Mass mass1(
            L=0.01, m=200)
            annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
          MSL_Extend.Hydraulics_Simple.Components.Cylinders.Hydraulic_Mechanical_Conversion_Translational
            hydraulic_Mechanical_Conversion_Translational1(piston_area=pi*0.05^2/4)
            annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
          Modelica.Mechanics.Translational.Components.Mass mass2(
            L=0.01, m=300)
            annotation (Placement(transformation(extent={{60,-120},{80,-100}})));
          MSL_Extend.Hydraulics_Simple.Components.Cylinders.Hydraulic_Mechanical_Conversion_Translational
            hydraulic_Mechanical_Conversion_Translational2(piston_area=pi*0.05^2/4)
            annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));
          Modelica.Mechanics.Translational.Components.Mass mass3(
            L=0.01, m=400)
            annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
          MSL_Extend.Hydraulics_Simple.Components.Cylinders.Hydraulic_Mechanical_Conversion_Translational
            hydraulic_Mechanical_Conversion_Translational3(piston_area=pi*0.05^2/4)
            annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
          Modelica.Mechanics.Translational.Components.Mass mass4(
            L=0.01, m=500)
            annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
          MSL_Extend.Hydraulics_Simple.Components.Cylinders.Hydraulic_Mechanical_Conversion_Translational
            hydraulic_Mechanical_Conversion_Translational4(piston_area=pi*0.05^2/4)
            annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
        equation

          connect(hydraulic_Mechanical_Conversion_Translational.flange, mass.flange_a)
            annotation (Line(
              points={{-30,-170},{60,-170}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(integerConstant1.y, hydraulic_manifold.u) annotation (Line(
              points={{-79.3,91},{-38.8,91},{-38.8,90.9}},
              color={255,127,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hydraulic_manifold.u1, integerConstant1.y) annotation (Line(
              points={{-29.6,90.9},{-29.6,91},{-79.3,91}},
              color={255,127,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hydraulic_manifold.u2, integerConstant1.y) annotation (Line(
              points={{-20.4,90.9},{-20.4,91},{-79.3,91}},
              color={255,127,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hydraulic_manifold.u3, integerConstant1.y) annotation (Line(
              points={{-11.2,90.9},{-11.2,91},{-79.3,91}},
              color={255,127,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(integerConstant1.y, hydraulic_manifold.u4) annotation (Line(
              points={{-79.3,91},{-2,91},{-2,90.9}},
              color={255,127,0},
              thickness=0.5,
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Translational1.flange, mass1.flange_a)
            annotation (Line(
              points={{-30,-140},{60,-140}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Translational2.flange, mass2.flange_a)
            annotation (Line(
              points={{-30,-110},{60,-110}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Translational3.flange, mass3.flange_a)
            annotation (Line(
              points={{-30,-80},{60,-80}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(hydraulic_Mechanical_Conversion_Translational4.flange, mass4.flange_a)
            annotation (Line(
              points={{-30,-50},{60,-50}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(hydraulic_manifold.A_1, hydraulic_Mechanical_Conversion_Translational.hyd_a)
            annotation (Line(
              points={{-47.08,80.4},{-100,80.4},{-100,-180},{-40,-180}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.B_1, hydraulic_Mechanical_Conversion_Translational.hyd_b)
            annotation (Line(
              points={{-2.92,80.4},{50,80.4},{50,-180},{-20,-180}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.A_2,
            hydraulic_Mechanical_Conversion_Translational1.hyd_a) annotation (Line(
              points={{-47.08,66.4},{-90,66.4},{-90,-150},{-40,-150}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.B_2,
            hydraulic_Mechanical_Conversion_Translational1.hyd_b) annotation (Line(
              points={{-2.92,66.4},{40,66.4},{40,-150},{-20,-150}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.A_3,
            hydraulic_Mechanical_Conversion_Translational2.hyd_a) annotation (Line(
              points={{-47.08,52.4},{-80,52.4},{-80,-120},{-40,-120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.B_3,
            hydraulic_Mechanical_Conversion_Translational2.hyd_b) annotation (Line(
              points={{-2.92,52.4},{28,52.4},{28,-120},{-20,-120}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.A_4,
            hydraulic_Mechanical_Conversion_Translational3.hyd_a) annotation (Line(
              points={{-47.08,38.4},{-70,38.4},{-70,-90},{-40,-90}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.B_4,
            hydraulic_Mechanical_Conversion_Translational3.hyd_b) annotation (Line(
              points={{-2.92,38.4},{20,38.4},{20,-90},{-20,-90}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.A_5,
            hydraulic_Mechanical_Conversion_Translational4.hyd_a) annotation (Line(
              points={{-47.08,24.4},{-60,24.4},{-60,-60},{-40,-60}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_manifold.B_5,
            hydraulic_Mechanical_Conversion_Translational4.hyd_b) annotation (Line(
              points={{-2.92,24.4},{10,24.4},{10,-60},{-20,-60}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(pressure_Source2.hydraulic_port, hydraulic_manifold.P) annotation (
              Line(
              points={{-40.5,0},{-40.5,32},{-28.68,32},{-28.68,13.2}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(pressure_Source3.hydraulic_port, hydraulic_manifold.T) annotation (
              Line(
              points={{-10,0},{-10,34},{-15.8,34},{-15.8,13.2}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(extent={{-100,-200},{100,100}}),
                              graphics), Icon(coordinateSystem(extent={{-100,-200},{100,
                    100}}),                   graphics));
        end Test_Hydraulic_Manifold;

        model Test_Hydraulic_Fitting
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Fitting_Generic hydraulic_Fitting(
            loss_coeff=1,
            flow_area=0.001) annotation (Placement(transformation(extent={{-30,-22},{10,38}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source      pressure_Source2(
              P_constant=2500000)
            annotation (Placement(transformation(extent={{-7,-7},{7,7}},
                rotation=90,
                origin={-66,21})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source      pressure_Source3(
              P_constant=2000000)
            annotation (Placement(transformation(extent={{-7,-7},{7,7}},
                rotation=90,
                origin={53,19})));
        equation

          connect(pressure_Source2.hydraulic_port, hydraulic_Fitting.hyd_in)
            annotation (Line(
              points={{-66,28},{-64,28},{-64,38},{-46,38},{-46,32},{-50,32}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(hydraulic_Fitting.hyd_out, pressure_Source3.hydraulic_port)
            annotation (Line(
              points={{30,32},{40,32},{40,44},{53,44},{53,26}},
              color={255,0,128},
              smooth=Smooth.None));
          annotation (Diagram(graphics));
        end Test_Hydraulic_Fitting;

        model Test_Pump_Hydraulic
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                          pressure_Source(P_constant=22000000)
            annotation (Placement(transformation(extent={{-60,36},{-40,56}})));
          Pump_Hydraulic
            test_hydraulic_pump
            annotation (Placement(transformation(extent={{18,10},{-18,64}})));
          inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC
                                                      env
            annotation (Placement(transformation(extent={{-46,-76},{-26,-56}})));
          MSL_Extend.Hydraulics_Simple.Sources.Pressure_Source
                          pressure_Source1(P_constant=24000000)
            annotation (Placement(transformation(extent={{60,40},{40,60}})));
          MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                                              testing_Torque
            annotation (Placement(transformation(extent={{20,-12},{0,8}})));
        equation
          connect(pressure_Source.hydraulic_port, test_hydraulic_pump.hyd_out)
            annotation (Line(
              points={{-40,46},{-18,46}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(test_hydraulic_pump.hyd_in, pressure_Source1.hydraulic_port)
            annotation (Line(
              points={{18,46},{30,46},{30,50},{40,50}},
              color={255,0,128},
              smooth=Smooth.None));
          connect(test_hydraulic_pump.brg_01, testing_Torque.flange_a) annotation (Line(
              points={{18,38.8},{26,38.8},{26,40},{30,40},{30,-2},{20,-2}},
              color={0,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics));
        end Test_Pump_Hydraulic;
      end Tests;
    end Hydraulic;

    package Fuel_System
      extends Modelica.Icons.Package;

      model Fuel_Tank "Parametric cuboid fuel tank model "

        parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8()
          "Medium in the component"
          annotation(__Dymola_choicesAllMatching=true);

        MSL_Extend.Thermal.FluidHeatFlow.Components.Volumes.OpenTank
                                        tank(medium=medium,
          level_start=level_start,
          T0=293.15,
          height=height,
          crossArea=crossArea)
          annotation (Placement(transformation(extent={{-58,-40},{22,40}})));
        parameter SI.Height height= 0.1 "Height of fuel tank";
        parameter SI.Length length = 2.0 "Length (long dimension) of fuel tank";
        parameter SI.Length depth = 1.0 "Depth (short dimension) of fuel tank";

        parameter Real initial_fill_fraction(min=0, max=1) = 0.5;

      protected
          parameter SI.Area crossArea=length * depth
          "Constant cross sectional area of tank";
          parameter SI.Height level_start=initial_fill_fraction*height
          "Initial level in tank";

      public
        Modelica.Blocks.Sources.Constant height_const(k=height)
          annotation (Placement(transformation(extent={{60,20},{80,40}})));
        Modelica.Blocks.Math.Division fraction_full
          annotation (Placement(transformation(extent={{100,60},{120,80}})));
        Modelica.Blocks.Interfaces.RealOutput level_fraction annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,226})));
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=
              medium)
          annotation (Placement(transformation(extent={{-92,232},{-72,252}})));
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=
              medium) annotation (Placement(transformation(extent={{-172,230},
                  {-152,250}})));
        Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=
              293.15) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-16,-98})));
      equation
        assert(tank.level_output < 1.0, "Tank overflowed");
        assert(tank.level_output > 0.0, "Tank ran dry");
        connect(height_const.y, fraction_full.u2) annotation (Line(
            points={{81,30},{90,30},{90,64},{98,64}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fraction_full.y, level_fraction) annotation (Line(
            points={{121,70},{128,70},{128,150},{0,150},{0,226}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tank.flowPort_a, fluid_out)  annotation (Line(
            points={{-58,0},{-82,0},{-82,242}},
            color={255,0,0},
            smooth=Smooth.None));
        connect(fraction_full.u1, tank.level_output) annotation (Line(
            points={{98,76},{42,76},{42,0},{25.2,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tank.flowPort_a, fluid_in) annotation (Line(
            points={{-58,0},{-162,0},{-162,240}},
            color={255,0,0},
            smooth=Smooth.None));
        connect(fixedTemperature.port, tank.heatPort) annotation (Line(
            points={{-16,-88},{-16,-40},{-18,-40}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                  -320},{200,280}}),
                               graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-320},{200,280}}), graphics={
              Rectangle(
                extent={{-130,0},{-10,-120}},
                lineColor={170,255,85},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                lineThickness=0.5),
              Polygon(
                points={{-130,0},{-30,140},{90,140},{-10,0},{-130,0}},
                lineColor={170,255,85},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                lineThickness=0.5),
              Polygon(
                points={{-10,-120},{-10,0},{90,140},{90,20},{-10,-120}},
                lineColor={170,255,85},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineThickness=0.5),
              Line(
                points={{-160,238},{-160,78},{-68,78},{-68,30}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-68,28},{-80,52}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-66,206},{-78,230}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-54,64},{-54,136},{-78,136},{-78,230}},
                color={0,0,255},
                smooth=Smooth.None),
              Text(
                extent={{-300,268},{-130,210}},
                lineColor={128,128,128},
                textString="ret"),
              Text(
                extent={{-24,268},{146,210}},
                lineColor={128,128,128},
                textString="level")}));
      end Fuel_Tank;

      model Fuel_Tank_Dual_Sender "Fuel tank with two pickup points"
        extends
          C2M2L_OM.C2M2L_Delivered_Component_Implementations.Fuel_System.Fuel_Tank;
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b sender(medium=
              medium) annotation (Placement(transformation(extent={{150,230},
                  {170,250}})));
      equation

        connect(tank.flowPort_a, sender) annotation (Line(
            points={{-58,0},{-58,106},{160,106},{160,240}},
            color={255,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                extent={{-200,-320},{200,280}}), graphics));
      end Fuel_Tank_Dual_Sender;

      model Fuel_Pump "Fuel Pump"
        extends
          C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Pumps_And_Fans.TwoPortFlowDevice;

        parameter SI.Power pow_max=100000;
        parameter SI.Torque trq_max=100 "Maximum output torque";
        parameter SI.Voltage v_nom=24
          "Nominal voltage that device is intended to operate at"
          annotation (Dialog(tab="Electrical Model"));

        Modelica.Blocks.Interfaces.RealInput demand annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=270,
              origin={-78,288})));
        Modelica.Blocks.Interfaces.RealOutput tau annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-18,286})));
        Modelica.Blocks.Interfaces.RealOutput w annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={22,286})));
        Modelica.Blocks.Interfaces.RealOutput i annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={62,286})));
        Modelica.Blocks.Interfaces.RealOutput v annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={102,286})));
        MSL_Extend.Electrical.Electric_Machines.Electric_Motor
                                                    electric_Motor1(
          use_heat_port=false,
          v_nom=v_nom,
          pow_max=pow_max,
          trq_max=trq_max)
          annotation (Placement(transformation(extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-98,150})));
        Modelica.Electrical.Analog.Interfaces.NegativePin pin_n1
          annotation (Placement(transformation(extent={{190,110},{210,130}})));
        Modelica.Electrical.Analog.Interfaces.PositivePin pin_p1
          annotation (Placement(transformation(extent={{-210,110},{-190,130}})));
      equation

        connect(electric_Motor1.v, v)
                                     annotation (Line(
            points={{-119.2,143.6},{-126,143.6},{-126,198},{102,198},{102,286}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(electric_Motor1.i, i)
                                     annotation (Line(
            points={{-119.2,136.4},{-130,136.4},{-130,204},{62,204},{62,286}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(electric_Motor1.w, w)
                                     annotation (Line(
            points={{-113.6,128.8},{-134,128.8},{-134,210},{22,210},{22,286}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(electric_Motor1.tau, tau)
                                         annotation (Line(
            points={{-109.2,128.8},{-109.2,116},{-144,116},{-144,214},{-18,214},{-18,286}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(electric_Motor1.demand, demand)
                                               annotation (Line(
            points={{-104,128.8},{-104,102},{-150,102},{-150,228},{-78,228},{-78,288}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(electric_Motor1.p, pin_p1)
                                         annotation (Line(
            points={{-114,150},{-156,150},{-156,120},{-200,120}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(pin_n1, electric_Motor1.n)
                                         annotation (Line(
            points={{200,120},{62,120},{62,150},{-82,150}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(electric_Motor1.support, internalSupport) annotation (Line(
            points={{-98,170},{-98,182},{28,182},{28,-120},{0,-120},{0,-140}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(flow_device.flange, electric_Motor1.flange) annotation (Line(
            points={{0,80},{0,66},{-98,66},{-98,130}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,-320},
                  {200,280}}),       graphics), Icon(coordinateSystem(
                preserveAspectRatio=false,extent={{-200,-320},{200,280}}), graphics={
              Polygon(
                points={{38,-40},{78,-55},{38,-70},{38,-40}},
                lineColor={0,128,255},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=showDesignFlowDirection),
              Polygon(
                points={{38,-45},{68,-55},{38,-65},{38,-45}},
                lineColor={255,255,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                visible=allowFlowReversal),
              Line(
                points={{73,-55},{-42,-55}},
                color={0,128,255},
                smooth=Smooth.None,
                visible=showDesignFlowDirection),
              Ellipse(
                extent={{-114,106},{112,-126}},
                lineColor={0,0,0},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-8,92},{-48,10},{32,-30},{4,-106}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Line(
                points={{96,-4},{12,34},{-28,-46},{-94,-28}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Line(
                points={{60,64},{-20,42},{6,-46},{-62,-86}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Ellipse(
                extent={{-30,18},{30,-42}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{53,71},{-15,43},{17,-45},{-77,-73}},
                color={255,255,255},
                smooth=Smooth.Bezier,
                origin={-5,-11},
                rotation=90),
              Line(
                points={{-202,-80},{-172,-80},{-172,14},{-146,14}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-188,-154},{-188,-174},{-132,-174},{-132,-186},{-114,-164},{
                    -132,-142},{-132,-154},{-188,-154}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{118,-156},{118,-176},{174,-176},{174,-188},{192,-166},{174,
                    -144},{174,-156},{118,-156}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{146,6},{174,6},{174,-82},{200,-82}},
                color={0,0,0},
                smooth=Smooth.None),
              Ellipse(extent={{-148,138},{146,-156}},
                                                  lineColor={0,0,0})}));
      end Fuel_Pump;

      model Fuel_Filter

        Modelica.Blocks.Sources.Constant const(k=1)
          annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
        parameter Modelica.Thermal.FluidHeatFlow.Media.Medium medium=C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8()
          "Medium"
          annotation(__Dymola_choicesAllMatching=true);
        parameter SI.Pressure dp_nominal;
        parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate m_flow_nominal
          "Nominal mass flowrate";
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_a fluid_in(medium=medium)
          annotation (Placement(transformation(extent={{-210,-90},{-190,-70}})));
        Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort_b fluid_out(medium=medium)
          annotation (Placement(transformation(extent={{192,-90},{212,-70}})));
        Modelica.Thermal.FluidHeatFlow.Components.Valve valveIncompressible(
          y1=1,
          kv0=1e-3,
          medium=medium,
          rho0=medium.rho,
          LinearCharacteristic=false,
          Kv1=m_flow_nominal/medium.rho,
          dp0(displayUnit="Pa") = dp_nominal,
          m=1e-6)
          annotation (Placement(transformation(extent={{-10,10},{10,30}})));
      equation
        connect(valveIncompressible.flowPort_b, fluid_out)
                                             annotation (Line(
            points={{10,20},{106,20},{106,-80},{202,-80}},
            color={255,0,0},
            smooth=Smooth.None));
        connect(valveIncompressible.flowPort_a, fluid_in)
                                            annotation (Line(
            points={{-10,20},{-104,20},{-104,-80},{-200,-80}},
            color={255,0,0},
            smooth=Smooth.None));
        connect(const.y, valveIncompressible.y)
                                  annotation (Line(
            points={{-19,70},{0,70},{0,29}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                  -320},{200,280}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-320},{200,280}}),
                                            graphics={
              Polygon(
                points={{-148,184},{-148,-156},{164,-156},{164,184},{-148,184}},
                lineColor={0,0,255},
                smooth=Smooth.None),
              Rectangle(extent={{-12,184},{30,134}},
                                                  lineColor={0,0,0}),
              Rectangle(extent={{-20,-80},{0,-100}}, lineColor={0,0,255}),
              Rectangle(
                extent={{-116,138},{134,-124}},
                lineColor={0,0,0},
                fillColor={255,170,85},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-90,138},{-90,-124}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-60,138},{-60,-122}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-26,138},{-26,-122}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{18,138},{18,-126}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{56,138},{56,-124}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{98,138},{98,-126}},
                color={0,0,255},
                smooth=Smooth.None),
              Polygon(
                points={{-238,-20},{-238,-46},{-188,-46},{-188,-66},{-168,-32},{-188,
                    -4},{-188,-20},{-238,-20}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{168,-24},{168,-50},{218,-50},{218,-70},{238,-36},{218,-8},{
                    218,-24},{168,-24}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid)}));
      end Fuel_Filter;

      package Tests
        extends Modelica.Icons.Package;

        model Test_Fuel_Tank
          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Fuel_Tank fuel_Tank(medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
            annotation (Placement(transformation(extent={{-20,-32},{20,28}})));
          MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                          Fuel_To_Engine(
            constantMassFlow=-0.1,
            medium=C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
                                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-52,50})));
        equation
          connect(Fuel_To_Engine.flowPort, fuel_Tank.fluid_out) annotation (
              Line(
              points={{-42,50},{-8.2,50},{-8.2,24.2}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics),
            experiment(StopTime=150),
            __Dymola_experimentSetupOutput);
        end Test_Fuel_Tank;

        model Test_Fuel_Tank_Dual_Sender
          extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Fuel_Tank_Dual_Sender
                    fuel_Tank(medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
            annotation (Placement(transformation(extent={{-20,-32},{20,28}})));
          MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                          Fuel_To_Engine(
            constantMassFlow=-0.1, medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
                                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-68,52})));
          MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                          Fuel_To_Engine_B(
              constantMassFlow=-0.1, medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
                                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-64,78})));
        equation
          connect(Fuel_To_Engine.flowPort, fuel_Tank.fluid_out) annotation (Line(
              points={{-58,52},{-8.2,52},{-8.2,24.2}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(Fuel_To_Engine_B.flowPort, fuel_Tank.sender) annotation (Line(
              points={{-54,78},{16,78},{16,24}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics),
            experiment(StopTime=80),
            __Dymola_experimentSetupOutput);
        end Test_Fuel_Tank_Dual_Sender;

        model Test_Delivered_FuelPump
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
           Fuel_Pump ancilliary_Pump(
            rotating_inertia=0.01,
            efficiency_characteristic=[0,1; 10,1],
            trq_max=10,
            pow_max=100,
            flow_characteristic=[0.00083259501,172823.2968; 0.00087131978,170206.0469;
                0.00095845365,162573.5506; 0.00098265505,160211.4067; 0.00106011088,
                152651.3054; 0.00111819802,145782.0587; 0.00115692279,141202.5609;
                0.00123921133,132120.0971; 0.00125373469,130517.0660; 0.00132150618,
                122884.5697; 0.00135539193,118774.6049; 0.00138443234,115252.0734;
                0.00145220383,107619.5771; 0.00147640523,105165.7329; 0.00151997532,
                100749.6409; 0.00158774050,92913.7492; 0.00159258583,92353.8949;
                0.00167003535,83194.8994; 0.00173780684,73933.8614; 0.00174264586,
                73272.6541; 0.00186850449,56481.0243],
            medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
            annotation (Placement(transformation(extent={{-20,-14},{20,46}})));
          Modelica.Electrical.Spice3.Sources.V_constant v_constant(V=24)
            annotation (Placement(transformation(extent={{-12,56},{8,76}})));
          Modelica.Blocks.Sources.Constant const(k=1)
            annotation (Placement(transformation(extent={{-100,52},{-80,72}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{48,46},{68,66}})));
          Modelica.Thermal.FluidHeatFlow.Sources.Ambient pump_outlet(medium=
                Modelica.Thermal.FluidHeatFlow.Media.Water(), constantAmbientPressure=
                105000)
            annotation (Placement(transformation(extent={{48,0},{68,20}})));
          Modelica.Thermal.FluidHeatFlow.Sources.Ambient pump_inlet(medium=
                Modelica.Thermal.FluidHeatFlow.Media.Water(), constantAmbientPressure=
                100000)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-42,10})));
        equation

          connect(ground.p, v_constant.n) annotation (Line(
              points={{58,66},{8,66}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(ancilliary_Pump.pin_n1, v_constant.n) annotation (Line(
              points={{20,30},{40,30},{40,66},{8,66}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(v_constant.p, ancilliary_Pump.pin_p1) annotation (Line(
              points={{-12,66},{-36,66},{-36,30},{-20,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(pump_outlet.flowPort, ancilliary_Pump.flowPort_b) annotation (
             Line(
              points={{48,10},{20,10}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(ancilliary_Pump.flowPort_a, pump_inlet.flowPort) annotation (
              Line(
              points={{-20,10},{-32,10}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(ancilliary_Pump.demand, const.y) annotation (Line(
              points={{-7.8,46.8},{-7.8,62},{-79,62}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                              graphics));
        end Test_Delivered_FuelPump;

        model Test_Fuel_Filter
        extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;
          Fuel_Filter fuel_Filter(
            medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8(),
            m_flow_nominal=0.01,
            dp_nominal=20000)
            annotation (Placement(transformation(extent={{-22,-14},{8,30}})));

          Modelica.Thermal.FluidHeatFlow.Sources.Ambient filter_outlet(medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8(),
              constantAmbientPressure=100000)
            annotation (Placement(transformation(extent={{52,-6},{72,14}})));
          MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                          filter_inlet(medium=
                C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8(),
              constantMassFlow=0.01)                                       annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-68,4})));
        equation
          connect(fuel_Filter.fluid_out, filter_outlet.flowPort) annotation (Line(
              points={{8.15,3.6},{31.075,3.6},{31.075,4},{52,4}},
              color={255,0,0},
              smooth=Smooth.None));
          connect(fuel_Filter.fluid_in, filter_inlet.flowPort) annotation (Line(
              points={{-22,3.6},{-42,3.6},{-42,4},{-58,4}},
              color={255,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics));
        end Test_Fuel_Filter;
      end Tests;
    end Fuel_System;
  end C2M2L_Delivered_Component_Implementations;

  package C2M2L_Test_Assemblies
    "A place to test delivered components working with each other"
      extends Modelica.Icons.Package;

    model no_controls "Test vehicle performance on grade"
      extends MSL_Extend.Icons.Simple_Test_Case;

      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-196,-48},{-154,-12}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        period=20,
        width=500,
        amplitude=0.7,
        offset=0.3,
        startTime=2.1,
        rising=0.5)
        annotation (Placement(transformation(extent={{-240,120},{-220,140}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-240,90},{-220,110}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
          powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712;
            0.3,0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712;
            0.9,0.2488; 1,0.2; 1.1,0; 10,0.0],
        synchronizer_max_torque_TC=1000)
        annotation (Placement(transformation(extent={{-80,-54},{-40,6}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Cross_Drive_without_TC
        cross_Drive_without_TC(useSupport=false, medium=
            C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                  annotation (Placement(transformation(extent={{20,-54},{60,8}})));
      Modelica.Blocks.Sources.IntegerStep     integerConstant(height=2, startTime=2)
        annotation (Placement(transformation(extent={{0,90},{20,110}})));
      Modelica.Blocks.Sources.Pulse step(
        startTime=20,
        period=10,
        width=0)  annotation (Placement(transformation(extent={{0,120},{20,140}})));
      MSL_Extend.Testing_Blocks.Land.Road_Wheel_Load_Both_Sides
                                                       road_Wheel_Load_Both_Sides(
          vehicle_mass=30000, linear_resistance=5000)
        annotation (Placement(transformation(extent={{220,-40},{260,0}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft
        annotation (Placement(transformation(extent={{80,30},{100,50}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft1
        annotation (Placement(transformation(extent={{80,-90},{100,-70}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{-136,118},{-116,138}})));
      Modelica.Blocks.Sources.Constant const2(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={64,114})));
      Modelica.Blocks.Sources.Constant const(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-54,158})));
      Modelica.Blocks.Sources.Constant const1(
                                             k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-106,86})));
      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(
          fixed_htc=200)
        annotation (Placement(transformation(extent={{-256,154},{-236,174}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-148,14},{-128,34}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation
        annotation (Placement(transformation(extent={{132,8},{172,68}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation1
        annotation (Placement(transformation(extent={{132,-112},{172,-52}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area1(
                                         area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-42,26},{-22,46}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-206,18},{-186,38}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
        cooling_Cart_For_Testing(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-140,-32},{-120,-12}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink(m_flow=
           0.5, medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-88,22},{-68,42}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink1(
        m_flow=5,
        medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC(),
        T=338.15) annotation (Placement(transformation(extent={{8,34},{28,54}})));
    equation

      connect(drive_Shaft1.frame_a, cross_Drive_without_TC.brg_03) annotation (
          Line(
          points={{80,-80},{60,-80},{60,-54}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft.frame_a, cross_Drive_without_TC.brg_02) annotation (
          Line(
          points={{80,40},{60,40},{60,8}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.ECU_Throttle_Out, demand.y) annotation (Line(
          points={{-175,-10.9412},{-175,130},{-219,130}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(const2.y, cross_Drive_without_TC.brake_apply_command) annotation (
          Line(
          points={{64,103},{58,103},{58,9.24},{50.5882,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(integerConstant.y, cross_Drive_without_TC.gear_selected)
        annotation (Line(
          points={{21,100},{38.8235,100},{38.8235,9.24}},
          color={255,127,0},
          smooth=Smooth.None));
      connect(step.y, cross_Drive_without_TC.steer_command) annotation (Line(
          points={{21,130},{36,130},{36,26},{31.7647,26},{31.7647,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{-80,-24},{-110,-24},{-110,-37.4118},{-154,-37.4118}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.brg_01, pTM_with_TC.brg_06) annotation (Line(
          points={{20,-23},{-10,-23},{-10,-24},{-40,-24}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
        annotation (Line(
          points={{-148,24},{-164.5,24},{-164.5,-12}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation.brg_01, drive_Shaft.frame_b)
        annotation (Line(
          points={{131.8,40},{100,40}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_b,
        example_Standalone_Final_Drive_Implementation1.brg_01) annotation (Line(
          points={{100,-80},{131.8,-80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation1.brg_02,
        road_Wheel_Load_Both_Sides.lhs_flange) annotation (Line(
          points={{172,-79.8},{196,-79.8},{196,-28},{220,-28}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(road_Wheel_Load_Both_Sides.rhs_flange,
        example_Standalone_Final_Drive_Implementation.brg_02) annotation (Line(
          points={{220,-12},{196,-12},{196,40.2},{172,40.2}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area1.solid, pTM_with_TC.outer_surface_heat_port)
        annotation (Line(
          points={{-42,36},{-50,36},{-50,38},{-58,38},{-58,6}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-190,18},{-190,9},{-187.39,9},{-187.39,-12}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-196,-11.7882},{-202,-11.7882},{-202,18}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{-140,-16},{-144,-16},{-144,-22.5882},{-154,-22.5882}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-140,-28},{-146,-28},{-146,-48},{-154,-48}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.return_port, pTM_with_TC.flowPort_b) annotation (
          Line(
          points={{-72,22},{-74,22},{-74,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.supply_port, pTM_with_TC.flowPort_a) annotation (
          Line(
          points={{-84,22},{-82,22},{-82,6},{-80,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink1.return_port, cross_Drive_without_TC.flowPort_b)
        annotation (Line(
          points={{24,34},{24,8},{27.0588,8}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_a, fluid_Source_Sink1.supply_port)
        annotation (Line(
          points={{20,8},{14,8},{14,34},{12,34}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (Line(
          points={{-106,75},{-90,75},{-90,74},{-70,74},{-70,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{-54,147},{-64,147},{-64,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (
          Line(
          points={{-52,7.2},{-52,128},{-115,128}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
         Line(
          points={{-219,100},{-181.3,100},{-181.3,-10.9412}},
          color={255,0,255},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-260,-180},{300,180}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=80),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-260,-180},{300,180}})));
    end no_controls;

    model Engine_Cooling "Engine with simple cooling system"
      extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(fixed_htc=
           200)
        annotation (Placement(transformation(extent={{-170,-220},{-150,-200}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Radiators.Radiator_Main_Cooling_Pack
        radiator_Main_Cooling_Pack(
        core_length=1,
        core_width=1,
        core_depth=0.1,
        loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
        flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        pressure_drop_a=[0,0; 1,100000],
        pressure_drop_b=[0,0; 1,100000],
        flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effectiveness_table=[0.0,0.0,0.1,0.2,0.3; 0.0,0.0,0.0,0.0,0.0; 0.1,0.0,100,800,
            1000; 0.2,0.0,800,1000,1000; 0.3,0.0,1000,1000,1000],
        ref_core_length=1,
        ref_core_width=1,
        ref_core_depth=0.1)
        annotation (Placement(transformation(extent={{-134,162},{-174,102}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fans.Hydraulic_Fan_Assembly
        fan_Hydraulic_Drive_Asm(
        efficiency_characteristic=[0.0,0.7],
        vol_per_radian_motor=0.0001,
        N_ref=20.943951023932,
        flow_characteristic=[1,200000; 2,150000; 3,100000],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{42,162},{82,102}})));
      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-168,-152},{-128,-118}})));

      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(
        locked_max_torque_TC=1200,
        synchronizer_max_torque_TC=1000,
        powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712; 0.3,
            0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712; 0.9,0.2488;
            1,0.2; 1.1,0; 10,0.0],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{60,-152},{100,-92}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Pump_Hydraulic        pump_Hydraulic
        annotation (Placement(transformation(extent={{44,-70},{84,-10}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        width=500,
        startTime=2.1,
        rising=0.5,
        amplitude=0,
        offset=1,
        period=2000)
        annotation (Placement(transformation(extent={{-208,-10},{-188,10}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-208,-40},{-188,-20}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{116,16},{136,36}})));
      Modelica.Blocks.Sources.Step booleanStep1(startTime=20)
        annotation (Placement(transformation(extent={{164,16},{184,36}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fill_and_Pressurization.Degas_Bottle
        degas_Bottle(p_degas_bottle=200000)
        annotation (Placement(transformation(extent={{-256,120},{-296,180}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Reservoir
        hydraulic_Reservoir(total_volume=0.1, hydraulic_fluid_accumulated_start=0.05)
                  annotation (Placement(transformation(extent={{-34,44},{6,104}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient1(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-224,184})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor return_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-212,86})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor top_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-98,88})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient2(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={110,178})));
      Modelica.Blocks.Sources.Constant const(k=0)
        annotation (Placement(transformation(extent={{102,-42},{122,-22}})));
      MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                           load(d=8, J=10)
        annotation (Placement(transformation(extent={{142,-132},{162,-112}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-182,-76},{-162,-56}})));
    equation

      connect(radiator_Main_Cooling_Pack.hot_fluid_out, return_hose.flowPort)
        annotation (Line(
          points={{-194,108},{-203,108},{-203,96},{-212,96}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(return_hose.flowPort, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-212,96},{-230,96},{-230,-166},{-114,-166},{-114,-152},{-128,
              -152}},
          color={255,0,0},
          smooth=Smooth.None));

      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
          Line(
          points={{-187,-30},{-154,-30},{-154,-117}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(demand.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-187,0},{-148,0},{-148,-117}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_in, top_hose.flowPort)
        annotation (Line(
          points={{-114,108},{-106,108},{-106,98},{-98,98}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{60,-122},{-34,-122},{-34,-142},{-128,-142}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.flowPort_a, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{60,-92},{-52,-92},{-52,-128},{-128,-128}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(booleanStep1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (
          Line(
          points={{185,26},{206,26},{206,-82},{70,-82},{70,-90.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (Line(
          points={{88,-90.8},{88,-54},{137,-54},{137,26}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(radiator_ambient1.flowPort, radiator_Main_Cooling_Pack.cold_fluid_out)
        annotation (Line(
          points={{-214,184},{-204,184},{-204,156},{-194,156}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_out, degas_Bottle.flowPort_a)
        annotation (Line(
          points={{-194,108},{-226,108},{-226,144},{-256,144}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.brg_01, pTM_with_TC.brg_05) annotation (Line(
          points={{44,-38},{26,-38},{26,-107},{60,-107}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.hyd_in, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{44,-30},{36,-30},{36,118},{42,118}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.hydraulic_Port_b, pump_Hydraulic.hyd_out)
        annotation (Line(
          points={{82,118},{90,118},{90,-30},{84,-30}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(hydraulic_Reservoir.hyd1, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-21.8,54},{-21.8,36},{36,36},{36,118},{42,118}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_a, radiator_Main_Cooling_Pack.cold_fluid_in)
        annotation (Line(
          points={{42,138},{-36,138},{-36,156},{-114,156}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_b, radiator_ambient2.flowPort)
                                                                     annotation (
          Line(
          points={{82,138},{90,138},{90,178},{100,178}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{123,-32},{142,-32},{142,-68},{76,-68},{76,-90.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(load.flange_a, pTM_with_TC.brg_06) annotation (Line(
          points={{142,-122},{100,-122}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-166,-76},{-166,-85},{-159.8,-85},{-159.8,-118}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-168,-117.8},{-178,-117.8},{-178,-76}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.flowPort_b, top_hose.flowPort) annotation (Line(
          points={{66,-92},{66,-64},{-80,-64},{-80,98},{-98,98}},
          color={255,0,0},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-460,-280},{380,240}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-460,-280},{380,240}})));
    end Engine_Cooling;

    model Engine_Cooling_with_CDT "Engine with simple cooling system"
      extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(fixed_htc=
           200)
        annotation (Placement(transformation(extent={{-250,-216},{-230,-196}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Radiators.Radiator_Main_Cooling_Pack
        radiator_Main_Cooling_Pack(
        core_length=1,
        core_width=1,
        core_depth=0.1,
        loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
        flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        pressure_drop_a=[0,0; 1,100000],
        pressure_drop_b=[0,0; 1,100000],
        flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effectiveness_table=[0.0,0.0,0.1,0.2,0.3; 0.0,0.0,0.0,0.0,0.0; 0.1,0.0,100,800,
            1000; 0.2,0.0,800,1000,1000; 0.3,0.0,1000,1000,1000],
        ref_core_length=1,
        ref_core_width=1,
        ref_core_depth=0.1)
        annotation (Placement(transformation(extent={{-250,166},{-290,106}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fans.Hydraulic_Fan_Assembly
        fan_Hydraulic_Drive_Asm(
        efficiency_characteristic=[0.0,0.7],
        vol_per_radian_motor=0.0001,
        N_ref=20.943951023932,
        flow_characteristic=[1,200000; 2,150000; 3,100000],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-74,166},{-34,106}})));
      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-284,-148},{-242,-112}})));

      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(
        locked_max_torque_TC=1200,
        synchronizer_max_torque_TC=1000,
        powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712; 0.3,
            0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712; 0.9,0.2488;
            1,0.2; 1.1,0; 10,0.0],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-56,-148},{-16,-88}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Pump_Hydraulic        pump_Hydraulic
        annotation (Placement(transformation(extent={{-72,-66},{-32,-6}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        width=500,
        startTime=2.1,
        rising=0.5,
        amplitude=0,
        offset=1,
        period=2000)
        annotation (Placement(transformation(extent={{-324,-6},{-304,14}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-324,-36},{-304,-16}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{0,20},{20,40}})));
      Modelica.Blocks.Sources.Step booleanStep1(startTime=20)
        annotation (Placement(transformation(extent={{48,20},{68,40}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fill_and_Pressurization.Degas_Bottle
        degas_Bottle(p_degas_bottle=200000)
        annotation (Placement(transformation(extent={{-372,124},{-412,184}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Reservoir
        hydraulic_Reservoir(total_volume=0.1, hydraulic_fluid_accumulated_start=0.05)
                  annotation (Placement(transformation(extent={{-150,48},{-110,
                108}})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor return_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-328,90})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor top_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-214,92})));
      Modelica.Blocks.Sources.Constant const(k=0)
        annotation (Placement(transformation(extent={{-14,-38},{6,-18}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Cross_Drive_without_TC
        cross_Drive_without_TC(useSupport=false, medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(extent={{132,-142},{172,
                -80}})));
      Modelica.Blocks.Sources.IntegerStep     integerConstant(height=2, startTime=2)
        annotation (Placement(transformation(extent={{112,2},{132,22}})));
      Modelica.Blocks.Sources.Pulse step(
        startTime=20,
        period=10,
        width=0)  annotation (Placement(transformation(extent={{112,32},{132,52}})));
      MSL_Extend.Testing_Blocks.Land.Road_Wheel_Load_Both_Sides
                                                       road_Wheel_Load_Both_Sides(
          vehicle_mass=30000, linear_resistance=5000)
        annotation (Placement(transformation(extent={{332,-128},{372,-88}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft
        annotation (Placement(transformation(extent={{192,-58},{212,-38}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft1
        annotation (Placement(transformation(extent={{192,-178},{212,-158}})));
      Modelica.Blocks.Sources.Constant const2(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={176,26})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation
        example_Standalone_Final_Drive_Implementation
        annotation (Placement(transformation(extent={{244,-80},{284,-20}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation
        example_Standalone_Final_Drive_Implementation1
        annotation (Placement(transformation(extent={{244,-200},{284,-140}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand1(
        falling=5,
        period=20,
        width=500,
        amplitude=0.7,
        offset=0.3,
        startTime=2.1,
        rising=0.5)
        annotation (Placement(transformation(extent={{-306,16},{-286,36}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-318,-70},{-298,-50}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient1(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-346,196})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient2(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={-12,190})));
    equation

      connect(radiator_Main_Cooling_Pack.hot_fluid_out, return_hose.flowPort)
        annotation (Line(
          points={{-310,112},{-319,112},{-319,100},{-328,100}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(return_hose.flowPort, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-328,100},{-350,100},{-350,-156},{-234,-156},{-234,-148},{-242,
              -148}},
          color={255,0,0},
          smooth=Smooth.None));

      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
          Line(
          points={{-303,-26},{-269.3,-26},{-269.3,-110.941}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_in, top_hose.flowPort)
        annotation (Line(
          points={{-230,112},{-222,112},{-222,102},{-214,102}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{-56,-118},{-150,-118},{-150,-137.412},{-242,-137.412}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.flowPort_a, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{-56,-88},{-148,-88},{-148,-122.588},{-242,-122.588}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(booleanStep1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (
          Line(
          points={{69,30},{78,30},{78,-74},{-46,-74},{-46,-86.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (Line(
          points={{-28,-86.8},{-28,-50},{21,-50},{21,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_out, degas_Bottle.flowPort_a)
        annotation (Line(
          points={{-310,112},{-342,112},{-342,148},{-372,148}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.brg_01, pTM_with_TC.brg_05) annotation (Line(
          points={{-72,-34},{-90,-34},{-90,-103},{-56,-103}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.hyd_in, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-72,-26},{-80,-26},{-80,122},{-74,122}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.hydraulic_Port_b, pump_Hydraulic.hyd_out)
        annotation (Line(
          points={{-34,122},{-26,122},{-26,-26},{-32,-26}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(hydraulic_Reservoir.hyd1, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-137.8,58},{-137.8,40},{-80,40},{-80,122},{-74,122}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_a, radiator_Main_Cooling_Pack.cold_fluid_in)
        annotation (Line(
          points={{-74,142},{-152,142},{-152,160},{-230,160}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{7,-28},{26,-28},{26,-64},{-40,-64},{-40,-86.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_a,cross_Drive_without_TC. brg_03) annotation (
          Line(
          points={{192,-168},{172,-168},{172,-142}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft.frame_a,cross_Drive_without_TC. brg_02) annotation (
          Line(
          points={{192,-48},{172,-48},{172,-80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const2.y,cross_Drive_without_TC. brake_apply_command) annotation (
          Line(
          points={{176,15},{170,15},{170,-78.76},{162.588,-78.76}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(integerConstant.y,cross_Drive_without_TC. gear_selected)
        annotation (Line(
          points={{133,12},{150.824,12},{150.824,-78.76}},
          color={255,127,0},
          smooth=Smooth.None));
      connect(step.y,cross_Drive_without_TC. steer_command) annotation (Line(
          points={{133,42},{148,42},{148,-62},{143.765,-62},{143.765,-78.76}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.brg_01, pTM_with_TC.brg_06) annotation (Line(
          points={{132,-111},{102,-111},{102,-118},{-16,-118}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation.brg_01,drive_Shaft. frame_b)
        annotation (Line(
          points={{243.8,-48},{212,-48}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_b,example_Standalone_Final_Drive_Implementation1.
                                                       brg_01) annotation (Line(
          points={{212,-168},{243.8,-168}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation1.brg_02,
        road_Wheel_Load_Both_Sides.lhs_flange) annotation (Line(
          points={{284,-167.8},{308,-167.8},{308,-116},{332,-116}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(road_Wheel_Load_Both_Sides.rhs_flange,
        example_Standalone_Final_Drive_Implementation.brg_02) annotation (Line(
          points={{332,-100},{308,-100},{308,-47.8},{284,-47.8}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_a, pTM_with_TC.flowPort_b)
        annotation (Line(
          points={{132,-80},{12,-80},{12,-70},{-50,-70},{-50,-88}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_b, radiator_Main_Cooling_Pack.hot_fluid_in)
        annotation (Line(
          points={{139.059,-80},{136,-80},{136,-62},{106,-62},{106,-52},{-170,-52},
              {-170,112},{-230,112}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(demand1.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-285,26},{-278,26},{-278,24},{-263,24},{-263,-110.941}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-302,-70},{-302,-79},{-275.39,-79},{-275.39,-112}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-284,-111.788},{-314,-111.788},{-314,-70}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(radiator_ambient1.flowPort, radiator_Main_Cooling_Pack.cold_fluid_out)
        annotation (Line(
          points={{-336,196},{-326,196},{-326,160},{-310,160}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_b, radiator_ambient2.flowPort)
                                                                     annotation (
          Line(
          points={{-34,142},{-32,142},{-32,190},{-22,190}},
          color={255,0,0},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-460,-280},{380,240}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-460,-280},{380,240}})));
    end Engine_Cooling_with_CDT;

    model Engine_Cooling_with_CDT_and_Electrical
      "Engine with simple cooling system"
      extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(fixed_htc=
           200)
        annotation (Placement(transformation(extent={{-250,-216},{-230,-196}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Radiators.Radiator_Main_Cooling_Pack
        radiator_Main_Cooling_Pack(
        core_length=1,
        core_width=1,
        core_depth=0.1,
        loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
        flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        pressure_drop_a=[0,0; 1,100000],
        pressure_drop_b=[0,0; 1,100000],
        flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effectiveness_table=[0.0,0.0,0.1,0.2,0.3; 0.0,0.0,0.0,0.0,0.0; 0.1,0.0,100,800,
            1000; 0.2,0.0,800,1000,1000; 0.3,0.0,1000,1000,1000],
        ref_core_length=1,
        ref_core_width=1,
        ref_core_depth=0.1)
        annotation (Placement(transformation(extent={{-250,166},{-290,106}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fans.Hydraulic_Fan_Assembly
        fan_Hydraulic_Drive_Asm(
        efficiency_characteristic=[0.0,0.7],
        vol_per_radian_motor=0.0001,
        N_ref=20.943951023932,
        flow_characteristic=[1,200000; 2,150000; 3,100000],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-74,166},{-34,106}})));
      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-284,-148},{-246,-116}})));

      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(
        locked_max_torque_TC=1200,
        synchronizer_max_torque_TC=1000,
        powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712; 0.3,
            0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712; 0.9,0.2488;
            1,0.2; 1.1,0; 10,0.0],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-56,-148},{-16,-88}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Pump_Hydraulic        pump_Hydraulic
        annotation (Placement(transformation(extent={{-72,-66},{-32,-6}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        width=500,
        startTime=2.1,
        rising=0.5,
        amplitude=0,
        offset=1,
        period=2000)
        annotation (Placement(transformation(extent={{-324,-6},{-304,14}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-324,-36},{-304,-16}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{0,20},{20,40}})));
      Modelica.Blocks.Sources.Step booleanStep1(startTime=20)
        annotation (Placement(transformation(extent={{48,20},{68,40}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fill_and_Pressurization.Degas_Bottle
        degas_Bottle(p_degas_bottle=200000)
        annotation (Placement(transformation(extent={{-372,124},{-412,184}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Reservoir
        hydraulic_Reservoir(total_volume=0.1, hydraulic_fluid_accumulated_start=0.05)
                  annotation (Placement(transformation(extent={{-150,48},{-110,
                108}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient1(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-340,188})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor return_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-328,90})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor top_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-214,92})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient radiator_ambient2(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={-6,182})));
      Modelica.Blocks.Sources.Constant const(k=0)
        annotation (Placement(transformation(extent={{-14,-38},{6,-18}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Cross_Drive_without_TC
        cross_Drive_without_TC(useSupport=false, medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
                  annotation (Placement(transformation(extent={{132,-142},{172,
                -80}})));
      Modelica.Blocks.Sources.IntegerStep     integerConstant(height=2, startTime=2)
        annotation (Placement(transformation(extent={{112,2},{132,22}})));
      Modelica.Blocks.Sources.Pulse step(
        startTime=20,
        period=10,
        width=0)  annotation (Placement(transformation(extent={{112,32},{132,52}})));
      MSL_Extend.Testing_Blocks.Land.Road_Wheel_Load_Both_Sides
                                                       road_Wheel_Load_Both_Sides(
          vehicle_mass=30000, linear_resistance=5000)
        annotation (Placement(transformation(extent={{332,-128},{372,-88}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft
        annotation (Placement(transformation(extent={{192,-58},{212,-38}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft1
        annotation (Placement(transformation(extent={{192,-178},{212,-158}})));
      Modelica.Blocks.Sources.Constant const2(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={176,26})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation
        example_Standalone_Final_Drive_Implementation
        annotation (Placement(transformation(extent={{244,-80},{284,-20}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation
        example_Standalone_Final_Drive_Implementation1
        annotation (Placement(transformation(extent={{244,-200},{284,-140}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand1(
        falling=5,
        period=20,
        width=500,
        amplitude=0.7,
        offset=0.3,
        startTime=2.1,
        rising=0.5)
        annotation (Placement(transformation(extent={{-306,16},{-286,36}})));
      C2M2L_Delivered_Component_Implementations.Electrical_System.Charging_Systems.Alternator
        alternator
        annotation (Placement(transformation(extent={{-422,-116},{-462,-56}})));
      C2M2L_Delivered_Component_Implementations.Electrical_System.Starting_Systems.Lead_Acid_Battery
        lead_Acid_Battery
        annotation (Placement(transformation(extent={{-424,-32},{-464,28}})));
      C2M2L_Delivered_Component_Implementations.Amphibious.Bilge_Pump.Bilge_Pump_Electrical
        bilge_Pump_Electrical(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-440,-214},{-480,-154}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient boundary(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())     annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-532,-166})));
      Modelica.Blocks.Sources.Constant const1(k=0)
        annotation (Placement(transformation(extent={{-462,-52},{-442,-32}})));
      Modelica.Electrical.Analog.Basic.Ground ground
        annotation (Placement(transformation(extent={{-504,-190},{-484,-170}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient  hull_leakage_rate(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-326,-184},{-306,-164}})));
      MSL_Extend.Mechanics.Rotational.Components.Pulley_System_1D_ideal
                                                                      pulley_System_1D(
        use_pulley_3=true,
        use_pulley_4=true,
        use_pulley_6=true,
        use_pulley_2=false,
        use_pulley_5=false)
        annotation (Placement(transformation(extent={{-348,-104},{-368,-84}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-308,-68},{-288,-48}})));
    equation

      connect(radiator_Main_Cooling_Pack.hot_fluid_out, return_hose.flowPort)
        annotation (Line(
          points={{-310,112},{-319,112},{-319,100},{-328,100}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(return_hose.flowPort, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-328,100},{-344,100},{-344,-154},{-228,-154},{-228,-148},{-246,
              -148}},
          color={255,0,0},
          smooth=Smooth.None));

      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
          Line(
          points={{-303,-26},{-270.7,-26},{-270.7,-115.059}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_in, top_hose.flowPort)
        annotation (Line(
          points={{-230,112},{-222,112},{-222,102},{-214,102}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{-56,-118},{-150,-118},{-150,-138.588},{-246,-138.588}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pTM_with_TC.flowPort_a, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{-56,-88},{-162,-88},{-162,-125.412},{-246,-125.412}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(booleanStep1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (
          Line(
          points={{69,30},{78,30},{78,-74},{-46,-74},{-46,-86.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (Line(
          points={{-28,-86.8},{-28,-50},{21,-50},{21,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(radiator_ambient1.flowPort, radiator_Main_Cooling_Pack.cold_fluid_out)
        annotation (Line(
          points={{-330,188},{-320,188},{-320,160},{-310,160}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_out, degas_Bottle.flowPort_a)
        annotation (Line(
          points={{-310,112},{-342,112},{-342,148},{-372,148}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.brg_01, pTM_with_TC.brg_05) annotation (Line(
          points={{-72,-34},{-90,-34},{-90,-103},{-56,-103}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(pump_Hydraulic.hyd_in, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-72,-26},{-80,-26},{-80,122},{-74,122}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.hydraulic_Port_b, pump_Hydraulic.hyd_out)
        annotation (Line(
          points={{-34,122},{-26,122},{-26,-26},{-32,-26}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(hydraulic_Reservoir.hyd1, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-137.8,58},{-137.8,40},{-80,40},{-80,122},{-74,122}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_a, radiator_Main_Cooling_Pack.cold_fluid_in)
        annotation (Line(
          points={{-74,142},{-152,142},{-152,160},{-230,160}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_b, radiator_ambient2.flowPort)
                                                                     annotation (
          Line(
          points={{-34,142},{-26,142},{-26,182},{-16,182}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{7,-28},{26,-28},{26,-64},{-40,-64},{-40,-86.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_a,cross_Drive_without_TC. brg_03) annotation (
          Line(
          points={{192,-168},{172,-168},{172,-142}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft.frame_a,cross_Drive_without_TC. brg_02) annotation (
          Line(
          points={{192,-48},{172,-48},{172,-80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const2.y,cross_Drive_without_TC. brake_apply_command) annotation (
          Line(
          points={{176,15},{170,15},{170,-78.76},{162.588,-78.76}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(integerConstant.y,cross_Drive_without_TC. gear_selected)
        annotation (Line(
          points={{133,12},{150.824,12},{150.824,-78.76}},
          color={255,127,0},
          smooth=Smooth.None));
      connect(step.y,cross_Drive_without_TC. steer_command) annotation (Line(
          points={{133,42},{148,42},{148,-62},{143.765,-62},{143.765,-78.76}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.brg_01, pTM_with_TC.brg_06) annotation (Line(
          points={{132,-111},{102,-111},{102,-118},{-16,-118}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation.brg_01,drive_Shaft. frame_b)
        annotation (Line(
          points={{243.8,-48},{212,-48}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_b,example_Standalone_Final_Drive_Implementation1.
                                                       brg_01) annotation (Line(
          points={{212,-168},{243.8,-168}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation1.brg_02,
        road_Wheel_Load_Both_Sides.lhs_flange) annotation (Line(
          points={{284,-167.8},{308,-167.8},{308,-116},{332,-116}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(road_Wheel_Load_Both_Sides.rhs_flange,
        example_Standalone_Final_Drive_Implementation.brg_02) annotation (Line(
          points={{332,-100},{308,-100},{308,-47.8},{284,-47.8}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_a, pTM_with_TC.flowPort_b)
        annotation (Line(
          points={{132,-80},{12,-80},{12,-70},{-50,-70},{-50,-88}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_b, radiator_Main_Cooling_Pack.hot_fluid_in)
        annotation (Line(
          points={{139.059,-80},{136,-80},{136,-62},{106,-62},{106,-52},{-170,-52},
              {-170,112},{-230,112}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(demand1.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-285,26},{-278,26},{-278,24},{-265,24},{-265,-115.059}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(boundary.flowPort,bilge_Pump_Electrical. flowPort_b) annotation (Line(
          points={{-522,-166},{-522,-190},{-480,-190}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pulley_System_1D.pulley_1_flange,alternator. brg_01) annotation (Line(
          points={{-368,-84},{-396,-84},{-396,-86},{-422,-86}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const1.y,alternator. demand) annotation (Line(
          points={{-441,-42},{-438,-42},{-438,-55.1}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(bilge_Pump_Electrical.pin_n,ground. p) annotation (Line(
          points={{-480,-170},{-494,-170}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(hull_leakage_rate.flowPort, bilge_Pump_Electrical.flowPort_a)
        annotation (Line(
          points={{-326,-174},{-378,-174},{-378,-190},{-440,-190}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(ground.p, lead_Acid_Battery.pin_n) annotation (Line(
          points={{-494,-170},{-494,34},{-484,34}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(lead_Acid_Battery.pin_p, bilge_Pump_Electrical.pin_p) annotation (
          Line(
          points={{-404,34},{-386,34},{-386,-170},{-440,-170}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(example_Engine_Basic.brg_01,pulley_System_1D. nominally_driven_pulley)
        annotation (Line(
          points={{-284,-138.588},{-332,-138.588},{-332,-94},{-348,-94}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-292,-68},{-292,-77},{-276.21,-77},{-276.21,-116}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-284,-115.812},{-304,-115.812},{-304,-68}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(alternator.pin_p, lead_Acid_Battery.pin_p) annotation (Line(
          points={{-422,-68},{-386,-68},{-386,34},{-404,34}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(alternator.pin_n, lead_Acid_Battery.pin_n) annotation (Line(
          points={{-462,-68},{-494,-68},{-494,34},{-484,34}},
          color={0,0,255},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-460,-280},{380,240}},
              preserveAspectRatio=false),
                          graphics={Text(
              extent={{-256,240},{214,196}},
              lineColor={255,0,0},
              textString="DOES NOT RUN")}),
        experiment(StopTime=1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-460,-280},{380,240}})));
    end Engine_Cooling_with_CDT_and_Electrical;

    model Seed_Model_Add_Electrical "Test cooling system air path"
      extends C2M2L_OM.MSL_Extend.Icons.Simple_Test_Case;

      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(fixed_htc=
           200)
        annotation (Placement(transformation(extent={{-170,-220},{-150,-200}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Radiators.Radiator_Main_Cooling_Pack
        radiator_Main_Cooling_Pack(
        core_length=1,
        core_width=1,
        core_depth=0.1,
        loss_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        loss_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Loss_Spec.deltaP,
        flow_spec_side_b=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Effec_Spec.Q_per_ITD_Area,
        flow_effec_spec=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        pressure_drop_a=[0,0; 1,100000],
        pressure_drop_b=[0,0; 1,100000],
        flow_spec_side_a=C2M2L_OM.MSL_Extend.Thermal.FluidHeatFlow.Components.Heat_Exchangers.Types.Flow_Spec.mass_flow_rate,
        effectiveness_table=[0.0,0.0,0.1,0.2,0.3; 0.0,0.0,0.0,0.0,0.0; 0.1,0.0,100,800,
            1000; 0.2,0.0,800,1000,1000; 0.3,0.0,1000,1000,1000],
        ref_core_length=1,
        ref_core_width=1,
        ref_core_depth=0.1)
        annotation (Placement(transformation(extent={{-134,162},{-174,102}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fans.Hydraulic_Fan_Assembly
        fan_Hydraulic_Drive_Asm(
        efficiency_characteristic=[0.0,0.7],
        vol_per_radian_motor=0.0001,
        N_ref=20.943951023932,
        flow_characteristic=[1,200000; 2,150000; 3,100000],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{42,162},{82,102}})));
      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-168,-152},{-128,-118}})));

      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(
        locked_max_torque_TC=1200,
        synchronizer_max_torque_TC=1000,
        powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712; 0.3,
            0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712; 0.9,0.2488;
            1,0.2; 1.1,0; 10,0.0],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{60,-152},{100,-92}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Pump_Hydraulic        pump_Hydraulic
        annotation (Placement(transformation(extent={{44,-70},{84,-10}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        width=500,
        startTime=2.1,
        rising=0.5,
        amplitude=0,
        offset=1,
        period=2000)
        annotation (Placement(transformation(extent={{-208,-10},{-188,10}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-208,-40},{-188,-20}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{116,16},{136,36}})));
      Modelica.Blocks.Sources.Step booleanStep1(startTime=20)
        annotation (Placement(transformation(extent={{164,16},{184,36}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fill_and_Pressurization.Degas_Bottle
        degas_Bottle(p_degas_bottle=200000)
        annotation (Placement(transformation(extent={{-256,120},{-296,180}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Reservoir
        hydraulic_Reservoir(total_volume=0.1, hydraulic_fluid_accumulated_start=0.05)
                  annotation (Placement(transformation(extent={{-34,44},{6,104}})));
      C2M2L_Delivered_Component_Implementations.Electrical_System.Charging_Systems.Alternator
        alternator
        annotation (Placement(transformation(extent={{-280,-142},{-320,-82}})));
      MSL_Extend.Mechanics.Rotational.Components.Pulley_System_1D     pulley_System_1D(
        use_pulley_3=true,
        use_pulley_4=true,
        use_pulley_6=true,
        use_pulley_2=false,
        use_pulley_5=false)
        annotation (Placement(transformation(extent={{-206,-130},{-226,-110}})));
      C2M2L_Delivered_Component_Implementations.Electrical_System.Starting_Systems.Lead_Acid_Battery
        lead_Acid_Battery
        annotation (Placement(transformation(extent={{-282,-58},{-322,2}})));
      C2M2L_Delivered_Component_Implementations.Amphibious.Bilge_Pump.Bilge_Pump_Electrical
        bilge_Pump_Electrical(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-298,-240},{-338,-180}})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor return_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-212,74})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor top_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-98,76})));
      Modelica.Blocks.Sources.Constant const(k=0)
        annotation (Placement(transformation(extent={{106,-30},{126,-10}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient boundary(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())     annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-390,-192})));
      Modelica.Blocks.Sources.Constant const1(k=0)
        annotation (Placement(transformation(extent={{-320,-78},{-300,-58}})));
      Modelica.Electrical.Analog.Basic.Ground ground
        annotation (Placement(transformation(extent={{-362,-216},{-342,-196}})));
      MSL_Extend.Thermal.FluidHeatFlow.Sources.MassFlowSource
                                                      hull_leakage_rate(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water(), constantMassFlow=0.1)
        annotation (Placement(transformation(extent={{-178,-178},{-158,-158}})));
      MSL_Extend.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load
                                           load(d=8, J=10)
        annotation (Placement(transformation(extent={{134,-132},{154,-112}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-178,-70},{-158,-50}})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient exhaust_out(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={-222,172})));
      Modelica.Thermal.FluidHeatFlow.Sources.Ambient exhaust_in(
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(),
        constantAmbientPressure=101300,
        constantAmbientTemperature=293.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=0,
            origin={112,166})));
    equation

      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
          Line(
          points={{-187,-30},{-154,-30},{-154,-117}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(demand.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-187,0},{-148,0},{-148,-117}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{60,-122},{-34,-122},{-34,-142},{-128,-142}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.brg_01, pulley_System_1D.nominally_driven_pulley)
        annotation (Line(
          points={{-168,-142},{-187,-142},{-187,-120},{-206,-120}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.hydraulic_Port_b, pump_Hydraulic.hyd_out)
        annotation (Line(
          points={{82,118},{100,118},{100,-30},{84,-30}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(pump_Hydraulic.hyd_in, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{44,-30},{28,-30},{28,118},{42,118}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(hydraulic_Reservoir.hyd1, fan_Hydraulic_Drive_Asm.hydraulic_Port_a)
        annotation (Line(
          points={{-21.8,54},{28,54},{28,118},{42,118}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_a, radiator_Main_Cooling_Pack.cold_fluid_in)
        annotation (Line(
          points={{42,138},{-36,138},{-36,156},{-114,156}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(degas_Bottle.flowPort_a, radiator_Main_Cooling_Pack.hot_fluid_out)
        annotation (Line(
          points={{-256,144},{-226,144},{-226,108},{-194,108}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_out, return_hose.flowPort)
        annotation (Line(
          points={{-194,108},{-194,96},{-212,96},{-212,84}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(radiator_Main_Cooling_Pack.hot_fluid_in, top_hose.flowPort)
        annotation (Line(
          points={{-114,108},{-106,108},{-106,86},{-98,86}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(top_hose.flowPort, pTM_with_TC.flowPort_b) annotation (Line(
          points={{-98,86},{-72,86},{-72,42},{-30,42},{-30,-70},{66,-70},{66,-92}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(return_hose.flowPort, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-212,84},{-236,84},{-236,-96},{-206,-96},{-206,-100},{-176,
              -100},{-176,-148},{-128,-148},{-128,-152}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.top_hose_outlet, pTM_with_TC.flowPort_a)
        annotation (Line(
          points={{-128,-128},{-32,-128},{-32,-92},{60,-92}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(booleanStep.y, pTM_with_TC.lockup_torque_converter) annotation (Line(
          points={{137,26},{150,26},{150,-60},{88,-60},{88,-90.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(booleanStep1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (
          Line(
          points={{185,26},{224,26},{224,-38},{80,-38},{80,-90.8},{70,-90.8}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (Line(
          points={{127,-20},{146,-20},{146,-56},{76,-56},{76,-90.8}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pump_Hydraulic.brg_01, pTM_with_TC.brg_05) annotation (Line(
          points={{44,-38},{32,-38},{32,-107},{60,-107}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(boundary.flowPort, bilge_Pump_Electrical.flowPort_b) annotation (Line(
          points={{-380,-192},{-380,-216},{-338,-216}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(pulley_System_1D.pulley_1_flange, alternator.brg_01) annotation (Line(
          points={{-226,-110},{-254,-110},{-254,-112},{-280,-112}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const1.y, alternator.demand) annotation (Line(
          points={{-299,-68},{-296,-68},{-296,-81.1}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(bilge_Pump_Electrical.pin_n, ground.p) annotation (Line(
          points={{-338,-196},{-352,-196}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(hull_leakage_rate.flowPort, bilge_Pump_Electrical.flowPort_a)
        annotation (Line(
          points={{-178,-168},{-236,-168},{-236,-216},{-298,-216}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(ground.p, lead_Acid_Battery.pin_n) annotation (Line(
          points={{-352,-196},{-352,8},{-342,8}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(lead_Acid_Battery.pin_p, bilge_Pump_Electrical.pin_p) annotation (
          Line(
          points={{-262,8},{-244,8},{-244,-196},{-298,-196}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(load.flange_a, pTM_with_TC.brg_06) annotation (Line(
          points={{134,-122},{100,-122}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-162,-70},{-162,-79},{-159.8,-79},{-159.8,-118}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-168,-117.8},{-168,-94.9},{-174,-94.9},{-174,-70}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(exhaust_out.flowPort, radiator_Main_Cooling_Pack.cold_fluid_out)
        annotation (Line(
          points={{-212,172},{-202,172},{-202,156},{-194,156}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fan_Hydraulic_Drive_Asm.flowPort_b, exhaust_in.flowPort)
                                                                     annotation (
          Line(
          points={{82,138},{92,138},{92,166},{102,166}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(alternator.pin_p, lead_Acid_Battery.pin_p) annotation (Line(
          points={{-280,-94},{-244,-94},{-244,8},{-262,8}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(alternator.pin_n, lead_Acid_Battery.pin_n) annotation (Line(
          points={{-320,-94},{-352,-94},{-352,8},{-342,8}},
          color={0,0,255},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-460,-280},{380,240}},
              preserveAspectRatio=false),
                          graphics={Text(
              extent={{-276,258},{194,214}},
              lineColor={255,0,0},
              textString="DOES NOT RUN")}),
        experiment(StopTime=1000),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-460,-280},{380,240}})));
    end Seed_Model_Add_Electrical;

    model no_controls_adv "Test vehicle performance on grade"
      extends MSL_Extend.Icons.Simple_Test_Case;

      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic_Advanced
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-196,-48},{-154,-12}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        period=20,
        width=500,
        amplitude=0.7,
        startTime=2.1,
        rising=0.5,
        offset=0.3)
        annotation (Placement(transformation(extent={{-240,120},{-220,140}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-240,90},{-220,110}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
          powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712;
            0.3,0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712;
            0.9,0.2488; 1,0.2; 1.1,0; 10,0.0],
        synchronizer_max_torque_TC=1000)
        annotation (Placement(transformation(extent={{-80,-54},{-40,6}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Cross_Drive_without_TC
        cross_Drive_without_TC(useSupport=false, medium=
            C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                  annotation (Placement(transformation(extent={{20,-54},{60,8}})));
      Modelica.Blocks.Sources.IntegerStep     integerConstant(height=2, startTime=2)
        annotation (Placement(transformation(extent={{0,90},{20,110}})));
      Modelica.Blocks.Sources.Pulse step(
        startTime=20,
        period=10,
        width=0)  annotation (Placement(transformation(extent={{0,120},{20,140}})));
      MSL_Extend.Testing_Blocks.Land.Road_Wheel_Load_Both_Sides
                                                       road_Wheel_Load_Both_Sides(
          vehicle_mass=30000, linear_resistance=5000)
        annotation (Placement(transformation(extent={{220,-40},{260,0}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft
        annotation (Placement(transformation(extent={{80,30},{100,50}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft1
        annotation (Placement(transformation(extent={{80,-90},{100,-70}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{-136,118},{-116,138}})));
      Modelica.Blocks.Sources.Constant const2(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={64,114})));
      Modelica.Blocks.Sources.Constant const(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-54,158})));
      Modelica.Blocks.Sources.Constant const1(
                                             k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-106,86})));
      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(
          fixed_htc=200)
        annotation (Placement(transformation(extent={{-256,154},{-236,174}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-148,14},{-128,34}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation
        annotation (Placement(transformation(extent={{132,8},{172,68}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation1
        annotation (Placement(transformation(extent={{132,-112},{172,-52}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area1(
                                         area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-42,26},{-22,46}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-206,18},{-186,38}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
        cooling_Cart_For_Testing(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-140,-32},{-120,-12}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink(m_flow=
           0.5, medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-88,22},{-68,42}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink1(
        m_flow=5,
        medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC(),
        T=338.15) annotation (Placement(transformation(extent={{8,34},{28,54}})));
      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Tests.Test_Driver_adv
        test_Driver_adv
        annotation (Placement(transformation(extent={{-244,16},{-224,36}})));
      Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage(V=24)
        annotation (Placement(transformation(extent={{-238,-56},{-218,-36}})));
      Modelica.Electrical.Analog.Basic.Ground ground
        annotation (Placement(transformation(extent={{-212,-72},{-192,-52}})));
      C2M2L_Delivered_Component_Implementations.Fuel_System.Fuel_Tank
                            fuel_Tank(medium=
            C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
        annotation (Placement(transformation(extent={{-254,-130},{-214,-70}})));
    equation

      connect(drive_Shaft1.frame_a, cross_Drive_without_TC.brg_03) annotation (
          Line(
          points={{80,-80},{60,-80},{60,-54}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft.frame_a, cross_Drive_without_TC.brg_02) annotation (
          Line(
          points={{80,40},{60,40},{60,8}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const2.y, cross_Drive_without_TC.brake_apply_command) annotation (
          Line(
          points={{64,103},{58,103},{58,9.24},{50.5882,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(integerConstant.y, cross_Drive_without_TC.gear_selected)
        annotation (Line(
          points={{21,100},{38.8235,100},{38.8235,9.24}},
          color={255,127,0},
          smooth=Smooth.None));
      connect(step.y, cross_Drive_without_TC.steer_command) annotation (Line(
          points={{21,130},{36,130},{36,26},{31.7647,26},{31.7647,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{-80,-24},{-110,-24},{-110,-37.4118},{-154,-37.4118}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.brg_01, pTM_with_TC.brg_06) annotation (Line(
          points={{20,-23},{-10,-23},{-10,-24},{-40,-24}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
        annotation (Line(
          points={{-148,24},{-164.5,24},{-164.5,-12}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation.brg_01, drive_Shaft.frame_b)
        annotation (Line(
          points={{131.8,40},{100,40}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_b,
        example_Standalone_Final_Drive_Implementation1.brg_01) annotation (Line(
          points={{100,-80},{131.8,-80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation1.brg_02,
        road_Wheel_Load_Both_Sides.lhs_flange) annotation (Line(
          points={{172,-79.8},{196,-79.8},{196,-28},{220,-28}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(road_Wheel_Load_Both_Sides.rhs_flange,
        example_Standalone_Final_Drive_Implementation.brg_02) annotation (Line(
          points={{220,-12},{196,-12},{196,40.2},{172,40.2}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area1.solid, pTM_with_TC.outer_surface_heat_port)
        annotation (Line(
          points={{-42,36},{-50,36},{-50,38},{-58,38},{-58,6}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-190,18},{-190,9},{-187.39,9},{-187.39,-12}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-196,-11.7882},{-202,-11.7882},{-202,18}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{-140,-16},{-144,-16},{-144,-22.5882},{-154,-22.5882}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-140,-28},{-146,-28},{-146,-48},{-154,-48}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.return_port, pTM_with_TC.flowPort_b) annotation (
          Line(
          points={{-72,22},{-74,22},{-74,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.supply_port, pTM_with_TC.flowPort_a) annotation (
          Line(
          points={{-84,22},{-82,22},{-82,6},{-80,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink1.return_port, cross_Drive_without_TC.flowPort_b)
        annotation (Line(
          points={{24,34},{24,8},{27.0588,8}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_a, fluid_Source_Sink1.supply_port)
        annotation (Line(
          points={{20,8},{14,8},{14,34},{12,34}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (Line(
          points={{-106,75},{-90,75},{-90,74},{-70,74},{-70,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{-54,147},{-64,147},{-64,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (
          Line(
          points={{-52,7.2},{-52,128},{-115,128}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(test_Driver_adv.starter_engage, example_Engine_Basic.starter_engage)
        annotation (Line(
          points={{-223.4,31},{-223.4,54.5},{-181.3,54.5},{-181.3,-10.9412}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(example_Engine_Basic.pin_p,constantVoltage. p) annotation (Line(
          points={{-196,-28.9412},{-214,-28.9412},{-220,-28},{-238,-28},{-238,-46}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(constantVoltage.n, example_Engine_Basic.pin_n) annotation (Line(
          points={{-218,-46},{-216,-46},{-216,-38},{-202,-38},{-202,-33.1765},{-196,
              -33.1765}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(ground.p,constantVoltage. n) annotation (Line(
          points={{-202,-52},{-210,-52},{-210,-46},{-218,-46}},
          color={0,0,255},
          smooth=Smooth.None));
      connect(fuel_Tank.fluid_out, example_Engine_Basic.fuel_in) annotation (Line(
          points={{-242.2,-73.8},{-208.1,-73.8},{-208.1,-41.6471},{-196,-41.6471}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.from_cac, example_Engine_Basic.to_cac)
        annotation (Line(
          points={{-196,-20.4706},{-202,-20.4706},{-204,-20},{-208,-20},{-208,
              -24.7059},{-196,-24.7059}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(demand.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-219,130},{-219,38},{-175,38},{-175,-10.9412}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-260,-180},{300,180}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=80),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-260,-180},{300,180}})));
    end no_controls_adv;

    model no_controls_adv_worksInOM "Test vehicle performance on grade"
      extends MSL_Extend.Icons.Simple_Test_Case;

      C2M2L_Delivered_Component_Implementations.Prime_Movers.Reciprocating.Compression_Ignition.Engine_Basic.Example_Engine_Basic_wFuel
        example_Engine_Basic(
        flow_characteristic=[0.000167,1.3e5; 0.0025,1e5; 0.004,0.6e5; 0.005,0.2e5],
        K=1e-6,
        efficiency_characteristic=[-1,0.8; 0,0.8; 1,0.8],
        cooling_Q_nom=300000,
        effectiveness_nom=0.95,
        V_dot_nom=0.003,
        N_ref(displayUnit="rpm") = 314.15926535898,
        T_inlet_nom=358.15)
        annotation (Placement(transformation(extent={{-196,-48},{-154,-12}})));
    public
      Modelica.Blocks.Sources.Trapezoid demand(
        falling=5,
        period=20,
        width=500,
        amplitude=0.7,
        startTime=2.1,
        rising=0.5,
        offset=0.3)
        annotation (Placement(transformation(extent={{-240,120},{-220,140}})));
      Modelica.Blocks.Sources.BooleanStep     booleanConstant(
          startValue=true, startTime=1)
        annotation (Placement(transformation(extent={{-240,90},{-220,110}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Power_Take_Off_Module.PTM_with_TC
        pTM_with_TC(medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
          powerCoeffTable_TC=[-10,0.2; 0,0.2; 0.00001,0.2; 0.1,0.2488; 0.2,0.2712;
            0.3,0.2872; 0.4,0.2968; 0.5,0.3; 0.6,0.2968; 0.7,0.2872; 0.8,0.2712;
            0.9,0.2488; 1,0.2; 1.1,0; 10,0.0],
        synchronizer_max_torque_TC=1000)
        annotation (Placement(transformation(extent={{-80,-54},{-40,6}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Cross_Drive_Transmission.Cross_Drive_without_TC
        cross_Drive_without_TC(useSupport=false, medium=
            C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC())
                  annotation (Placement(transformation(extent={{20,-54},{60,8}})));
      Modelica.Blocks.Sources.IntegerStep     integerConstant(height=2, startTime=2)
        annotation (Placement(transformation(extent={{0,90},{20,110}})));
      Modelica.Blocks.Sources.Pulse step(
        startTime=20,
        period=10,
        width=0)  annotation (Placement(transformation(extent={{0,120},{20,140}})));
      MSL_Extend.Testing_Blocks.Land.Road_Wheel_Load_Both_Sides
                                                       road_Wheel_Load_Both_Sides(
          vehicle_mass=30000, linear_resistance=5000)
        annotation (Placement(transformation(extent={{220,-40},{260,0}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft
        annotation (Placement(transformation(extent={{80,30},{100,50}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Drive_Shafts.Drive_Shaft
        drive_Shaft1
        annotation (Placement(transformation(extent={{80,-90},{100,-70}})));
      Modelica.Blocks.Sources.Step booleanStep(startTime=50)
        annotation (Placement(transformation(extent={{-136,118},{-116,138}})));
      Modelica.Blocks.Sources.Constant const2(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={64,114})));
      Modelica.Blocks.Sources.Constant const(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-54,158})));
      Modelica.Blocks.Sources.Constant const1(
                                             k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=270,
            origin={-106,86})));
      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite env(
          fixed_htc=200)
        annotation (Placement(transformation(extent={{-256,154},{-236,174}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area(area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-148,14},{-128,34}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation
        annotation (Placement(transformation(extent={{132,8},{172,68}})));
      C2M2L_Delivered_Component_Implementations.Drive_Line.Final_Drive.Example_Standalone_Final_Drive_Implementation_loss
        example_Standalone_Final_Drive_Implementation1
        annotation (Placement(transformation(extent={{132,-112},{172,-52}})));
      MSL_Extend.Environments.Thermal_To_Environment_Thru_Area
        thermal_To_Environment_Thru_Area1(
                                         area_for_heat_transfer=0.5)
        annotation (Placement(transformation(extent={{-42,26},{-22,46}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                                            air_Path_For_Testing(
          medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{-206,18},{-186,38}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
        cooling_Cart_For_Testing(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-132,-32},{-112,-12}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink(m_flow=
           0.5, medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-88,22},{-68,42}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Fluid_Source_Sink
                                                         fluid_Source_Sink1(
        m_flow=5,
        medium=C2M2L_OM.MSL_Extend.Media.Essotherm650_80degC(),
        T=338.15) annotation (Placement(transformation(extent={{8,34},{28,54}})));
      C2M2L_Delivered_Component_Implementations.Fuel_System.Fuel_Tank
                            fuel_Tank(medium=
            C2M2L_OM.MSL_Extend.Media.Constant_Property_JP8())
        annotation (Placement(transformation(extent={{-254,-130},{-214,-70}})));
    equation

      connect(drive_Shaft1.frame_a, cross_Drive_without_TC.brg_03) annotation (
          Line(
          points={{80,-80},{60,-80},{60,-54}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft.frame_a, cross_Drive_without_TC.brg_02) annotation (
          Line(
          points={{80,40},{60,40},{60,8}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(const2.y, cross_Drive_without_TC.brake_apply_command) annotation (
          Line(
          points={{64,103},{58,103},{58,9.24},{50.5882,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(integerConstant.y, cross_Drive_without_TC.gear_selected)
        annotation (Line(
          points={{21,100},{38.8235,100},{38.8235,9.24}},
          color={255,127,0},
          smooth=Smooth.None));
      connect(step.y, cross_Drive_without_TC.steer_command) annotation (Line(
          points={{21,130},{36,130},{36,26},{31.7647,26},{31.7647,9.24}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.brg_01, example_Engine_Basic.brg_02) annotation (Line(
          points={{-80,-24},{-110,-24},{-110,-37.4118},{-154,-37.4118}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.brg_01, pTM_with_TC.brg_06) annotation (Line(
          points={{20,-23},{-10,-23},{-10,-24},{-40,-24}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area.solid, example_Engine_Basic.outer_surface_heat_port)
        annotation (Line(
          points={{-148,24},{-164.5,24},{-164.5,-12}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation.brg_01, drive_Shaft.frame_b)
        annotation (Line(
          points={{131.8,40},{100,40}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(drive_Shaft1.frame_b,
        example_Standalone_Final_Drive_Implementation1.brg_01) annotation (Line(
          points={{100,-80},{131.8,-80}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(example_Standalone_Final_Drive_Implementation1.brg_02,
        road_Wheel_Load_Both_Sides.lhs_flange) annotation (Line(
          points={{172,-79.8},{196,-79.8},{196,-28},{220,-28}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(road_Wheel_Load_Both_Sides.rhs_flange,
        example_Standalone_Final_Drive_Implementation.brg_02) annotation (Line(
          points={{220,-12},{196,-12},{196,40.2},{172,40.2}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(thermal_To_Environment_Thru_Area1.solid, pTM_with_TC.outer_surface_heat_port)
        annotation (Line(
          points={{-42,36},{-50,36},{-50,38},{-58,38},{-58,6}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing.exhaust_out, example_Engine_Basic.fluid_out)
        annotation (Line(
          points={{-190,18},{-190,9},{-187.39,9},{-187.39,-12}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.fluid_in, air_Path_For_Testing.intake_air)
        annotation (Line(
          points={{-196,-11.7882},{-202,-11.7882},{-202,18}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.to_rad, example_Engine_Basic.top_hose_outlet)
        annotation (Line(
          points={{-132,-16},{-144,-16},{-144,-22.5882},{-154,-22.5882}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing.from_rad, example_Engine_Basic.bottom_hose_in)
        annotation (Line(
          points={{-132,-28},{-146,-28},{-146,-48},{-154,-48}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.return_port, pTM_with_TC.flowPort_b) annotation (
          Line(
          points={{-72,22},{-74,22},{-74,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink.supply_port, pTM_with_TC.flowPort_a) annotation (
          Line(
          points={{-84,22},{-82,22},{-82,6},{-80,6}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(fluid_Source_Sink1.return_port, cross_Drive_without_TC.flowPort_b)
        annotation (Line(
          points={{24,34},{24,8},{27.0588,8}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cross_Drive_without_TC.flowPort_a, fluid_Source_Sink1.supply_port)
        annotation (Line(
          points={{20,8},{14,8},{14,34},{12,34}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(const1.y, pTM_with_TC.PTO2_clutch_apply_command) annotation (Line(
          points={{-106,75},{-90,75},{-90,74},{-70,74},{-70,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(const.y, pTM_with_TC.waterjet_clutch_apply_command) annotation (
          Line(
          points={{-54,147},{-64,147},{-64,7.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pTM_with_TC.lockup_torque_converter, booleanStep.y) annotation (
          Line(
          points={{-52,7.2},{-52,128},{-115,128}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(fuel_Tank.fluid_out, example_Engine_Basic.fuel_in) annotation (Line(
          points={{-242.2,-73.8},{-208.1,-73.8},{-208.1,-41.6471},{-196,-41.6471}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(example_Engine_Basic.from_cac, example_Engine_Basic.to_cac)
        annotation (Line(
          points={{-196,-20.4706},{-202,-20.4706},{-204,-20},{-208,-20},{-208,
              -24.7059},{-196,-24.7059}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(booleanConstant.y, example_Engine_Basic.starter_engage) annotation (
         Line(
          points={{-219,100},{-181.3,100},{-181.3,-10.9412}},
          color={255,0,255},
          smooth=Smooth.None));
      connect(demand.y, example_Engine_Basic.ECU_Throttle_Out) annotation (Line(
          points={{-219,130},{-175,130},{-175,-10.9412}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-260,-180},{300,180}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=80),
        __Dymola_experimentSetupOutput,
        Icon(coordinateSystem(extent={{-260,-180},{300,180}})));
    end no_controls_adv_worksInOM;

    model Integration_Example_Alt_Layout_Hyd_simple
      "Integration example with alternate layout of x-drive and ptm"
      extends C2M2L_Ext.Icons.Simple_Test_Case;
      parameter Real pi = Modelica.Constants.pi;

      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                          air_Path_For_Testing3(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{10,-10},{-10,10}},
            rotation=270,
            origin={184,256})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Reservoir           bReservoir(
          total_volume=0.1, hydraulic_fluid_accumulated_start=0.05)
                  annotation (Placement(transformation(extent={{-34,250},{6,310}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Radiators.Radiator_Main_Cooling_Pack
        aRadiator(
        core_length=1,
        core_width=1,
        core_depth=0.1,
        effec_spec=C2M2L_Ext.Fluid.Base_Classes.Effec_Spec.Q_per_ITD_Area,
        flow_effec_spec=C2M2L_Ext.Fluid.Base_Classes.Flow_Spec.mass_flow_rate,
        ref_core_length=1,
        ref_core_width=1,
        flow_spec_side_a=C2M2L_Ext.Fluid.Base_Classes.Flow_Spec.mass_flow_rate,
        flow_spec_side_b=C2M2L_Ext.Fluid.Base_Classes.Flow_Spec.mass_flow_rate,
        pressure_drop_b=[0,0; 5,10000],
        loss_spec_side_a=C2M2L_Ext.Fluid.Base_Classes.Loss_Spec.deltaP,
        loss_spec_side_b=C2M2L_Ext.Fluid.Base_Classes.Loss_Spec.deltaP,
        effectiveness_table=[0.0,0.0,0.1,0.2,0.3; 0.0,0.0,0.0,0.0,0.0; 0.1,0.0,500,800,
            800; 0.2,0.0,800,1000,1000; 0.3,0.0,800,1000,1000],
        ref_core_depth=0.1)
        annotation (Placement(transformation(extent={{-314,298},{-354,238}})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                return_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=270,
            origin={-392,252})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor
                                                top_hose(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=270,
            origin={-272,250})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Air_Path_For_Testing
                                          air_Path_For_Testing1(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Air_30degC(), T=313.15)
        annotation (Placement(transformation(extent={{10,-10},{-10,10}},
            rotation=270,
            origin={-164,268})));
      inner MSL_Extend.Environments.Lumped_Thermal_Fixed_HTC_Infinite
                                                  env(fixed_htc=200)
        annotation (Placement(transformation(extent={{-298,16},{-278,36}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Pump_Hydraulic
        eHydraulicPump(                fixed_efficiency=0.98, cc_per_rev=50)
        annotation (Placement(transformation(extent={{-20,-30},{20,30}},
            rotation=180,
            origin={78,-4})));
      Modelica.Blocks.Sources.TimeTable timeTable(table=[0,0.0; 5,0; 5,-1; 15,-1])
        annotation (Placement(transformation(extent={{172,124},{152,144}})));
      C2M2L_Delivered_Component_Implementations.Cooling_System.Fans.Hydraulic_Fan_Assembly
        cHydraulicFan(
        efficiency_characteristic=[0.0,0.7],
        N_ref=209.43951023932,
        N_switch=20.943951023932,
        rotating_inertia=0.1,
        vol_per_radian_motor=(50/1e6)/(2*pi),
        Nm_per_pascal_motor=(50/1e6)/(2*pi),
        leakage_motor=1e-7,
        flow_characteristic=[0,20000; 1,15000; 1.5,0],
        medium=Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(extent={{82,286},{122,226}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Manifold_Open_Center.Hydraulic_Manifold_Open_Center_1
        dHydraulicManifold(p_max=1e+13)
        annotation (Placement(transformation(extent={{58,54},{98,114}})));
      C2M2L_Delivered_Component_Implementations.Hydraulic.Hydraulic_Filter           fFilter(
          loss_factor=1.2e-3/4e5)                annotation (Placement(
            transformation(
            extent={{-20,-30},{20,30}},
            rotation=90,
            origin={8,204})));
      Modelica.Blocks.Sources.TimeTable timeTable1(table=[0,0.0; 10,0; 10,40; 30,80])
        annotation (Placement(transformation(extent={{222,-12},{202,8}})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
        cooling_Cart_For_Testing(medium=Modelica.Thermal.FluidHeatFlow.Media.Water())
        annotation (Placement(transformation(extent={{-354,196},{-334,216}})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor T_air_off_radiators1(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=270,
            origin={-228,296})));
      Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor T_air_off_radiators(medium=
            Modelica.Thermal.FluidHeatFlow.Media.Air_30degC())
        annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=270,
            origin={-124,342})));
      Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=false)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=180,
            origin={178,-2})));
      Modelica.Mechanics.Rotational.Components.Inertia inertia2(J=1)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}},
            rotation=180,
            origin={138,-2})));
      MSL_Extend.Testing_Blocks.Fluid_Source_Sinks.Cooling_Cart_For_Testing
        cooling_Cart_For_Testing1(medium=Modelica.Thermal.FluidHeatFlow.Media.Water(),
          p=199999.99)
        annotation (Placement(transformation(extent={{-246,186},{-226,206}})));
    equation

      connect(dHydraulicManifold.P, eHydraulicPump.hyd_out)             annotation (
         Line(
          points={{57,58},{40,58},{40,-10},{58,-10}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(dHydraulicManifold.u_1, timeTable.y)             annotation (Line(
          points={{62,116},{62,134},{151,134}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(fFilter.hyd_in, dHydraulicManifold.T)
        annotation (Line(
          points={{-1.77636e-015,186},{-1.77636e-015,104},{0,104},{0,28},{110,28},{110,
              58},{99,58}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(aRadiator.hot_fluid_out, return_hose.flowPort) annotation (Line(
          points={{-374,244},{-382,244},{-382,242},{-392,242}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(return_hose.flowPort, cooling_Cart_For_Testing.to_rad) annotation (
          Line(
          points={{-392,242},{-394,242},{-394,212},{-354,212}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(top_hose.flowPort, aRadiator.hot_fluid_in) annotation (Line(
          points={{-272,240},{-282,240},{-282,244},{-294,244}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(air_Path_For_Testing1.exhaust_out, T_air_off_radiators1.flowPort)
        annotation (Line(
          points={{-174,274},{-202,274},{-202,286},{-228,286}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(T_air_off_radiators1.flowPort, aRadiator.cold_fluid_in) annotation (
          Line(
          points={{-228,286},{-260,286},{-260,292},{-294,292}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(aRadiator.cold_fluid_out, T_air_off_radiators.flowPort) annotation (
          Line(
          points={{-374,292},{-404,292},{-404,332},{-124,332}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cHydraulicFan.hydraulic_Port_a, dHydraulicManifold.A_1) annotation (
          Line(
          points={{82,242},{82,140},{30,140},{30,68},{57,68}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(dHydraulicManifold.B_1, cHydraulicFan.hydraulic_Port_b) annotation (
          Line(
          points={{98.8,68},{138,68},{138,242},{122,242}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(air_Path_For_Testing3.exhaust_out, cHydraulicFan.flowPort_b)
        annotation (Line(
          points={{174,262},{122,262}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(cHydraulicFan.flowPort_a, T_air_off_radiators.flowPort) annotation (
          Line(
          points={{82,262},{30,262},{30,332},{-124,332}},
          color={255,0,0},
          smooth=Smooth.None));
      connect(bReservoir.hyd1, fFilter.hyd_out) annotation (Line(
          points={{-21.8,260},{0,260},{0,226}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(inertia2.flange_a,torque. flange) annotation (Line(
          points={{148,-2},{168,-2}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(timeTable1.y, torque.tau) annotation (Line(
          points={{201,-2},{190,-2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(inertia2.flange_b, eHydraulicPump.brg_01) annotation (Line(
          points={{128,-2},{98,-2}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(eHydraulicPump.hyd_in, bReservoir.hyd1) annotation (Line(
          points={{98,-10},{108,-10},{108,-48},{-21.8,-48},{-21.8,260}},
          color={255,0,128},
          smooth=Smooth.None));
      connect(cooling_Cart_For_Testing1.to_rad, top_hose.flowPort) annotation (Line(
          points={{-246,202},{-260,202},{-260,240},{-272,240}},
          color={255,0,0},
          smooth=Smooth.None));
      annotation (Diagram(coordinateSystem(extent={{-420,-60},{260,360}},
              preserveAspectRatio=false),
                          graphics),
        experiment(StopTime=200),
        __Dymola_experimentSetupOutput(events=false),
        Icon(coordinateSystem(extent={{-420,-60},{260,360}})));
    end Integration_Example_Alt_Layout_Hyd_simple;
  end C2M2L_Test_Assemblies;

  package Suspension_Ideal
      extends Modelica.Icons.Package;

    package Wheeled_Suspension
      extends Modelica.Icons.Package;

      package Component_Test_Cases
          extends C2M2L_Ext.Icons.Package_For_Simple_Test_Cases;

        model Susp_Module_Test_w_Steering_Components
          "System test that includes the suspension module, struts, steering components, and wheels. Demonstrates driveline inputs, steering capabilities, and suspension movement"

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-200,-20},{-180,0}})));

            replaceable Suspension_Module_Flange_Driveline_Brakes suspension_Module
            annotation (Placement(transformation(extent={{-40,-150},{40,-70}})));
          Modelica.Mechanics.Rotational.Sources.Position position(exact=true)
            annotation (Placement(transformation(extent={{-148,160},{-128,180}})));

            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Wheels.Wheel_w_Flange
                                              wheel_right
            annotation (Placement(transformation(extent={{100,-150},{140,-110}})));

            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Wheels.Wheel_w_Flange
                                              wheel_left
            annotation (Placement(transformation(extent={{-140,-150},{-100,-110}})));
          Modelica.Blocks.Sources.Sine sine1(
            freqHz=1,
            startTime=4,
            amplitude=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,190})));
          Modelica.Blocks.Sources.Ramp ramp(
            startTime=0,
            duration=3,
            height=-2500,
            offset=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-50})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-140,-60},{-120,-40}})));

            C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Centerlink
            centerlink                        annotation (Placement(transformation(
                extent={{-40,40},{40,-40}},
                rotation=0,
                origin={0,60})));
           Strut_w_Endstops    strut_left
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-80,-90})));
           Strut_w_Endstops    strut_right
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={80,-90})));
           C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_right annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,20})));
           C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_left  annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,20})));
          inner C2M2L_Ext.Testing_Blocks.Land.Terrains.Ground_Definition_2D ground_context(road=[-10,
                -0.1; 10,-0.1])
                   annotation (Placement(transformation(extent={{180,180},{200,200}})));

            C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Gear
            pitman
            annotation (Placement(transformation(extent={{-80,100},{-40,140}})));

            C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Back_Drive_Gear
            idler
            annotation (Placement(transformation(extent={{80,100},{40,140}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_left(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,-0.2})               annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_right(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,0.2})                annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
            specularCoefficient=0.3,
            animation=false,
            r={0,0,0})                        annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,-10})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-90,-40},{-70,-20}})));
          C2M2L_OM.Suspension_Ideal.Wheeled_Suspension.Test_Driver_Differential
                                                                                test_Driver
            annotation (Placement(transformation(extent={{-40,-200},{-20,-180}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-110,110},{-90,130}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{90,110},{110,130}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load testing_Load
            annotation (Placement(transformation(extent={{60,-200},{80,-180}})));
          inner Modelica.Fluid.System system
            annotation (Placement(transformation(extent={{100,180},{120,200}})));
          inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
            annotation (Placement(transformation(extent={{140,180},{160,200}})));
          Test_Driver_Brakes Brakes_control
            annotation (Placement(transformation(extent={{-80,-188},{-60,-168}})));
          Modelica.Blocks.Sources.Ramp ramp1(
            offset=0,
            height=1000,
            startTime=3,
            duration=0.5)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-90})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{-170,-80},{-150,-60}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(s(fixed=true), v(
                fixed=true))
            annotation (Placement(transformation(extent={{-170,-20},{-150,0}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        equation
          connect(sine1.y, position.phi_ref) annotation (Line(
              points={{-179,190},{-160,190},{-160,170},{-150,170}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_left, tierod_left.tierod_inner_connect)
            annotation (Line(
              points={{-40.8,60},{-60,60},{-60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.steer_left, tierod_left.tierod_outer_connect)
            annotation (Line(
              points={{-40,-94},{-60,-94},{-60,-0.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_right, tierod_right.tierod_inner_connect)
            annotation (Line(
              points={{40.8,60},{60,60},{60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tierod_right.tierod_outer_connect, suspension_Module.steer_right)
            annotation (Line(
              points={{60,-0.4},{60,-94},{40,-94}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_left, wheel_left.flange) annotation (Line(
              points={{-42,-110},{-60,-110},{-60,-130},{-120,-130}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_right, wheel_right.flange) annotation (Line(
              points={{42.4,-110},{60,-110},{60,-130},{120,-130}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, suspension_Module.frame_C) annotation (Line(
              points={{-120,-10},{0,-10},{0,-70}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_left.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,120},{-140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_right.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,148},{150,148},{150,120},{
                  140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver.differential_Control_Bus, suspension_Module.differential_Control_Bus)
            annotation (Line(
              points={{-20,-190},{-12,-190},{-12,-144}},
              color={255,0,255},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_attach_left.frame_b, flange1.bearingFrame) annotation (Line(
              points={{-120,120},{-100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position.flange, flange1.flange) annotation (Line(
              points={{-128,170},{-100,170},{-100,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_attach_right.frame_b, flange2.bearingFrame) annotation (Line(
              points={{120,120},{100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, suspension_Module.torque_input) annotation (Line(
              points={{-80,-30},{-80,-20},{-12,-20},{-12,-70}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(testing_Load.flange, suspension_Module.diff_to_diff) annotation (Line(
              points={{60,-190},{32,-190},{32,-158},{0,-158},{0,-150}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.arm_to_centerlink, centerlink.idler_connect) annotation (Line(
              points={{39.6,120},{16,120},{16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.arm_to_centerlink, centerlink.pitman_connect) annotation (Line(
              points={{-39.6,120},{-16,120},{-16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.gear_mount, flange1) annotation (Line(
              points={{-80,120},{-100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.gear_mount, flange2) annotation (Line(
              points={{80,120},{100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(Brakes_control.driver_Bus, suspension_Module.driver_Bus) annotation (
              Line(
              points={{-60,-178},{-48,-178},{-48,-144},{-24,-144}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(add.y, torque.tau) annotation (Line(
              points={{-149,-70},{-146,-70},{-146,-50},{-142,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ramp.y, add.u1) annotation (Line(
              points={{-179,-50},{-176,-50},{-176,-64},{-172,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ramp1.y, add.u2) annotation (Line(
              points={{-179,-90},{-176,-90},{-176,-76},{-172,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(world.frame_b, prismatic.frame_a) annotation (Line(
              points={{-180,-10},{-170,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-150,-10},{-145,-10},{-145,-10},{-140,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, inertia.flange_a) annotation (Line(
              points={{-120,-50},{-120,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_b, flange.flange) annotation (Line(
              points={{-100,-30},{-80,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(strut_right.frame_C, suspension_Module.strut_upper_right) annotation (
             Line(
              points={{80,-79.8},{80,-60},{20,-60},{20,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_C, suspension_Module.strut_upper_left) annotation (
              Line(
              points={{-80,-79.8},{-80,-60},{-20,-60},{-20,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_a, suspension_Module.strut_attach_right)
            annotation (Line(
              points={{80,-100.2},{80,-134},{40,-134}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_a, suspension_Module.strut_attach_left) annotation (
              Line(
              points={{-80,-100.2},{-80,-134},{-40,-134}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=8, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Susp_Module_Test_w_Steering_Components;

        model Susp_Module_Kinematic_Test
          "System test that includes the suspension module, struts, and steering components, and wheels. Demonstrates kinematic_suspension movement"
          extends C2M2L_Ext.Icons.Simple_Test_Case;

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-200,0},{-180,20}})));
          replaceable Suspension_Module_Flange_Driveline_Brakes suspension_Module
            annotation (Placement(transformation(extent={{-40,-92},{40,-12}})));
          Modelica.Blocks.Sources.Ramp ramp(
            startTime=0,
            offset=0,
            height=0.150,
            duration=3)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-170})));
          Strut_w_Endstops                strut_left
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-80,-30})));
          Strut_w_Endstops                strut_right
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={80,-30})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_right annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,40})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_left  annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,40})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
            specularCoefficient=0.3,
            animation=false,
            r={0,0,0})                        annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,10})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{110,-80},{130,-60}})));
          C2M2L_OM.Suspension_Ideal.Wheeled_Suspension.Test_Driver_Differential
                                                                                test_Driver
            annotation (Placement(transformation(extent={{-40,-142},{-20,-122}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load testing_Load
            annotation (Placement(transformation(extent={{20,-140},{40,-120}})));
          inner Modelica.Fluid.System system
            annotation (Placement(transformation(extent={{100,180},{120,200}})));
          inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
            annotation (Placement(transformation(extent={{140,180},{160,200}})));
          Test_Driver_Brakes Brakes_control
            annotation (Placement(transformation(extent={{-80,-130},{-60,-110}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic
            annotation (Placement(transformation(extent={{-170,0},{-150,20}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Y_Position_Driver
                                                y_Position_Driver annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={120,-150})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-130,-80},{-110,-60}})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_left(animation=false,
              r={0.0003,-1.0646,-1.1919})
            annotation (Placement(transformation(extent={{-160,-200},{-140,-180}})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_right(animation=
                false, r={0.0003,-1.0646,1.1919})
            annotation (Placement(transformation(extent={{160,-200},{140,-180}})));
          Modelica.Blocks.Sources.Constant
                                       const(k=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-30})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-170,-40},{-150,-20}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-140,-40},{-120,-20}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Centerlink
            centerlink                        annotation (Placement(transformation(
                extent={{-40,40},{40,-40}},
                rotation=0,
                origin={0,100})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation pitman_attach(r={0.2442,-0.0055,
                -0.2})
            annotation (Placement(transformation(extent={{-80,140},{-60,160}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation idler_attach(r={0.2442,-0.0055,
                0.2}) annotation (Placement(transformation(extent={{-20,160},{0,180}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Y_Position_Driver
                                                y_Position_Driver1
                                                                  annotation (Placement(
                transformation(
                extent={{-16,16},{16,-16}},
                rotation=90,
                origin={-120,-160})));
        equation
          connect(suspension_Module.steer_left, tierod_left.tierod_outer_connect)
            annotation (Line(
              points={{-40,-36},{-60,-36},{-60,19.6}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tierod_right.tierod_outer_connect, suspension_Module.steer_right)
            annotation (Line(
              points={{60,19.6},{60,-36},{40,-36}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, suspension_Module.frame_C) annotation (Line(
              points={{-120,10},{0,10},{0,-12}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver.differential_Control_Bus, suspension_Module.differential_Control_Bus)
            annotation (Line(
              points={{-20,-132},{-12,-132},{-12,-86}},
              color={255,0,255},
              thickness=0.5,
              smooth=Smooth.None));
          connect(testing_Load.flange, suspension_Module.diff_to_diff) annotation (Line(
              points={{20,-130},{0,-130},{0,-92}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(Brakes_control.driver_Bus, suspension_Module.driver_Bus) annotation (
              Line(
              points={{-60,-120},{-48,-120},{-48,-86},{-24,-86}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, prismatic.frame_a) annotation (Line(
              points={{-180,10},{-170,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-150,10},{-145,10},{-145,10},{-140,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));

          connect(y_Position_Driver.frame_b, flange.bearingFrame) annotation (Line(
              points={{120,-134},{120,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position_ground_right.frame_b, y_Position_Driver.frame_a) annotation (
             Line(
              points={{140,-190},{120,-190},{120,-166}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, flange2.flange) annotation (Line(
              points={{-150,-30},{-130,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(flange2, suspension_Module.torque_input) annotation (Line(
              points={{-130,-30},{-130,-4},{-12,-4},{-12,-12}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.tau, const.y) annotation (Line(
              points={{-172,-30},{-179,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_right, tierod_right.tierod_inner_connect)
            annotation (Line(
              points={{40.8,100},{60,100},{60,60.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_left, tierod_left.tierod_inner_connect)
            annotation (Line(
              points={{-40.8,100},{-60,100},{-60,60.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler_attach.frame_b, centerlink.idler_connect) annotation (Line(
              points={{0,170},{16,170},{16,140.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler_attach.frame_a, fixedTranslation.frame_b) annotation (Line(
              points={{-20,170},{-160,170},{-160,40},{-120,40},{-120,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.pitman_connect, pitman_attach.frame_b) annotation (Line(
              points={{-16,140.8},{-16,150},{-60,150}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman_attach.frame_a, fixedTranslation.frame_b) annotation (Line(
              points={{-80,150},{-160,150},{-160,40},{-120,40},{-120,10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_right, flange) annotation (Line(
              points={{42.4,-52},{120,-52},{120,-70}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_left, flange1) annotation (Line(
              points={{-42,-52},{-120,-52},{-120,-70}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));

          connect(y_Position_Driver1.frame_b, flange1.bearingFrame) annotation (Line(
              points={{-120,-144},{-120,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(y_Position_Driver1.frame_a, position_ground_left.frame_b) annotation (
             Line(
              points={{-120,-176},{-120,-190},{-140,-190}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(ramp.y, y_Position_Driver.TestInput) annotation (Line(
              points={{-2.02067e-015,-181},{-2.02067e-015,-190},{110,-190},{110,-167.4}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(y_Position_Driver1.TestInput, ramp.y) annotation (Line(
              points={{-110,-177.4},{-110,-190},{-2.02067e-015,-190},{-2.02067e-015,
                  -181}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(strut_left.frame_C, suspension_Module.strut_upper_left) annotation (
              Line(
              points={{-80,-19.8},{-80,0},{-20,0},{-20,-12}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_C, suspension_Module.strut_upper_right) annotation (
             Line(
              points={{80,-19.8},{80,0},{20,0},{20,-12}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_a, suspension_Module.strut_attach_right)
            annotation (Line(
              points={{80,-40.2},{80,-76},{40,-76}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_a, suspension_Module.strut_attach_left) annotation (
              Line(
              points={{-80,-40.2},{-80,-76},{-40,-76}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=3, NumberOfIntervals=600),
            __Dymola_experimentSetupOutput);
        end Susp_Module_Kinematic_Test;

        model Susp_Module_Kinematic_Test_2
          "System test that includes the suspension module, struts, steering components, and wheels. Demonstrates driveline inputs, steering capabilities, and suspension movement"

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-200,-20},{-180,0}})));
          replaceable Suspension_Module_Flange_Driveline_Brakes suspension_Module
            annotation (Placement(transformation(extent={{-40,-112},{40,-32}})));
          Modelica.Mechanics.Rotational.Sources.Position position(exact=true)
            annotation (Placement(transformation(extent={{-148,160},{-128,180}})));
          Modelica.Blocks.Sources.Sine sine1(
            freqHz=1,
            startTime=4,
            amplitude=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,190})));
          Modelica.Blocks.Sources.Ramp ramp(
            startTime=0,
            duration=3,
            offset=0,
            height=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-50})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-170,-60},{-150,-40}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Centerlink
            centerlink                        annotation (Placement(transformation(
                extent={{-40,40},{40,-40}},
                rotation=0,
                origin={0,60})));
          Strut_w_Endstops                strut_left
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-80,-50})));
          Strut_w_Endstops                strut_right
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={80,-50})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_right annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,20})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_left  annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,20})));
          inner C2M2L_Ext.Testing_Blocks.Land.Terrains.Ground_Definition_2D
            ground annotation (Placement(transformation(extent={{180,180},{200,200}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Gear
            pitman
            annotation (Placement(transformation(extent={{-80,100},{-40,140}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Back_Drive_Gear
            idler
            annotation (Placement(transformation(extent={{80,100},{40,140}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_left(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,-0.2})               annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_right(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,0.2})                annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.2,0})                     annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,-10})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-120,-60},{-100,-40}})));
          C2M2L_OM.Suspension_Ideal.Wheeled_Suspension.Test_Driver_Differential
                                                                                test_Driver
            annotation (Placement(transformation(extent={{-40,-162},{-20,-142}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-110,110},{-90,130}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{90,110},{110,130}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load testing_Load
            annotation (Placement(transformation(extent={{60,-162},{80,-142}})));
          inner Modelica.Fluid.System system
            annotation (Placement(transformation(extent={{100,180},{120,200}})));
          inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
            annotation (Placement(transformation(extent={{140,180},{160,200}})));
          Test_Driver_Brakes Brakes_control
            annotation (Placement(transformation(extent={{-80,-150},{-60,-130}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(s(fixed=true), v(
                fixed=true))
            annotation (Placement(transformation(extent={{-170,-20},{-150,0}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-140,-60},{-120,-40}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Y_Position_Driver
                                                y_Position_Driver1
                                                                  annotation (Placement(
                transformation(
                extent={{-16,16},{16,-16}},
                rotation=90,
                origin={-120,-160})));
          Modelica.Blocks.Sources.Ramp ramp2(
            startTime=0,
            offset=0,
            height=0.150,
            duration=3)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-170})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Y_Position_Driver
                                                y_Position_Driver annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={120,-160})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_right(animation=
                false, r={0.0003,-1.2646,1.1919})
            annotation (Placement(transformation(extent={{160,-200},{140,-180}})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_left(animation=false, r={
                0.0003,-1.2646,-1.1919})
            annotation (Placement(transformation(extent={{-160,-200},{-140,-180}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange3(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-130,-120},{-110,-100}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange4(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{110,-120},{130,-100}})));
        equation
          connect(sine1.y, position.phi_ref) annotation (Line(
              points={{-179,190},{-160,190},{-160,170},{-150,170}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_left, tierod_left.tierod_inner_connect)
            annotation (Line(
              points={{-40.8,60},{-60,60},{-60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.steer_left, tierod_left.tierod_outer_connect)
            annotation (Line(
              points={{-40,-56},{-60,-56},{-60,-0.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_right, tierod_right.tierod_inner_connect)
            annotation (Line(
              points={{40.8,60},{60,60},{60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tierod_right.tierod_outer_connect, suspension_Module.steer_right)
            annotation (Line(
              points={{60,-0.4},{60,-56},{40,-56}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, suspension_Module.frame_C) annotation (Line(
              points={{-120,-10},{0,-10},{0,-32}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_left.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,120},{-140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_right.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,148},{150,148},{150,120},{
                  140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver.differential_Control_Bus, suspension_Module.differential_Control_Bus)
            annotation (Line(
              points={{-20,-152},{-12,-152},{-12,-106}},
              color={255,0,255},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_attach_left.frame_b, flange1.bearingFrame) annotation (Line(
              points={{-120,120},{-100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position.flange, flange1.flange) annotation (Line(
              points={{-128,170},{-100,170},{-100,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_attach_right.frame_b, flange2.bearingFrame) annotation (Line(
              points={{120,120},{100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, suspension_Module.torque_input) annotation (Line(
              points={{-110,-50},{-110,-24},{-12,-24},{-12,-32}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(testing_Load.flange, suspension_Module.diff_to_diff) annotation (Line(
              points={{60,-152},{32,-152},{32,-120},{0,-120},{0,-112}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.arm_to_centerlink, centerlink.idler_connect) annotation (Line(
              points={{39.6,120},{16,120},{16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.arm_to_centerlink, centerlink.pitman_connect) annotation (Line(
              points={{-39.6,120},{-16,120},{-16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.gear_mount, flange1) annotation (Line(
              points={{-80,120},{-100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.gear_mount, flange2) annotation (Line(
              points={{80,120},{100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(Brakes_control.driver_Bus, suspension_Module.driver_Bus) annotation (
              Line(
              points={{-60,-140},{-48,-140},{-48,-106},{-24,-106}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, prismatic.frame_a) annotation (Line(
              points={{-180,-10},{-170,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-150,-10},{-145,-10},{-145,-10},{-140,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, inertia.flange_a) annotation (Line(
              points={{-150,-50},{-140,-50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_b, flange.flange) annotation (Line(
              points={{-120,-50},{-110,-50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(ramp2.y, y_Position_Driver1.TestInput) annotation (Line(
              points={{-2.02067e-015,-181},{-2.02067e-015,-190},{-110,-190},{-110,
                  -177.4}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(ramp2.y, y_Position_Driver.TestInput)
                                                       annotation (Line(
              points={{-2.02067e-015,-181},{-2.02067e-015,-190},{110,-190},{110,-177.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(position_ground_right.frame_b,y_Position_Driver. frame_a) annotation (
             Line(
              points={{140,-190},{120,-190},{120,-176}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position_ground_left.frame_b,y_Position_Driver1. frame_a) annotation (
             Line(
              points={{-140,-190},{-120,-190},{-120,-176}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(ramp.y, torque.tau) annotation (Line(
              points={{-179,-50},{-172,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(y_Position_Driver.frame_b, flange4.bearingFrame) annotation (Line(
              points={{120,-144},{120,-110}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(y_Position_Driver1.frame_b, flange3.bearingFrame) annotation (Line(
              points={{-120,-144},{-120,-110}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_right, flange4) annotation (Line(
              points={{42.4,-72},{120,-72},{120,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_left, flange3) annotation (Line(
              points={{-42,-72},{-120,-72},{-120,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_C, suspension_Module.strut_upper_left) annotation (
              Line(
              points={{-80,-39.8},{-80,-20},{-20,-20},{-20,-32}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_a, suspension_Module.strut_attach_left) annotation (
              Line(
              points={{-80,-60.2},{-80,-96},{-40,-96}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_a, suspension_Module.strut_attach_right)
            annotation (Line(
              points={{80,-60.2},{80,-96},{40,-96}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_C, suspension_Module.strut_upper_right) annotation (
             Line(
              points={{80,-39.8},{80,-20},{20,-20},{20,-32}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=8, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Susp_Module_Kinematic_Test_2;

        model Susp_Module_Test_w_Steering_Components_Rill
          "System test that includes the suspension module, struts, steering components, and wheels. Demonstrates driveline inputs, steering capabilities, and suspension movement.  Using Rill Tires"
          extends C2M2L_Ext.Icons.Simple_Test_Case;

          inner replaceable block Road =
            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Environments.NoGraphicsRoad
            constrainedby
            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Environments.Interfaces.TyreRoadInterface;

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-200,-20},{-180,0}})));
          replaceable Suspension_Module_Flange_Driveline_Brakes suspension_Module
            annotation (Placement(transformation(extent={{-40,-150},{40,-70}})));
          Modelica.Mechanics.Rotational.Sources.Position position(exact=false)
            annotation (Placement(transformation(extent={{-148,160},{-128,180}})));
           Wheel_Rill_FLANGE       wheel_right
            annotation (Placement(transformation(extent={{100,-150},{140,-110}})));
           Wheel_Rill_FLANGE       wheel_left
            annotation (Placement(transformation(extent={{-100,-150},{-140,-110}})));
          Modelica.Blocks.Sources.Sine sine1(
            freqHz=1,
            startTime=4,
            amplitude=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,190})));
          Modelica.Blocks.Sources.Ramp ramp(
            startTime=0,
            duration=3,
            height=-2500,
            offset=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-50})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-140,-60},{-120,-40}})));

            C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Centerlink
            centerlink                        annotation (Placement(transformation(
                extent={{-40,40},{40,-40}},
                rotation=0,
                origin={0,60})));
           Strut_w_Endstops    strut_left
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-80,-90})));
           Strut_w_Endstops    strut_right
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={80,-90})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_right annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,20})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_left  annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,20})));

          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Gear
            pitman
            annotation (Placement(transformation(extent={{-80,100},{-40,140}})));

          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Back_Drive_Gear
            idler
            annotation (Placement(transformation(extent={{80,100},{40,140}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_left(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,-0.2})               annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_right(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,0.2})                annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.2,0})                     annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,-10})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-90,-40},{-70,-20}})));
          C2M2L_OM.Suspension_Ideal.Wheeled_Suspension.Test_Driver_Differential
                                                                                test_Driver
            annotation (Placement(transformation(extent={{-40,-200},{-20,-180}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-110,110},{-90,130}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{90,110},{110,130}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load testing_Load
            annotation (Placement(transformation(extent={{60,-200},{80,-180}})));
          inner Modelica.Fluid.System system
            annotation (Placement(transformation(extent={{100,180},{120,200}})));
          inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
            annotation (Placement(transformation(extent={{140,180},{160,200}})));
          Test_Driver_Brakes Brakes_control
            annotation (Placement(transformation(extent={{-80,-188},{-60,-168}})));
          Modelica.Blocks.Sources.Ramp ramp1(
            offset=0,
            height=1000,
            startTime=3,
            duration=0.5)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-90})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{-170,-80},{-150,-60}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(s(fixed=true), v(
                fixed=true))
            annotation (Placement(transformation(extent={{-170,-20},{-150,0}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        equation
          connect(sine1.y, position.phi_ref) annotation (Line(
              points={{-179,190},{-160,190},{-160,170},{-150,170}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_left, tierod_left.tierod_inner_connect)
            annotation (Line(
              points={{-40.8,60},{-60,60},{-60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.steer_left, tierod_left.tierod_outer_connect)
            annotation (Line(
              points={{-40,-94},{-60,-94},{-60,-0.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_right, tierod_right.tierod_inner_connect)
            annotation (Line(
              points={{40.8,60},{60,60},{60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tierod_right.tierod_outer_connect, suspension_Module.steer_right)
            annotation (Line(
              points={{60,-0.4},{60,-94},{40,-94}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, suspension_Module.frame_C) annotation (Line(
              points={{-120,-10},{0,-10},{0,-70}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_left.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,120},{-140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_right.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,148},{150,148},{150,120},{
                  140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver.differential_Control_Bus, suspension_Module.differential_Control_Bus)
            annotation (Line(
              points={{-20,-190},{-12,-190},{-12,-144}},
              color={255,0,255},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_attach_left.frame_b, flange1.bearingFrame) annotation (Line(
              points={{-120,120},{-100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position.flange, flange1.flange) annotation (Line(
              points={{-128,170},{-100,170},{-100,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_attach_right.frame_b, flange2.bearingFrame) annotation (Line(
              points={{120,120},{100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, suspension_Module.torque_input) annotation (Line(
              points={{-80,-30},{-80,-20},{-12,-20},{-12,-70}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(testing_Load.flange, suspension_Module.diff_to_diff) annotation (Line(
              points={{60,-190},{32,-190},{32,-158},{0,-158},{0,-150}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.arm_to_centerlink, centerlink.idler_connect) annotation (Line(
              points={{39.6,120},{16,120},{16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.arm_to_centerlink, centerlink.pitman_connect) annotation (Line(
              points={{-39.6,120},{-16,120},{-16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.gear_mount, flange1) annotation (Line(
              points={{-80,120},{-100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.gear_mount, flange2) annotation (Line(
              points={{80,120},{100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(Brakes_control.driver_Bus, suspension_Module.driver_Bus) annotation (
              Line(
              points={{-60,-178},{-48,-178},{-48,-144},{-24,-144}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(add.y, torque.tau) annotation (Line(
              points={{-149,-70},{-146,-70},{-146,-50},{-142,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ramp.y, add.u1) annotation (Line(
              points={{-179,-50},{-176,-50},{-176,-64},{-172,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(ramp1.y, add.u2) annotation (Line(
              points={{-179,-90},{-176,-90},{-176,-76},{-172,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(world.frame_b, prismatic.frame_a) annotation (Line(
              points={{-180,-10},{-170,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-150,-10},{-145,-10},{-145,-10},{-140,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, inertia.flange_a) annotation (Line(
              points={{-120,-50},{-120,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_b, flange.flange) annotation (Line(
              points={{-100,-30},{-80,-30}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(wheel_left.carrierFrame, suspension_Module.wheel_left) annotation (
              Line(
              points={{-100,-130},{-60,-130},{-60,-110},{-42,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(wheel_right.carrierFrame, suspension_Module.wheel_right) annotation (
              Line(
              points={{100,-130},{60,-130},{60,-110},{42.4,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_C, suspension_Module.strut_upper_right) annotation (
             Line(
              points={{80,-79.8},{80,-60},{20,-60},{20,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.strut_upper_left, strut_left.frame_C) annotation (
              Line(
              points={{-20,-70},{-20,-60},{-80,-60},{-80,-79.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_a, suspension_Module.strut_attach_right)
            annotation (Line(
              points={{80,-100.2},{80,-134},{40,-134}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.strut_attach_left, strut_left.frame_a) annotation (
              Line(
              points={{-40,-134},{-80,-134},{-80,-100.2}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=8, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Susp_Module_Test_w_Steering_Components_Rill;

        model TEST_RillTyre_FLANGE
          extends C2M2L_Ext.Icons.Simple_Test_Case;

          inner replaceable block Road =
            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Environments.NoGraphicsRoad
            constrainedby
            C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Environments.Interfaces.TyreRoadInterface;

          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          inner Modelica.Mechanics.MultiBody.World world(gravityType=Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity,
              n={0,-1,0})
            annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
          Modelica.Blocks.Sources.Sine steer_signal(
            freqHz=0.5,
            amplitude=pi/8,
            startTime=1.5)
                         annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
          Modelica.Mechanics.Rotational.Sources.Position steer_position(
            useSupport=true,
            exact=false,
            f_crit=500)                                              annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-70,-20})));
          Modelica.Mechanics.MultiBody.Joints.Revolute steering_joint(
            useAxisFlange=true,
            cylinderColor={255,155,0},
            n={0,1,0})            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-10,-10})));
          Modelica.Blocks.Sources.Trapezoid torque_signal(
            period=10,
            offset=0,
            width=1,
            rising=1,
            falling=1,
            startTime=1,
            nperiod=1,
            amplitude=-120)
                         annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          replaceable Wheel_Rill_FLANGE
            wheel
            annotation (Placement(transformation(extent={{60,0},{80,20}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
                         animation=false, r={0,1,0})
            annotation (Placement(transformation(extent={{-70,-100},{-50,-80}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic_x(n={1,0,0})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-30,-90})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic_y(n={0,1,0})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-10,-70})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic_z(n={0,0,1})
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-10,-40})));
        equation
          connect(steer_position.phi_ref, steer_signal.y)
                                             annotation (Line(
              points={{-70,-32},{-70,-40},{-79,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(steer_position.flange, steering_joint.axis)
                                                  annotation (Line(
              points={{-70,-10},{-20,-10}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(steering_joint.support, steer_position.support)
                                                      annotation (Line(
              points={{-20,-16},{-20,-20},{-60,-20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(torque_signal.y, torque.tau)
                                      annotation (Line(
              points={{-59,50},{-42,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(world.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-80,-90},{-70,-90}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, flange.flange) annotation (Line(
              points={{-20,50},{30,50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(flange, wheel.carrierFrame) annotation (Line(
              points={{30,50},{60,50},{60,10}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic_y.frame_b, prismatic_z.frame_a)
                                                          annotation (Line(
              points={{-10,-60},{-10,-50}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic_z.frame_b, steering_joint.frame_a)
                                                        annotation (Line(
              points={{-10,-30},{-10,-20}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, prismatic_x.frame_a)
                                                                annotation (Line(
              points={{-50,-90},{-40,-90}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic_x.frame_b, prismatic_y.frame_a)
                                                          annotation (Line(
              points={{-20,-90},{-10,-90},{-10,-80}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(steering_joint.frame_b, flange.bearingFrame)
                                                         annotation (Line(
              points={{-10,0},{-10,20},{30,20},{30,50}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(graphics),
            experiment(StopTime=10, NumberOfIntervals=5000),
            __Dymola_experimentSetupOutput);
        end TEST_RillTyre_FLANGE;

        model Strut_test "Simple motion test of suspension strut"
          extends C2M2L_Ext.Icons.Simple_Test_Case;

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-80,-80},{-60,-60}})));
          replaceable Strut_w_Endstops strut
            annotation (Placement(transformation(extent={{20,20},{60,60}})));
          Modelica.Blocks.Sources.Sine sine(
            startTime=1,
            amplitude=0.5,
            freqHz=0.25)
            annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Y_Position_Driver
                                                y_Position_Driver annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={40,-20})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation upper_attach(animation=
                false, r={0,0.75,0})
            annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
        equation
          connect(strut.frame_a, y_Position_Driver.frame_b) annotation (Line(
              points={{40,19.6},{40,-4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(sine.y, y_Position_Driver.TestInput) annotation (Line(
              points={{1,-50},{30,-50},{30,-37.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(strut.frame_C, upper_attach.frame_b) annotation (Line(
              points={{40,60.4},{40,70},{-20,70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(upper_attach.frame_a, world.frame_b) annotation (Line(
              points={{-40,70},{-50,70},{-50,-70},{-60,-70}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, y_Position_Driver.frame_a) annotation (Line(
              points={{-60,-70},{40,-70},{40,-36}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Strut_test;

        model Parking_Brake_Test
          extends C2M2L_Ext.Icons.Simple_Test_Case;

          replaceable Parking_Brake_Module
                               parking_Brake_Module constrainedby
            Parking_Brake_Module
            annotation (Placement(transformation(extent={{-20,-20},{20,20}})));
          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          Modelica.Mechanics.Rotational.Sources.Torque    torque
            annotation (Placement(transformation(extent={{80,20},{60,40}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          Modelica.Blocks.Sources.Ramp ramp(              duration=1, height=-10000)
            annotation (Placement(transformation(extent={{60,60},{80,80}})));
          Test_Driver_Parking_Brake   test_Driver_Parking_Brake
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
        equation
          connect(parking_Brake_Module.knuckle, flange) annotation (Line(
              points={{-20,0},{-50,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, flange.bearingFrame) annotation (Line(
              points={{-80,0},{-50,0}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver_Parking_Brake.driver_Bus, parking_Brake_Module.driver_Bus)
            annotation (Line(
              points={{-40,50},{-17,50},{-17,17}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, flange1.flange) annotation (Line(
              points={{60,30},{50,30},{50,0}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(ramp.y, torque.tau) annotation (Line(
              points={{81,70},{90,70},{90,30},{82,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(flange1, parking_Brake_Module.wheel) annotation (Line(
              points={{50,0},{20,0}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(graphics),
            experiment(StopTime=5, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Parking_Brake_Test;

        model Susp_Module_Test_w_Steering_Components_2
          "System test that includes the suspension module, struts, steering components, and wheels. Demonstrates driveline inputs, steering capabilities, and suspension movement"

          inner Modelica.Mechanics.MultiBody.World world(g=9.81)
            annotation (Placement(transformation(extent={{-200,-20},{-180,0}})));
          replaceable Suspension_Module_Flange_Driveline_Brakes suspension_Module
            annotation (Placement(transformation(extent={{-40,-112},{40,-32}})));
          Modelica.Mechanics.Rotational.Sources.Position position(exact=true)
            annotation (Placement(transformation(extent={{-148,160},{-128,180}})));
          Modelica.Blocks.Sources.Sine sine1(
            freqHz=1,
            startTime=4,
            amplitude=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,190})));
          Modelica.Blocks.Sources.Ramp ramp(
            startTime=0,
            duration=3,
            offset=0,
            height=0)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-190,-50})));
          Modelica.Mechanics.Rotational.Sources.Torque torque
            annotation (Placement(transformation(extent={{-140,-60},{-120,-40}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Centerlink
            centerlink                        annotation (Placement(transformation(
                extent={{-40,40},{40,-40}},
                rotation=0,
                origin={0,60})));
          Strut_w_Endstops                strut_left
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-110,50})));
          Strut_w_Endstops                strut_right
                               annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={110,50})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation strut_attach_left(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={-0.1718,0.5632,-0.5903})       annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,90})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation strut_attach_right(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={-0.1718,0.5632,0.5903})        annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=0,
                origin={130,90})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_right annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={60,20})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Tierod
            tierod_left  annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=270,
                origin={-60,20})));
          inner
            C2M2L_Ext.C2M2L_Component_Building_Blocks.Suspension.Contact_Models.Ground_Definition_2D
            ground annotation (Placement(transformation(extent={{180,180},{200,200}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Gear
            pitman
            annotation (Placement(transformation(extent={{-80,100},{-40,140}})));
          C2M2L_Ext.C2M2L_Delivered_Component_Implementations.Wheeled_Steering.Steering_Arm_w_Back_Drive_Gear
            idler
            annotation (Placement(transformation(extent={{80,100},{40,140}})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_left(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,-0.2})               annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation arm_attach_right(
            color={255,0,0},
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.0055,0.2})                annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={130,120})));
          Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(
            specularCoefficient=0.3,
            animation=false,
            r={0,-0.2,0})                     annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={-130,-10})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
          C2M2L_OM.Suspension_Ideal.Wheeled_Suspension.Test_Driver_Differential
                                                                                test_Driver
            annotation (Placement(transformation(extent={{-40,-162},{-20,-142}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange1(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-110,110},{-90,130}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange2(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{90,110},{110,130}})));
          C2M2L_Ext.Testing_Blocks.Mechanical_Source_Sinks.Testing_Load testing_Load
            annotation (Placement(transformation(extent={{60,-162},{80,-142}})));
          inner Modelica.Fluid.System system
            annotation (Placement(transformation(extent={{100,180},{120,200}})));
          inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
            annotation (Placement(transformation(extent={{140,180},{160,200}})));
          Test_Driver_Brakes Brakes_control
            annotation (Placement(transformation(extent={{-80,-150},{-60,-130}})));
          Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(s(fixed=true), v(
                fixed=true))
            annotation (Placement(transformation(extent={{-170,-20},{-150,0}})));
          Modelica.Mechanics.Rotational.Components.Inertia inertia(J=1)
            annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
          C2M2L_Ext.Testing_Blocks.Land.Y_Position_Driver y_Position_Driver1
                                                                  annotation (Placement(
                transformation(
                extent={{-16,16},{16,-16}},
                rotation=90,
                origin={-100,-160})));
          Modelica.Blocks.Sources.Ramp ramp2(
            startTime=0,
            offset=0,
            height=0.150,
            duration=3)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-170})));
          C2M2L_Ext.Testing_Blocks.Land.Y_Position_Driver y_Position_Driver
                                                                  annotation (Placement(
                transformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={100,-160})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_right(animation=
                false, r={0.0003,-1.2646,1.1919})
            annotation (Placement(transformation(extent={{160,-200},{140,-180}})));
          Modelica.Mechanics.MultiBody.Parts.Fixed position_ground_left(animation=false, r={
                0.0003,-1.2646,-1.1919})
            annotation (Placement(transformation(extent={{-160,-200},{-140,-180}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange3(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{-110,-120},{-90,-100}})));
          Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing flange4(
              includeBearingConnector=true)
            annotation (Placement(transformation(extent={{90,-120},{110,-100}})));
        equation
          connect(sine1.y, position.phi_ref) annotation (Line(
              points={{-179,190},{-160,190},{-160,170},{-150,170}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(strut_right.frame_a, suspension_Module.strut_attach_right)
            annotation (Line(
              points={{110,39.8},{110,-20},{40,-20},{40,-96}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_left.frame_a, suspension_Module.strut_attach_left) annotation (
              Line(
              points={{-110,39.8},{-110,-20},{-40,-20},{-40,-96}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_attach_left.frame_b, strut_left.frame_C) annotation (Line(
              points={{-120,90},{-110,90},{-110,60.2}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(strut_right.frame_C, strut_attach_right.frame_b) annotation (Line(
              points={{110,60.2},{110,90},{120,90}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_left, tierod_left.tierod_inner_connect)
            annotation (Line(
              points={{-40.8,60},{-60,60},{-60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.steer_left, tierod_left.tierod_outer_connect)
            annotation (Line(
              points={{-40,-56},{-60,-56},{-60,-0.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(centerlink.tierod_inner_right, tierod_right.tierod_inner_connect)
            annotation (Line(
              points={{40.8,60},{60,60},{60,40.4}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(tierod_right.tierod_outer_connect, suspension_Module.steer_right)
            annotation (Line(
              points={{60,-0.4},{60,-56},{40,-56}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, suspension_Module.frame_C) annotation (Line(
              points={{-120,-10},{0,-10},{0,-32}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, strut_attach_left.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,90},{-140,90}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_left.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,120},{-140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, strut_attach_right.frame_a) annotation (
              Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,148},{150,148},{150,90},{140,
                  90}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(fixedTranslation.frame_b, arm_attach_right.frame_a) annotation (Line(
              points={{-120,-10},{-120,20},{-160,20},{-160,148},{150,148},{150,120},{
                  140,120}},
              color={95,95,95},
              pattern=LinePattern.None,
              thickness=0.5,
              smooth=Smooth.None));
          connect(test_Driver.differential_Control_Bus, suspension_Module.differential_Control_Bus)
            annotation (Line(
              points={{-20,-152},{-12,-152},{-12,-106}},
              color={255,0,255},
              thickness=0.5,
              smooth=Smooth.None));
          connect(arm_attach_left.frame_b, flange1.bearingFrame) annotation (Line(
              points={{-120,120},{-100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position.flange, flange1.flange) annotation (Line(
              points={{-128,170},{-100,170},{-100,120}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(arm_attach_right.frame_b, flange2.bearingFrame) annotation (Line(
              points={{120,120},{100,120}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(flange, suspension_Module.torque_input) annotation (Line(
              points={{-90,-50},{-80,-50},{-80,-24},{-12,-24},{-12,-32}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(testing_Load.flange, suspension_Module.diff_to_diff) annotation (Line(
              points={{60,-152},{32,-152},{32,-120},{0,-120},{0,-112}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.arm_to_centerlink, centerlink.idler_connect) annotation (Line(
              points={{39.6,120},{16,120},{16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.arm_to_centerlink, centerlink.pitman_connect) annotation (Line(
              points={{-39.6,120},{-16,120},{-16,100.8}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(pitman.gear_mount, flange1) annotation (Line(
              points={{-80,120},{-100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(idler.gear_mount, flange2) annotation (Line(
              points={{80,120},{100,120}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(Brakes_control.driver_Bus, suspension_Module.driver_Bus) annotation (
              Line(
              points={{-60,-140},{-48,-140},{-48,-106},{-24,-106}},
              color={255,85,85},
              thickness=0.5,
              smooth=Smooth.None));
          connect(world.frame_b, prismatic.frame_a) annotation (Line(
              points={{-180,-10},{-170,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(prismatic.frame_b, fixedTranslation.frame_a) annotation (Line(
              points={{-150,-10},{-145,-10},{-145,-10},{-140,-10}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(torque.flange, inertia.flange_a) annotation (Line(
              points={{-120,-50},{-120,-40}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(inertia.flange_b, flange.flange) annotation (Line(
              points={{-100,-40},{-92,-40},{-92,-50},{-90,-50}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(ramp2.y, y_Position_Driver1.TestInput) annotation (Line(
              points={{-2.02067e-015,-181},{-2.02067e-015,-190},{-90,-190},{-90,-177.4}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(ramp2.y, y_Position_Driver.TestInput)
                                                       annotation (Line(
              points={{-2.02067e-015,-181},{-2.02067e-015,-190},{90,-190},{90,-177.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(position_ground_right.frame_b,y_Position_Driver. frame_a) annotation (
             Line(
              points={{140,-190},{100,-190},{100,-176}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(position_ground_left.frame_b,y_Position_Driver1. frame_a) annotation (
             Line(
              points={{-140,-190},{-100,-190},{-100,-176}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(ramp.y, torque.tau) annotation (Line(
              points={{-179,-50},{-142,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(y_Position_Driver.frame_b, flange4.bearingFrame) annotation (Line(
              points={{100,-144},{100,-110}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(y_Position_Driver1.frame_b, flange3.bearingFrame) annotation (Line(
              points={{-100,-144},{-100,-110}},
              color={95,95,95},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_right, flange4) annotation (Line(
              points={{42.4,-72},{100,-72},{100,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          connect(suspension_Module.wheel_left, flange3) annotation (Line(
              points={{-42,-72},{-100,-72},{-100,-110}},
              color={135,135,135},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                    200}})),
            experiment(StopTime=8, Interval=0.001),
            __Dymola_experimentSetupOutput);
        end Susp_Module_Test_w_Steering_Components_2;
      end Component_Test_Cases;

      model Strut_w_Endstops
        "Strut - Integrated spring-damper unit.  Includes bumpstop and rebound stop, and metric to read strut length."
          extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        parameter SI.Mass m_strut=1 "Mass of strut";
        parameter SI.Length L_max=1.0 "Maximum extended length of strut";
        parameter SI.Length L_min=0.5 "Minimum compressed length of strut";

      // Spring Parameters

        parameter Real f_s_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "Displacement [m] versus force [N] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4m give a force of 16N)"
          annotation (Dialog(group="Spring Properties"));
        parameter Real f_s_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "Displacement [m] versus force [N] ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4m give a force of 16N)"
          annotation (Dialog(group="Spring Properties"));
        parameter Real spring_scale(min=0, max=1) = 0.0
          "Spring scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(group="Spring Properties"));
        parameter SI.Length s_rel0=1 "Unstretched spring length"
          annotation (Dialog(group="Spring Properties"));

      // Damper Parameters

        parameter Real f_v_table_max[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
          annotation (Dialog(group="Damper Properties"));
        parameter Real f_v_table_min[:,:]=[-4,-16; -2,-4; -1,-1; 0,0; 1,1; 2,4; 4,16]
          "force versus velocity ( e.g.,[-4, -16; -2, -4; -1, -1; 0, 0; 1, 1; 2, 4; 4, 16] @4ms give a force of 16N)"
          annotation (Dialog(group="Damper Properties"));
        parameter Real compression_scale(min=0, max=1) = 0.0
          "Compression damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(group="Damper Properties"));
        parameter Real rebound_scale(min=0, max=1) = 0.0
          "Rebound damping scale factor between min and max force curves (=0, lower input; =1, upper input)"
          annotation (Dialog(group="Damper Properties"));

      // Bumpstop Parameters
        parameter Real bumpstop_force_table[:,:]=[0.0,0; 0.1,1; 0.2,4]
          "Engagement [m] versus force [N] ( e.g.,[0.0, 0; 0.1, 1; 0.2, 4] @0.2m give a force of 4N)"
                annotation (Dialog(group="Bumpstop Properties"));
        parameter SI.Length bstop_engage=0.55
          "Strut length where bumpstop becomes active"
            annotation (Dialog(group="Bumpstop Properties"));

      // Rebound Stop Parameters

        parameter Real reboundstop_force_table[:,:]=[0.0,0; 0.1,1; 0.2,4]
          "Engagement [m] versus force [N] ( e.g.,[0.0, 0; 0.1, 1; 0.2, 4] @0.2m give a force of 4N)"
            annotation (Dialog(group="Rebound Stop Properties"));
        parameter SI.Length rstop_engage=0.95
          "Strut length where rebound stop becomes active"
            annotation (Dialog(group="Rebound Stop Properties"));

        Modelica.Mechanics.MultiBody.Interfaces.Frame_a     frame_a
          annotation (extent=[-120, -14; -90, 16], Placement(transformation(
              extent={{-15,-15},{15,15}},
              rotation=0,
              origin={-200,0}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,-204})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shapeA(
          shapeType="sphere",
          r_shape={-0.015,0,0},
          lengthDirection={1,0,0},
          color={0,0,0},
          length=0.03,
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
                       annotation (extent=[-50, -44; -30, -24], Placement(
              transformation(extent={{-140,-40},{-120,-20}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shapeB(
          shapeType="sphere",
          r_shape={-0.015,0,0},
          lengthDirection={1,0,0},
          color={0,0,0},
          length=0.03,
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
                       annotation (extent=[54, -48; 74, -28], Placement(
              transformation(extent={{140,-40},{120,-20}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Translational_Spring_From_Table_With_Range
          translational_Spring_From_Table_With_Range(
          s_rel0=s_rel0,
          spring_scale=spring_scale,
          max_table=f_s_table_max,
          min_table=f_s_table_min)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Translational_Damper_From_Table_With_Range
          damper_From_Table_With_Range(
          L_max=L_max,
          L_min=L_min,
          max_table=f_v_table_max,
          min_table=f_v_table_min,
          compression_scale=compression_scale,
          rebound_scale=rebound_scale,
          m_damper=m_strut)
          annotation (Placement(transformation(extent={{-10,-50},{10,-30}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_C annotation (Placement(
              transformation(extent={{184,-16},{216,16}}),iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,204})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Bumpstop_From_Table
          bumpstop(TargetInput=bstop_engage, bumpstop_force_table=
              bumpstop_force_table)
          annotation (Placement(transformation(extent={{-10,70},{10,90}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Suspension.Suspension_Components.Reboundstop_From_Table
          reboundStop(TargetInput=rstop_engage, reboundstop_force_table=
              reboundstop_force_table)
          annotation (Placement(transformation(extent={{-10,30},{10,50}})));
        Modelica.Mechanics.MultiBody.Sensors.Distance strut_length(animation=false)
          annotation (Placement(transformation(extent={{-80,140},{-60,160}})));
        Modelica.Mechanics.MultiBody.Parts.Body body_upper(
          m=m_strut/2,
          r_CM={0,0,0},
          animation=false)
          annotation (Placement(transformation(extent={{140,20},{120,40}})));
        Modelica.Mechanics.MultiBody.Parts.Body body_lower(
          m=m_strut/2,
          r_CM={0,0,0},
          animation=false)
          annotation (Placement(transformation(extent={{-140,20},{-120,40}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Record output_strut_length(nu=1)
          annotation (Placement(transformation(extent={{180,-100},{200,-80}})));
      equation
        connect(frame_a, translational_Spring_From_Table_With_Range.frame_a)
          annotation (Line(
            points={{-200,0},{-10,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(damper_From_Table_With_Range.frame_a, frame_a) annotation (Line(
            points={{-10,-40},{-40,-40},{-40,0},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shapeA.frame_a, frame_a) annotation (Line(
            points={{-140,-30},{-180,-30},{-180,0},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(translational_Spring_From_Table_With_Range.frame_b, frame_C)
          annotation (Line(
            points={{10,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(damper_From_Table_With_Range.frame_b, frame_C) annotation (Line(
            points={{10,-40},{72,-40},{72,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shapeB.frame_a, frame_C) annotation (Line(
            points={{140,-30},{180,-30},{180,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_length.frame_a, frame_a)
                                         annotation (Line(
            points={{-80,150},{-200,150},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_length.frame_b, frame_C)
                                         annotation (Line(
            points={{-60,150},{200,150},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(frame_a, bumpstop.frame_a) annotation (Line(
            points={{-200,0},{-40,0},{-40,80},{-10,80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(frame_a, reboundStop.frame_a) annotation (Line(
            points={{-200,0},{-40,0},{-40,40},{-10,40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(reboundStop.frame_b, frame_C) annotation (Line(
            points={{10,40},{72,40},{72,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bumpstop.frame_b, frame_C) annotation (Line(
            points={{10,80},{72,80},{72,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_length.distance, bumpstop.TestInput) annotation (Line(
            points={{-70,139},{-70,88},{-10.2,88}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(strut_length.distance, reboundStop.TestInput) annotation (Line(
            points={{-70,139},{-70,48},{-10.2,48}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(body_lower.frame_a, frame_a) annotation (Line(
            points={{-140,30},{-180,30},{-180,0},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(body_upper.frame_a, frame_C) annotation (Line(
            points={{140,30},{180,30},{180,0},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_length.distance, output_strut_length.u[1]) annotation (Line(
            points={{-70,139},{-70,-90},{180,-90}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Coordsys(
            extent=[-100, -100; 100, 100],
            grid=[2, 2],
            component=[20, 20]),
          Icon(
            Rectangle(extent=[-40, 10; -4, -10], style(gradient=2, fillColor=8)),
            Polygon(points=[-8, 20; -4, 0; -8, 0; -12, 20; -8, 20], style(color=8,
                   fillColor=8)),
            Ellipse(extent=[-76, -16; -44, 16], style(
                color=0,
                fillColor=7,
                fillPattern=1)),
            coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}}),
            Polygon(points=[8, 20; 4, 0; 0, 0; 4, 20; 8, 20], style(color=9,
                  fillColor=9)),
            Polygon(points=[4, 0; 0, -20; -4, -20; 0, 0; 4, 0], style(color=9,
                  fillColor=9)),
            Polygon(points=[-8, 20; -12, 0; -16, 0; -12, 20; -8, 20], style(color=
                   9, fillColor=9)),
            Polygon(points=[-12, 0; -16, -20; -20, -20; -16, 0; -12, 0], style(
                  color=9, fillColor=9)),
            Rectangle(extent=[-4, 16; 40, -16], style(gradient=2, fillColor=8)),
            Polygon(points=[-4, 0; 0, -20; -4, -20; -8, 0; -4, 0], style(color=8,
                   fillColor=8)),
            Polygon(points=[8, 20; 12, 0; 8, 0; 4, 20; 8, 20], style(color=8,
                  fillColor=8)),
            graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-4,40},{-12,-40},{-4,-40},{4,40},{-4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,108},
                rotation=90),
              Polygon(
                points={{4,40},{-12,-40},{-4,-40},{12,40},{4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,-52},
                rotation=90),
              Rectangle(
                extent={{-130,12},{130,-12}},
                lineColor={0,0,0},
                fillColor={185,185,185},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={3.55271e-015,0},
                rotation=90),
              Polygon(
                points={{4,40},{-12,-40},{-4,-40},{12,40},{4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,76},
                rotation=90),
              Polygon(
                points={{4,40},{-12,-40},{-4,-40},{12,40},{4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,-20},
                rotation=90),
              Polygon(
                points={{4,40},{-12,-40},{-4,-40},{12,40},{4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,12},
                rotation=90),
              Polygon(
                points={{4,40},{-12,-40},{-4,-40},{12,40},{4,40}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={0,128,255},
                lineColor={0,0,0},
                origin={0,44},
                rotation=90),
              Ellipse(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={0,140},
                rotation=360),
              Ellipse(
                extent={{-16,16},{16,-16}},
                lineColor={0,0,0},
                fillColor={40,40,40},
                fillPattern=FillPattern.Solid,
                origin={0,140},
                rotation=360),
              Ellipse(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={0,-140},
                rotation=360),
              Ellipse(
                extent={{-16,16},{16,-16}},
                lineColor={0,0,0},
                fillColor={40,40,40},
                fillPattern=FillPattern.Solid,
                origin={0,-140},
                rotation=360),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={0,140},
                rotation=360),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={0,-140},
                rotation=360),
              Rectangle(
                extent={{-50,16},{50,-16}},
                lineColor={0,0,0},
                fillColor={185,185,185},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={0,-34},
                rotation=90),
              Rectangle(
                extent={{-55,26},{55,-26}},
                lineColor={0,0,0},
                fillColor={185,185,185},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={0,65},
                rotation=90),
              Text(
                extent={{-20,20},{20,-20}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={185,185,185},
                lineColor={0,0,255},
                origin={-60,160},
                rotation=360,
                textString="C"),
              Polygon(
                points={{-10,40},{6,-40},{14,-40},{-2,40},{-10,40}},
                smooth=Smooth.None,
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                origin={0,-6},
                rotation=90,
                pattern=LinePattern.None),
              Polygon(
                points={{-10,40},{6,-40},{14,-40},{-2,40},{-10,40}},
                smooth=Smooth.None,
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                origin={0,90},
                rotation=90,
                pattern=LinePattern.None),
              Polygon(
                points={{-10,40},{6,-40},{14,-40},{-2,40},{-10,40}},
                smooth=Smooth.None,
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                origin={0,26},
                rotation=90,
                pattern=LinePattern.None),
              Polygon(
                points={{-10,40},{6,-40},{14,-40},{-2,40},{-10,40}},
                smooth=Smooth.None,
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                origin={0,58},
                rotation=90,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-44,-8},{-36,-16}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-44,88},{-36,80}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-44,24},{-36,16}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{36,40},{44,32}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{36,104},{44,96}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{36,8},{44,0}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-44,56},{-36,48}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{36,72},{44,64}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={0,-140},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={0,140},
                rotation=360),
              Rectangle(
                extent={{-35,5},{35,-5}},
                fillColor={175,175,175},
                fillPattern=FillPattern.VerticalCylinder,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                origin={0,-71},
                rotation=360),
              Polygon(
                points={{-2,20},{-1.07621e-016,-20},{8,-20},{4,20},{-2,20}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={85,170,255},
                lineColor={0,0,0},
                origin={20,-64},
                rotation=90),
              Ellipse(
                extent={{36,-56},{44,-64}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Polygon(
                points={{-10,40},{6,-40},{14,-40},{-2,40},{-10,40}},
                smooth=Smooth.None,
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                origin={0,-38},
                rotation=90,
                pattern=LinePattern.None),
              Ellipse(
                extent={{36,-24},{44,-32}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-44,-40},{-36,-48}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-44,3},{44,-3}},
                fillColor={175,175,175},
                fillPattern=FillPattern.VerticalCylinder,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                origin={0,-67},
                rotation=360),
              Polygon(
                points={{-2,20},{-1.07621e-016,-20},{8,-20},{4,20},{-2,20}},
                pattern=LinePattern.None,
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={85,170,255},
                lineColor={0,0,0},
                origin={-20,106},
                rotation=90),
              Ellipse(
                extent={{-44,112},{-36,104}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-44,3},{44,-3}},
                fillColor={175,175,175},
                fillPattern=FillPattern.VerticalCylinder,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                origin={0,113},
                rotation=360)}),
          Window(
            x=0.45,
            y=0.01,
            width=0.28,
            height=0.42),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{
                  200,200}}),
                  graphics),
          Documentation(info="<HTML>
<p>
The damper is mounted inside the coil spring which gives a compact component. The force generation is modelled from table values
</p>
<p>
Advantages:
Compact.
</p>
<p>
Disadvantages:
Mounting and Demounting is sometimes more timeconsuming than with separate components.
</p>
<p>
Usage:
Front suspension in many cars.</p>
<p>
The following parameters are used to define the component, see nomenclature for further information:
</p>
<pre>
  scaleFactor: The component can be scaled assymetrically, e.g. {1,-1,1} mirrors it around the xz-plane.
  rA: location of strut end A, resolved in frame_A.
  rB: location of strut end B, resolved in frame_B.
  s_rel0: unstretched strut length. Not affected by scaleFactor.
  forceTable: To set the force generation table add a component named [name] of class Utilities.Forces.Utilities.ForceTable1D to the model and write forceTable=[name] in the modifiers row
  Mass and inertia properties not yet solved!  
</pre>
</HTML>
"),                 extent=[-20, -20; 20, 20]);
      end Strut_w_Endstops;

      model Suspension_Module_Flange_Driveline_Brakes
        "Left and right double wishbone modules.  No steering or struts in the module.  Flange connections.  Differential, halfshafts, and geared hubs added."
          extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        import C2M2L_Ext;

        parameter SI.Length addl_half_track_width=0
          "Additional half track width";

      // UCA GEOMETRY

        parameter SI.Position[3] uca_front={0.1227, 0.1246, 0.3375}
          "Vector from frame_C to UCA front mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Upper Control Arm"));
        parameter SI.Position[3] uca_rear={-0.1367, 0.1246, 0.3375}
          "Vector from frame_C to UCA rear mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Upper Control Arm"));
        parameter SI.Position[3] uca_outer={-0.007, 0.1408, 0.7986}
          "Vector from frame_C to UCA outer resolved in frame_C"
              annotation (Dialog(group="Geometry - Upper Control Arm"));

      // LCA GEOMETRY

        parameter SI.Position[3] lca_front={0.1433, -0.1537, 0.2552}
          "Vector from frame_C to LCA front mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_rear={-0.3128, -0.1537, 0.2552}
          "Vector from frame_C to LCA rear mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_outer={0.0052, -0.222, 0.8467}
          "Vector from frame_C to LCA outer resolved in frame_C"
              annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_strut={-0.1718, -0.1582, 0.6029}
          "Vector from frame_C to lower strut mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Lower Control Arm"));

      // KNUCKLE GEOMETRY

        parameter SI.Position[3] wheel_center={0.0003, -0.0646, 1.1919}
          "Vector from frame_C to wheel center resolved in frame_C"
              annotation (Dialog(group="Geometry - Knuckle"));
         parameter SI.Position[3] tierod_outer={0.2443, -0.0177, 0.8653}
          "Vector from frame_C to tierod attachment on knuckle resolved in frame_C"
              annotation (Dialog(group="Geometry - Knuckle"));

      // HALFSHAFT GEOMETRY
        parameter SI.Position[3] halfshaft_inner={0, 0, 0.4233}
          "Vector from frame_C to inner halfshaft attachment resolved in frame_C"
          annotation (Dialog( group="Geometry - Halfshafts"));
        parameter SI.Position[3] halfshaft_outer={0.0003, -0.0647, 0.8771}
          "Vector from frame_C to outer halfshaft attachment resolved in frame_C"
          annotation (Dialog( group="Geometry - Halfshafts"));

      // STRUT GEOMETRY
        parameter SI.Position[3] strut_upper={-0.1718, 0.5632, 0.5903}
          "Vector from frame_C to upper strut mount resolved in frame_C"
              annotation (Dialog(group="Geometry - Strut"));

      // MASS PROPERTIES

        parameter SI.Position cm_uca[3]={-0.007, 0.142, 0.555}
          "Vector from frame_C to UCA cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Upper Control Arm"));
        parameter SI.Mass m_uca=10 "Mass of UCA"
          annotation (Dialog(tab="Mass Properties", group="Upper Control Arm"));
        parameter SI.Position cm_lca[3]={-0.098, -0.192, 0.508}
          "Vector from frame_C to LCA cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Lower Control Arm"));
        parameter SI.Mass m_lca=10 "Mass of UCA"
          annotation (Dialog(tab="Mass Properties", group="Lower Control Arm"));

        parameter SI.Position cm_knuckle[3]={0.004, -0.063, 1.037}
          "Vector from frame_C to knuckle cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Mass m_knuckle=10 "Mass of knuckle"
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_xx_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_yy_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_zz_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));

      // DRIVELINE PROPERTIES
        parameter Real hub_ratio=3.55
          "Transmission ratio (flange_a.phi/flange_b.phi)"
          annotation (Dialog(tab="Driveline and Braking", group="Driveline Ratios"));
        parameter Real axle_ratio=2.06
          "Bevel or hypoid gear ratio from prop shaft"
          annotation (Dialog(tab="Driveline and Braking", group="Driveline Ratios"));
        parameter Real axle_loss_table[:, 5]=[0, 0.96, 0.96, 0, 0]
          "losses for bevel gear mesh"
          annotation (Dialog(tab="Driveline and Braking", group="Driveline Ratios"));
        parameter SI.Position axle_c_of_g_position[3]={0,0,0}
          "Vector from origin to C_of_G position in origin frame"
          annotation (Dialog(tab="Driveline and Braking", group="Geomerty"));
        parameter SI.Mass axle_mass=1 "Mass of axle"
          annotation (Dialog(tab="Driveline and Braking", group="Geomerty"));
        parameter SI.Inertia axle_J_xxyyzz[6]={0.001, 0.001, 0.001, 0, 0, 0}
          "Vector element of inertia tensor"
          annotation (Dialog(tab="Driveline and Braking", group="Geomerty"));

      // BRAKE SYSTEM PROPERTIES
        parameter Real brake_torque_table[:,:]=[4.29,0.892; 8.58,0.908; 17.16,0.939; 25.74,0.969; 34.32, 1; 42.9,0.816; 51.48,0.581]
          "Rotational wheel velocity (rad/sec) at start of braking event vs normalized average braking torque for event (max torque = 1)"
          annotation (Dialog(tab="Driveline and Braking", group="Brake Parameters"));
        parameter SI.Torque t_max=22000 "Maximum brake torque"
          annotation (Dialog(tab="Driveline and Braking", group="Brake Parameters"));
        parameter Real brake_torque_ratio_min=0.5
          "Minimum braking torque available, as ratio of t_max"
          annotation (Dialog(tab="Driveline and Braking", group="Brake Parameters"));

      protected
        parameter SI.Position[3] strut_upper_position_left={strut_upper[1],strut_upper[2],addl_half_track_width-strut_upper[3]};
        parameter SI.Position[3] strut_upper_position_right={strut_upper[1],strut_upper[2],addl_half_track_width+strut_upper[3]};

        parameter SI.Position[3] diff_center={halfshaft_inner[1],halfshaft_inner[2],0}
          "Vector from frame_C to differential center resolved in frame_C";

        parameter SI.Position[3] halfshaft_inner_left={0,0,-halfshaft_inner[3]}
          "Vector from frame_C to inner halfshaft attachment resolved in frame_C";
        parameter SI.Position[3] halfshaft_inner_right={0,0,halfshaft_inner[3]}
          "Vector from frame_C to inner halfshaft attachment resolved in frame_C";

        parameter SI.Position diff_output_right[3,3]=[{halfshaft_inner_right}; 1,0,0; 0,1,0]
          "Offset xyz, local_x, local_y of brg_03 from origin";
        parameter SI.Position diff_output_left[3,3]=[{halfshaft_inner_left}; -1,0,0; 0,1,0]
          "Offset xyz, local_x, local_y of brg_04 from origin";

        parameter SI.Position[3] halfshaft_outer_right=wheel_center-halfshaft_outer
          "Vector from frame_C to inner halfshaft attachment resolved in frame_C";

        parameter SI.Position hub_mount_right[3,3]=[{halfshaft_outer_right}; 1,0,0; 0,1,0]
          "Offset xyz, local_x, local_y of mount_02 from origin";
        parameter SI.Position hub_mount_left[3,3]=[{halfshaft_outer_right}; -1,0,0; 0,1,0]
          "Offset xyz, local_x, local_y of mount_02 from origin";

      public
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_C
                                                             annotation (Placement(
              transformation(extent={{-16,-16},{16,16}},
              rotation=270,
              origin={0,200}),                               iconTransformation(
                extent={{-16,-16},{16,16}},
              rotation=90,
              origin={0,200})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        wheel_right(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{204,-16},{236,16}}), iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={212,0})));
        DoubleWishBone                           susp_left(
          scaleFactor={1,1,-1},
          uca_front=uca_front,
          uca_rear=uca_rear,
          uca_outer=uca_outer,
          lca_front=lca_front,
          lca_rear=lca_rear,
          lca_outer=lca_outer,
          lca_strut=lca_strut,
          wheel_center=wheel_center,
          tierod_outer=tierod_outer,
          cm_uca=cm_uca,
          m_uca=m_uca,
          cm_lca=cm_lca,
          m_lca=m_lca,
          cm_knuckle=cm_knuckle,
          m_knuckle=m_knuckle,
          I_xx_knuckle=I_xx_knuckle,
          I_yy_knuckle=I_yy_knuckle,
          I_zz_knuckle=I_zz_knuckle,
          addl_half_track_width=addl_half_track_width)
                            annotation (Placement(transformation(
              extent={{40,-40},{-40,40}},
              rotation=0,
              origin={-80,0})));
        DoubleWishBone susp_right(
          uca_front=uca_front,
          uca_rear=uca_rear,
          uca_outer=uca_outer,
          lca_front=lca_front,
          lca_rear=lca_rear,
          lca_outer=lca_outer,
          lca_strut=lca_strut,
          wheel_center=wheel_center,
          tierod_outer=tierod_outer,
          cm_uca=cm_uca,
          m_uca=m_uca,
          cm_lca=cm_lca,
          m_lca=m_lca,
          cm_knuckle=cm_knuckle,
          m_knuckle=m_knuckle,
          I_xx_knuckle=I_xx_knuckle,
          I_yy_knuckle=I_yy_knuckle,
          I_zz_knuckle=I_zz_knuckle,
          addl_half_track_width=addl_half_track_width)
                            annotation (Placement(transformation(
              extent={{-40,-40},{40,40}},
              rotation=0,
              origin={80,0})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        wheel_left(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{-236,-16},{-204,16}}),
                                                           iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={-210,0})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a steer_right
          annotation (Placement(transformation(extent={{184,104},{216,136}}),
              iconTransformation(extent={{184,64},{216,96}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a steer_left
          annotation (Placement(transformation(extent={{-216,104},{-184,136}}),
              iconTransformation(extent={{-216,64},{-184,96}})));
        Modelica.Mechanics.MultiBody.Sensors.Distance total_track(animation=false)
          annotation (Placement(transformation(extent={{40,160},{20,140}})));
        Modelica.Blocks.Math.Gain gain(k=0.5)
          annotation (Placement(transformation(extent={{100,160},{120,180}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b strut_attach_left annotation (
           Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=0,
              origin={-200,-60}),iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={-200,-120})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b strut_attach_right
          annotation (Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=0,
              origin={200,-60}),iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={200,-120})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Record output_half_track_width(nu=1)
          annotation (Placement(transformation(extent={{180,160},{200,180}})));
        Differentials.Differential_Dog_Clutch_Lock
          differential_Open(ratio=axle_ratio,
          transform_brg_03=diff_output_right,
          transform_brg_04=diff_output_left,
          loss_table_bevel=axle_loss_table,
          c_of_g_position=axle_c_of_g_position,
          mass=axle_mass,
          J_xxyyzz=axle_J_xxyyzz)
                            annotation (Placement(transformation(
              extent={{-30,-40},{30,40}},
              rotation=90,
              origin={0,-140})));
        Drive_Shafts.Drive_Shaft_CV_Joint
                             halfshaft_right(length_flange_to_joint_center=0)
                          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={100,-120})));
        Drive_Shafts.Drive_Shaft_CV_Joint
                             halfshaft_left(length_flange_to_joint_center=0)
                         annotation (Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=0,
              origin={-100,-120})));
        Wheel_Hubs.Wheel_Hub_Planetary
                            wheel_hub_left(ratio=hub_ratio, transform_brg_02=
              hub_mount_left)
          annotation (Placement(transformation(extent={{-140,-88},{-180,-148}})));
        Wheel_Hubs.Wheel_Hub_Planetary
                            wheel_hub_right(ratio=hub_ratio, transform_brg_02=
              hub_mount_right)
          annotation (Placement(transformation(extent={{140,-88},{180,-148}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Drive_Line.Differential.Differential_Control_Bus
          differential_Control_Bus annotation (Placement(transformation(extent={{-54,-208},
                  {-34,-188}}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={-60,-170})));
        inner C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC env
          annotation (Placement(transformation(extent={{-140,-200},{-120,-180}})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing torque_input(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{-16,-206},{16,-174}}),
                                                           iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={-60,200})));
        inner Modelica.Fluid.System system
          annotation (Placement(transformation(extent={{-180,-200},{-160,-180}})));

        Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r=
              diff_center, animation=false) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-70})));

        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing diff_to_diff(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{54,-206},{86,-174}}),iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={0,-200})));
        C2M2L_Ext.Interfaces.Context_Interfaces.Driver.Driver_Bus driver_Bus
          annotation (Placement(transformation(extent={{-180,60},{-160,80}}),
              iconTransformation(extent={{-130,-180},{-110,-160}})));
      protected
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        wheel_left1(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{-156,-16},{-124,16}}),
                                                           iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={-210,0})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        wheel_right1(
            includeBearingConnector=true)                     annotation (Placement(
              transformation(extent={{124,-16},{156,16}}), iconTransformation(extent={{-16,-16},
                  {16,16}},
              rotation=0,
              origin={212,0})));
      public
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Brake_Module
          brake_left(brake_torque_table=brake_torque_table, t_max=t_max,
          brake_torque_ratio_min=brake_torque_ratio_min)
          annotation (Placement(transformation(extent={{-160,-20},{-200,20}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Brake_Module
          brake_right(brake_torque_table=brake_torque_table, t_max=t_max,
          brake_torque_ratio_min=brake_torque_ratio_min)
          annotation (Placement(transformation(extent={{160,-20},{200,20}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a strut_upper_left annotation (
            Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={-60,200}), iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={-100,200})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a strut_upper_right annotation (
           Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={60,200}),  iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=90,
              origin={100,200})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation1(
                           animation=false, r=strut_upper_position_left)
                                            annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=0,
              origin={-30,180})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation2(
                           animation=false, r=strut_upper_position_right)
                                            annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={30,180})));

      equation
        connect(susp_left.frame_chassis, frame_C) annotation (Line(
            points={{-40,0},{0,0},{0,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(susp_right.frame_chassis, frame_C) annotation (Line(
            points={{40,0},{0,0},{0,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(total_track.distance,gain. u) annotation (Line(
            points={{30,161},{30,170},{98,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(steer_left, susp_left.frame_tierod) annotation (Line(
            points={{-200,120},{-30,120},{-30,32},{-40,32}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(susp_left.frame_strut, strut_attach_left) annotation (Line(
            points={{-80,-40},{-80,-60},{-200,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(susp_right.frame_strut, strut_attach_right) annotation (Line(
            points={{80,-40},{80,-60},{200,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(steer_right, susp_right.frame_tierod) annotation (Line(
            points={{200,120},{30,120},{30,32},{40,32}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(gain.y, output_half_track_width.u[1]) annotation (Line(
            points={{121,170},{180,170}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(differential_Control_Bus,differential_Open. differential_Control_Bus)
          annotation (Line(
            points={{-44,-198},{-44,-137.333},{-27.2,-137.333}},
            color={255,0,255},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(differential_Open.brg_01, torque_input)   annotation (Line(
            points={{-1.83697e-015,-167.333},{-1.83697e-015,-179.666},{0,-179.666},{0,
                -190}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));

        connect(frame_C, fixedTranslation.frame_a) annotation (Line(
            points={{0,200},{0,-60},{1.83697e-015,-60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation.frame_b, differential_Open.mount_02) annotation (
            Line(
            points={{-1.83697e-015,-80},{60,-80},{60,-137.333},{42.6667,-137.333}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheel_hub_left.brg_01, halfshaft_left.frame_b) annotation (Line(
            points={{-140,-120},{-120,-120}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(halfshaft_right.frame_b, wheel_hub_right.brg_01) annotation (Line(
            points={{120,-120},{140,-120}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(wheel_hub_right.brg_02, wheel_right) annotation (Line(
            points={{180,-120},{220,-120},{220,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(halfshaft_right.frame_a, differential_Open.brg_03) annotation (Line(
            points={{80,-120},{54,-120},{54,-116.333},{26.6667,-116.333}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(halfshaft_left.frame_a, differential_Open.brg_04) annotation (Line(
            points={{-80,-120},{-54,-120},{-54,-116.333},{-27.2,-116.333}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(differential_Open.brg_02, diff_to_diff) annotation (Line(
            points={{1.83697e-015,-107.333},{1.83697e-015,-90},{70,-90},{70,-190}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));

        connect(wheel_hub_left.brg_02, wheel_left) annotation (Line(
            points={{-180,-120},{-220,-120},{-220,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(total_track.frame_b, wheel_left.bearingFrame) annotation (Line(
            points={{20,150},{-220,150},{-220,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(total_track.frame_a, wheel_right.bearingFrame) annotation (Line(
            points={{40,150},{220,150},{220,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(susp_left.frame_wheel, wheel_left1.bearingFrame) annotation (Line(
            points={{-120,0},{-140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(susp_right.frame_wheel, wheel_right1.bearingFrame) annotation (Line(
            points={{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(brake_left.knuckle, wheel_left1) annotation (Line(
            points={{-160,0},{-140,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(brake_left.wheel, wheel_left) annotation (Line(
            points={{-200,0},{-220,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(driver_Bus, brake_left.driver_Bus) annotation (Line(
            points={{-170,70},{-163,70},{-163,17}},
            color={255,85,85},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(brake_right.wheel, wheel_right) annotation (Line(
            points={{200,0},{220,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(brake_right.knuckle, wheel_right1) annotation (Line(
            points={{160,0},{140,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(brake_right.driver_Bus, driver_Bus) annotation (Line(
            points={{163,17},{163,70},{-170,70}},
            color={255,85,85},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(fixedTranslation1.frame_b, strut_upper_left) annotation (Line(
            points={{-40,180},{-60,180},{-60,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation1.frame_a, frame_C) annotation (Line(
            points={{-20,180},{0,180},{0,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation2.frame_a, frame_C) annotation (Line(
            points={{20,180},{0,180},{0,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(fixedTranslation2.frame_b, strut_upper_right) annotation (Line(
            points={{40,180},{60,180},{60,200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                  200}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}}),
              graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-30,80},{-70,40},{-70,-20},{-30,-60},{30,-60},{70,-20},{70,38},
                    {32,80},{-30,80}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-62,5},{62,-5}},
                lineColor={0,0,255},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                origin={81,-48},
                rotation=-10),
              Rectangle(
                extent={{-52,4},{50,-4}},
                lineColor={0,0,255},
                fillColor={170,255,255},
                fillPattern=FillPattern.Solid,
                origin={93,60},
                rotation=-3),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,255},
                fillColor={75,75,75},
                fillPattern=FillPattern.Solid,
                origin={20,-37},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={20,-37},
                rotation=0),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,255},
                fillColor={75,75,75},
                fillPattern=FillPattern.Solid,
                origin={40,63},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={40,63},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={142,57},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={142,-59},
                rotation=0),
              Polygon(
                points={{-28.5,55},{-18.5,55},{11.5,15},{11.5,5},{29.5,5},{29.5,-5},{11.5,
                    -5},{11.5,-15},{-18.5,-55},{-28.5,-55},{-28.5,-45},{-8.5,-25},{-8.5,
                    9},{-29.5,10},{-29.5,18},{-8.5,19},{-8.5,25},{-28.5,46},{-28.5,55}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={165.5,0},
                rotation=0),
              Text(
                extent={{10,200},{70,160}},
                lineColor={0,0,0},
                textString="Ch"),
              Rectangle(
                extent={{-62,5},{62,-5}},
                lineColor={0,0,255},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                origin={-81,-48},
                rotation=10),
              Rectangle(
                extent={{-52,4},{50,-4}},
                lineColor={0,0,255},
                fillColor={170,255,255},
                fillPattern=FillPattern.Solid,
                origin={-93,60},
                rotation=3),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,255},
                fillColor={75,75,75},
                fillPattern=FillPattern.Solid,
                origin={-20,-37},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-20,-37},
                rotation=0),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,255},
                fillColor={75,75,75},
                fillPattern=FillPattern.Solid,
                origin={-40,63},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-40,63},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={-142,57},
                rotation=0),
              Ellipse(
                extent={{-4,4},{4,-4}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={-142,-59},
                rotation=0),
              Polygon(
                points={{28.5,55},{18.5,55},{-11.5,15},{-11.5,5},{-29.5,5},{-29.5,-5},
                    {-11.5,-5},{-11.5,-15},{18.5,-55},{28.5,-55},{28.5,-45},{8.5,-25},
                    {8.5,9},{29.5,10},{29.5,18},{8.5,19},{8.5,25},{28.5,46},{28.5,55}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                origin={-165.5,0},
                rotation=0),
              Text(
                extent={{-200,-60},{-160,-100}},
                lineColor={0,0,0},
                textString="L"),
              Text(
                extent={{160,-60},{200,-100}},
                lineColor={0,0,0},
                textString="R"),
              Line(
                points={{0,200},{0,-200}},
                color={0,0,255},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Text(
                extent={{-190,120},{-130,80}},
                lineColor={0,0,0},
                textString="sL"),
              Text(
                extent={{130,120},{190,80}},
                lineColor={0,0,0},
                textString="sR"),
              Line(
                points={{-200,80},{-130,80},{-110,14},{-136,14}},
                color={255,0,255},
                smooth=Smooth.None,
                thickness=0.5,
                pattern=LinePattern.Dash),
              Line(
                points={{200,80},{130,80},{110,14},{136,14}},
                color={255,0,255},
                smooth=Smooth.None,
                thickness=0.5,
                pattern=LinePattern.Dash),
              Line(
                points={{0,120},{0,47.5},{-10,45},{10,40},{-10,35},{10,30},{-10,25},{10,
                    20},{-10,15},{10,10},{-10,5},{10,0},{-10,-5},{0,-7.5},{0,-200},{-100,
                    -200}},
                color={0,0,255},
                smooth=Smooth.None,
                origin={-100,80},
                rotation=0),
              Line(
                points={{0,120},{0,47.5},{-10,45},{10,40},{-10,35},{10,30},{-10,25},{10,
                    20},{-10,15},{10,10},{-10,5},{10,0},{-10,-5},{0,-7.5},{0,-200},{100,
                    -200}},
                color={0,0,255},
                smooth=Smooth.None,
                origin={100,80},
                rotation=0),
              Text(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,0},
                origin={-40,176},
                rotation=360,
                textString="t",
                fontName="Symbol"),
              Rectangle(
                extent={{-8,4},{8,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={156,0},
                rotation=0),
              Ellipse(
                extent={{-7,-7},{7,7}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={146,0},
                rotation=360,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-40,4},{40,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={108,4},
                rotation=-6),
              Ellipse(
                extent={{-7,-7},{7,7}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={72,8},
                rotation=360,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-10,4},{10,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={62,8},
                rotation=0),
              Rectangle(
                extent={{-10,4},{10,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-62,8},
                rotation=0),
              Ellipse(
                extent={{-7,-7},{7,7}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-72,8},
                rotation=360,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-40,4},{40,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-108,4},
                rotation=6),
              Ellipse(
                extent={{-7,-7},{7,7}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-146,0},
                rotation=360,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-8,4},{8,-4}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-156,0},
                rotation=0),
              Polygon(
                points={{-24,34},{-24,-34},{0,-38},{0,38},{-24,34}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={-168,0},
                rotation=360),
              Line(
                points={{-190,0},{-170,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,10},{-170,10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,20},{-170,20}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,30},{-170,30}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,-10},{-170,-10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,-20},{-170,-20}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-190,-30},{-170,-30}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{24,34},{24,-34},{0,-38},{0,38},{24,34}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={170,0},
                rotation=360),
              Line(
                points={{172,30},{192,30}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,20},{192,20}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,10},{192,10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,0},{192,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,-10},{192,-10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,-20},{192,-20}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{172,-30},{192,-30}},
                color={0,0,0},
                smooth=Smooth.None)}),
          experiment(StopTime=5, Interval=0.001),
          __Dymola_experimentSetupOutput);
      end Suspension_Module_Flange_Driveline_Brakes;

      model Parking_Brake_Module
          extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        import C2M2L_Ext;

        parameter SI.Torque t_max=50000 "Maximum brake torque";

      protected
        parameter Real brake_torque_table[:,:]=[0,1]
          "Rotational wheel velocity (rad/sec) at start of braking event vs normalized average braking torque for event (max torque = 1)";
        parameter Real fn_max=t_max;

      public
        Modelica.Mechanics.Rotational.Components.Clutch clutch(
            useHeatPort=false,
          fn_max=fn_max,
          mue_pos=[0,1.0; 1,1.0])
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing knuckle(
            includeBearingConnector=true) annotation (Placement(transformation(
                extent={{-210,-10},{-190,10}}), iconTransformation(extent={{-210,
                  -10},{-190,10}})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing wheel(
            includeBearingConnector=true) annotation (Placement(transformation(
                extent={{190,-10},{210,10}}), iconTransformation(extent={{190,-10},
                  {210,10}})));
        C2M2L_Ext.Interfaces.Context_Interfaces.Driver.Driver_Bus driver_Bus
          annotation (Placement(transformation(extent={{-180,180},{-160,200}}),
              iconTransformation(extent={{-180,160},{-160,180}})));
        Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(
          m=0.01, animation=false,
          animateSphere=false,
          r={0,0,0},
          r_CM={0,0,0})
          annotation (Placement(transformation(extent={{-160,-60},{-140,-40}})));

        Modelica.Mechanics.MultiBody.Parts.Mounting1D mounting1D(n={0,0,1})
          annotation (Placement(transformation(extent={{-180,-10},{-160,10}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Park_Brake_Controller
          park_Brake_Controller
          annotation (Placement(transformation(extent={{-40,120},{-20,140}})));
        Modelica.Mechanics.Rotational.Components.Inertia inertia(J=0.01)
          annotation (Placement(transformation(extent={{80,-10},{100,10}})));
        Modelica.Mechanics.MultiBody.Joints.Revolute revolute(phi(fixed=true))
          annotation (Placement(transformation(extent={{-10,-60},{10,-40}})));
        Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape1(
          m=0.01, animation=false,
          animateSphere=false,
          r={0,0,0},
          r_CM={0,0,0})
          annotation (Placement(transformation(extent={{140,-60},{160,-40}})));
      equation

        connect(bodyShape.frame_a, knuckle.bearingFrame)        annotation (Line(
            points={{-160,-50},{-200,-50},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting1D.frame_a, knuckle.bearingFrame) annotation (Line(
            points={{-170,-10},{-170,-20},{-200,-20},{-200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mounting1D.flange_b, clutch.flange_a) annotation (Line(
            points={{-160,0},{-10,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(mounting1D.flange_b, knuckle.flange) annotation (Line(
            points={{-160,0},{-160,20},{-200,20},{-200,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(park_Brake_Controller.brake_torque_signal, clutch.f_normalized)
          annotation (Line(
            points={{-19,130},{0,130},{0,11}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(driver_Bus.park_brake, park_Brake_Controller.park_brake) annotation (
            Line(
            points={{-170,190},{-170,130},{-40,130}},
            color={255,85,85},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(clutch.flange_b, inertia.flange_a) annotation (Line(
            points={{10,0},{80,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(inertia.flange_b, wheel.flange) annotation (Line(
            points={{100,0},{200,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(bodyShape.frame_b, revolute.frame_a) annotation (Line(
            points={{-140,-50},{-10,-50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(revolute.frame_b, bodyShape1.frame_a) annotation (Line(
            points={{10,-50},{140,-50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bodyShape1.frame_b, wheel.bearingFrame) annotation (Line(
            points={{160,-50},{200,-50},{200,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),      graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-200},{200,200}}), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-150,-150},{150,150}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-160,-160},{160,160}},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360,
                startAngle=95,
                endAngle=170,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-90,-90},{90,90}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360,
                pattern=LinePattern.None),
              Ellipse(
                extent={{-80,-80},{80,80}},
                lineColor={0,0,255},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360),
              Ellipse(
                extent={{-40,-40},{40,40}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={0,0},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-52,-30},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-52,30},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={0,60},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={52,-30},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={52,30},
                rotation=360),
              Ellipse(
                extent={{-8,-8},{8,8}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={0,-60},
                rotation=360),
              Ellipse(
                extent={{-18,18},{18,-18}},
                lineColor={0,0,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                origin={-104,60},
                rotation=360),
              Ellipse(
                extent={{-18,18},{18,-18}},
                lineColor={0,0,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                origin={-52,108},
                rotation=360),
              Text(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,0},
                textString="W",
                origin={176,-60},
                rotation=360),
              Text(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,0},
                textString="K",
                origin={-176,-60},
                rotation=360),
              Text(
                extent={{-50,50},{50,-50}},
                lineColor={255,0,0},
                origin={140,140},
                rotation=360,
                textString="P",
                textStyle={TextStyle.Bold})}));
      end Parking_Brake_Module;

      model Wheel_Rill_FLANGE
        "Wheel model according to Rill.  Operates in XZ Ground Plane, and has flange attachment"
        extends C2M2L_Ext.Interfaces.Delivered_C2M2L;

        import Modelica.Math;
        extends
          C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Wheels.Utilities.BaseWheel_FLANGE(
            final wheelData(
            R0=tyreData.R0,
            width=tyreData.width,
            m=tyreData.m,
            Izz=tyreData.Izz,
            Ixx=tyreData.Ixx,
            Rrim=tyreData.Rrim),
                               carrierFrame(includeBearingConnector=true));

        //Tire Parameters
        parameter SI.Length D_tire=1.096 "Undeformed diameter of tire";
        parameter SI.Length D_wheel=0.508 "Diameter of rim";
        parameter SI.Length W_wheel=0.254 "Width of rim";
        parameter SI.Mass m_wheel=150 "Mass of wheel and tire assembly";
        parameter SI.Inertia Izz_wheel=2.5
          "Wheel inertia with respect to wheel axis";
        parameter SI.Inertia Ixx_wheel=1
          "Wheel inertia with respect to axis perpendicular to wheel axis";
        parameter SI.TranslationalSpringConstant c_x_wheel=100000
          "Tire spring constant in x-direction";
        parameter SI.TranslationalSpringConstant c_y_wheel=200000
          "Tire spring constant in y-direction";
        parameter SI.TranslationalSpringConstant c_z_wheel=150000
          "Tire spring constant in z-direction";
        parameter SI.TranslationalDampingConstant d_x_wheel=1000
          "Tire damping constant in x-direction";
        parameter SI.TranslationalDampingConstant d_y_wheel=2000
          "Tire damping constant in y-direction";
        parameter SI.TranslationalDampingConstant d_z_wheel=1500
          "Tire damping constant in z-direction";
        parameter Real crr(min=0)=0.01
          "Rolling resistance coefficient for the tire";

        // Data for nominal vertical load 1
        parameter Real mue_nom=0.7
          "Friction coefficient of road for which tire data is valid";

        parameter SI.Force Fy_nom_1=3000 "Nominal normal force"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force Fds_x_1=50000
          "Slope at s_x=0 in longitudinal direction"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real s_max_x_1=0.15 "Slip of maximum longitudinal tyre force"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force F_max_x_1=3000 "maximum longitudinal tyre force"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real s_slide_x_1=0.4 "Slip of sliding begin"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force F_slide_x_1=2800
          "Longitudinal tyre force at sliding begin"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force Fds_z_1=40000 "Slope at s_y=0 in lateral direction"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real s_max_z_1=0.21 "Slip of maximum lateral tyre force"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force F_max_z_1=2750 "maximum lateral tyre force"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real s_slide_z_1=0.6 "Slip of sliding begin"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter SI.Force F_slide_z_1=2500
          "Lateral tyre force at sliding begin"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real dL0_1=0.133
          "(distance contact point to f_z) / (length of contact area) for zero lateral slip"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real s0_1=0.25
          "Lateral slip where dL=0 for the first time (usually, a bit higher as s_Fmax_z)"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));
        parameter Real sE_1=0.6
          "Lateral slip where dL remains zero for higher slips"
          annotation (Dialog(tab="Nominal Load 1", group="Input Data for Tire - Set 1"));

        // Data for nominal vertical load 2
        parameter SI.Force Fy_nom_2=6000 "Nominal normal force"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force Fds_x_2=75000
          "Slope at s_x=0 in longitudinal direction"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real s_max_x_2=0.18 "Slip of maximum longitudinal tyre force"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force F_max_x_2=4500 "maximum longitudinal tyre force"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real s_slide_x_2=0.5 "Slip of sliding begin"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force F_slide_x_2=4200
          "Longitudinal tyre force at sliding begin"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force Fds_z_2=60000 "Slope at s_y=0 in lateral direction"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real s_max_z_2=0.24 "Slip of maximum lateral tyre force"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force F_max_z_2=4125 "maximum lateral tyre force"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real s_slide_z_2=0.8 "Slip of sliding begin"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter SI.Force F_slide_z_2=3750
          "Lateral tyre force at sliding begin"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real dL0_2=0.1
          "(distance contact point to f_z) / (length of contact area) for zero lateral slip"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real s0_2=0.275
          "Lateral slip where dL=0 for the first time (usually, a bit higher as s_Fmax_z)"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));
        parameter Real sE_2=0.8
          "Lateral slip where dL remains zero for higher slips"
          annotation (Dialog(tab="Nominal Load 2", group="Input Data for Tire - Set 2"));

        //SLIP DEFINITION

        SI.Angle slipAngle
          "Angle between wheel axis velocity and the x-direction of the wheel";
        Real slip "slip at contact point computed with contact velocities";
        Real slip_limited "slip limited in the range -1.1 for plotting";
        Real sinphi
          "sin(phi), where phi is the angle between -Wv_x and -Wv_y, where Wv_x, Wv_y are the contact point velocities";
        Real cosphi "cos(phi)";
        SI.Velocity Wv_abs "Absolute value of contact point velocity";
        SI.Velocity Rw "denominator of slip quotient";

        //TIRE DEFLECTION
      protected
        parameter Real delta_x_nom=tyreData.load1.F_slide_x/tyreData.c_x
          "nominal tyre deflection in x-direction";
        parameter Real delta_z_nom=tyreData.load1.F_slide_z/tyreData.c_z
          "nominal tyre deflection in z-direction";
        parameter SI.Position delta_y_offset=1e-3
          "In order to make the y-computations less non-linear";
      public
        SI.Position delta_x
          "Longitudinal tyre deflection (= wheel deformation in x-direction of W-frame)";
        SI.Position delta_z
          "Lateral tyre deflection (= wheel deformation in z-direction of W-frame)";
        SI.Position delta_y
          "Radial tyre deflection (= wheel deformation in y-direction of W-frame)";

        //TYRE CONTACT AND FORCE GENERATION

        Boolean contact "true, if wheel has contact with road";
        Real mueRoad;
      protected
        parameter Real delta_eps=0.1
          "should be about 0.1 ... 1; see explanation in model";
      public
        SI.Force f_x "Tyre/contact force at origin of W-frame in x-direction";
        SI.Force f_y "Tyre/contact force at origin of W-frame in y-direction";
        SI.Force f_z "Tyre/contact force at origin of W-frame in z-direction";
        SI.Force f_x0 "f_x at steady state conditions";
        SI.Force f_z0 "f_z at steady state conditions";
        SI.Force f0
          "Absolute value of tyre/contact force in contact plane at steady state conditions";
        SI.Force df_ds
          "Derivative of steady state contact force in contact plane with respect to slip";
        SI.Force t_y "Tyre/contact torque at W-frame in y-direction";
        Real dL
          "(distance contact point to f_z) / (length of contact area); used to compute t_y";
        Real dfx_dvx1 "Partial derivative of f_x with respect to Wv_x";
        Real dfz_dvz1 "Partial derivative of f_z with respect to Wv_z";
        Real dfx_dvx "dfx_dvx1 where potential positive values are set to zero";
        Real dfz_dvz "dfz_dvz1 where potential positive values are set to zero";

        Real Lcontact "length of contact area in x-direction";
        Real delta_diff;
        Real delta_diff_pos;

        Real delta_x_scaled "delta_x scaled on nominal value";
        Real delta_z_scaled "delta_z scaled on nominal value";
        Real S_rel[3, 3];

      public
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Wheels.RillTyre.TyreData
          tyreData(
          R0=D_tire/2,
          Rrim=D_wheel/2,
          width=W_wheel,
          m=m_wheel,
          Izz=Izz_wheel,
          Ixx=Ixx_wheel,
          c_x=c_x_wheel,
          c_y=c_y_wheel,
          c_z=c_z_wheel,
          d_x=d_x_wheel,
          d_y=d_y_wheel,
          d_z=d_z_wheel,
          mue_nom=mue_nom,
          Fy_nom_1=Fy_nom_1,
          Fds_x_1=Fds_x_1,
          s_max_x_1=s_max_x_1,
          F_max_x_1=F_max_x_1,
          s_slide_x_1=s_slide_x_1,
          F_slide_x_1=F_slide_x_1,
          Fds_z_1=Fds_z_1,
          s_max_z_1=s_max_z_1,
          F_max_z_1=F_max_z_1,
          s_slide_z_1=s_slide_z_1,
          F_slide_z_1=F_slide_z_1,
          dL0_1=dL0_1,
          s0_1=s0_1,
          sE_1=sE_1,
          Fy_nom_2=Fy_nom_2,
          Fds_x_2=Fds_x_2,
          s_max_x_2=s_max_x_2,
          F_max_x_2=F_max_x_2,
          s_slide_x_2=s_slide_x_2,
          F_slide_x_2=F_slide_x_2,
          Fds_z_2=Fds_z_2,
          s_max_z_2=s_max_z_2,
          F_max_z_2=F_max_z_2,
          s_slide_z_2=s_slide_z_2,
          F_slide_z_2=F_slide_z_2,
          dL0_2=dL0_2,
          s0_2=s0_2,
          sE_2=sE_2)                    annotation (Placement(transformation(extent={{-180,
                  160},{-160,180}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.Wheels.RillTyre.tyreForces
          tyre(data=tyreData)              annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape_1(
          r_shape=-nShape*0.7*abs(wheelData.width),
          length=abs(wheelData.width),
          width=2*wheelData.R0,
          height=2*wheelData.R0,
          lengthDirection=nShape,
          widthDirection={1,0,0},
          color={0,0,0},
          specularCoefficient=0.5,
          extra=wheelData.R0,
          shapeType="tire") annotation (Placement(
              transformation(extent={{20,-60},{40,-40}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape1(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={0,0,0},
          lengthDirection={1,0,0}) annotation (Placement(
              transformation(extent={{-50,-120},{-30,-100}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape2(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={100,100,100},
          lengthDirection={0.5,0.86603,0})
                                   annotation (Placement(
              transformation(extent={{-20,-120},{0,-100}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape3(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={100,100,100},
          lengthDirection={-0.5,0.86603,0})
                                   annotation (Placement(
              transformation(extent={{10,-120},{30,-100}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape4(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={100,100,100},
          lengthDirection={-1,0,0})
                                   annotation (Placement(
              transformation(extent={{40,-120},{60,-100}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape5(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={100,100,100},
          lengthDirection={-0.5,-0.86603,0})
                                   annotation (Placement(
              transformation(extent={{70,-120},{90,-100}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape6(
          r_shape=abs(wheelData.width)*nShape*0.2,
          length=wheelData.R0 - 0.01,
          width=0.02,
          height=0.05,
          widthDirection=-nShape,
          specularCoefficient=0.1,
          color={100,100,100},
          lengthDirection={0.5,-0.86603,0})
                                   annotation (Placement(
              transformation(extent={{100,-120},{120,-100}})));

        Modelica.Blocks.Math.Gain gain(k=crr)
          annotation (Placement(transformation(extent={{40,100},{60,120}})));
        Modelica.Blocks.Math.Sqrt normal_force
          annotation (Placement(transformation(extent={{0,100},{20,120}})));
        Modelica.Blocks.Math.Add fx_squared_plus_fy_squared
          annotation (Placement(transformation(extent={{-60,100},{-40,120}})));
        Modelica.Blocks.Math.Product fx_squared
          annotation (Placement(transformation(extent={{-120,120},{-100,140}})));
        Modelica.Blocks.Math.Product fy_squared
          annotation (Placement(transformation(extent={{-120,80},{-100,100}})));
        Modelica.Blocks.Math.Gain normalize_for_clutch(k=1/10000)
          annotation (Placement(transformation(extent={{80,100},{100,120}})));
        Modelica.Mechanics.Rotational.Components.Clutch rolling_resistance(mue_pos=[0,
              1], fn_max=10000)
          annotation (Placement(transformation(extent={{40,20},{20,40}})));
        Modelica.Blocks.Sources.RealExpression realExpression3(y=f_x)
          annotation (Placement(transformation(extent={{-180,120},{-160,140}})));
        Modelica.Blocks.Sources.RealExpression realExpression4(y=f_y)
          annotation (Placement(transformation(extent={{-180,80},{-160,100}})));
      equation
        //SLIP DEFINITION
        //slipAngle = Modelica.Math.atan2(Cv[2], noEvent(abs(Cv[1])));
        slipAngle = Modelica.Math.atan2(Wv_z, Rw);
        //also possible slipAngle=Modelica.Math.atan2(Wv_z,Wv_x);
        /* Determine slip
       Wv_abs: Absolute value of contact point velocity (= sqrt(Wv*Wv))
       phi   : Angle between longitudinal and lateral contact point velocity
               Assumption: For Wv_abs small -> Wv_x = Wv_abs, Wv_z = 0, i.e.,
                           velocity only in longitudinal direction.
       sinphi: sin(phi) (= 0 for Wv_abs = 0)
       cosphi: cos(phi) (= -1 for Wv_abs = 0)
    */
        Wv_abs = noEvent(max([sqrt(Wv_x*Wv_x + Wv_z*Wv_z); 1.e-10]));
        Rw = wheelData.R0*abs(w) + 0.1;
        slip = Wv_abs/Rw;
        slip_limited = noEvent(if slip > 1 then 1 else if slip < -1 then -1 else
          slip);
        if noEvent(Wv_abs > v_eps) then
          sinphi = -Wv_z/Wv_abs;
          cosphi = -Wv_x/Wv_abs;
        else
          sinphi = 0;
          cosphi = -1;
        end if;

        //TYRE FORCES AND TORQUES

        delta_y = if delta_r >= 0 then delta_r else 0;

        // Compute  force perpendicular to contact plane.
        f_y = if delta_r >= 0 then tyreData.c_y*delta_y + tyreData.d_y*ddelta_r
           else 0;

        // Compute steady state tyre forces in x- and z-direction

        // (f0,f_x0,f_z0,df_ds,dL) = RillTyre.tyreForces(tyreData, slip, sinphi,
        //  cosphi, f_y, mueRoad, camberAngle);
        tyre.slip = slip;
        tyre.sinphi = sinphi;
        tyre.cosphi = cosphi;
        tyre.f_y = f_y;
        tyre.mueRoad = mueRoad;
        tyre.camberAngle = camberAngle;
        tyre.f0 = f0;
        tyre.f_x0 = f_x0;
        tyre.f_z0 = f_z0;
        tyre.df_ds = df_ds;
        tyre.dL = dL;

        // Compute data for tyre deflection differential equations
        if noEvent(Wv_abs > v_eps) then
          dfx_dvx1 = -(df_ds*slip*cosphi*cosphi + f0*sinphi*sinphi)/Wv_abs;
          dfz_dvz1 = -(df_ds*slip*sinphi*sinphi + f0*cosphi*cosphi)/Wv_abs;
        else
          dfx_dvx1 = -df_ds/Rw;
          dfz_dvz1 = dfx_dvx1;
        end if;

        dfx_dvx = if dfx_dvx1 <= 0 then dfx_dvx1 else 0;
        dfz_dvz = if dfz_dvz1 <= 0 then dfz_dvz1 else 0;

        /* Differential equations for tyre deflections in x- and z-direction
         If the wheel angular velocity is too small, the prerequisites for the
         validity of the tyre force calculation are violated and the equations
         give wrong results. In such a case it is assumed that the profil
         particles do no longer get their maximum deflection. If only
         longitudinal slip is present, the deflection delta_x is calculated
         by "der(delta_x) = -Wv_x" (which is the definition of the deflection delta_x).
         However, delta_x has a maximum which is reached when the particle leaves
         the contact area. If the velocity is constant, a particle remains
         "T = Lcontact / (R0*abs(w))" seconds in the contact area, where Lcontact
         is the length of the contact area, R0 is the undeformed wheel radius
         and w is the angular velocity of the wheel. Therefore, the maximum
         deflection is
               delta_x_max = -Wv_x*T
                           = -Wv_x*Lcontact/(R0*abs(w))
                           = slip*Lcontact.
         Therefore, the estimation is used that the simplified differential
         equation is used as long as deflection is less then "delta_eps*slip*Lcontact"
         where delta_eps is choosen appropriately (e.g., delta_eps=0.1;
         note that delta_eps=1 gives the theoretical switching condition
         derived by simplified assumptions).
      */
        contact = delta_r >= 0;
        Lcontact = noEvent(sqrt(8*tyreData.R0*(delta_y + delta_y_offset)) - sqrt(
          8*tyreData.R0*delta_y_offset));
        delta_diff = noEvent(sqrt(delta_x*delta_x + delta_z*delta_z) - abs(
          delta_eps*slip*Lcontact));
        delta_diff_pos = noEvent(if delta_diff >= 0 or Rw >= 1 then 1 else 0);

        der(delta_x_scaled) = (if not contact then 0 else if noEvent(
          delta_diff_pos > 0.5) then (f_x0 - tyreData.c_x*delta_x)/(tyreData.d_x
           - dfx_dvx) else -Wv_x)/delta_x_nom;
        der(delta_z_scaled) = (if not contact then 0 else if noEvent(
          delta_diff_pos > 0.5) then (f_z0 - tyreData.c_z*delta_z)/(tyreData.d_z
           - dfz_dvz) else -Wv_z)/delta_z_nom;

        delta_x = delta_x_scaled*delta_x_nom;
        delta_z = delta_z_scaled*delta_z_nom;

        when change(contact) then
          // Tyre looses contact to ground or gets contact to ground
          reinit(delta_x_scaled, 0);
          reinit(delta_z_scaled, 0);
        end when;

          // Compute dynamic tyre forces in x- and y-direction and tyre torque in z-direction
        f_x = tyreData.c_x*delta_x + tyreData.d_x*der(delta_x);
        f_z = tyreData.c_z*delta_z + tyreData.d_z*der(delta_z);
        t_y = -Lcontact*dL*f_z;

        //FORCES AND MOMENTS REQUIRED BY THE BaseWheel
        F_x = f_x;
        F_y = f_y;
        F_z = f_z;
        M_x = 0;
        //this model is yet unable to generate overturning moment
        M_z = 0;
        //and roll resistance torque.
        M_y = t_y;

        //VISUAL REPRESENTATION OF TYRE AND RIM
        S_rel = [nn]*transpose([nn]) + (identity(3) - [nn]*transpose([nn]))*cos(
          phi) - skew(nn)*sin(phi);
        //tyre
        // shape_1.S = wheel_body.frame_b.R.T*transpose(S_rel);
        // shape_1.r = wheel_body.frame_b.r_0;
        //rim
        // shape0.S = shape_1.S;
        // shape0.r = shape_1.r;
        // shape1.S = shape0.S;
        // shape1.r = shape0.r;
        // shape2.S = shape1.S;
        // shape2.r = shape1.r;
        // shape3.S = shape2.S;
        // shape3.r = shape2.r;
        // shape4.S = shape3.S;
        // shape4.r = shape3.r;
        // shape5.S = shape4.S;
        // shape5.r = shape4.r;
        // shape6.S = shape5.S;
        // shape6.r = shape5.r;

        connect(shape_1.frame_a, wheel_body.frame_a) annotation (Line(
            points={{20,-50},{20,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape1.frame_a, wheel_body.frame_a) annotation (Line(
            points={{-50,-110},{-50,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape2.frame_a, wheel_body.frame_a) annotation (Line(
            points={{-20,-110},{-20,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape3.frame_a, wheel_body.frame_a) annotation (Line(
            points={{10,-110},{10,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape4.frame_a, wheel_body.frame_a) annotation (Line(
            points={{40,-110},{40,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape5.frame_a, wheel_body.frame_a) annotation (Line(
            points={{70,-110},{70,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape6.frame_a, wheel_body.frame_a) annotation (Line(
            points={{100,-110},{100,-80},{120,-80},{120,0},{140,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(normal_force.y,gain. u) annotation (Line(
            points={{21,110},{38,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fx_squared.y,fx_squared_plus_fy_squared. u1) annotation (Line(
            points={{-99,130},{-80,130},{-80,116},{-62,116}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fy_squared.y,fx_squared_plus_fy_squared. u2) annotation (Line(
            points={{-99,90},{-80,90},{-80,104},{-62,104}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(fx_squared_plus_fy_squared.y,normal_force. u) annotation (Line(
            points={{-39,110},{-2,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gain.y,normalize_for_clutch. u) annotation (Line(
            points={{61,110},{78,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(normalize_for_clutch.y,rolling_resistance. f_normalized) annotation (
            Line(
            points={{101,110},{120,110},{120,60},{30,60},{30,41}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rolling_resistance.flange_a, hub.axis) annotation (Line(
            points={{40,30},{50,30},{50,10},{0,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(rolling_resistance.flange_b, hub.support) annotation (Line(
            points={{20,30},{-20,30},{-20,10},{-6,10}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(realExpression3.y, fx_squared.u1) annotation (Line(
            points={{-159,130},{-142,130},{-142,136},{-122,136}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(realExpression3.y, fx_squared.u2) annotation (Line(
            points={{-159,130},{-142,130},{-142,124},{-122,124}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(realExpression4.y, fy_squared.u1) annotation (Line(
            points={{-159,90},{-140,90},{-140,96},{-122,96}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(realExpression4.y, fy_squared.u2) annotation (Line(
            points={{-159,90},{-140,90},{-140,84},{-122,84}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Documentation(info="This element contains the inertia properties of a
rotating wheel and the tyre forces acting at the
contact point of the wheel with the road. The tyre forces
are computed accorded to the equations of Rill (see reference below).
The wheel data is defined via the record WheelData and the tire
data is defined via the record RillTyre.TyreData.
Therefore, it suffices to define one instance of
these records and use them for all 4 wheels of a vehicle.
The frames of this object have the following meaning:
Frame carrierFrame is fixed in the carrier of the wheel
and is located on the spin axis of the wheel in the
middle point of the wheel. This point is also approximately
used as the center-of-mass of the wheel.
It is temporarily assumed that the road lies in the
x-z plane of the inertial frame! This restriction can
be removed by defining the road properties via inner/outer
functions.
Flange driveShaft is used to drive the wheel with
a 1D-drive train.
This element is realized according to the description
  Georg Rill: Simulation von Kraftfahrzeugen,
              Vieweg, 1994
"),       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                  200}})),
          Coordsys(
            extent=[-100, -100; 100, 100],
            grid=[2, 2],
            component=[20, 20]),
          Window(
            x=0.03,
            y=0.14,
            width=0.45,
            height=0.81),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                  200}}),
                  graphics));
      end Wheel_Rill_FLANGE;

      model Test_Driver_Differential
        extends C2M2L_Ext.Icons.Test_Driver;

        Modelica.Blocks.Sources.Ramp Diff_in(
          duration=1,
          startTime=5,
          height=0,
          offset=1)
          annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
        Modelica.Blocks.Sources.Step Diff_out(height=0, offset=1)
          annotation (Placement(transformation(extent={{-70,38},{-50,58}})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Drive_Line.Differential.Differential_Control_Bus
          differential_Control_Bus
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
      equation
        connect(Diff_out.y,differential_Control_Bus. Output_Diff_Lock) annotation (
            Line(
            points={{-49,48},{-12,48},{-12,0},{100,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Diff_in.y, differential_Control_Bus.Input_Diff_Lock) annotation (Line(
            points={{-19,80},{-12,80},{-12,0},{100,0}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(graphics));
      end Test_Driver_Differential;

      model Test_Driver_Brakes
        extends C2M2L_Ext.Icons.Test_Driver;

        Modelica.Blocks.Sources.Ramp Brake_Signal(
          duration=1,
          startTime=5,
          height=1)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        C2M2L_Ext.Interfaces.Context_Interfaces.Driver.Driver_Bus driver_Bus
          annotation (Placement(transformation(extent={{90,-10},{110,10}}),
              iconTransformation(extent={{90,-10},{110,10}})));
      equation
        connect(Brake_Signal.y, driver_Bus.brakePedalPosition) annotation (Line(
            points={{-39,0},{100,0}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (Diagram(graphics), Icon(graphics));
      end Test_Driver_Brakes;

      model Test_Driver_Parking_Brake
        extends C2M2L_Ext.Icons.Test_Driver;

        parameter Boolean brake_on=true "=true, if park brake is on";
        parameter Integer value = if brake_on then C2M2L_Ext.Interfaces.Context_Interfaces.Driver.ParkBrake_Setting.On else C2M2L_Ext.Interfaces.Context_Interfaces.Driver.ParkBrake_Setting.Off;

        Modelica.Blocks.Sources.IntegerConstant Park_Brake_Signal(k=value)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        C2M2L_Ext.Interfaces.Context_Interfaces.Driver.Driver_Bus driver_Bus
          annotation (Placement(transformation(extent={{90,-10},{110,10}}),
              iconTransformation(extent={{90,-10},{110,10}})));

      equation
        connect(Park_Brake_Signal.y, driver_Bus.park_brake) annotation (Line(
            points={{-39,0},{100,0}},
            color={255,127,0},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (Diagram(graphics), Icon(graphics));
      end Test_Driver_Parking_Brake;

      model DoubleWishBone
        "Consists of upper and lower control arms, and steering knuckle"

        import SI = Modelica.SIunits;

        parameter Real[3] scaleFactor={1,1,1}
          "To make left hand side use {1,1,-1}";
        parameter SI.Length addl_half_track_width=0 "Additional track width";

      // UCA PARAMETERS

        parameter SI.Position[3] uca_front
          "Vector from frame_C to UCA front attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Upper Control Arm"));
        parameter SI.Position[3] uca_rear
          "Vector from frame_C to UCA rear attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Upper Control Arm"));
        parameter SI.Position[3] uca_outer
          "Vector from frame_C to UCA outer ball joint resolved in frame_C"
          annotation (Dialog(group="Geometry - Upper Control Arm"));
        parameter SI.Position[3] cm_uca
          "Vector from frame_C to UCA cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Upper Control Arm"));
        parameter SI.Mass m_uca=1 "Mass of UCA"
          annotation (Dialog(tab="Mass Properties", group="Upper Control Arm"));

      // LCA PARAMETERS

        parameter SI.Position[3] lca_front
          "Vector from frame_C to LCA front attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_rear
          "Vector from frame_C to LCA rear attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_outer
          "Vector from frame_C to LCA lower ball joint resolved in frame_C"
          annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position[3] lca_strut
          "Vector from frame_C to lower strut attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Lower Control Arm"));
        parameter SI.Position cm_lca[3]
          "Vector from frame_C to LCA cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Lower Control Arm"));
        parameter SI.Mass m_lca=1 "Mass of UCA"
          annotation (Dialog(tab="Mass Properties", group="Lower Control Arm"));

      // KNUCKLE PARAMETERS

        parameter SI.Position[3] wheel_center
          "Vector from frame_C to wheel center resolved in frame_C"
          annotation (Dialog(group="Geometry - Knuckle"));
        parameter SI.Position[3] tierod_outer
          "Vector from frame_C to knuckle tierod attachment resolved in frame_C"
          annotation (Dialog(group="Geometry - Knuckle"));

        parameter SI.Position cm_knuckle[3]
          "Vector from frame_C to knuckle cg resolved in frame_C"
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Mass m_knuckle=1 "Mass of knuckle"
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_xx_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_yy_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));
        parameter SI.Inertia I_zz_knuckle=1e-3
          annotation (Dialog(tab="Mass Properties", group="Knuckle"));

      protected
        parameter Real[3] uca_front_scaled1={uca_front[1],uca_front[2],uca_front[3]+addl_half_track_width};
        parameter Real[3] uca_rear_scaled1={uca_rear[1],uca_rear[2],uca_rear[3]+addl_half_track_width};
        parameter Real[3] uca_outer_scaled1={uca_outer[1],uca_outer[2],uca_outer[3]+addl_half_track_width};
        parameter Real[3] cm_uca_scaled1={cm_uca[1],cm_uca[2],cm_uca[3]+addl_half_track_width};

        parameter SI.Position[3] lca_front_scaled1={lca_front[1],lca_front[2],lca_front[3]+addl_half_track_width};
        parameter SI.Position[3] lca_rear_scaled1={lca_rear[1],lca_rear[2],lca_rear[3]+addl_half_track_width};
        parameter SI.Position[3] lca_outer_scaled1={lca_outer[1],lca_outer[2],lca_outer[3]+addl_half_track_width};
        parameter SI.Position[3] lca_strut_scaled1={lca_strut[1],lca_strut[2],lca_strut[3]+addl_half_track_width};
        parameter SI.Position[3] cm_lca_scaled1={cm_lca[1],cm_lca[2],cm_lca[3]+addl_half_track_width};

        parameter SI.Position[3] wheel_center_scaled1={wheel_center[1],wheel_center[2],wheel_center[3]+addl_half_track_width};
        parameter SI.Position[3] tierod_outer_scaled1={tierod_outer[1],tierod_outer[2],tierod_outer[3]+addl_half_track_width};

        parameter Real[3] uca_front_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                               scaleFactor, uca_front_scaled1);
        parameter Real[3] uca_rear_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                              scaleFactor, uca_rear_scaled1);
        parameter Real[3] uca_outer_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                               scaleFactor, uca_outer_scaled1);
        parameter Real[3] cm_uca_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                            scaleFactor, cm_uca_scaled1);

        parameter SI.Position[3] lca_front_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                      scaleFactor, lca_front_scaled1);
        parameter SI.Position[3] lca_rear_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                     scaleFactor, lca_rear_scaled1);
        parameter SI.Position[3] lca_outer_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                      scaleFactor, lca_outer_scaled1);
        parameter SI.Position[3] lca_strut_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                      scaleFactor, lca_strut_scaled1);
        parameter Real[3] cm_lca_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                            scaleFactor, cm_lca_scaled1);

        parameter SI.Position[3] wheel_center_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                         scaleFactor, wheel_center_scaled1);
        parameter SI.Position[3] tierod_outer_scaled=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                                                         scaleFactor, tierod_outer_scaled1);

        parameter SI.Position rU[3]=wheel_center_scaled - lca_outer_scaled
          "Position vector from lca_outer to frame_wheel, resolved in frame_C";

        parameter Real n_a[3]=cross(uca_front, rU)
          "First rotation axis of universalUtilities.Joints.Joint in springJoint, resolved in frame_C";
      protected
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_hidden
          annotation (extent=[54, -11; 68, -24], Placement(transformation(extent={{49,-24},
                  {81,-56}})));
      public
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation
                                                     outerRod(r=wheel_center_scaled - lca_outer_scaled,
          width=0.03,
          height=0.03,
          color={0,0,200},
          specularCoefficient=0.1)
          annotation (extent=[65, -10; 85, 10], rotation=0,
          Placement(transformation(extent={{60,-10},{80,10}})));
        Modelica.Mechanics.MultiBody.Parts.Body knuckle(
          animation=false,
          m=m_knuckle,
          I_11=I_xx_knuckle,
          I_22=I_yy_knuckle,
          I_33=I_zz_knuckle,
          r_CM={0,0,0})
                     annotation (extent=[66, -60; 86, -40], Placement(transformation(
                extent={{80,-70},{100,-50}})));
        Modelica.Mechanics.MultiBody.Joints.Revolute lca_inner(n=lca_front_scaled -
              lca_rear_scaled,
          cylinderColor={100,100,100},
          cylinderLength=0.05,
          cylinderDiameter=0.10,
          specularCoefficient=0.1)     annotation (extent=[-70, -50; -50, -30],
            Placement(transformation(extent={{-80,-47},{-60,-27}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation
                                                     lowerFrontBar(r=lca_outer_scaled - lca_front_scaled,
          color={255,0,0},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
                    annotation (extent=[-40, -50; -20, -30], Placement(
              transformation(extent={{-50,-47},{-30,-27}})));

      public
        Modelica.Mechanics.MultiBody.Joints.Revolute uca_inner(n=uca_front_scaled -
              uca_rear_scaled, cylinderColor={100,100,100},
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          specularCoefficient=0.1,
          stateSelect=StateSelect.always)
                              annotation (extent=[-70, 30; -50, 50], Placement(
              transformation(extent={{-80,26},{-60,46}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation
                                                     upperFrontBar(
                    r=uca_outer_scaled - uca_front_scaled,
          color={0,128,255},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
                    annotation (extent=[-40, 30; -20, 50], Placement(transformation(
                extent={{-50,26},{-30,46}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape2(
          color={100,100,100},
          shapeType="cylinder",
          length=0.05,
          width=0.08,
          height=0.08,
          lengthDirection=uca_front_scaled - uca_rear_scaled,
          r_shape={-0.025,0,0},
          specularCoefficient=0.1) annotation (extent=[-42, 76; -22, 96], Placement(
              transformation(extent={{-50,70},{-30,90}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape4(
          color={100,100,100},
          shapeType="cylinder",
          length=0.05,
          width=0.10,
          height=0.10,
          lengthDirection=lca_front_scaled - lca_rear_scaled,
          r_shape={-0.025,0,0},
          specularCoefficient=0.1) annotation (extent=[-50, -39; -30, -19], Placement(
              transformation(extent={{-50,-87},{-30,-67}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape7(
          shapeType="sphere",
          lengthDirection={1,0,0},
          specularCoefficient=0.1,
          r_shape={-0.015,0,0},
          length=0.03,
          width=0.03,
          height=0.03,
          color={0,0,200})         annotation (extent=[6, -69; 26, -49], Placement(
              transformation(extent={{-5,-70},{15,-50}})));
        Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape8(
          shapeType="sphere",
          lengthDirection={1,0,0},
          specularCoefficient=0.1,
          r_shape={-0.015,0,0},
          length=0.03,
          width=0.03,
          height=0.03,
          color={0,0,200})         annotation (extent=[14, 13; 34, 33], Placement(
              transformation(extent={{0,26},{20,46}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation lower(r=lca_front_scaled,
            animation=false)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-90,-20})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation upper(r=uca_front_scaled,
            animation=false)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-90,20})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_strut
                                                                   annotation (
            Placement(transformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={10,-102}),iconTransformation(
              extent={{-16,-16},{16,16}},
              rotation=270,
              origin={0,-100})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation
                                                     lowerRearBar(
          r=lca_rear_scaled - lca_outer_scaled,
          widthDirection=cross(lca_rear_scaled - lca_outer_scaled, {0,0,1}),
          color={255,0,0},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
          annotation (Placement(transformation(extent={{-30,-67},{-50,-47}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation
                                                     upperRearBar(
          r=uca_rear_scaled - uca_outer_scaled,
          widthDirection=cross(uca_rear_scaled - uca_outer_scaled, {0,0,1}),
          color={0,128,255},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)
          annotation (Placement(transformation(extent={{-30,50},{-50,70}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_chassis
          annotation (Placement(transformation(extent={{-118,-16},{-86,16}}),
              iconTransformation(extent={{-116,-16},{-84,16}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_wheel
          annotation (Placement(transformation(extent={{86,-16},{118,16}}),
              iconTransformation(extent={{84,-16},{116,16}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation strut_mount(
                                                   height=0.03, r=lca_strut_scaled
               - lca_front_scaled,
          color={255,0,0},
          width=0.03)
                    annotation (extent=[-40, -50; -20, -30], Placement(transformation(
                extent={{-30,-100},{-10,-80}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation steeringArm(
                     r=tierod_outer_scaled - lca_outer_scaled,
          width=0.04,
          height=0.04,
          specularCoefficient=0.1)
          annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=270,
              origin={60,60})));
        Modelica.Mechanics.MultiBody.Joints.Spherical upr_joint(
          sphereDiameter=0.04,
          specularCoefficient=0.3,
          sphereColor={0,0,200},
          animation=false)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,24})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation knuckle_height(
          r(displayUnit="m") = uca_outer_scaled - lca_outer_scaled,
          color={0,0,200},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1)          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,0})));
        Modelica.Mechanics.MultiBody.Joints.Spherical lwr_joint(
          specularCoefficient=0.3, animation=false)
          annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=270,
              origin={-10,-24})));
        Modelica.Mechanics.MultiBody.Parts.BodyShape knuckle_shape(
          sphereDiameter=0.042,
          width=0.002,
          height=0.002,
          color={100,100,100},
          specularCoefficient=0.1,
          r=uca_outer_scaled - lca_outer_scaled,
          r_CM=C2M2L_Ext.C2M2L_Component_Building_Blocks.Wheeled_Suspension.EWM(
                   uca_outer_scaled - lca_outer_scaled, {0.5,0.5,0.5}),
          m=10,
          useQuaternions=false)
                    annotation (extent=[-40, -50; -20, -30], Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={35,-40})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_tierod
          annotation (Placement(transformation(extent={{-16,-16},{16,16}},
              rotation=0,
              origin={-102,100}),
              iconTransformation(extent={{-116,64},{-84,96}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation upper_CG(
          widthDirection=cross(uca_rear_scaled - uca_outer_scaled, {0,0,1}),
          color={0,128,255},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1,
          r=cm_uca_scaled - uca_front_scaled,
          animation=false)
          annotation (Placement(transformation(extent={{-60,45},{-80,65}})));
        Modelica.Mechanics.MultiBody.Parts.Body uca(
          animation=false,
          m=m_uca,
          I_11=1e-3,
          I_22=1e-3,
          I_33=1e-3,
          r_CM={0,0,0})
                     annotation (extent=[66, -60; 86, -40], Placement(transformation(
                extent={{-80,60},{-100,80}})));
        Modelica.Mechanics.MultiBody.Parts.Body lca(
          animation=false,
          I_11=1e-3,
          I_22=1e-3,
          I_33=1e-3,
          m=m_lca,
          r_CM={0,0,0})
                     annotation (extent=[66, -60; 86, -40], Placement(transformation(
                extent={{-80,-90},{-100,-70}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation lower_CG(
          widthDirection=cross(uca_rear_scaled - uca_outer_scaled, {0,0,1}),
          color={0,128,255},
          width=0.03,
          height=0.03,
          specularCoefficient=0.1,
          r=cm_lca_scaled - lca_front_scaled,
          animation=false)
          annotation (Placement(transformation(extent={{-60,-70},{-80,-50}})));
      equation
        connect(frame_chassis, frame_chassis)
                                  annotation (Line(
            points={{-102,0},{-102,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lower.frame_b, lca_inner.frame_a)       annotation (Line(
            points={{-90,-30},{-90,-37},{-80,-37}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upper.frame_b, uca_inner.frame_a)       annotation (Line(
            points={{-90,30},{-90,36},{-80,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(knuckle.frame_a, frame_hidden)
                                      annotation (Line(
            points={{80,-60},{65,-60},{65,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(frame_hidden, outerRod.frame_a)
                                             annotation (Line(
            points={{65,-40},{50,-40},{50,0},{60,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lca_inner.frame_b, lowerFrontBar.frame_a)       annotation (Line(
            points={{-60,-37},{-50,-37}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(uca_inner.frame_b, upperFrontBar.frame_a)       annotation (Line(
            points={{-60,36},{-50,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upper.frame_a, frame_chassis)
                                        annotation (Line(
            points={{-90,10},{-90,0},{-102,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lower.frame_a, frame_chassis)
                                        annotation (Line(
            points={{-90,-10},{-90,0},{-102,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(outerRod.frame_b, frame_wheel)
                                           annotation (Line(
            points={{80,0},{102,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_mount.frame_b, frame_strut)
                                                 annotation (Line(
            points={{-10,-90},{10,-90},{10,-102}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(steeringArm.frame_a, frame_hidden)
                                                annotation (Line(
            points={{60,50},{50,50},{50,-40},{65,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(strut_mount.frame_a, lca_inner.frame_b) annotation (Line(
            points={{-30,-90},{-60,-90},{-60,-37}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape2.frame_a, upperRearBar.frame_b) annotation (Line(
            points={{-50,80},{-55,80},{-55,60},{-50,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upperRearBar.frame_a, upperFrontBar.frame_b) annotation (Line(
            points={{-30,60},{-25,60},{-25,36},{-30,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lowerFrontBar.frame_b, lowerRearBar.frame_a) annotation (Line(
            points={{-30,-37},{-25,-37},{-25,-57},{-30,-57}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lowerRearBar.frame_b, shape4.frame_a) annotation (Line(
            points={{-50,-57},{-55,-57},{-55,-77},{-50,-77}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upperFrontBar.frame_b, upr_joint.frame_b) annotation (Line(
            points={{-30,36},{-10,36},{-10,34}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upr_joint.frame_a, knuckle_height.frame_b) annotation (Line(
            points={{-10,14},{-10,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(knuckle_height.frame_a, lwr_joint.frame_b) annotation (Line(
            points={{-10,-10},{-10,-12},{-10,-14},{-10,-14}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lowerFrontBar.frame_b, lwr_joint.frame_a) annotation (Line(
            points={{-30,-37},{-10,-37},{-10,-34}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape8.frame_a, upr_joint.frame_b) annotation (Line(
            points={{0,36},{-10,36},{-10,34}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(knuckle_shape.frame_a, frame_hidden)
                                                 annotation (Line(
            points={{35,-50},{35,-60},{65,-60},{65,-40}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(knuckle_height.frame_a, steeringArm.frame_a) annotation (Line(
            points={{-10,-10},{30,-10},{30,50},{60,50}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(shape7.frame_a, lwr_joint.frame_a) annotation (Line(
            points={{-5,-60},{-10,-60},{-10,-34}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(frame_tierod, steeringArm.frame_b) annotation (Line(
            points={{-102,100},{60,100},{60,70}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(upper_CG.frame_a, uca_inner.frame_b) annotation (Line(
            points={{-60,55},{-60,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(uca.frame_a, upper_CG.frame_b) annotation (Line(
            points={{-80,70},{-80,55}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lower_CG.frame_a, lca_inner.frame_b) annotation (Line(
            points={{-60,-60},{-60,-37}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(lower_CG.frame_b, lca.frame_a) annotation (Line(
            points={{-80,-60},{-80,-80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          Coordsys(
            extent=[-100, -100; 100, 100],
            grid=[1, 1],
            component=[20, 20]),
          Icon(
            Rectangle(extent=[26, -16; 50, -24], style(
                color=7,
                fillColor=7,
                fillPattern=1)),
            coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}),
            Ellipse(extent=[30, -34; 46, -18], style(
                color=0,
                fillColor=7,
                fillPattern=1)),
            Ellipse(extent=[30, 21; 46, 37], style(
                color=0,
                fillColor=7,
                fillPattern=1)),
            Rectangle(extent=[26, 27; 50, 19], style(
                color=7,
                fillColor=7,
                fillPattern=1)),
            Line(points=[-58, -44; 30, -28; -58, -18], style(color=0, thickness=4)),
            Ellipse(extent=[-58, -28; -38, -8], style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            graphics={
              Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{52,-19},{66,31},{73,31},{60,-19},{52,-19}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={45,-35},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={45,-35},
                rotation=360),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={45,25},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={45,25},
                rotation=360),
              Line(
                points={{-33,-30},{37,-40},{-53,-55}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=1),
              Line(
                points={{-33,-52},{-9,-33}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=1),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={70,40},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={70,40},
                rotation=360),
              Rectangle(
                extent={{60,49},{65,29}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={70,40},
                rotation=360),
              Rectangle(
                extent={{35,23},{55,3}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Rectangle(
                extent={{35,-25},{55,-33}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-43,40},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-43,40},
                rotation=360),
              Rectangle(
                extent={{-59,50},{-44,30}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-43,40},
                rotation=360),
              Rectangle(
                extent={{40,25},{50,-35}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={45,25},
                rotation=360),
              Line(
                points={{-33,40},{37,30},{-53,15}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=1),
              Line(
                points={{-33,18},{-9,37}},
                color={0,0,0},
                smooth=Smooth.None,
                thickness=1),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-63,15},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-63,15},
                rotation=360),
              Rectangle(
                extent={{-79,25},{-64,5}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-63,15},
                rotation=360),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-43,-30},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-43,-30},
                rotation=360),
              Rectangle(
                extent={{-59,-20},{-44,-40}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-43,-30},
                rotation=360),
              Ellipse(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-63,-55},
                rotation=360),
              Ellipse(
                extent={{-8,8},{8,-8}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                origin={-63,-55},
                rotation=360),
              Rectangle(
                extent={{-79,-45},{-64,-65}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={-63,-55},
                rotation=360),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                origin={45,-35},
                rotation=360),
              Polygon(
                points={{41,-25},{74,-25},{84,-3},{99,-3},{99,3},{80,3},{70,-19},{41,
                    -19},{41,-25}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-70,65},{70,40}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dot,
                thickness=0.5)},
            Ellipse(extent=[-54, -12; -42, -24], style(
                color=0,
                fillColor=0,
                fillPattern=1))),
          Diagram(
            coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}},
              grid={1,1}),
            Line(points=[-90, 0; -77, -40], style(color=1, arrow=1)),
            Text(
              extent=[-97, -35; -77, -42],
              style(color=1, arrow=1),
              string="lca_front"),
            Line(points=[-90, 0; 0, -40], style(color=1, arrow=1)),
            Text(
              extent=[-20, 36; -5, 29],
              style(color=1, arrow=1),
              string="uca_outer"),
            Text(
              extent=[-99, 36; -72, 30],
              style(color=1, arrow=1),
              string="uca_front"),
            Line(points=[-90, 0; -77, 40], style(color=1, arrow=1)),
            Text(
              extent=[-12, 55; 12, 48],
              style(color=1, arrow=1),
              string="rRL3"),
            Line(points=[-90, 0; 65, 80], style(color=1, arrow=1)),
            Line(points=[-90, 0; 61, 54], style(color=1, arrow=1)),
            Text(
              extent=[21, 51; 44, 44],
              style(color=1, arrow=1),
              string="rUL3"),
            Text(
              extent=[64, 22; 91, 16],
              style(color=1, arrow=1),
              string="wheel_center"),
            Line(points=[-90, 0; 90, 15], style(color=1, arrow=1)),
            Text(
              extent=[-17, -27; 0, -33],
              style(color=1, arrow=1),
              string="lca_outer"),
            Line(points=[-90, 0; 0, 39], style(color=1, arrow=1)),
            graphics),
          Window(
            x=0.45,
            y=0.01,
            width=0.28,
            height=0.42),
          Documentation(info="<HTML>
<p>
The MacPherson strut suspension was invented in the 1940s by Earl S. MacPherson of Ford.
It was introduced on the 1950 English Ford and has since become one of the dominating suspensions 
systems of the world because of its compactness and low cost. 
Unlike other suspension designs, in MacPherson strut suspension, the telescopic shock absorber also 
serves as a link to control the position of the wheel and makes the upper control arm obsolete. Since 
the strut is vertically positioned, the whole suspension is very compact and suitable for front-wheel
 drive cars, whose engine and transmission are all located inside the front compartment and need front suspensions which engage very little width of the car.
</p>
<p>
Advantages:
Compact and cheap.
</p>
<p>
Disadvantages:
Body roll and wheel's movement lead to variation in camber, although not as severe as swing axle suspension. 
</p>
<p>
Usage:
The MacPherson strut is the dominatin front suspension for cars.
</p>
<p>
The following parameters are used to define the component, see nomenclature for further information:
</p>
<pre>
  scaleFactor: The component can be scaled assymetrically, e.g. {1,-1,1} makes a left-hand linkage into a right-hand dito.
  uca_outer: location of UCA outer ball joint, resolved in frame_C
  uca_front: location of UCA inner front joint, resolved in frame_C
  lca_rear:  location of inner rearUtilities.Joints.Joint, resolved in frame_C
  rCS:    location of strut mount in chassis, resolved in frame_C
  rUS:    location of strut mount in upright, resolved in frame_C
  wheel_center:    location of frame_W, resolved in frame_C
  forceTable: To set the force generation table add a component named [name] of class Utilities.Forces.Utilities.ForceTable1D to the model and write forceTable=[name] in the modifiers row
  Mass and inertia properties not yet solved!  
</pre>
</HTML>
"));
      end DoubleWishBone;
    end Wheeled_Suspension;

    package Drive_Shafts
      extends Modelica.Icons.Package;

      partial model Partial_Mechanical
        "Base class for all mechanical implementations of drive shafts"

        parameter SI.Length length(final min=0) = 1
          "Length of shaft, slip joint collapsed";
        parameter SI.Length length_flange_to_joint_center(final min=0) = 0.1
          "Length of from connection flanges to the center of the articulating joints";
        parameter SI.Length max_slip(final min=0) = 0.1
          "Maximum length slip joint can extend";
        parameter SI.Diameter outer_dia(final min=0) = 0.05
          "Outer diameter of shaft";
        parameter SI.Diameter wall_thick(final min=0) = 0.005
          "Wall thickness of shaft";
        parameter SI.Density rho(final min=0) = 8000
          "Material density of shaft";
        parameter SI.ShearModulus G(final min=0) = 79.3e9
          "Shear modulus of shaft material";
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        frame_a(
            includeBearingConnector=world.driveTrainMechanics3D)
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        frame_b(
            includeBearingConnector=world.driveTrainMechanics3D)
          annotation (Placement(transformation(extent={{84,-16},{116,16}})));
        outer Modelica.Mechanics.MultiBody.World world
          annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
      equation

        annotation (Icon(graphics={
              Rectangle(
                extent={{-82,78},{-60,50}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.HorizontalCylinder),
              Rectangle(
                extent={{62,24},{84,-4}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.HorizontalCylinder),
              Polygon(
                points={{-46,74},{58,24},{48,2},{-56,54},{-46,74}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={175,175,175}),
              Line(
                points={{-98,2},{-88,2},{-88,66},{-54,66},{58,8},{100,8}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.DashDot)}), Documentation(info="<html>
<p>Partial model that specifies the connection ports that a drive shaft mechanical model implements.</p>
<p>Specifies an <b>outer</b> record that will obtain the drive shaft data from a containing drive shaft component. All the data required from the record is copied into local parameters so extending models can use them directly.</p>
</html>"),Diagram(graphics));
      end Partial_Mechanical;

      model Mechanical_Simple_1D_Bevel_CV "Bevels 1D for CV joint"
        extends C2M2L_OM.Suspension_Ideal.Drive_Shafts.Partial_Mechanical;

        C2M2L_Ext.Mechanics.MultiBody.Adaptors.BearingFrame_To_Flange bearingFrame_To_Flange
          annotation (Placement(transformation(extent={{-76,-10},{-56,10}})));
        C2M2L_Ext.Mechanics.MultiBody.Adaptors.BearingFrame_To_Flange bearingFrame_To_Flange1
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={68,0})));
        Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS position_joints(animation=
             world.enableAnimation)
          "Positions the joints in space but does not transmit any torque or provide any constraints"
          annotation (Placement(transformation(extent={{-20,80},{20,40}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation stub_a(r={0,0,
              length_flange_to_joint_center}, animation=world.enableAnimation)
          "Straight portion of the shaft before articulating joint"
          annotation (Placement(transformation(extent={{-96,50},{-76,70}})));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation stub_b(r={0,0,
              length_flange_to_joint_center}, animation=world.enableAnimation)
          "Straight portion of the shaft before articulating joint"
          annotation (Placement(transformation(extent={{76,50},{96,70}})));
        Modelica.Mechanics.MultiBody.Parts.FixedRotation transform_a(
          rotationType=Modelica.Mechanics.MultiBody.Types.RotationTypes.PlanarRotationSequence,
          angles={-90,90,0},
          animation=world.enableAnimation)
          "Lines up the internal frame with frame_a when the shaft is at 0 deg angle"
                               annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-16,26})));

        outer Modelica.Mechanics.MultiBody.World world
          annotation (Placement(transformation(extent={{0,80},{20,100}})));
        parameter Real k=0
          "Torque (Nm) lost in each joint per radian of deflection";
        parameter Real CVlossTable[:,:]=[0,1;0.08727,0.996;0.17453,0.991;0.26180,0.986;0.34907,0.981;0.43633,0.976;0.52360,0.971;0.61087,0.966]
          "Array for CV joint efficiencies at angle [rad vs efficiency]";
        parameter SI.Inertia moi_rotational=0.01
          "Input rotational moment of inertia";
        Ideal_Gears.Bevel_Gear_3D_Auto_Orient_Angle_Dependant_Losses
          bevel_Gear_3D_b(
          ratio=1,
          lossTable=[0,1,1,0,0],
          combiTable1D(table=CVlossTable))
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
        Ideal_Gears.Bevel_Gear_3D_Auto_Orient_Angle_Dependant_Losses
          bevel_Gear_3D_a(
          ratio=1,
          lossTable=[0,1,1,0,0],
          combiTable1D(table=CVlossTable))
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        Modelica.Mechanics.MultiBody.Parts.FixedRotation transform_b(
          rotationType=Modelica.Mechanics.MultiBody.Types.RotationTypes.PlanarRotationSequence,
          animation=world.enableAnimation,
          angles={0,90,-90})
          "Lines up the internal frame with frame_a when the shaft is at 0 deg angle"
                               annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={16,26})));

        Modelica.Mechanics.Rotational.Components.Inertia moi(J=moi_rotational)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      equation
        connect(frame_a, bearingFrame_To_Flange.bearing_frame) annotation (Line(
            points={{-100,0},{-76,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bearingFrame_To_Flange1.bearing_frame, frame_b) annotation (Line(
            points={{78,-1.22465e-015},{88,-1.22465e-015},{88,0},{100,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(stub_a.frame_b, position_joints.frame_a)    annotation (Line(
            points={{-76,60},{-20,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position_joints.frame_b, stub_b.frame_a)     annotation (Line(
            points={{20,60},{76,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(stub_b.frame_b, frame_b.bearingFrame)            annotation (Line(
            points={{96,60},{100,60},{100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(stub_a.frame_a, frame_a.bearingFrame)           annotation (Line(
            points={{-96,60},{-100,60},{-100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(position_joints.frame_ia, transform_a.frame_a)
                                                          annotation (Line(
            points={{-16,40},{-16,38},{-16,36},{-16,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_b.frame_b, frame_b.bearingFrame) annotation (Line(
            points={{60,8},{100,8},{100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_b.flange_b, bearingFrame_To_Flange1.frame) annotation (
            Line(
            points={{60,0},{64,0},{64,-2.44929e-016},{70,-2.44929e-016}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(bevel_Gear_3D_a.flange_a, bearingFrame_To_Flange.frame) annotation (
            Line(
            points={{-60,0},{-68,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(bevel_Gear_3D_a.frame_a, frame_a.bearingFrame) annotation (Line(
            points={{-60,8},{-94,8},{-94,0},{-100,0}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_a.frame_b, transform_a.frame_b)   annotation (Line(
            points={{-40,8},{-16,8},{-16,16}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(position_joints.frame_ib, transform_b.frame_a)
                                                           annotation (Line(
            points={{16,40},{16,36}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_b.frame_a, transform_b.frame_b)    annotation (Line(
            points={{40,8},{16,8},{16,16}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_a.case_reaction, frame_a.bearingFrame) annotation (Line(
            points={{-50,-10},{-50,-20},{-100,-20},{-100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_b.case_reaction, frame_b.bearingFrame) annotation (Line(
            points={{50,-10},{50,-20},{100,-20},{100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bevel_Gear_3D_a.flange_b, moi.flange_a)            annotation (Line(
            points={{-40,0},{-10,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(moi.flange_b, bevel_Gear_3D_b.flange_a)            annotation (Line(
            points={{10,0},{40,0}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (Diagram(graphics), Documentation(info="<html>
<p>Mechanical model that includes:</p>
<p><ul>
<li>The mass and inertia effects of the main shaft</li>
<li>Losses in the universal joints at both ends of the shaft</li>
</ul></p>
<p>Note that the UJs are rotated 90degrees apart so that the axis of their revolute joints match across the main shaft. This is essential to reduce speed and torque fluctuations observed caused by the joints, only when they are 90deg apart will they not cause a speed variation. Regardless of their orientation the center shaft will always experience speed fluctuations.</p>
</html>"));
      end Mechanical_Simple_1D_Bevel_CV;

      model Drive_Shaft_CV_Joint
        "Drive shaft implementation with replaceable mechanical and thermal sub-models"
        //extends Interfaces.Base_C2M2L(thermal_To_Environment(area_for_heat_transfer=
        //        0.1));
        extends C2M2L_Ext.Interfaces.Delivered_C2M2L_200x200;

      //Mechanical
        parameter SI.Length min_length(final min=0) = 1
          "Length of shaft, slip joint collapsed" annotation(Dialog(group="Mechanical"));
        parameter SI.Length length_flange_to_joint_center(final min=0) = 0.1
          "Length of from connection flanges to the center of the articulating joints"
                                                                                       annotation(Dialog(group="Mechanical"));
        parameter SI.Length max_length(final min=0) = 1.1
          "Maximum length with slip joint at max extension" annotation(Dialog(group="Mechanical"));
        parameter SI.Diameter Tube_Outside_Diameter(final min=0) = 0.05
          "Outer diameter of shaft"                                                   annotation(Dialog(group="Mechanical"));
        parameter SI.Diameter Tube_Thickness = 0.005 "Wall thickness of shaft"            annotation(Dialog(group="Mechanical"));

        parameter Real CVlossTable[:,:]=[0,1;0.08727,0.996;0.17453,0.991;0.26180,0.986;0.34907,0.981;0.43633,0.976;0.52360,0.971;0.61087,0.966]
          "Array for CV joint efficiencies at angle [rad vs efficiency]"
                                                                        annotation(Dialog(group="Mechanical"));
        parameter SI.Inertia moi_rotational=0.01
          "Input rotational moment of inertia"                                       annotation(Dialog(group="Mechanical"));

        //parameter SI.Diameter wall_thick(final min=0) = 0.005
        //  "Wall thickness of shaft" annotation(Dialog(group="Mechanical"));
        //parameter SI.Density rho(final min=0) = 8000 "Material density of shaft" annotation(Dialog(group="Mechanical"));
        //parameter SI.ShearModulus G(final min=0) = 79.3e9
        //  "Shear modulus of shaft material" annotation(Dialog(group="Mechanical"));
        //Bevel **has no effect on model, removed
        //parameter Real k=5 "Torque (Nm) lost in each joint per radian of deflection"  annotation(Dialog(group="Mechanical"));

      //Thermal
        parameter SI.ThermalConductivity k_thermal = 40
          "Conductivity of shaft material" annotation(Dialog(group="Thermal"));
        parameter SI.SpecificHeatCapacity c_thermal = 466
          "Specific heat of shaft material" annotation(Dialog(group="Thermal"));

      //Shaft Calculations
        SI.Length running_length "Instantaneous length of shaft";
        Real critical_bending_speed
          "calculated ratio current speed / critical speed";
        Real tau_max
          "ratio of current stress /calculated max stress. used in max torque calculation";

        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        frame_a(
            includeBearingConnector=true)
          "Connection to one end of the drive shaft"
          annotation (Placement(transformation(extent={{-116,-16},{-84,16}})));
        Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearing
                                                        frame_b(
            includeBearingConnector=true)
          "Connection to other end of the drive shaft"
          annotation (Placement(transformation(extent={{84,-16},{116,16}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Sensor_TSP_Single_Output sensor_TSP_a(
            use_bearing_frames=true)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Sensor_TSP_Single_Output sensor_TSP_b(
            use_bearing_frames=true)
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_torque(nu=1)
          "Outputs a ratio of current torque / allowable max torque. Any value greater than 1 is a fail"
          annotation (Placement(transformation(extent={{76,80},{96,100}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_speed(nu=1)
          "Outputs a ratio of current speed / allowable max speed. Any value greater than 1 is a fail"
          annotation (Placement(transformation(extent={{76,54},{96,74}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_power(nu=1)
          annotation (Placement(transformation(extent={{76,28},{96,48}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Extract_Abs_Max_TSP_Bus max_TSP_Bus(nu=2)
          annotation (Placement(transformation(extent={{0,55},{8,75}})));
        Drive_Shafts.Mechanical_Simple_1D_Bevel_CV
          mechanical_Simple_1D_Bevel_CV(
          length_flange_to_joint_center=length_flange_to_joint_center,
          CVlossTable=CVlossTable,
          moi_rotational=moi_rotational,
          length=min_length,
          max_slip=max_length - min_length,
          outer_dia=Tube_Outside_Diameter,
          wall_thick=Tube_Thickness)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        Modelica.Mechanics.MultiBody.Sensors.RelativePosition relativePosition
          annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
      protected
        Modelica.Blocks.Interfaces.RealOutput critical_bending_speed_output
          annotation (Placement(transformation(extent={{30,65},{50,85}})));
      protected
        Modelica.Blocks.Interfaces.RealOutput tau_max_output
          annotation (Placement(transformation(extent={{30,85},{50,105}})));
      equation
        running_length = ((relativePosition.r_rel[1]^2) +(relativePosition.r_rel[2]^2) + (relativePosition.r_rel[3]^2))^0.5;
        critical_bending_speed = abs(sensor_TSP_a.speedSensor.w)/(167*((Tube_Outside_Diameter*1000)/running_length)*2*pi/60);
        tau_max = ((Tube_Outside_Diameter*abs(sensor_TSP_a.torqueSensor.tau))/(pi*((Tube_Outside_Diameter/2)^4-((Tube_Outside_Diameter-2*Tube_Thickness)/2)^4)))/300000000;
        tau_max_output = tau_max;
        critical_bending_speed_output = critical_bending_speed;
        connect(frame_a, sensor_TSP_a.bearing_frame_a) annotation (Line(
            points={{-100,0},{-60,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensor_TSP_b.bearing_frame_b, frame_b) annotation (Line(
            points={{60,0},{100,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(max_TSP_Bus.y_power, max_power.u[1]) annotation (Line(
            points={{6.2,59},{38,59},{38,38},{76,38}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sensor_TSP_a.sensor_Block_Bus, max_TSP_Bus.sensor_TSP_bus_in[1])
          annotation (Line(
            points={{-50,10},{-50,65},{-3,65}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensor_TSP_b.sensor_Block_Bus, max_TSP_Bus.sensor_TSP_bus_in[2])
          annotation (Line(
            points={{50,10},{50,30},{0,30},{0,65},{3,65}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensor_TSP_a.bearing_frame_b, mechanical_Simple_1D_Bevel_CV.frame_a)
          annotation (Line(
            points={{-40,0},{-10,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(mechanical_Simple_1D_Bevel_CV.frame_b, sensor_TSP_b.bearing_frame_a)
          annotation (Line(
            points={{10,0},{40,0}},
            color={135,135,135},
            thickness=0.5,
            smooth=Smooth.None));
        connect(critical_bending_speed_output, max_speed.u[1]) annotation (Line(
            points={{40,75},{70,75},{70,64},{76,64}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tau_max_output, max_torque.u[1]) annotation (Line(
            points={{40,95},{70,95},{70,90},{76,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(relativePosition.frame_b, frame_b.bearingFrame) annotation (Line(
            points={{-60,20},{100,20},{100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(relativePosition.frame_a, frame_a.bearingFrame) annotation (Line(
            points={{-80,20},{-100,20},{-100,0}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        annotation (
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>Partial model that specifies the connections a drive shaft provides and the sub-models a drive shaft must contain and how they are internally connected.</p>
<p>A drive shaft must contain:</p>
<p><ul>
<li>A mechanical model that extends Partial_Mechanical</li>
<li>A thermal model that extends Partial_Thermal</li>
<li>A data record that extends Drive_Shaft_Record_Template</li>
</ul></p>
<p><br/>The mechanical model must connect to the two external MultiBody frames as well as internally via two heat ports to the thermal model. These two heat ports can be used to represent heat generation within the joints of the drive shaft. The thermal model connects to the mechanical model via two heat ports and must also connect to an external heat port.</p>
<p>The data record is specified as an<b> inner </b>and will be available to the mechanical and thermal models as an <b>outer</b> component.</p>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{56,74},{48,74},{46,80},{48,86},{56,88},{60,86},{72,86},{82,
                    88},{86,86},{88,76},{82,72},{86,72},{86,66},{80,60},{72,62},{68,
                    66},{66,64},{62,62},{58,60},{52,62},{48,68},{56,74}},
                lineColor={0,0,0},
                smooth=Smooth.Bezier,
                fillColor={254,254,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-82,84},{-60,56}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.HorizontalCylinder),
              Rectangle(
                extent={{62,30},{84,2}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.HorizontalCylinder),
              Polygon(
                points={{-46,80},{58,30},{48,8},{-56,60},{-46,80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                smooth=Smooth.None,
                fillColor={175,175,175}),
              Line(
                points={{-98,8},{-88,8},{-88,72},{-54,72},{58,14},{100,14}},
                color={0,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.DashDot),
              Line(
                points={{60,14},{60,46},{58,64}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{60,86},{60,80},{58,74},{52,70}},
                color={175,175,175},
                smooth=Smooth.Bezier),
              Line(
                points={{68,66},{68,68},{68,72},{74,74},{82,72}},
                color={175,175,175},
                smooth=Smooth.Bezier),
              Line(
                points={{58,74},{64,74},{68,70}},
                color={175,175,175},
                smooth=Smooth.Bezier),
              Line(
                points={{72,86},{70,80},{70,78},{74,74}},
                color={175,175,175},
                smooth=Smooth.Bezier),
              Line(
                points={{52,54},{58,64},{64,54}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{-6,-5},{0,5},{6,-5}},
                color={255,0,0},
                smooth=Smooth.None,
                origin={42,81},
                rotation=270),
              Line(
                points={{-54,72},{-50,90},{46,80}},
                color={255,0,0},
                smooth=Smooth.None),
              Text(
                extent={{-120,-20},{-100,-40}},
                lineColor={215,215,215},
                fillColor={254,254,255},
                fillPattern=FillPattern.Solid,
                textString="a"),
              Text(
                extent={{100,-20},{120,-40}},
                lineColor={215,215,215},
                fillColor={254,254,255},
                fillPattern=FillPattern.Solid,
                textString="b"),
              Text(
                extent={{-140,-40},{140,-80}},
                lineColor={0,0,255},
                fillColor={254,254,255},
                fillPattern=FillPattern.Solid,
                textString="%name")}));
      end Drive_Shaft_CV_Joint;
    end Drive_Shafts;

    package Differentials
      extends Modelica.Icons.Package;

      model Differential_Open_Base "Open differential with a bevel gear input "
        extends C2M2L_Ext.Containers.Mechanical_Models.Case_4_Shafts_Alt;

        parameter SI.Inertia moi_rotational=0.01
          "Input rotational moment of inertia";
        parameter Real ratio = 3.10
          "Bevel or hypoid gear ratio from prop shaft"                          annotation(Dialog(group="Bevel"));
        parameter Real loss_table_bevel[:, 5]=[0, 0.96, 0.96, 0, 0]
          "losses for bevel gear mesh"
          annotation(Dialog(group="Bevel"));
      //Diff in
        parameter Integer sideGear_teeth_diff_in = 13 "Side gear tooth count" annotation(Dialog(group="Differential In"));
        parameter Integer spiderGear_teeth_diff_in = 11
          "Spider gear tooth count"                                               annotation(Dialog(group="Differential In"));
        parameter Real loss_table_diff_in[:, 5]=[0, 0.98, 0.98, 0, 0]
          "losses for side & spider gear mesh"
          annotation(Dialog(group="Differential In"));
      //Diff Out
        parameter Integer sideGear_teeth_diff_out = 13 "Side gear tooth count" annotation(Dialog(group="Differential Out"));
        parameter Integer spiderGear_teeth_diff_out = 11
          "Spider gear tooth count"                                                annotation(Dialog(group="Differential Out"));
        parameter Real loss_table_diff_out[:, 5]=[0, 0.98, 0.98, 0, 0]
          "losses for side & spider gear mesh"
          annotation(Dialog(group="Differential Out"));
      //Clutch diff in
      parameter SI.Force maxApply_force_diff_in=10000
          "Maximum clutch apply force"                                             annotation (Dialog(tab="Differential In"));
        parameter Integer frictionPlate_count_diff_in(min=1)=3
          "Number of clutch friction plates" annotation (Dialog(tab="Differential In"));
        parameter SI.Length meanRadius_diff_in=0.1 "Friction plate mean radius"
                                                                                annotation (Dialog(tab="Differential In"));
        parameter Real mue_diff_in[:,2]=[0,0.14]
          "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0). "
                                                                                                              annotation (Dialog(tab="Differential In"));
      //Clutch diff out
      parameter SI.Force maxApply_force_diff_out=10000
          "Maximum clutch apply force"                                              annotation (Dialog(tab="Differential Out"));
        parameter Integer frictionPlate_count_diff_out(min=1)=3
          "Number of clutch friction plates" annotation (Dialog(tab="Differential Out"));
        parameter SI.Length meanRadius_diff_out=0.1
          "Friction plate mean radius"                                           annotation (Dialog(tab="Differential Out"));
        parameter Real mue_diff_out[:,2]=[0,0.14]
          "Assume holding mu=0.14 and shifting mu=0.12, if no data given by the supplier :: [w,mue] positive sliding friction coefficient (w_rel>=0). "
                                                                                                              annotation (Dialog(tab="Differential Out"));
      //limits
      //  parameter SI.Conversions.NonSIunits.AngularVelocity_rpm Speed_max = 10000
      //    "Sun speed, maximum limit [rpm]" annotation(Dialog(group="Limits"));
      //  parameter SI.Torque Torque_max = 7500 "Maximum transmited torque limit [Nm]"
      //                                           annotation(Dialog(group="Limits"));

        Ideal_Gears.Differential_Bevel_Gear_Open
          Differential_Output(
          sideGear_teeth=sideGear_teeth_diff_out,
          spiderGear_teeth=spiderGear_teeth_diff_out,
          input_J=0.0001
                       /ratio,
          left_J=0.0001,
          right_J=0.0001,
          lossTable=loss_table_diff_out)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={118,4})));

        Ideal_Gears.Bevel_Gear_3D_Auto_Orient_With_Lossy_Gear_B
          bevel_Gear_Rotation_Axis(
          ratio=ratio,
          lossTable=loss_table_bevel)
          annotation (Placement(transformation(extent={{26,-10},{46,10}})));
        Modelica.Mechanics.Rotational.Components.IdealGear sign_convention(ratio=-1)
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={118,-40})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_power(nu=1)
          annotation (Placement(transformation(extent={{-144,24},{-124,44}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_speed(nu=1)
          annotation (Placement(transformation(extent={{-144,50},{-124,70}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_torque(nu=1)
          annotation (Placement(transformation(extent={{-144,76},{-124,96}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Signal_Extractor_TSP_Bus signal_Extractor_TSP_Bus
          annotation (Placement(transformation(extent={{-172,50},{-164,70}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Sensor_TSP_Single_Output sensor_TSP_Single_Output
          annotation (Placement(transformation(extent={{-182,-10},{-162,10}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Empty max_temp(nu=1)
          "Maximum temp in deg C"
          annotation (Placement(transformation(extent={{-170,204},{-150,224}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor env_T_sensor
          annotation (Placement(transformation(extent={{-198,204},{-178,224}})));
        Modelica.Mechanics.Rotational.Components.Inertia moi_up(J=moi_rotational/2)
          annotation (Placement(transformation(extent={{-88,-10},{-68,10}})));
        Modelica.Mechanics.Rotational.Components.Inertia moi_down(J=moi_rotational/2)
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        Ideal_Gears.Differential_Bevel_Gear_Open
          Differential_Input(
          sideGear_teeth=sideGear_teeth_diff_in,
          spiderGear_teeth=spiderGear_teeth_diff_in,
          lossTable=loss_table_diff_in,
          input_J=0.0001
                       /ratio,
          left_J=0.0001,
          right_J=0.0001)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-48,4})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
          Differential_Input_Lock(
          use_environment_heat_port=true,
          maxApply_force=maxApply_force_diff_in,
          frictionPlate_count=frictionPlate_count_diff_in,
          meanRadius=meanRadius_diff_in,
          mue=mue_diff_in)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-10,4})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Drive_Line.Brakes_Clutch.Clutch_Brake
          Differential_Output_Lock(
          use_environment_heat_port=true,
          maxApply_force=maxApply_force_diff_out,
          frictionPlate_count=frictionPlate_count_diff_out,
          meanRadius=meanRadius_diff_out,
          mue=mue_diff_out)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={162,4})));
        C2M2L_Ext.C2M2L_Component_Building_Blocks.Drive_Line.Differential.Differential_Control_Bus
          differential_Control_Bus
          annotation (Placement(transformation(extent={{-10,194},{10,214}})));
        Modelica.Mechanics.Rotational.Sensors.SpeedSensor speed_front annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-100,50})));
        Modelica.Mechanics.Rotational.Sensors.SpeedSensor speed_rear annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-60,50})));
        Modelica.Mechanics.Rotational.Sensors.SpeedSensor speed_left annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={90,-80})));
        Modelica.Mechanics.Rotational.Sensors.SpeedSensor speed_right annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={90,80})));
      equation
        connect(sign_convention.flange_b, Differential_Output.output_Left)
          annotation (Line(
            points={{118,-30},{118,-6}},
            color={255,0,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(bevel_Gear_Rotation_Axis.frame_a, brg_01.bearingFrame) annotation (
            Line(
            points={{26,8},{-200,8},{-200,0}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(sensor_TSP_Single_Output.flange_a, brg_01.flange) annotation (Line(
            points={{-182,0},{-200,0}},
            color={0,128,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(signal_Extractor_TSP_Bus.y_power, max_input_power.u[1]) annotation (
            Line(
            points={{-165.8,54},{-154,54},{-154,34},{-144,34}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.y_speed, max_input_speed.u[1]) annotation (
            Line(
            points={{-165.8,60},{-144,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.y_torque, max_input_torque.u[1]) annotation (
           Line(
            points={{-165.8,66},{-154,66},{-154,86},{-144,86}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.sensor_TSP_bus_in, sensor_TSP_Single_Output.sensor_Block_Bus)
          annotation (Line(
            points={{-172,60},{-172,10}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(env_T_sensor.port, env.heat_port) annotation (Line(
            points={{-198,214},{-206,214},{-206,160},{-190,160},{-190,171.8}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(env_T_sensor.T, max_temp.u[1]) annotation (Line(
            points={{-178,214},{-170,214}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(moi_down.flange_b, Differential_Output.Input)          annotation (
            Line(
            points={{80,0},{106.4,0},{106.4,4.44089e-016},{110.8,4.44089e-016}},
            color={0,255,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(bevel_Gear_Rotation_Axis.flange_b, moi_down.flange_a) annotation (
            Line(
            points={{46,0},{60,0}},
            color={0,255,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(Differential_Output.output_Right, brg_04.flange) annotation (Line(
            points={{118,14},{118,110},{140,110},{140,204}},
            color={255,0,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(bevel_Gear_Rotation_Axis.frame_b, brg_04.bearingFrame) annotation (
            Line(
            points={{46,8},{120,8},{120,204},{140,204}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(bevel_Gear_Rotation_Axis.case_reaction, origin) annotation (Line(
            points={{36,-10},{36,-138},{0,-138},{0,-200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(Differential_Output.output_Left, Differential_Output_Lock.flange_a)
          annotation (Line(
            points={{118,-6},{162,-6}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(Differential_Output.output_Right, Differential_Output_Lock.flange_b)
          annotation (Line(
            points={{118,14},{162,14}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(moi_up.flange_b, Differential_Input.Input) annotation (Line(
            points={{-68,0},{-46.6,0},{-46.6,4.44089e-016},{-55.2,4.44089e-016}},
            color={0,128,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(Differential_Input.output_Right, Differential_Input_Lock.flange_b)
          annotation (Line(
            points={{-48,14},{-10,14}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(Differential_Input.output_Left, Differential_Input_Lock.flange_a)
          annotation (Line(
            points={{-48,-6},{-10,-6}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(Differential_Input.output_Left, bevel_Gear_Rotation_Axis.flange_a)
          annotation (Line(
            points={{-48,-6},{-48,-22},{14,-22},{14,0},{26,0}},
            color={0,255,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(Differential_Input.output_Right, brg_02.flange) annotation (Line(
            points={{-48,14},{-48,26},{182,26},{182,0},{200,0}},
            color={255,128,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(sign_convention.flange_a, brg_03.flange) annotation (Line(
            points={{118,-50},{118,-100},{140,-100},{140,-200}},
            color={255,0,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(sensor_TSP_Single_Output.flange_b, moi_up.flange_a) annotation (Line(
            points={{-162,0},{-88,0}},
            color={0,128,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(speed_front.flange, moi_up.flange_a) annotation (Line(
            points={{-100,40},{-100,0},{-88,0}},
            color={0,128,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(Differential_Input.output_Right, speed_rear.flange) annotation (Line(
            points={{-48,14},{-48,26},{-60,26},{-60,40}},
            color={255,128,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(speed_left.flange, sign_convention.flange_a) annotation (Line(
            points={{100,-80},{118,-80},{118,-50}},
            color={255,0,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(speed_right.flange, Differential_Output.output_Right) annotation (
            Line(
            points={{100,80},{118,80},{118,14}},
            color={255,0,0},
            smooth=Smooth.None,
            thickness=0.5));
        connect(Differential_Output_Lock.brake_clutch_command,
          differential_Control_Bus.Output_Diff_Lock) annotation (Line(
            points={{150.6,-4},{140,-4},{140,40},{0,40},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Differential_Input_Lock.brake_clutch_command,
          differential_Control_Bus.Input_Diff_Lock) annotation (Line(
            points={{-21.4,-4},{-30,-4},{-30,40},{0,40},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(speed_front.w, differential_Control_Bus.Diff_Front_Speed) annotation (
           Line(
            points={{-100,61},{-100,80},{0,80},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(speed_rear.w, differential_Control_Bus.Diff_Rear_Speed) annotation (
            Line(
            points={{-60,61},{-60,80},{0,80},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(speed_right.w, differential_Control_Bus.Diff_Right_Speed) annotation (
           Line(
            points={{79,80},{0,80},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(speed_left.w, differential_Control_Bus.Diff_Left_Speed) annotation (
            Line(
            points={{79,-80},{54,-80},{54,80},{0,80},{0,204}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Icon(graphics={
              Rectangle(
                extent={{-73.5,9.5},{73.5,-9.5}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={108.5,128.5},
                rotation=90),
              Rectangle(
                extent={{-11,65},{11,-65}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.VerticalCylinder,
                lineColor={0,0,0},
                origin={111,13},
                rotation=90),
              Rectangle(
                extent={{-81,9},{81,-9}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={111,-119},
                rotation=90),
              Rectangle(
                extent={{-4,-19},{4,19}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={65,-56},
                rotation=90),
              Polygon(
                points={{-10,4},{-10,16},{10,16},{10,4},{-10,-16},{-10,4}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={196,-22},
                rotation=90),
              Rectangle(
                extent={{70,-4},{-70,4}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={44,10},
                rotation=90),
              Polygon(
                points={{-10,39},{-10,-37},{8,-23},{8,21},{-10,39}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                origin={111,-32},
                rotation=90),
              Polygon(
                points={{-49,-10},{-31,8},{31,8},{49,-10},{-49,-10}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={76,11},
                rotation=270),
              Polygon(
                points={{-10,-4},{-10,-16},{10,-16},{10,-4},{-10,16},{-10,-4}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={24,-22},
                rotation=90),
              Rectangle(
                extent={{-200,10},{200,-10}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.HorizontalCylinder,
                origin={0,2},
                rotation=180),
              Polygon(
                points={{-32,-9},{-14,9},{14,9},{32,-9},{-32,-9}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={13,3},
                rotation=270),
              Rectangle(
                extent={{-4,-22},{4,22}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={62,80},
                rotation=90),
              Rectangle(
                extent={{-4,-24},{4,24}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={156,80},
                rotation=90),
              Rectangle(
                extent={{-4,-25},{4,25}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={155,-56},
                rotation=90),
              Rectangle(
                extent={{70,-4},{-70,4}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={176,12},
                rotation=90),
              Polygon(
                points={{-49,10},{-31,-8},{31,-8},{49,10},{-49,10}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={147,12},
                rotation=270),
              Polygon(
                points={{10,39},{10,-37},{-8,-23},{-8,21},{10,39}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                origin={111,56},
                rotation=90)}),                   Diagram(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-320},{200,280}}),
                                                          graphics),
          Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Model uses Differential_Bevel_Gear_Open and lossy_Gear_With_Environment for bevel ratio</li>
<li>User must input spider and side gear teeth count, mesh efficiency, torque &AMP; speed limits, input bevel ratio and efficiency</li>
</ul></p>
</html>"));
      end Differential_Open_Base;

      model Differential_Dog_Clutch_Lock
        extends C2M2L_OM.Suspension_Ideal.Differentials.Differential_Open_Base(
          redeclare C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume
                                                                                env(
              redeclare package Medium =
                C2M2L_Ext.Media.Incompressible.Water_Incompressible_Constant,
              fluid_area=0.5),
          Differential_Input_Lock(
            use_environment_heat_port=false,
            maxApply_force=20000,
            frictionPlate_count=4,
            meanRadius=0.2,
            mue=[0,1]),
          Differential_Output_Lock(
            use_environment_heat_port=false,
            maxApply_force=20000,
            frictionPlate_count=4,
            meanRadius=0.2,
            mue=[0,1]));
        extends
          C2M2L_Ext.Containers.Thermal_Models.Case_Simple_Convection_Conduction;
        extends C2M2L_Ext.Mounting.Rigid_Mounts.Triple_Mount;
        extends C2M2L_Ext.Interfaces.Delivered_C2M2L;
        annotation (Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Differential includes direct drive through unit with integrated lock-up diff (front to rear) and lock-up diff on left to right wheel outputs. With a ratio from input to wheel outputs</li>
<li>User must input differential, clutch, and ratio parameters</li>
</ul></p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -320},{200,280}}), graphics));
      end Differential_Dog_Clutch_Lock;
    end Differentials;

    package Wheel_Hubs
      extends Modelica.Icons.Package;

      model Planetary_Reduction_Simple
        extends C2M2L_Ext.Containers.Mechanical_Models.Case_2_Shafts;
          extends
          C2M2L_Ext.Containers.Thermal_Models.Case_Simple_Convection_Conduction;

        Modelica.Mechanics.MultiBody.Parts.Mounting1D mounting1D(n={0,0,1})
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=0,
              origin={0,-160})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Sensor_TSP_Single_Output sensor_TSP_Single_Output
          annotation (Placement(transformation(extent={{-160,-10},{-140,10}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_power(nu=1)
          annotation (Placement(transformation(extent={{-120,24},{-100,44}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_speed(nu=1)
          annotation (Placement(transformation(extent={{-120,50},{-100,70}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Abs_Empty max_input_torque(nu=1)
          annotation (Placement(transformation(extent={{-120,76},{-100,96}})));
        C2M2L_Ext.Mechanics.Rotational.Sensors.Signal_Extractor_TSP_Bus signal_Extractor_TSP_Bus
          annotation (Placement(transformation(extent={{-150,50},{-142,70}})));
        C2M2L_Ext.Blocks.Metrics.Empty_Metrics.Latch_Max_Empty max_temp(nu=1)
          "Maximum temp in deg C"
          annotation (Placement(transformation(extent={{-170,204},{-150,224}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor env_T_sensor
          annotation (Placement(transformation(extent={{-198,204},{-178,224}})));

        parameter SI.Inertia moi_rotational=0.01
          "Input rotational moment of inertia";
      //Teeth Count
        parameter Real ratio(start=1)=2.5
          "Transmission ratio (flange_a.phi/flange_b.phi)";
        parameter Real lossTable[:, 5]=[0, 0.96, 0.96, 0, 0]
          "Array for mesh efficiencies and bearing friction depending on speed";

        Modelica.Mechanics.Rotational.Components.Inertia moi_up(J=moi_rotational/2)
          annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
        Modelica.Mechanics.Rotational.Components.Inertia moi_down(J=moi_rotational/2)
          annotation (Placement(transformation(extent={{80,-10},{100,10}})));
        Modelica.Mechanics.Rotational.Components.IdealPlanetary idealPlanetary(ratio=
              ratio - 1)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        Modelica.Mechanics.Rotational.Components.IdealGear
          lossy_Gear_With_Environment(ratio=1)
          annotation (Placement(transformation(extent={{-54,-10},{-34,10}})));
      equation
        connect(mounting1D.frame_a, origin) annotation (Line(
            points={{0,-170},{0,-200}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sensor_TSP_Single_Output.flange_a, brg_01.flange) annotation (Line(
            points={{-160,0},{-200,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sensor_TSP_Single_Output.sensor_Block_Bus, signal_Extractor_TSP_Bus.sensor_TSP_bus_in)
          annotation (Line(
            points={{-150,10},{-150,60}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.y_power, max_input_power.u[1]) annotation (
            Line(
            points={{-143.8,54},{-130,54},{-130,34},{-120,34}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.y_speed, max_input_speed.u[1]) annotation (
            Line(
            points={{-143.8,60},{-120,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signal_Extractor_TSP_Bus.y_torque, max_input_torque.u[1]) annotation (
           Line(
            points={{-143.8,66},{-130,66},{-130,86},{-120,86}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(env_T_sensor.port, env.heat_port) annotation (Line(
            points={{-198,214},{-206,214},{-206,160},{-190,160},{-190,171.8}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(env_T_sensor.T, max_temp.u[1]) annotation (Line(
            points={{-178,214},{-170,214}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sensor_TSP_Single_Output.flange_b, moi_up.flange_a) annotation (Line(
            points={{-140,0},{-100,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(moi_down.flange_b, brg_02.flange) annotation (Line(
            points={{100,0},{200,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(idealPlanetary.ring, mounting1D.flange_b) annotation (Line(
            points={{10,0},{42,0},{42,-160},{10,-160}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(idealPlanetary.carrier, moi_down.flange_a) annotation (Line(
            points={{-10,4},{-20,4},{-20,20},{60,20},{60,0},{80,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(moi_up.flange_b,lossy_Gear_With_Environment. flange_a) annotation (
            Line(
            points={{-80,0},{-54,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(lossy_Gear_With_Environment.flange_b, idealPlanetary.sun) annotation (
           Line(
            points={{-34,0},{-10,0}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-200,
                  -320},{200,280}}), graphics), Icon(graphics={
            Rectangle(
              extent={{-200,10},{-16,-10}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
              Rectangle(
                extent={{-6,98},{-46,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-12,28},{-52,-32}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-5,98},{-47,104}},
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{200,10},{24,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-12,43},{-52,83}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-5,-106},{-47,-100}},
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-11,68},{19,58}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-12,-83},{-52,-43}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-11,-58},{19,-68}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{24,-71},{11,71}},
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid)}));
      end Planetary_Reduction_Simple;

      model Wheel_Hub_Planetary
        extends C2M2L_OM.Suspension_Ideal.Wheel_Hubs.Planetary_Reduction_Simple(
          redeclare C2M2L_Ext.Environments.Lumped_Thermal_Fixed_HTC_Open_Volume
                                                                                env(
            redeclare package Medium =
                C2M2L_Ext.Media.Incompressible.Water_Incompressible_Constant,
            fixed_htc=3000,
            initial_T=293.15),
          transform_brg_02=[-0.1,0,0.0; 1,0,0; 0,-1,0],
          lossy_Gear_With_Environment);
        extends C2M2L_Ext.Interfaces.Delivered_C2M2L;
        extends C2M2L_Ext.Mounting.Rigid_Mounts.Double_Mount;
        annotation (Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Wheel hub with static planetary gear ratio</li>
<li>temp, torque, speed, and power metrics embedded into model</li>
</ul></p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -320},{200,280}}), graphics));
      end Wheel_Hub_Planetary;
    end Wheel_Hubs;

    package Ideal_Gears
      extends Modelica.Icons.Package;

      model Bevel_Gear_3D_Auto_Orient_With_Lossy_Gear_B
        "Similar to Bevel_Gear_3D in MSL but calculates shaft directions from frame resolves and includes a loss calculation"
        extends Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;

        parameter Real ratio(start=1) "Gear speed ratio";
        parameter SI.Area area_for_heat_transfer=0.1
          "Area available for heat transfer to the environment";
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a case_reaction if
                                                                   world.driveTrainMechanics3D
          "Bearing frame"
          annotation (Placement(transformation(
              origin={0,-100},
              extent={{-20,-20},{20,20}},
              rotation=90)));

      protected
        outer Modelica.Mechanics.MultiBody.World world;
        Real e_a[3](each final unit="1")
          "Unit vector in direction of flange_a rotation axis";
        Real e_b[3](each final unit="1")
          "Unit vector in direction of flange_b rotation axis";
        encapsulated model Housing
          import Modelica;
          input Modelica.SIunits.Torque t[3];
          Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a
                                     annotation (Placement(transformation(extent={{
                    -116,-16},{-84,16}}, rotation=0)));
        equation
          frame_a.f = zeros(3);
          frame_a.t = t;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-150,110},{150,150}},
                  lineColor={0,0,255},
                  textString="%name")}));
        end Housing;
        Housing housing(t=-flange_a.tau*e_a - flange_b.tau*e_b) if world.driveTrainMechanics3D
                        annotation (Placement(transformation(extent={{20,-60},{40,-40}},
                rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput n_a[3]
          "Axis of rotation of flange_a, resolved in frame_a"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-54,18})));
        Modelica.Blocks.Interfaces.RealOutput n_b[3]
          "Axis of rotation of flange_b, resolved in frame_a"
                                                annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={54,18})));

      public
        Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
          tansformRelativeVector_n_a(frame_r_out=Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b) if
                                                                                        world.driveTrainMechanics3D
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-54,-20})));
        Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
          tansformRelativeVector_n_b(frame_r_out=Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b) if
                                                                                        world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{44,-10},{64,-30}})));
        Modelica.Blocks.Sources.Constant unit_z_vector[3](k={0,0,1})
          annotation (Placement(transformation(extent={{-88,-80},{-68,-60}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_a if
                                                                   world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{-116,64},{-84,96}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_b if
                                                                   world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{84,64},{116,96}})));
        Modelica.Mechanics.Rotational.Components.IdealGear lossy_gear(ratio=ratio)
          annotation (Placement(transformation(extent={{-8,38},{12,58}})));
        parameter Real lossTable[:,5]=[0,1,1,0,0]
          "Array for mesh efficiencies and bearing friction depending on speed";
      equation

        e_a = Modelica.Math.Vectors.normalize(n_a, 0.0);
        e_b = Modelica.Math.Vectors.normalize(n_b, 0.0);

        connect(housing.frame_a, case_reaction)
                                          annotation (Line(
            points={{20,-50},{0,-50},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(unit_z_vector.y, tansformRelativeVector_n_a.r_in) annotation (Line(
            points={{-67,-70},{-54,-70},{-54,-32}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(unit_z_vector.y, tansformRelativeVector_n_b.r_in) annotation (Line(
            points={{-67,-70},{54,-70},{54,-32}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_a.r_out, n_a) annotation (Line(
            points={{-54,-9},{-54,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.r_out, n_b) annotation (Line(
            points={{54,-9},{54,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(frame_a, tansformRelativeVector_n_a.frame_b) annotation (Line(
            points={{-100,80},{-78,80},{-78,-20},{-64,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_a.frame_a, case_reaction) annotation (Line(
            points={{-44,-20},{0,-20},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.frame_a, case_reaction) annotation (Line(
            points={{44,-20},{0,-20},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.frame_b, frame_b) annotation (Line(
            points={{64,-20},{78,-20},{78,80},{100,80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(flange_a, lossy_gear.flange_a)                  annotation (Line(
            points={{-100,0},{-86,0},{-86,48},{-8,48}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(lossy_gear.flange_b, flange_b)                  annotation (Line(
            points={{12,48},{86,48},{86,0},{100,0}},
            color={0,0,0},
            smooth=Smooth.None));
        if not world.driveTrainMechanics3D then
          // Directly connect the unit vector to the outputs if no 3D
          connect(unit_z_vector.y, n_a) annotation (Line(
            points={{-67,-70},{-66,-70},{-66,18},{-54,18}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
          connect(unit_z_vector.y, n_b) annotation (Line(
            points={{-67,-70},{-66,-70},{-66,-72},{72,-72},{72,18},{54,18}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
        end if;

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Rectangle(
                extent={{-40,20},{-20,-20}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{-40,140},{-20,20}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{20,100},{40,60}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{20,60},{40,-60}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{40,10},{100,-10}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{-20,90},{20,70}},
                lineColor={0,0,0}),
              Rectangle(
                extent={{-100,10},{-40,-10}},
                lineColor={0,0,0}),
              Text(
                extent={{-150,180},{150,150}},
                textString="%name=%ratio",
                lineColor={0,0,255}),
              Line(points={{-80,20},{-60,20}}, color={0,0,0}),
              Line(points={{-80,-20},{-60,-20}}, color={0,0,0}),
              Line(points={{-10,100},{10,100}}, color={0,0,0}),
              Line(points={{-10,60},{10,60}}, color={0,0,0}),
              Line(points={{60,20},{80,20}}, color={0,0,0}),
              Line(points={{60,-20},{80,-20}}, color={0,0,0}),
              Line(points={{-70,-20},{-70,-70},{70,-70},{70,-20}}, color={0,0,0}),
              Line(points={{0,60},{0,-70},{0,-100}}, color={0,0,0}),
              Text(
                extent={{-150,-36},{150,-66}},
                textString="%name=%ratio",
                lineColor={0,0,0}),
              Line(
                points={{-96,80},{-70,80},{-70,20}},
                color={135,135,135},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{96,80},{70,80},{70,20}},
                color={135,135,135},
                smooth=Smooth.None,
                pattern=LinePattern.Dash)}),
          Documentation(info="<html>
<p>This component is used to model a 1-dim. gearbox
with non-parallel axes (defined by parameters <code>n_a</code>, <code>n_b</code>).
A 3-dim. <code>bearing</code> frame is necessary to reflect the
correct support torque, as the axes of rotation of <code>flange_a</code> and
<code>flange_b</code> and the direction of the support torque vector
are different in general.</p>
<p>Note: The name BevelGear1D is kept only for simplicity. Regardless,
this component could be used to model any kind of gearbox with non-parallel axes.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-24,32},{18,16}},
                lineColor={255,0,0},
                textString="Do not connect support of lossy gear!
The text layer will apply the correct reaction 
to the housing.")}));
      end Bevel_Gear_3D_Auto_Orient_With_Lossy_Gear_B;

      model Differential_Bevel_Gear_Open
        "Open differential using bevel gears.  Includes inertias for at all flanges."

        parameter Integer sideGear_teeth = 13 "Side gear tooth count" annotation(Dialog(group="Teeth Count"));
        parameter Integer spiderGear_teeth = 11 "Spider gear tooth count" annotation(Dialog(group="Teeth Count"));

        parameter Real lossTable[:, 5]=[0, 0.98, 0.98, 0, 0]
          "losses for side & spider gear mesh"
          annotation(Dialog(group="Efficiency"));

      //limits
        parameter SI.Conversions.NonSIunits.AngularVelocity_rpm Speed_max = 10000
          "Sun speed, maximum limit [rpm]" annotation(Dialog(group="Limits"));
        parameter SI.Torque Torque_max = 7500
          "Maximum transmited torque limit [Nm]" annotation(Dialog(group="Limits"));

        Lossy_Planetary_Simple_B lossy_Planetary_Simple(
          N_sun=sideGear_teeth,
          N_planet=spiderGear_teeth,
          lossTable_sun=lossTable,
          lossTable_ring=lossTable,
          N_ring=sideGear_teeth,
          sunSpeed_max=Speed_max,
          carrierSpeed_max=Speed_max,
          ringSpeed_max=Speed_max,
          planetSpeed_max=Speed_max,
          Torque_max=Torque_max)
          annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_b output_Left
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_b output_Right
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_a Input
          annotation (Placement(transformation(extent={{-50,62},{-30,82}}),
              iconTransformation(extent={{-50,62},{-30,82}})));
        Modelica.Mechanics.Rotational.Components.Inertia carrier_inertia(J=input_J)
          annotation (Placement(transformation(extent={{-50,24},{-30,44}})));
        Modelica.Mechanics.Rotational.Components.Inertia sun_inertia(J=left_J)
          annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
        Modelica.Mechanics.Rotational.Components.Inertia ring_inertia(J=right_J)
          annotation (Placement(transformation(extent={{34,-10},{54,10}})));
        parameter SI.Inertia input_J=0.01 "Input moment of inertia"
          annotation (Dialog(group="Inertias"));
        parameter SI.Inertia left_J=0.01 "Left side moment of inertia"
          annotation (Dialog(group="Inertias"));
        parameter SI.Inertia right_J=0.01 "Right side moment of inertia"
          annotation (Dialog(group="Inertias"));
      equation

        connect(carrier_inertia.flange_b, lossy_Planetary_Simple.carrier) annotation (
           Line(
            points={{-30,34},{-30,4},{-8,4}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(Input, carrier_inertia.flange_a) annotation (Line(
            points={{-40,72},{-64,72},{-64,34},{-50,34}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(sun_inertia.flange_b, lossy_Planetary_Simple.sun) annotation (Line(
            points={{-44,0},{-8,0}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(sun_inertia.flange_a, output_Left) annotation (Line(
            points={{-64,0},{-100,0}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(ring_inertia.flange_b, output_Right) annotation (Line(
            points={{54,0},{100,0}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(ring_inertia.flange_a, lossy_Planetary_Simple.ring) annotation (Line(
            points={{34,0},{11.8,0}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        annotation (Diagram(graphics), Icon(graphics={
              Rectangle(
                extent={{-6,50},{6,-50}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.VerticalCylinder,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-100,10},{-40,-10}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.HorizontalCylinder),
              Rectangle(
                extent={{40,10},{100,-10}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.HorizontalCylinder),
              Polygon(
                points={{-40,38},{-40,-38},{-22,-20},{-22,20},{-40,38}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-9,38},{-9,-38},{9,-20},{9,20},{-9,38}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                origin={31,0},
                rotation=180),
              Polygon(
                points={{-38,-40},{-20,-22},{20,-22},{38,-40},{-38,-40}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-38,-9},{-20,9},{20,9},{38,-9},{-38,-9}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={0,31},
                rotation=180),
              Rectangle(
                extent={{-60,16},{-52,56}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-4,-58},{4,58}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={-2,52},
                rotation=90),
              Rectangle(
                extent={{52,16},{60,56}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,-56},{-52,-16}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-4,-58},{4,58}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                origin={0,-52},
                rotation=90),
              Rectangle(
                extent={{52,-56},{60,-16}},
                pattern=LinePattern.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-50,80},{-50,56},{-30,56},{-30,80},{-50,98},{-50,80}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-50,-80},{-50,-56},{-30,-56},{-30,-80},{-50,-98},{-50,-80}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-20,-44},{46,-44},{46,88}},
                color={255,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Polygon(
                points={{36,82},{46,102},{56,82},{36,82}},
                lineColor={255,0,0},
                smooth=Smooth.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-20,44},{46,44},{46,44}},
                color={255,0,0},
                smooth=Smooth.None,
                pattern=LinePattern.Dash)}),
          Documentation(info="<html>
<p>Notes:</p>
<p><ul>
<li>Bevel gear differential can be modeled as a simple plantary</li>
<li>Sun, carrier, and ring inertia are small inertia for compatibility</li>
<li>User must input spider and side gear teeth count, mesh efficiency, and torque &AMP; speed limits</li>
</ul></p>
</html>"));
      end Differential_Bevel_Gear_Open;

      model Lossy_Planetary_Simple_B
        "Ring, planet, sun simple planetary with \"no Event\" lossy gears"

        parameter Integer N_sun = 50 "Number of teeth on Sun gear" annotation(Dialog(group="Teeth Count"));
        parameter Integer N_ring = 100 "Number of teeth on Ring gear" annotation(Dialog(group="Teeth Count"));
        parameter Integer N_planet = 25 "Number of teeth on Planet gear" annotation(Dialog(group="Teeth Count"));

         SI.AngularVelocity nPlanet "Planet Speed";
         SI.AngularVelocity nSun "Sun Speed";
         SI.AngularVelocity nRing "Ring Speed";
         SI.AngularVelocity nCarrier "Carrier Speed";

      //Limit properties for speed on components
         parameter SI.Conversions.NonSIunits.AngularVelocity_rpm sunSpeed_max = 10000
          "Sun speed, maximum limit [rpm]"  annotation(Dialog(tab="Limits",group="Speed Limits"));
      //   output Integer sunSpeed_limit(start=0, max=1, fixed = true)
      //     "Sun speed limit reached?" annotation(Dialog(tab="Initialization"));
         parameter SI.Conversions.NonSIunits.AngularVelocity_rpm carrierSpeed_max = 10000
          "Carrier speed, maximum limit [rpm]"  annotation(Dialog(tab="Limits",group="Speed Limits"));
      //   output Integer carrierSpeed_limit(start=0, max=1, fixed = true)
      //     "carrier speed limit reached?" annotation(Dialog(tab="Initialization"));
         parameter SI.Conversions.NonSIunits.AngularVelocity_rpm ringSpeed_max = 10000
          "Ring speed, maximum limit [rpm]"  annotation(Dialog(tab="Limits",group="Speed Limits"));
      //   output Integer ringSpeed_limit(start=0, max=1, fixed = true)
      //     "Ring speed limit reached?" annotation(Dialog(tab="Initialization"));
         parameter SI.Conversions.NonSIunits.AngularVelocity_rpm planetSpeed_max = 10000
          "Planet speed, maximum limit [rpm]"  annotation(Dialog(tab="Limits",group="Speed Limits"));
      //   output Integer planetSpeed_limit(start=0, max=1, fixed = true)
      //     "Planet speed limit reached?" annotation(Dialog(tab="Initialization"));
      //
      // //Limit properties for torque on components
         parameter SI.Torque Torque_max = 1000
          "Maximum transmited torque limit [Nm]"  annotation(Dialog(tab="Limits",group="Torque Limit"));
      //   output Integer Torque_limit(start=0, max=1, fixed = true)
      //     "Torque limit reached?" annotation(Dialog(tab="Initialization"));

        Modelica.Mechanics.Rotational.Components.IdealGear sun_planet(ratio=N_planet/
              N_sun, useSupport=true)
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
        Modelica.Mechanics.Rotational.Components.IdealGear ring_planet(useSupport=true,
            ratio=-N_ring/N_planet)
          annotation (Placement(transformation(extent={{30,-10},{50,10}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_a sun
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
              iconTransformation(extent={{-110,-10},{-90,10}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_a carrier
          annotation (Placement(transformation(extent={{-110,30},{-90,50}}),
              iconTransformation(extent={{-110,30},{-90,50}})));
        Modelica.Mechanics.Rotational.Interfaces.Flange_b ring
          annotation (Placement(transformation(extent={{88,-10},{108,10}}),
              iconTransformation(extent={{88,-10},{108,10}})));

      //loss table parameters

        parameter Real lossTable_sun[:, 5]=[0, 0.995, 0.995, 0, 0]
          "losses for sun planet mesh"
          annotation(Dialog(group="Efficiency"));
        parameter Real lossTable_ring[:, 5]=[0, 0.995, 0.995, 0, 0]
          "losses for ring planet mesh"
          annotation(Dialog(group="Efficiency"));
      equation

         nSun = der(sun.phi);
         nRing = der(ring.phi);
         nCarrier = der(carrier.phi);
         nPlanet = (nSun-nCarrier)*(-1)*(N_sun/N_planet);

      //speed limits
      //   when SI.Conversions.to_rpm(abs(nSun)) > sunSpeed_max then
      //     sunSpeed_limit = 1;
      //   end when;
      //   when SI.Conversions.to_rpm(abs(nCarrier)) > carrierSpeed_max then
      //     carrierSpeed_limit = 1;
      //   end when;
      //   when SI.Conversions.to_rpm(abs(nRing)) > ringSpeed_max then
      //     ringSpeed_limit = 1;
      //   end when;
      //   when SI.Conversions.to_rpm(abs(nPlanet)) > planetSpeed_max then
      //     planetSpeed_limit = 1;
      //   end when;
      //
      // //Torque limit
      //   when max([abs(sun.tau),abs(carrier.tau),abs(ring.tau)]) > Torque_max then
      //     Torque_limit = 1;
      //   end when;

        connect(ring_planet.flange_b, ring) annotation (Line(
            points={{50,0},{98,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sun, sun_planet.flange_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sun_planet.flange_b, ring_planet.flange_a) annotation (Line(
            points={{-30,0},{30,0}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(ring_planet.support, carrier) annotation (Line(
            points={{40,-10},{40,-20},{20,-20},{20,40},{-100,40}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(sun_planet.support, carrier) annotation (Line(
            points={{-40,-10},{-40,-20},{-60,-20},{-60,40},{-100,40}},
            color={0,0,0},
            smooth=Smooth.None));
        annotation (Diagram(graphics), Icon(graphics={
              Rectangle(
                extent={{50,100},{10,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-10,45},{-50,85}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-10,30},{-50,-30}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-50,10},{-100,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{100,10},{50,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{50,100},{-50,105}},
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{50,-100},{-50,-105}},
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,70},{-50,60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Line(points={{-90,40},{-70,40}}, color={0,0,0}),
              Line(points={{-80,50},{-60,50}}, color={0,0,0}),
              Line(points={{-70,50},{-70,40}}, color={0,0,0}),
              Line(points={{-80,80},{-59,80}}, color={0,0,0}),
              Line(points={{-70,100},{-70,80}}, color={0,0,0}),
              Text(
                extent={{-148,142},{152,102}},
                textString="%name",
                lineColor={0,0,255}),
              Line(
                points={{-28,36},{-84,36},{-84,108}},
                color={255,0,0},
                smooth=Smooth.None),
              Line(
                points={{-26,90},{-84,90}},
                color={255,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-94,98},{-84,118},{-74,98},{-94,98}},
                lineColor={255,0,0},
                smooth=Smooth.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end Lossy_Planetary_Simple_B;

      model Bevel_Gear_3D_Auto_Orient_Angle_Dependant_Losses
        "Similar to Bevel_Gear_3D in MSL but calculates shaft directions from frame resolves and includes a loss calculation dependant on the angle"
        extends Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;

        parameter Real ratio(start=1) "Gear speed ratio";
        parameter SI.Area area_for_heat_transfer=0.1
          "Area available for heat transfer to the environment";
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a case_reaction if
                                                                   world.driveTrainMechanics3D
          "Bearing frame"
          annotation (Placement(transformation(
              origin={0,-100},
              extent={{-20,-20},{20,20}},
              rotation=90)));

        //inner Modelica.Mechanics.MultiBody.World world(driveTrainMechanics3D = false);
      protected
        outer Modelica.Mechanics.MultiBody.World world;
        Real e_a[3](each final unit="1")
          "Unit vector in direction of flange_a rotation axis";
        Real e_b[3](each final unit="1")
          "Unit vector in direction of flange_b rotation axis";
        encapsulated model Housing
          import Modelica;
          input Modelica.SIunits.Torque t[3];
          Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a
                                     annotation (Placement(transformation(extent={{
                    -116,-16},{-84,16}}, rotation=0)));
        equation
          frame_a.f = zeros(3);
          frame_a.t = t;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-150,110},{150,150}},
                  lineColor={0,0,255},
                  textString="%name")}));
        end Housing;
        Housing housing(t=-flange_a.tau*e_a - flange_b.tau*e_b) if world.driveTrainMechanics3D
                        annotation (Placement(transformation(extent={{20,-60},{40,-40}},
                rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput n_a[3]
          "Axis of rotation of flange_a, resolved in frame_a"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-54,18})));
        Modelica.Blocks.Interfaces.RealOutput n_b[3]
          "Axis of rotation of flange_b, resolved in frame_a"
                                                annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={54,18})));

      public
        Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
          tansformRelativeVector_n_a(frame_r_out=Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b) if
                                                                                        world.driveTrainMechanics3D
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-54,-20})));
        Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
          tansformRelativeVector_n_b(frame_r_out=Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b) if
                                                                                        world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{44,-10},{64,-30}})));
        Modelica.Blocks.Sources.Constant unit_z_vector[3](k={0,0,1})
          annotation (Placement(transformation(extent={{-88,-80},{-68,-60}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_a if
                                                                   world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{-116,64},{-84,96}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_b if
                                                                   world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{84,64},{116,96}})));
        Modelica.Mechanics.Rotational.Components.IdealGear lossy_gear(ratio=ratio)
          annotation (Placement(transformation(extent={{-8,38},{12,58}})));
        parameter Real lossTable[:,5]=[0,1,1,0,0]
          "Array for mesh efficiencies and bearing friction depending on speed";
        C2M2L_Ext.Mechanics.MultiBody.Sensors.Angle_Measure_Sensor angle_Measure_Sensor if world.driveTrainMechanics3D
          annotation (Placement(transformation(extent={{-60,90},{-40,110}})));
        Modelica.Blocks.Tables.CombiTable1D combiTable1D(table=[0,1; 3.1459,0.5; 6.28319,
              0; 10,0])
          annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
        Modelica.Blocks.Sources.Constant no_3D_angle(k=fixed_angle)
          "if no 3D use this angle instead"
          annotation (Placement(transformation(extent={{-76,54},{-56,74}})));
        parameter SI.Angle fixed_angle=0.0
          "The fixed angle to use if 3D is not enabled";
      equation

        e_a = Modelica.Math.Vectors.normalize(n_a, 0.0);
        e_b = Modelica.Math.Vectors.normalize(n_b, 0.0);

        connect(housing.frame_a, case_reaction)
                                          annotation (Line(
            points={{20,-50},{0,-50},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(unit_z_vector.y, tansformRelativeVector_n_a.r_in) annotation (Line(
            points={{-67,-70},{-54,-70},{-54,-32}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(unit_z_vector.y, tansformRelativeVector_n_b.r_in) annotation (Line(
            points={{-67,-70},{54,-70},{54,-32}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_a.r_out, n_a) annotation (Line(
            points={{-54,-9},{-54,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.r_out, n_b) annotation (Line(
            points={{54,-9},{54,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(frame_a, tansformRelativeVector_n_a.frame_b) annotation (Line(
            points={{-100,80},{-78,80},{-78,-20},{-64,-20}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_a.frame_a, case_reaction) annotation (Line(
            points={{-44,-20},{0,-20},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.frame_a, case_reaction) annotation (Line(
            points={{44,-20},{0,-20},{0,-100}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(tansformRelativeVector_n_b.frame_b, frame_b) annotation (Line(
            points={{64,-20},{78,-20},{78,80},{100,80}},
            color={95,95,95},
            thickness=0.5,
            smooth=Smooth.None));
        connect(flange_a, lossy_gear.flange_a)                  annotation (Line(
            points={{-100,0},{-86,0},{-86,48},{-8,48}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(lossy_gear.flange_b, flange_b)                  annotation (Line(
            points={{12,48},{86,48},{86,0},{100,0}},
            color={0,0,0},
            smooth=Smooth.None));
        if not world.driveTrainMechanics3D then
          // Directly connect the unit vector to the outputs if no 3D
          connect(unit_z_vector.y, n_a) annotation (Line(
            points={{-67,-70},{-66,-70},{-66,18},{-54,18}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
          connect(unit_z_vector.y, n_b) annotation (Line(
            points={{-67,-70},{-66,-70},{-66,-72},{72,-72},{72,18},{54,18}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
          connect(no_3D_angle.y, combiTable1D.u[1])
                                                  annotation (Line(
            points={{-55,64},{-44,64},{-44,70},{-42,70}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
        end if;

        connect(combiTable1D.u[1], angle_Measure_Sensor.y[1]) annotation (Line(
            points={{-42,70},{-50,70},{-50,89}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(frame_a, angle_Measure_Sensor.frame_a) annotation (Line(
            points={{-100,80},{-100,100},{-60,100}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));
        connect(frame_b, angle_Measure_Sensor.frame_b) annotation (Line(
            points={{100,80},{100,100},{-40,100}},
            color={95,95,95},
            pattern=LinePattern.Dot,
            smooth=Smooth.None));

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
              graphics={
              Rectangle(
                extent={{-40,20},{-20,-20}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-40,140},{-20,20}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{20,100},{40,60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{20,60},{40,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{40,10},{100,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-20,90},{20,70}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,10},{-40,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Text(
                extent={{-150,180},{150,150}},
                textString="%name=%ratio",
                lineColor={0,0,255}),
              Line(points={{-80,20},{-60,20}}, color={0,0,0}),
              Line(points={{-80,-20},{-60,-20}}, color={0,0,0}),
              Line(points={{-10,100},{10,100}}, color={0,0,0}),
              Line(points={{-10,60},{10,60}}, color={0,0,0}),
              Line(points={{60,20},{80,20}}, color={0,0,0}),
              Line(points={{60,-20},{80,-20}}, color={0,0,0}),
              Line(points={{-70,-20},{-70,-70},{70,-70},{70,-20}}, color={0,0,0}),
              Line(points={{0,60},{0,-70},{0,-100}}, color={0,0,0}),
              Text(
                extent={{-150,-36},{150,-66}},
                textString="%name=%ratio",
                lineColor={0,0,0}),
              Line(
                points={{-96,80},{-70,80},{-70,20}},
                color={135,135,135},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{96,80},{70,80},{70,20}},
                color={135,135,135},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Ellipse(
                extent={{-90,90},{90,-90}},
                lineColor={255,0,128},
                startAngle=0,
                endAngle=135)}),
          Documentation(info="<html>
<p>This component is used to model a 1-dim. gearbox
with non-parallel axes (defined by parameters <code>n_a</code>, <code>n_b</code>).
A 3-dim. <code>bearing</code> frame is necessary to reflect the
correct support torque, as the axes of rotation of <code>flange_a</code> and
<code>flange_b</code> and the direction of the support torque vector
are different in general.</p>
<p>Note: The name BevelGear1D is kept only for simplicity. Regardless,
this component could be used to model any kind of gearbox with non-parallel axes.</p>
<p><b>Reference</b><br>
<span style=\"font-variant:small-caps\">Schweiger</span>, Christian ;
<span style=\"font-variant:small-caps\">Otter</span>, Martin:
<a href=\"http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">Modelling
3D Mechanical Effects of 1-dim. Powertrains</a>. In: <i>Proceedings of the 3rd International
Modelica Conference</i>. Link&ouml;ping : The Modelica Association and Link&ouml;ping University,
November 3-4, 2003, pp. 149-158</p>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-24,32},{18,16}},
                lineColor={255,0,0},
                textString="Do not connect support of lossy gear!
The text layer will apply the correct reaction 
to the housing.")}));
      end Bevel_Gear_3D_Auto_Orient_Angle_Dependant_Losses;
    end Ideal_Gears;
  end Suspension_Ideal;
annotation (uses(Modelica(version="3.2")));
end C2M2L_OM;
